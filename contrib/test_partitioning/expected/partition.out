\set VERBOSITY terse
SET search_path = 'public';
/* Try to create table without pg_pathman extension installed */
CREATE TABLE abc(id SERIAL)
PARTITION BY RANGE(id) INTERVAL (100) (PARTITION abc_1 VALUES LESS THAN (100));
ERROR:  pg_pathman module isn't installed
CREATE EXTENSION pg_pathman;
/* Create interval partitioned table */
CREATE TABLE abc(id SERIAL)
PARTITION BY RANGE(id) INTERVAL (100)
(
    PARTITION abc_inf VALUES LESS THAN (100),
    PARTITION abc_100 VALUES LESS THAN (200)
);
NOTICE:  sequence "abc_seq" does not exist, skipping
ALTER TABLE abc ADD PARTITION abc_200 VALUES LESS THAN (400);
ALTER TABLE abc SPLIT PARTITION abc_200 AT (300) INTO (PARTITION abc_200, PARTITION abc_300);
ALTER TABLE abc MERGE PARTITIONS abc_200, abc_300 INTO PARTITION abc_200;
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | partattr | range_min | range_max 
--------+-----------+----------+----------+-----------+-----------
 abc    | abc_inf   |        2 | id       | NULL      | 100
 abc    | abc_100   |        2 | id       | 100       | 200
 abc    | abc_200   |        2 | id       | 200       | 400
(3 rows)

/* Check that we can omit optional INTO parameter */
ALTER TABLE abc SPLIT PARTITION abc_200 AT (300);
ALTER TABLE abc MERGE PARTITIONS abc_200, abc_1;
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | partattr | range_min | range_max 
--------+-----------+----------+----------+-----------+-----------
 abc    | abc_inf   |        2 | id       | NULL      | 100
 abc    | abc_100   |        2 | id       | 100       | 200
 abc    | abc_200   |        2 | id       | 200       | 400
(3 rows)

/* Inserting values into area not covered by partitions should create new partition */
INSERT INTO abc VALUES (450);
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | partattr | range_min | range_max 
--------+-----------+----------+----------+-----------+-----------
 abc    | abc_inf   |        2 | id       | NULL      | 100
 abc    | abc_100   |        2 | id       | 100       | 200
 abc    | abc_200   |        2 | id       | 200       | 400
 abc    | abc_2     |        2 | id       | 400       | 500
(4 rows)

DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 4 other objects
/*
 * Create range partitioned table (in contrast to interval-partitioned in terms
 * of Oracle)
 */
CREATE TABLE abc(id SERIAL)
PARTITION BY RANGE(id)
(
    PARTITION abc_inf VALUES LESS THAN (100),
    PARTITION abc_100 VALUES LESS THAN (200)
);
/* Inserting should produce an error */
INSERT INTO abc VALUES (250);
ERROR:  could not create new partitions for relation "abc"
DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 2 other objects
/* Create hash partitioned table */
CREATE TABLE abc (id serial)
PARTITION BY HASH (id) PARTITIONS (4);
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | partattr | range_min | range_max 
--------+-----------+----------+----------+-----------+-----------
 abc    | abc_0     |        1 | id       |           | 
 abc    | abc_1     |        1 | id       |           | 
 abc    | abc_2     |        1 | id       |           | 
 abc    | abc_3     |        1 | id       |           | 
(4 rows)

DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 4 other objects
/* Create hash partitioned table */
CREATE TABLE abc(id serial)
PARTITION BY HASH (id) PARTITIONS (3);
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | partattr | range_min | range_max 
--------+-----------+----------+----------+-----------+-----------
 abc    | abc_0     |        1 | id       |           | 
 abc    | abc_1     |        1 | id       |           | 
 abc    | abc_2     |        1 | id       |           | 
(3 rows)

