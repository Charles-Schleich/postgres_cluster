\set VERBOSITY terse
SET search_path = 'public';
/* Try to create table without pg_pathman extension installed */
CREATE TABLE abc(id SERIAL)
PARTITION BY RANGE(id) INTERVAL (100) (PARTITION abc_1 VALUES LESS THAN (100));
ERROR:  pg_pathman module isn't installed
CREATE EXTENSION pg_pathman;
/* Create interval partitioned table */
CREATE TABLE abc(id SERIAL)
PARTITION BY RANGE(id) INTERVAL (100)
(
    PARTITION abc_inf VALUES LESS THAN (100),
    PARTITION abc_100 VALUES LESS THAN (200)
);
ALTER TABLE abc ADD PARTITION abc_200 VALUES LESS THAN (400);
ALTER TABLE abc SPLIT PARTITION abc_200 AT (300) INTO (PARTITION abc_200, PARTITION abc_300);
ALTER TABLE abc MERGE PARTITIONS abc_100, abc_200, abc_300 INTO PARTITION abc_100;
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | expr | range_min | range_max 
--------+-----------+----------+------+-----------+-----------
 abc    | abc_inf   |        2 | id   |           | 100
 abc    | abc_100   |        2 | id   | 100       | 400
(2 rows)

/* Drop partition should shift next partition's lower bound */
ALTER TABLE abc ADD PARTITION abc_400 VALUES LESS THAN (500);
ALTER TABLE abc DROP PARTITION abc_100;
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | expr | range_min | range_max 
--------+-----------+----------+------+-----------+-----------
 abc    | abc_inf   |        2 | id   |           | 100
 abc    | abc_400   |        2 | id   | 100       | 500
(2 rows)

/* Inserting values into area not covered by partitions should create new partition */
INSERT INTO abc VALUES (550);
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | expr | range_min | range_max 
--------+-----------+----------+------+-----------+-----------
 abc    | abc_inf   |        2 | id   |           | 100
 abc    | abc_400   |        2 | id   | 100       | 500
 abc    | abc_1     |        2 | id   | 500       | 600
(3 rows)

DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 4 other objects
/*
 * Create range partitioned table (in contrast to interval-partitioned in terms
 * of Oracle)
 */
CREATE TABLE abc(id SERIAL)
PARTITION BY RANGE(id)
(
    PARTITION abc_inf VALUES LESS THAN (100),
    PARTITION abc_100 VALUES LESS THAN (200)
);
/* Inserting should produce an error because interval hasn't been set */
INSERT INTO abc VALUES (250);
ERROR:  cannot spawn new partition for key '250'
DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 3 other objects
/* Create hash partitioned table */
CREATE TABLE abc (id serial)
PARTITION BY HASH (id) PARTITIONS (4);
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | expr | range_min | range_max 
--------+-----------+----------+------+-----------+-----------
 abc    | abc_0     |        1 | id   |           | 
 abc    | abc_1     |        1 | id   |           | 
 abc    | abc_2     |        1 | id   |           | 
 abc    | abc_3     |        1 | id   |           | 
(4 rows)

DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 4 other objects
CREATE TABLE abc(id serial)
PARTITION BY HASH (id)
(
	PARTITION abc_first,
	PARTITION abc_second
);
SELECT * FROM pathman_partition_list;
 parent | partition  | parttype | expr | range_min | range_max 
--------+------------+----------+------+-----------+-----------
 abc    | abc_first  |        1 | id   |           | 
 abc    | abc_second |        1 | id   |           | 
(2 rows)

DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 2 other objects
CREATE TABLE abc(id serial);
INSERT INTO abc SELECT generate_series(1, 1000);
ALTER TABLE abc PARTITION BY RANGE (id) START FROM (1) INTERVAL (100);
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | expr | range_min | range_max 
--------+-----------+----------+------+-----------+-----------
 abc    | abc_inf   |        2 | id   |           | 1
 abc    | abc_1     |        2 | id   | 1         | 101
 abc    | abc_2     |        2 | id   | 101       | 201
 abc    | abc_3     |        2 | id   | 201       | 301
 abc    | abc_4     |        2 | id   | 301       | 401
 abc    | abc_5     |        2 | id   | 401       | 501
 abc    | abc_6     |        2 | id   | 501       | 601
 abc    | abc_7     |        2 | id   | 601       | 701
 abc    | abc_8     |        2 | id   | 701       | 801
 abc    | abc_9     |        2 | id   | 801       | 901
 abc    | abc_10    |        2 | id   | 901       | 1001
(11 rows)

SELECT drop_partitions('abc');
NOTICE:  100 rows copied from abc_1
NOTICE:  100 rows copied from abc_2
NOTICE:  100 rows copied from abc_3
NOTICE:  100 rows copied from abc_4
NOTICE:  100 rows copied from abc_5
NOTICE:  100 rows copied from abc_6
NOTICE:  100 rows copied from abc_7
NOTICE:  100 rows copied from abc_8
NOTICE:  100 rows copied from abc_9
NOTICE:  100 rows copied from abc_10
NOTICE:  0 rows copied from abc_inf
 drop_partitions 
-----------------
              11
(1 row)

ALTER TABLE abc PARTITION BY HASH (id) PARTITIONS (3);
SELECT * FROM pathman_partition_list;
 parent | partition | parttype | expr | range_min | range_max 
--------+-----------+----------+------+-----------+-----------
 abc    | abc_0     |        1 | id   |           | 
 abc    | abc_1     |        1 | id   |           | 
 abc    | abc_2     |        1 | id   |           | 
(3 rows)

DROP TABLE abc CASCADE;
NOTICE:  drop cascades to 3 other objects
