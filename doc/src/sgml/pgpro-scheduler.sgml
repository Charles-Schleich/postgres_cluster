<!-- doc/src/sgml/pgpro-scheduler.sgml -->

<sect1 id="pgpro-scheduler" xreflabel="pgpro_scheduler">
  <title>pgpro_scheduler</title>

  <indexterm zone="pgpro-scheduler">
   <primary>pgpro_scheduler</primary>
  </indexterm>
  <para>
    <filename>pgpro_scheduler</filename> is an internal <productname>&productname;</productname> extension that enables you to schedule, monitor, and
    manage job execution within the <productname>&productname;</productname> database. With
    <filename>pgpro_scheduler</filename>, you can:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        set advanced schedules using <type>jsonb</type> objects or <type>crontab</type> strings
      </para>
    </listitem>
    <listitem>
      <para>
        dynamically calculate the next execution time for repeated jobs
      </para>
    </listitem>
    <listitem>
      <para>
        execute <acronym>SQL</acronym> commands of the job in a single transaction or in
        different transactions, depending on your needs
      </para>
    </listitem>
  </itemizedlist>
  <para>
    Unlike external scheduling daemons,
    <filename>pgpro_scheduler</filename> offers the following benefits:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        With <filename>pgpro_scheduler</filename> enabled, any user can
        schedule jobs independently.
      </para>
    </listitem>
    <listitem>
      <para>
        You can manage job scheduling on the fly without restarting your
        database.
      </para>
    </listitem>
    <listitem>
      <para>
        Scheduling solution is very lightweight since
        <filename>pgpro_scheduler</filename> uses background workers to
        schedule, monitor, and manage job execution. At the same time,
        you do not use any client connections for scheduling.
      </para>
    </listitem>
    <listitem>
      <para>
        Each database has its own "supervisor" scheduler, with each
        scheduled job executed by a separate background worker for
        enhanced stability.
      </para>
    </listitem>
  </itemizedlist>

  <sect2 id="pgpro-scheduler-installation">
    <title>Installation</title>
      <para>
        <emphasis>Prerequisites:</emphasis> You must install <productname>&productname;</productname> to use <filename>pgpro_scheduler</filename>
        extension.
      </para>
    <para>
      To complete the installation of
      <filename>pgpro_scheduler</filename>: 
     <orderedlist>
      <listitem>
        <para>Modify the <filename>postgresql.conf</filename> file by adding
      <filename>pgpro_scheduler</filename> to the
      <varname>shared_preload_libraries</varname> variable:
    </para>
    <programlisting>
shared_preload_libraries = 'pgpro_scheduler'
</programlisting>
      </listitem>
      <listitem>
        <para>
          From the command line, run the following query:
        <programlisting>
$ psql -d <replaceable>dbname</replaceable> -c &quot;CREATE EXTENSION pgpro_scheduler;&quot;
</programlisting>
where <replaceable>dbname</replaceable> is the name of the database for which you would like to use <filename>pgpro_scheduler</filename>. Make sure to create the <filename>pgpro_scheduler</filename> extension for each database you are planning to use.
        </para>
      </listitem>
    </orderedlist>
    <para>
      Once you complete the installation, configure
      <filename>pgpro_scheduler</filename> for your database.
    </para>
  </sect2>

  <sect2 id="pgpro-scheduler-configuration">
   <title>Configuration</title>
          <para>You must have superuser rights to configure <filename>pgpro_scheduler</filename>.</para>
    <para>
      To dynamically configure <filename>pgpro_scheduler</filename>:
    </para>
    <orderedlist>
      <listitem>
        <para>
          Enable <filename>pgpro_scheduler</filename> for your system.
        <programlisting>
ALTER SYSTEM SET <varname>schedule.enable</> = <literal>true</>;
</programlisting></para>
      </listitem>
      <listitem>
        <para>
          Specify the names of the databases for which you need to
          schedule jobs, in the comma-separated format.

        <programlisting>
ALTER SYSTEM SET <varname>schedule.database</> = '<replaceable>database1</>,<replaceable>database2</>';
</programlisting></para>
      </listitem>
      <listitem>
        <para>
          To control the workload in your system, set the maximal number
          of background workers that can run simultaneously on each
          database:
        </para>
        <programlisting>
ALTER DATABASE <replaceable>database1</> SET <varname>schedule.max_workers</> = 5;
ALTER DATABASE <replaceable>database2</> SET <varname>schedule.max_workers</> = 3;
</programlisting>
        <para>
          You can also set the same number of background workers for all
          databases at once:
        </para>
        <programlisting>
ALTER SYSTEM SET <varname>schedule.max_workers</> = 5;
</programlisting>
      </listitem>
      <listitem>
        <para>
          Run <function>pg_reload_conf()</function> for the changes to
          take effect:
        </para>
        <programlisting>
SELECT <function>pg_reload_conf()</>;
</programlisting>
      </listitem>
    </orderedlist>
        <important>
        <para>When setting the
        <varname>schedule.max_workers</> variable, make sure to
        leave enough workers for the rest of the system as other
        subsystems may also use background workers. The
        <varname>schedule.max_workers</> value cannot exceed the
        total number of workers enabled by the
        <varname>max_worker_processes</> <productname>PostgreSQL</productname> variable.
      </para>
      <para>
        The <filename>pgpro_scheduler</filename> extension starts a
        separate background worker for the system, each database, and
        each monitored job. For example, if you work with two databases
        and set the maximal number of workers to 5,
        <filename>pgpro_scheduler</filename> can use up to 13 workers at
        peak times: one worker is supervising the system, two workers
        are monitoring the two databases, and 10 workers can be started
        for job scheduling, five for each database.
      </para>
      <para>
        If required, you can later change the number of workers. The
        running jobs will not be affected.
      </para></important>
    <para>
      Alternatively, you can modify <filename>pgpro_scheduler</filename>
      settings in the <filename>postgresql.conf</filename> file. In this
      case, all databases will have the same maximal number of
      background workers:
    </para>
    <programlisting>
<varname>schedule.enable</varname> = <literal>on</literal>
<varname>schedule.database</varname> = '<replaceable>database1</>,<replaceable>database2</>'
<varname>schedule.max_workers</varname> = 5
</programlisting>
    <para>
      Once the <filename>pgpro_scheduler</filename> is configured, you can
      start scheduling jobs.
    </para>
    <para>
      <emphasis role="strong">See Also</emphasis>
    </para>
    <para><xref linkend="pgpro-scheduler-guc-variables">
    </para>
  </sect2>
   <sect2 id="pgpro-scheduler-usage">
   <title>Usage</title>
  <sect3 id= "pgpro-scheduler-creating-scheduled-jobs">
        <title>Creating Scheduled Jobs</title>
      <para>
        To create and schedule a job, run the
        <function>create_job()</function> function that takes scheduling
        options as a <type>jsonb</type> object:

      <programlisting>
<function>schedule.create_job(<parameter>data</parameter> <type>jsonb</type>)</function>
</programlisting>
      </para>
      <para>
        In the <type>jsonb</type> object, you must specify one or more <acronym>SQL</acronym> commands
        in the <literal>commands</literal> key, and set the job schedule
        with at least one of the following keys:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>dates</literal> &mdash; a single date or an array of
            dates, in the <type>timestamp with time zone</type> format
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>cron</literal> &mdash; a string, in the <type>crontab</type> format
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>rule</literal> &mdash; a <type>jsonb</type> object that includes one
            or more of the following keys:
          </para>
        <itemizedlist>
        <listitem>
          <para>
            <literal>minutes</literal> &mdash; minutes; an array of integers
            in range [0, 59]
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>hours</literal> &mdash; hours; an array of integers in
            range [0, 23]
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>days</literal> &mdash; days of the month; an array of
            integers in range [1, 31]
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>months</literal> &mdash; months; an array of integers in
            range [1, 12]
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>wdays</literal> &mdash; days of the week; an array of
            integers in range [0, 6], where 0 is Sunday.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>onstart</literal> &mdash; integer value 0 or 1. If
            <literal>onstart</literal> is set to 1, the job is executed
            only once when <filename>pgpro_scheduler</filename> is
            started.
          </para>
        </listitem>
        </itemizedlist>
      </listitem>
      </itemizedlist>

      <para>
        You can combine <literal>dates</literal>,
        <literal>cron</literal>, and <literal>rule</literal> scheduling
        keys for advanced use cases.
      </para>

      <para>
        As a result, <filename>pgpro_scheduler</filename> creates an
        active job with the specified schedule and returns the job ID.
      </para>
        <tip><para>
          For simple job schedules, you can use the following shortcut syntax:
<programlisting>
schedule.create_job(<parameter>cron</parameter>, <parameter>commands</parameter>)
schedule.create_job(<parameter>dates</parameter>, <parameter>commands</parameter>)
</programlisting>
For details, see <xref linkend="schedule-create-job"> function description.</para>
      </tip>
      <para>
        If required, you can later modify one or more scheduling options
        with the <function>set_job_attribute()</function> or
        <function>set_job_attributes()</function> functions, respectively.
      </para>
      <para>
        If all background workers are busy at the specified time, the
        job waits for the next available worker. By default, the
        <filename>pgpro_scheduler</filename> can wait forever. You can
        limit the maximal wait time by setting the
        <literal>last_start_available</literal> key, in the <link linkend="datatype-datetime">time interval</link> format.
        If the timeout is reached, <filename>pgpro_scheduler</filename>
        cancels the job execution.
      </para>
      <para>
        <emphasis role="strong">Examples:</emphasis>
      </para>
      <para>
        To run the job every day at 3 pm, and, additionally, on December
        31, 2017 at 7 pm , and on April 4, 2020 at 1 pm:
      </para>
      <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT 15&quot;, &quot;cron&quot;: &quot;0 15 * * *&quot;, &quot;dates&quot;: [ &quot;2017-12-31 19:00&quot;, &quot;2020-04-04 13:00&quot; ]}');
</programlisting>
      <para>
        To limit the wait time for job execution to 30 seconds after the
        scheduled time:
      </para>
      <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT pg_sleep(100)&quot;, &quot;cron&quot;: &quot;15 */2 * * *&quot;, &quot;last_start_available&quot;: &quot;30 seconds&quot; }');
</programlisting>    
      <sect4 id="pgpro-scheduler-time-window">
        <title>Specifying the Time Window for Job Execution</title>
        <para>
          In addition to the general schedule, you can specify the
          timeframe during which the scheduled job can be executed. To
          ensure that <filename>pgpro_scheduler</filename> only executes
          the job within the specified time window, define the
          <literal>start_date</literal> and <literal>end_date</literal>
          keys, in the timestamp with time zone format. You can set one
          of these keys only to limit the start or the end time,
          respectively. If you define a time window for the job,
          <filename>pgpro_scheduler</filename> will only schedule this job
          within this time window. If the started job is incomplete when
          the specified time window ends,
          <filename>pgpro_scheduler</filename> completes the job and then
          excludes the job from further scheduling.
        </para>
        <para>
          <emphasis role="strong">Examples:</emphasis> </para>
          <para>To start
          scheduling the job only after 11am on May 1, 2017:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT now()&quot;, &quot;cron&quot;: &quot;2 17 * * *&quot;, &quot;start_date&quot;: &quot;2017-05-01 11:00&quot; }');
</programlisting>
        </para>
        <para>
          To schedule the job in the timeframe from 11am on May 1 till
          15pm on June 4, 2017:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT now()&quot;, &quot;cron&quot;: &quot;2 17 * * *&quot;, &quot;start_date&quot;: &quot;2017-05-01 11:00&quot;, &quot;end_date&quot;: &quot;2017-06-04 15:00&quot; }');
</programlisting>
        </para>
</sect4>
      <sect4 id="pgpro-scheduler-separate-transactions">
        <title>Running <acronym>SQL</acronym> Commands in Separate Transactions</title>
        <para>
          The <literal>commands</literal> key can take values of text
          and array types. If you specify several <acronym>SQL</acronym> commands as text
          separated by semicolons, the whole job is executed in the same
          transaction. If it is critical to perform each <acronym>SQL</acronym> command in
          a separate transaction, pass the <acronym>SQL</acronym> commands as an array. You
          can modify this behavior by setting the
          <literal>use_same_transaction</literal> key to <type>true</type>. In this
          case, <acronym>SQL</acronym> commands in the array are executed in the same transaction.
        </para>
        <para>
          <emphasis role="strong">Examples:</emphasis>
        </para>
        <para>
          To run the whole job in the same transaction:
        </para>
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT 1; SELECT 2; SELECT 3;&quot;, &quot;cron&quot;: &quot;23 23 */2 * *&quot; }');
</programlisting>
        <para>
          To run commands in separate transactions:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: [ &quot;SELECT 1&quot;, &quot;SELECT 2&quot;, &quot;SELECT 3&quot; ], &quot;cron&quot;: &quot;23 23 */2 * *&quot; }');
</programlisting>
        </para>
        <para>
          To run the whole job in the same transaction when passing the
          commands as an array:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: [ &quot;SELECT 1&quot;, &quot;SELECT 2&quot;, &quot;SELECT 3&quot; ], &quot;cron&quot;: &quot;23 23 */2 * *&quot;, &quot;use_same_transaction&quot;: true }');
</programlisting>
        </para>
      </sect4>
            <sect4 id="pgpro-scheduler-next-start-time">
        <title>Calculating the Job Start Time</title>
        <para>
          For repeated jobs, you can calculate the next start time by
          defining the corresponding <acronym>SQL</acronym> statement in the
          <literal>next_time_statement</literal> key. In this case, the
          first job starts on schedule, while all successive job
          executions depend on the result of the <acronym>SQL</acronym> statement.
        </para>
        <para>
          After the job run completes,
          <filename>pgpro_scheduler</filename> executes the <acronym>SQL</acronym> statement
          in the <literal>next_time_statement</literal> key to calculate
          the next start time and returns the result, in the timestamp
          with time zone type. If the return value is of a different
          type or an error occurs, <filename>pgpro_scheduler</filename>
          marks the job as broken and cancels any further execution.
          This process is repeated for each successive job run.</para>
          <tip><para>When the job run
          completes, <filename>pgpro_scheduler</filename> sets the
          transaction status in the
          <varname>schedule.transaction_state</varname> variable, in the
          string format. You can use this variable in your
          <literal>next_time_statement</literal> to dynamically
          calculate the next start time depending on the transaction
          status. At the time of the
          <literal>next_time_statement</literal> execution, the
          <literal>schedule.transaction_state</literal> variable must
          contain either <literal>success</literal> or
          <literal>failure</literal> status for the main transaction.
          Other status values indicate an internal
          <filename>pgpro_scheduler</filename> error.
        </para></tip>
        <para>
          <emphasis role="strong">Examples:</emphasis>
        </para>
        <para>
          To start the next job executions based on the result of the
          command specified in the
          <literal>next_time_statement</literal> key:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT random()&quot;, &quot;cron&quot;: &quot;45 10 * * *&quot;, &quot;next_time_statement&quot;: &quot;SELECT now() + ''1 day''::interval&quot; }');
</programlisting>
        </para>
      </sect4>
            <sect4 id="pgpro-scheduler-additional-conditions">
        <title>Setting Additional Conditions for Job Execution</title>
        <para>
          The <filename>pgpro_scheduler</filename> extension enables you
          to define additional conditions for task execution: 
        <itemizedlist>
        <listitem>
          <para>
          Set time limits for job execution with the
          <literal>max_run_time</literal> key. If the execution time is
          exceeded, <filename>pgpro_scheduler</filename> cancels the job.
          </para>
        </listitem>
                <listitem>
          <para>Define the maximal wait time before the function gets
          executed using the <literal>last_start_available</literal>
          key. If the timeout is reached, <filename>pgpro_scheduler</filename> cancels the job.
          </para>
        </listitem>
        <listitem>
          <para>Schedule a job on behalf of a different user with the
          <literal>run_as</literal> key.
          </para>
        </listitem>
        <listitem>
          <para>Define an <acronym>SQL</acronym> command to execute if the main transaction fails using the <literal>on_rollback</literal> key.
          </para>
        </listitem>
        </itemizedlist>
        <para>
          <emphasis role="strong">Examples:</emphasis> </para><para>To limit job
          execution to 5 seconds:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT pg_sleep(10)&quot;, &quot;cron&quot;: &quot;15 */10 * * *&quot;, &quot;max_run_time&quot;: &quot;5 seconds&quot; }');
</programlisting>
        </para>
        <para>
          To limit the wait time for job execution to 30 seconds after
          the scheduled time:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT pg_sleep(100)&quot;, &quot;cron&quot;: &quot;15 */2 * * *&quot;, &quot;last_start_available&quot;: &quot;30 seconds&quot; }');
</programlisting>
        </para>
        <para>
          To start the job on behalf of the <literal>robot</literal>
          user:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT session_user&quot;, &quot;cron&quot;: &quot;5 */5 * * *&quot;, &quot;run_as&quot;: &quot;robot&quot; }');
</programlisting>
        </para>
        <para>
          To define a backup <acronym>SQL</acronym> command in case of a rollback:
        <programlisting>
SELECT schedule.create_job('{&quot;commands&quot;: &quot;SELECT ''zzz''&quot;, &quot;cron&quot;: &quot;55 */12 * * *&quot;, &quot;on_rollback&quot;: &quot;SELECT ''An error occurred''&quot; }');
</programlisting>
        </para>
      </sect4>
  </sect3>
      <sect3 id="pgpro-scheduler-changing-and-removing-jobs">
      <title>Changing and Removing Scheduled Jobs</title>
      <para>
        When you create a new job with the
        <literal>create_job()</literal> function, the job is active and
        waiting for execution based on the specified schedule. Using the
        job ID returned by the <function>create_job()</function> function,
        you can change the scheduling settings or remove the job from
        the schedule altogether. To change the specified schedule for
        the jobs, use <function>set_job_attribute()</function> or
        <function>set_job_attributes()</function> functions: </para>
        <itemizedlist>
        <listitem>
          <para>To modify a
        single property of the job, run the
        <function>set_job_attribute()</function> function with the job ID,
        the property name to change, and the new value for this
        property.
          </para>
        </listitem>
        <listitem>
          <para>To modify more than one property of the job, run the
        <function>set_job_attributes()</function> function instead. In
        this case, you can specify all the job properties at once in a
        JSONB object. For details on all the keys available for job
        scheduling, see the <function>create_job()</function> function
        description.
          </para>
        </listitem>
        </itemizedlist>
      <para>
        To temporarily exclude the job from scheduling, run the
        <function>deactivate_job()</function> function:
      <programlisting>
<function>schedule.deactivate_job(<parameter>job_id</parameter> <type>integer</type>)</function>
</programlisting>
      </para>
      <para>
        In this case, you can re-activate the job later by running the
        <function>activate_job()</function> function:
      <programlisting>
<function>schedule.activate_job(<parameter>job_id</parameter> <type>integer</type>)</function>
</programlisting>
      </para>
      <para>
        To permanently remove the job from the schedule, run the
        <function>drop_job()</function> function:
      <programlisting>
<function>schedule.drop_job(<parameter>job_id</parameter> <type>integer</type>)</function>
</programlisting>
      </para>
    </sect3>
        <sect3 id="pgpro-scheduler-monitoring-jobs">
      <title>Monitoring Job Execution</title>
        <para>You must have
          superuser rights to monitor job execution for the whole
          system. Otherwise, you can only monitor the jobs that you own.
          To monitor scheduled jobs, <filename>pgpro_scheduler</filename>
          provides multiple functions that return the information in the
          <type>cron_rec</type> or <type>cron_job</type>
          types:
      <itemizedlist>
        <listitem>
          <para>
            <function>get_job()</function> &mdash; retrieves information about
            the job.
          </para>
        </listitem>
        <listitem>
          <para>
            <function>get_owned_cron()</function> &mdash; retrieves job list
            owned by user.
          </para>
        </listitem>
        <listitem>
          <para>
            <function>get_cron()</function> &mdash; retrieves job list executed
            as user.
          </para>
        </listitem>
        <listitem>
          <para>
            <function>get_active_jobs()</function> &mdash; returns the list of
            jobs executed at the moment of the function call.
          </para>
        </listitem>
        <listitem>
          <para>
            <function>get_log()</function> &mdash; returns the list of all
            completed jobs.
          </para>
        </listitem>
        <listitem>
          <para>
            <function>get_user_log()</function> &mdash; returns list of the
            completed jobs executed by the specified user.
          </para>
        </listitem>
        <listitem>
          <para>
            <function>clean_log()</function> &mdash; deletes all records with
            information about completed jobs.
          </para>
        </listitem>
      </itemizedlist></para>
          <para>To learn more about each function, see <xref linkend="pgpro-scheduler-functions">.
          </sect3>
   </sect2>
   <sect2 id="pgpro-scheduler-reference">
   <title>Reference</title>
       <sect3 id="pgpro-scheduler-guc-variables">
      <title>Variables</title>
   <variablelist>
    <varlistentry id="pgpro-scheduler-schedule-enable" xreflabel="schedule.enable">
     <term><varname>schedule.enable</varname> (<type>boolean</type>)
     <indexterm>
       <primary><varname>schedule.enable</> pgpro-scheduler parameter</primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Specifies whether the scheduler is enabled on our system.</para>
       <para>Default: <literal>false</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="pgpro-scheduler-schedule-database" xreflabel="schedule.database">
     <term><varname>schedule.database</varname> (<type>text</type>)
     <indexterm>
       <primary><varname>schedule.database</> pgpro-scheduler parameter</primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Specifies the list of databases for which the scheduler is enabled. Database names must be separated by commas.</para><para>Default: empty string.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="pgpro-scheduler-schedule-schema" xreflabel="schedule.schema">
     <term><varname>schedule.schema</varname> (<type>text</type>)
     <indexterm>
       <primary><varname>schedule.schema</> pgpro-scheduler parameter</primary>
     </indexterm>
     </term>
     <listitem>
      <para>
      Specifies the name of a schema where the scheduler
       stores its tables and functions. Normally, you should
       not change this variable. This
      variable may be useful if you run <filename>pgpro_scheduler</filename>
      on a multi-master cluster.</para>
       <para>Default: <literal>schedule</literal>. 
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="pgpro-scheduler-schedule-nodename" xreflabel="schedule.nodename">
     <term><varname>schedule.nodename</varname> (<type>text</type>)
     <indexterm>
       <primary><varname>schedule.nodename</> pgpro-scheduler parameter</primary>
     </indexterm>
     </term>
     <listitem>
      <para>
      Specifies the node name of your <productname>&productname;</productname> instance. Do
      not change or use this variable if you run a single server configuration. This
      variable may be useful if you run <filename>pgpro_scheduler</filename>
      on a multi-master cluster.</para>
       <para>Default: <literal>master</literal>. 
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="pgpro-scheduler-schedule-max-workers" xreflabel="schedule.max_workers">
     <term><varname>schedule.max_workers</varname> (<type>integer</type>)
     <indexterm>
       <primary><varname>schedule.max_workers</> pgpro-scheduler parameter</primary>
     </indexterm>
     </term>
     <listitem>
      <para>
      Specifies the maximal number of simultaneously running jobs in one database.</para>
       <para>Default: <literal>2</literal>.
      </para>
     </listitem>
    </varlistentry>


    <varlistentry id="pgpro-scheduler-schedule-transaction-state" xreflabel="schedule.transaction_state">
     <term><varname>schedule.transaction_state</varname> (<type>text</type>)
     <indexterm>
       <primary><varname>schedule.transaction_state</> pgpro-scheduler parameter</primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       An internal variable containing the state of the
                executed job. You can use this parameter when
                calculating the next job start time. Possible values
                are: 
                <itemizedlist><listitem>
          <para><literal>success</literal> &mdash; transaction has finished successfully.
          </para></listitem><listitem>
          <para><literal>failure</literal> &mdash; transaction has failed to finish;.
          </para></listitem><listitem>
          <para><literal>running</literal> &mdash
                transaction is in progress. </para></listitem>
                <listitem>
          <para><literal>undefined</literal> &mdash; transaction has
                not started yet. The last two values should not appear
                inside the user procedure. If you see them, they may
                indicate an internal <filename>pgpro_scheduler</filename>
                error.</para></listitem></itemizedlist>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

    </sect3>
<sect3 id="pgpro-scheduler-sql-schema">
   <title><acronym>SQL</acronym> Schema</title>

      <para>
        To store its internal tables and functions,
        <filename>pgpro_scheduler</filename> uses the
        <literal>schedule</literal> <acronym>SQL</acronym> schema. Direct access to tables is forbidden. To manage job scheduling, use the functions
        defined by the <filename>pgpro_scheduler</filename> extension.
      </para>
  </sect3>

  <sect3 id="pgpro-scheduler-sql-types">
   <title><acronym>SQL</acronym> Types</title>

   <para>
    The scheduler defines two <acronym>SQL</acronym> types and uses them as
    types for return values for some of its functions.
   </para>

   <sect4>
    <title>cron_rec</title>
    <para>
     This type contains information about the scheduled job.
<programlisting>
CREATE TYPE schedule.cron_rec AS(
    id integer,             -- job ID
    node text,              -- name of the node
                               on which to execute the job
    name text,              -- job name
    comments text,          -- comments about the job
    rule jsonb,             -- scheduling rules
    commands text[],        -- SQL commands to be executed
    run_as text,            -- username of the job executor
    owner text,             -- username of the job owner
    start_date timestamp,   -- lower bound of the execution window;
                            -- NULL if unbound
    end_date timestamp,     -- upper bound of the execution window;
                            -- NULL if unbound
    use_same_transaction boolean,   -- true if an array of SQL 
                                    -- commands will be executed 
                                    -- in a single transaction
    last_start_available interval,  -- maximal wait time for 
                                    -- the scheduled job if all 
                                    -- allowed workers are busy
    max_instances int,      -- maximal number of simultaneously 
                            -- running job instances
    max_run_time interval,  -- maximal execution time
    onrollback text,        -- SQL statement to execute 
                            -- if the main transaction fails

    next_time_statement text,   -- SQL statement to calculate 
                                -- the next start time
    active boolean,         -- true if job is scheduled 
                            -- successfully
    broken boolean          -- true if job has errors in 
                            -- configuration that prevented 
                            -- its further execution
);
</programlisting>
    </para>
   </sect4>

   <sect4>
    <title>cron_job</title>
    <para>
     This type contains information about a particular job execution.
<programlisting>
CREATE TYPE schedule.cron_job AS(
    cron integer,           -- job id
    node text,              -- name of the node
                            -- on which to execute the job
    scheduled_at timestamp, -- scheduled execution time
    name text,              -- job name
    comments text,          -- comments about the job
    commands text[],        -- SQL statement to be executed
    run_as text,            -- username of the job executor
    owner text,             -- username of the job owner
    use_same_transaction boolean,   -- true if an array of SQL 
                                    -- commands will be executed
                                    -- in a single transaction
    started timestamp,      -- timestamp of the job execution start
    last_start_available timestamp, -- maximal wait time for 
                                    -- the scheduled job if all 
                                    -- allowed workers are busy
    finished timestamp,     -- timestamp of the job
                            -- execution finish
    max_run_time interval,  -- maximal execution time
    max_instances int,      -- the number of simultaneously 
                            -- running job instances 
    onrollback text,        -- SQL statement to execute if the main
                            -- transaction fails
    next_time_statement text,   -- SQL statement to calculate 
                                -- the next start time
    status text,            -- status of the task: working, done,
                            -- or error
    message text            -- error message
);
</programlisting>
    </para>
   </sect4>
  </sect3>

  <sect3 id="pgpro-scheduler-functions">
   <title>Functions</title>
   <variablelist>
    <varlistentry id="schedule-create-job" xreflabel="schedule.create_job()">
     <term>
      <function>schedule.create_job(<parameter>data</parameter> <type>jsonb</type>)
      </function>
      <indexterm>
       <primary><function>schedule.create_job</></primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Creates an active job and returns the job ID.
      </para>
        <para>
    <emphasis role="strong">Alternative Syntax:</emphasis>
  </para>
  <programlisting>
schedule.create_job(<parameter>cron</parameter> <type>text</type>, <parameter>commands</parameter> <type>text</type> [, <parameter>node</parameter> <type>text</type>])
schedule.create_job(<parameter>cron</parameter> <type>text</type>, <parameter>commands</parameter> <type>text</type>[] [, <parameter>node</parameter> <type>text</type>])
schedule.create_job(<parameter>dates</parameter> <type>timestamp with time zone</type>, <parameter>commands</parameter> <type>text</type> [, <parameter>node</parameter> <type>text</type>])
schedule.create_job(<parameter>dates</parameter> <type>timestamp with time zone</type>, commands <type>text[]</type> [, <parameter>node</parameter> <type>text</type>])
schedule.create_job(<parameter>dates</parameter> <type>timestamp with time zone[]</type>, <parameter>commands</parameter> <type>text</type> [, <parameter>node</parameter> <type>text</type>])
schedule.create_job(<parameter>dates</parameter> <type>timestamp with time zone[]</type>, <parameter>commands</parameter> <type>text[]</type> [, <parameter>node</parameter> <type>text</type>])
</programlisting>
<para>Arguments:</para>
   <itemizedlist>
    <listitem>
    <para><parameter>data</parameter> &mdash; a <type>jsonb</type> object defining all the job properties. You do not need to define other parameters if the <parameter>data</parameter> is set. All the
            available <type>jsonb</type> keys are listed in <xref linkend="pgpro-scheduler-jsonb-keys">.</para>
    <para>Type: <type>jsonb</type></para>
    </listitem>
    <listitem>
    <para><parameter>cron</parameter> &mdash; a crontab-like string defining the job schedule.</para>
    <para>Type: <type>text</type></para>
    </listitem>
    <listitem>
    <para><parameter>dates</parameter> &mdash; the exact date or an array of dates for job execution.</para>
    <para>Type: <type>timestamp with time zone</type>, <type>timestamp with time zone[]</type></para>
    </listitem>
    <listitem>
    <para><parameter>commands</parameter> &mdash; <acronym>SQL</acronym> statements to execute. You can pass one or more <acronym>SQL</acronym>
            statements separated by semicolons, or an array of <acronym>SQL</acronym>
            statements. When passed as an array, <acronym>SQL</acronym> statements are
            executed in separate transactions.</para>
            <para>Type: <type>text</type>, <type>text[]</type></para>
    </listitem>
    <listitem>
    <para><parameter>node</parameter> &mdash; the name of the node on which the scheduled jobs
            run. Optional. You may need to specify this argument if you are
            scheduling jobs on a multi-master cluster.</para>
            <para>Type: <type>text</type></para>
    </listitem>
    </itemizedlist>
  <para>
    Return values:
<itemizedlist><listitem><para>
    ID of the created job.</para></listitem></itemizedlist>
  </para>
      <table id="pgpro-scheduler-jsonb-keys">
      <title><type>jsonb</type> Keys for Job Scheduling</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>
                Key
              </entry>
              <entry>
                Type
              </entry>
              <entry>
                Description
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <literal>cron</literal>
              </entry>
              <entry>
                <type>text</type>
              </entry>
              <entry>
                A crontab-like string defining the job schedule. You can
                combine <literal>cron</literal> with
                <literal>rule</literal> and <literal>dates</literal>
                keys, but at least one of them is mandatory.
              </entry>
            </row>
            <row>
              <entry>
                <literal>dates</literal>
              </entry>
              <entry>
                <type>timestamp with time zone</type>, <type>timestamp with time zone[]</type>
              </entry>
              <entry>
                The exact date or an array of dates when the scheduled
                job will be executed. You can combine
                <literal>dates</literal> with <literal>rule</literal>
                and <literal>cron</literal> keys, but at least one of
                them is mandatory.
              </entry>
            </row>
            <row>
              <entry>
                <literal>rule</literal>
              </entry>
              <entry>
                <type>jsonb</type>
              </entry>
              <entry><para>
                A <type>jsonb</type> object defining the job schedule. Mandatory, if
                both <literal>cron</literal> and
                <literal>dates</literal> keys are undefined. The <literal>rule</literal> object 
                includes one or more of the following keys:
               <itemizedlist>
               <listitem>
                <para><literal>minutes</literal> &mdash; minutes; an array of
                integers in range [0, 59] 
                </para></listitem><listitem><para>
                <literal>hours</literal> &mdash
                hours; an array of integers in range [0, 23]
                </para></listitem><listitem><para>
                <literal>days</literal> &mdash; days of the month; an array of
                integers in range [1, 31]
                </para></listitem><listitem><para><literal>months</literal> &mdash
                months; an array of integers in range [1, 12]
                </para></listitem><listitem><para>
                <literal>wdays</literal> &mdash; days of the week; an array of
                integers in range [0, 6], where 0 is Sunday.
                </para></listitem><listitem><para>
                <literal>onstart</literal> &mdash; integer value 0 or 1. If
                <literal>onstart</literal> is set to 1, the job is
                executed only once when
                <filename>pgpro_scheduler</filename> is started.</para></listitem></itemizedlist></para>
              </entry>
            </row>
            <row>
              <entry>
                <literal>commands</literal>
              </entry>
              <entry>
                <type>text</type>, <type>text []</type>
              </entry>
              <entry>
                <acronym>SQL</acronym> statements to execute. You can pass one or more <acronym>SQL</acronym>
                statements separated by semicolons, or an array of <acronym>SQL</acronym>
                statements. When passed as an array, <acronym>SQL</acronym> statements are
                executed in separate transactions by default. You can
                change this behavior by setting the
                <literal>use_same_transaction</literal> key.
              </entry>
            </row>
            <row>
              <entry>
                <literal>name</literal>
              </entry>
              <entry>
                <type>text</type>
              </entry>
              <entry>
                Optional. Job name.
              </entry>
            </row>
            <row>
              <entry>
                <literal>node</literal>
              </entry>
              <entry>
                <type>text</type>
              </entry>
              <entry>
                Optional. The name of the node on which the scheduled
                jobs run. You may need to specify this argument if you
                are scheduling jobs on a multi-master cluster.
              </entry>
            </row>
            <row>
              <entry>
                <literal>comments</literal>
              </entry>
              <entry>
                <type>text</type>
              </entry>
              <entry>
                Optional. Comments about the scheduled job.
              </entry>
            </row>
            <row>
              <entry>
                <literal>run_as</literal>
              </entry>
              <entry>
                <type>text</type>
              </entry>
              <entry>
                Optional. The user to execute command(s).
              </entry>
            </row>
            <row>
              <entry>
                <literal>start_date</literal>
              </entry>
              <entry>
                <type>timestamp with time zone</type>
              </entry>
              <entry>
                Optional. The start of the timeframe when the scheduled
                job can be executed. This key can be NULL.
              </entry>
            </row>
            <row>
              <entry>
                <literal>end_date</literal>
              </entry>
              <entry>
                <type>timestamp with time zone</type>
              </entry>
              <entry>
                Optional. The end of the timeframe when the scheduled
                job can be executed. This key can be NULL.
              </entry>
            </row>
            <row>
              <entry>
                <literal>use_same_transaction</literal>
              </entry>
              <entry></entry>
              <entry>
                Optional. If set to true, forces an array of <acronym>SQL</acronym>
                statements to be executed in the same transaction.
                Default: <literal>false</literal>
              </entry>
            </row>
            <row>
              <entry>
                <literal>last_start_available</literal>
              </entry>
              <entry>
                <type>interval</type>
              </entry>
              <entry>
                Optional. The maximal time interval to postpone the job
                execution if the maximal number of allowed workers
                reached at the scheduled moment. For example, if this
                key is set to '00:02:34', the job will wait for 2
                minutes 34 seconds. If this key is NULL or not set, the
                job can wait forever. Default: NULL.
              </entry>
            </row>
            <row>
              <entry>
                <literal>max_run_time</literal>
              </entry>
              <entry>
                <type>interval</type>
              </entry>
              <entry>
                Optional.The maximal time interval during which the
                scheduled job can be executed. If this key is NULL or
                not set, there are no time limits. Default: NULL.
              </entry>
            </row>
            <row>
              <entry>
                <literal>on_rollback</literal>
              </entry>
              <entry>
                <type>text</type>
              </entry>
              <entry>
                Optional. <acronym>SQL</acronym> statement to be executed if
                the main transaction fails.
              </entry>
            </row>
            <row>
              <entry>
                <literal>next_time_statement</literal>
              </entry>
              <entry>
                <type>text</type>
              </entry>
              <entry>
                Optional. <acronym>SQL</acronym> statement to calculate the start time for
                the next job execution. For details, see <xref linkend="pgpro-scheduler-next-start-time">.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.set_job_attributes(<parameter>job_id</parameter> <type>integer</type>,
       <parameter>data</parameter> <type>jsonb</type>)
      </function>
      <indexterm>
       <primary><function>schedule.set_job_attributes</></primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Updates properties of the existing job.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>job_id</parameter> &mdash; identifier of the existing job.</para>
        </listitem>
        <listitem>
         <para><parameter>data</parameter> &mdash; a <type>jsonb</type> object with properties to be edited.
          For the list of keys and their structure, see <xref linkend="pgpro-scheduler-jsonb-keys">.
          </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Return values:
       <itemizedlist>
        <listitem>
         <para><parameter>true</parameter> &mdash;  job properties were updated successfully.</para>
        </listitem>
        <listitem>
         <para><parameter>false</parameter> &mdash; job properties were not updated.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       To update the job properties, you must be the owner of the job or have superuser rights.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.set_job_attribute(<parameter>job_id</parameter> <type>integer</type>,
       <parameter>name</parameter> <type>text</type>,
       <parameter>value</parameter> <type>text</type> || <type>anyarray</type>)
      </function>
      <indexterm>
       <primary><function>schedule.set_job_attribute</></primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       Updates a property of the existing job.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>job_id</parameter> &mdash; identifier of the existing job.</para>
        </listitem>
        <listitem>
         <para><parameter>name</parameter> &mdash; property name.</para>
        </listitem>
        <listitem>
         <para><parameter>value</parameter> &mdash; property value.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       See <xref linkend="pgpro-scheduler-jsonb-keys"> for the list of properties you can update.
       Some values are of array types. They should be passed as an array.
       If you pass a value of the wrong type, an exception will be raised.
      </para>
      <para>
       Return values:
       <itemizedlist>
        <listitem>
         <para><parameter>true</parameter> &mdash;  job property was updated successfully.</para>
        </listitem>
        <listitem>
         <para><parameter>false</parameter> &mdash; job property was not updated.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       To update the job properties, you must be the owner of the job or have superuser rights.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.deactivate_job(<parameter>job_id</parameter> <type>integer</type>)
      </function>
     <indexterm>
       <primary><function>schedule.deactivate_job</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
      Deactivates the job and suspends its further scheduling and execution.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>job_id</parameter> &mdash; identifier of the existing job.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Return values:
       <itemizedlist>
        <listitem><para>
       <literal>true</literal> - the job is deactivated successfully.
        </para></listitem>
       <listitem><para>
       <literal>false</literal> - job deactivation failed.
        </para></listitem>
       </itemizedlist>       
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.activate_job(<parameter>job_id</parameter> <type>integer</type>)
      </function>
     <indexterm>
       <primary><function>schedule.activate_job</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
      Activates a job and starts its scheduling and execution.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>job_id</parameter> &mdash; identifier of the existing job.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Return values: 
       <itemizedlist>
        <listitem><para><literal>true</literal> &mdash; the job was activated successfully.</para></listitem>
        <listitem><para><literal>false</literal> &mdash; job activaction failed.</para></listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.drop_job(<parameter>job_id</parameter> <type>integer</type>)
      </function>
     <indexterm>
       <primary><function>schedule.drop_job</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Deletes a job.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>job_id</parameter> &mdash; identifier of the existing job.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Return values: 
       <itemizedlist>
        <listitem><para><literal>true</literal> &mdash; the job was deleted successfully.</para></listitem>
        <listitem><para><literal>false</literal> &mdash; job was not deleted.</para></listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.get_job(<parameter>job_id</parameter> <type>integer</type>)
      </function>
     <indexterm>
       <primary><function>schedule.get_job</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Returns information about the specified job.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>job_id</parameter> &mdash; identifier of the existing job.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Return values: 
       <itemizedlist>
        <listitem>
         <para>An object of type <type>cron_rec</type>. </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>For details on the <type>cron_rec</type> type, see <xref linkend="pgpro-scheduler-sql-types">.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.get_owned_cron(<parameter>username</parameter> <type>text</type>)
      </function>
     <indexterm>
       <primary><function>schedule.get_owned_cron</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Retrieves the list of jobs owned by the specified user.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>username</parameter> &mdash; username, optional.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>Return values:</para>
      <itemizedlist>
        <listitem><para>
       A set of records of type <type>cron_rec</type>.
       These records contain information about all jobs owned by the specified user.
       If the <parameter>username</parameter> is omitted, the session username is used.
       You must have superuser rights to retrieve jobs owned by another user.
      </para></listitem>
       </itemizedlist>     
      <para>For details on the <type>cron_rec</type> type, see <xref linkend="pgpro-scheduler-sql-types">.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.get_cron(<parameter>username</parameter> <type>text</type>)
      </function>
     <indexterm>
       <primary><function>schedule.get_cron</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Retrieves the list of jobs executed by the specified user.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>username</parameter> &mdash; username, optional.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Return values:
        <itemizedlist>
        <listitem>
         <para>A set of records of type <type>cron_rec</type>.
       These records contain information about all jobs executed by the specified user.
       If <parameter>username</parameter> is omitted, the session username is used.
       You must have superuser rights to retrieve jobs executed by another user.</para>
     </listitem>
     </itemizedlist>
      </para>
      <para>
       For details on the <type>cron_rec</type> type, see <xref linkend="pgpro-scheduler-sql-types">.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.get_active_jobs(<parameter>username</parameter> <type>text</type>)
      </function>
     <indexterm>
       <primary><function>schedule.get_active_jobs</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Return values:
        <itemizedlist>
        <listitem>
         <para>The list of jobs currently being executed by the specified user.</para></listitem></itemizedlist>
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>username</parameter> &mdash; username, optional.</para></listitem>
       </itemizedlist>
      </para>
      <para>
       If <parameter>username</parameter> is omitted, the session username is used.
       You must have superuser rights to retrieve jobs executed by another user.
      </para>
      <para>
       Return values:
        <itemizedlist>
        <listitem>
         <para>A set of records of type <type>cron_job</type>.</para></listitem></itemizedlist>
       <para>For details on the <type>cron_job</type> type, see <xref linkend="pgpro-scheduler-sql-types">.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.get_active_jobs()
      </function>
     <indexterm>
       <primary><function>schedule.get_active_jobs</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Returns the list of jobs being currently executed.
       You must have superuser rights to call this function.
      </para>
      <para>
       Return values:
       <itemizedlist>
        <listitem><para>A set of records of type <type>cron_job</type>.</para></listitem></itemizedlist>
       <para>For details on the <type>cron_job</type> type, see <xref linkend="pgpro-scheduler-sql-types">.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.get_log()
      </function>
     <indexterm>
       <primary><function>schedule.get_log</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Returns the list of all completed jobs.
       You must have superuser rights to call this function.
      </para>
      <para>Return values:
        <itemizedlist>
        <listitem>
         <para>A set of records of type <type>cron_job</type>.</para></listitem></itemizedlist></para>
       <para>For details on the <type>cron_job</type> type, see <xref linkend="pgpro-scheduler-sql-types">.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.get_user_log()
      </function>
     <indexterm>
       <primary><function>schedule.get_user_log</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
       Returns the list of completed jobs executed by the specified user.
      </para>
      <para>
       Arguments:
       <itemizedlist>
        <listitem>
         <para><parameter>username</parameter> &mdash; username, optional.</para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       If <parameter>username</parameter> is omitted, the session username is used.
      You must have superuser rights to retrieve the list of jobs executed by another user.
      </para>
      <para>Return values:
        <itemizedlist>
        <listitem>
         <para>A set of records of type <type>cron_job</type>.</para></listitem></itemizedlist></para>
       <para>For details on the <type>cron_job</type> type, see <xref linkend="pgpro-scheduler-sql-types">.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function>schedule.clean_log()
      </function>
     <indexterm>
       <primary><function>schedule.clean_log</></primary>
     </indexterm>
     </term>
     <listitem>
      <para>
      Deletes all records with information about the completed jobs.
      You must have superuser rights to call this function.
      </para>
      <para>
       Return values:
       <itemizedlist>
        <listitem>
         <para>The number of records deleted.</para></listitem></itemizedlist>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </sect3>
  </sect2>
  <sect2>
  <title>Authors</title>
  <para>Vladimir Ershov <email>v.ershov@postgrespro.ru</email>, Postgres Professional, Moscow, Russia</para>
  </sect2>

</sect1>
