<!-- doc/src/sgml/atx.sgml -->

<chapter id="atx">
 <title>Autonomous Transactions</title>

<sect1 id="atx-overview">
  <title>Overview</title>

<para>
&productname; supports nested transactions: they are rarely explicitly used by programmer and mostly used for error handling and stored
procedures. It is possible to rollback a subtransaction without affecting the parent transaction. But commit of a subtraction is delayed until
commit of parent transaction.
</para>
<para>
However, in some cases applications need to run several independent transactions inside a single transaction &mdash; <quote>autonomous transactions</quote>. Autonomous transactions are needed mostly for implementing audits, when the fact of performing an audit should be reported regardless of the
status of the audit itself: whether it was successfully completed or not.
</para>

</sect1>

<sect1><title>Behavior</title>
<para>
An autonomous transaction can happen only inside another transaction.
Inside an existing transaction (call it T0), the user can decide to start an autonomous transaction. Then T0 is paused and pushed in an autonomous transaction stack, and a new transaction (call it T1) is started.
</para>
<para>
At some point in the future the user can commit the autonomous transaction; after T1 is committed then T0 is popped from the autonomous transaction stack and resumed.
The user can also decide to <command>COMMIT</command> the parent transaction T0, in which case T1 is committed, then T0 is popped from the autonomous transaction stack and then committed.
</para>
<para>
All the transactions happen synchronously; at any time only one transaction can be active, while in the stack there are zero (or more) paused transactions in the stack.
All the possible combinations of <command>COMMIT</command> / <command>ROLLBACK</command> for T0 and T1 can happen;
for instance, it is possible to COMMIT T1 and ROLLBACK T0.
It is possible to nest autonomous transactions, up to a global resource limit (e.g. the autonomous transaction stack size) which can be set on the server.
</para>

</sect1>

<sect1><title>Examples</title>

<para>
This example illustrates how an autonomous transaction is executed. A continuous line denotes an active transaction, while a dotted line denotes a transaction which has been paused and pushed in the autonomous transaction stack. Time flows downwards.
</para>

<programlisting>
BEGIN; -- starts ordinary transaction T0
|
INSERT INTO t VALUES (1);
:\
: BEGIN AUTONOMOUS TRANSACTION; -- starts autonomous transaction 
: |                             -- T1, pushes T0 into stack
: |
: INSERT INTO t VALUES (2);
: |
: COMMIT AUTONOMOUS TRANSACTION / ROLLBACK AUTONOMOUS TRANSACTION; 
: |                             -- ends autonomous transaction 
: |                             -- T1, pops transaction T0 from stack
:/
COMMIT / ROLLBACK;              -- ends transaction T0
</programlisting>

<para>
Depending on the two choices between <command>COMMIT</command> and <command>ROLLBACK</command>, we can get four different outputs from:

<programlisting>
SELECT sum(x) from t;
</programlisting>
</para>

<para>
The parent transaction can have more than one autonomous transaction if the push/pop cycle is repeated.
</para>

<programlisting>
BEGIN;                          -- starts ordinary transaction T0
|
INSERT INTO t VALUES (1);
:\
: BEGIN AUTONOMOUS TRANSACTION; -- starts autonomous transaction
: |                             -- T1, pushes T0 into stack
: |
: INSERT INTO t VALUES (2);
: |
: COMMIT AUTONOMOUS TRANSACTION / ROLLBACK AUTONOMOUS TRANSACTION; 
: |                             -- ends autonomous transaction 
: |                             -- T1, pops T0 from stack
:/
|
:\
: BEGIN AUTONOMOUS TRANSACTION; -- starts autonomous transaction 
: |                             -- T2, pushes T0 into stack
: |
: INSERT INTO t VALUES (4);
: |
: COMMIT AUTONOMOUS TRANSACTION / ROLLBACK AUTONOMOUS TRANSACTION; 
: |                             -- ends autonomous transaction 
: |                             -- T2, pops T0 from stack
:/
COMMIT / ROLLBACK;              -- ends transaction T0
</programlisting>

</sect1>

<sect1><title>Visibility</title>

<para>
Visibility rules work as in the case of independent transactions executed via <literal>dblink</literal>.
T1 does not see the effects of T0, because the latter has not been committed yet. T0 might see the effects of T1, depending on its own transaction isolation mode.
In case of Read Committed isolation level the parent transaction will see changes made by autonomous transactions.
But in case of Repeatable Read isolation level the parent transaction will not see changes made by autonomous transactions.
</para>

<para>
Now single-session deadlocks become possible, because an autonomous transaction can become entangled with one of the paused transactions in its session.
Autonomous transaction T1 is assumed to depend on parent transaction T0 and if it attempts to obtain any resource locked by T0, then
deadlock is reported.
</para>

</sect1>

<sect1><title>SQL Grammar Extension for Autonomous Transactions</title>

<para>
&productname; <literal>BEGIN</literal>/<literal>END</literal> transaction statements are extended by optional keyword <literal>AUTONOMOUS</literal>:
</para>

<programlisting>
    BEGIN [AUTONOMOUS] [TRANSACTION] [<replaceable>isolation-level</replaceable>]
    END [AUTONOMOUS] [TRANSACTION]
</programlisting>

<para>
Specifying <literal>AUTONOMOUS</literal> keyword in <literal>END TRANSACTION</literal> clause is optional.
It is possible to have several nesting levels of autonomous transactions, but top level transaction cannot be autonomous.
</para>

</sect1>

<sect1><title>PL/pgSQL Grammar Extension for Autonomous Transactions</title>

<para>
Block construction in PL/pgSQL is extended by optional <literal>autonomous</literal> keyword.
It is possible to treat the whole function body as an autonomous transaction:
</para>

<programlisting>
create function foo(x integer) returns integer as $$
begin autonomous
  return x;
end;
$$ language plpgsql;
</programlisting>

<para>
or create separate begin-end block:
</para>

<programlisting>
create or replace function myaudit() returns boolean as $$
begin autonomous
        begin autonomous
        insert into audit_schedule values ('new audit',now());
        end;
        ... -- do audit itself
        return true;
end;
$$ language plpgsql;
</programlisting>

<para>
When exception is raised inside <command>BEGIN AUTONOMOUS</command> block, this autonomous transaction is aborted and standard 
exception handling procedure is started, unwinding stack and executing exception handlers until exception is caught.
So exception handling is done in the same way as with normal &productname; subtransactions.
</para>
<para>
When an error is caught by an <literal>EXCEPTION</literal> clause, the local variables of the PL/pgSQL function remain as they were when the error occurred, but all changes to persistent database state within the block are rolled back.
</para>

</sect1>

<sect1><title>PL/Python Extension for Autonomous Transactions</title>

<para>
In addition to <varname>subtransaction</varname> method, PL/Python module provides new <varname>autonomous</varname> method
which can be used in <varname>WITH</varname> clause to start an autonomous transaction:
</para>

<programlisting>
create or replace function pythonomous() returns void as $$
        plpy.execute("insert into atx_test values ('asd', 123)")

        try:
                with plpy.autonomous():
                        plpy.execute("insert into atx_test values ('bsd', 456)")
        except plpy.SPIError, e:
                print("error: %s" % e.args)

        plpy.execute("insert into atx_test values ('csd', 'csd')")
$$ language plpythonu;
</programlisting>

<para>
Exception handling for autonomous transaction in PL/Python is done in the same way as for subtransactions.
</para>

</sect1>
</chapter>
