<sect1 id="pg-pathman">
  <title>pg_pathman</title>
<para>
    The <filename>pg_pathman</filename> is a <productname>&productname;</productname> extension that
    provides an optimized partitioning solution for large and
    distributed databases. Using <filename>pg_pathman</filename>, you can:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        Partition large databases without downtime.
      </para>
    </listitem>
    <listitem>
      <para>
        Speed up query execution for partitioned tables.
      </para>
    </listitem>
    <listitem>
      <para>
        Manage existing partitions and add new partitions on the fly.
      </para>
    </listitem>
    <listitem>
      <para>
        Add foreign tables as partitions.
      </para>
    </listitem>
    <listitem>
      <para>
        Join partitioned tables for read and write operations.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    The extension is compatible with <productname>&productname;</productname> 9.5 or higher.
  </para>
  <sect2 id="pg-pathman-installation-and-setup">
    <title>Installation and Setup</title>
    <para>
      The <filename>pg_pathman</filename> extension is included into the
      <productname>&productname;</productname>. Once you have
      <productname>&productname;</productname> installed, complete
      the following steps to enable <filename>pg_pathman</filename>:
    </para>
    <orderedlist>
      <listitem>
        <para>
          Add <filename>pg_pathman</filename> to the
          <varname>shared_preload_libraries</varname> variable in the
          <filename>postgresql.conf</filename> file:
        </para>
        <programlisting>
shared_preload_libraries = 'pg_pathman'
</programlisting>
          <important><para>
            <filename>pg_pathman</filename> may have conflicts with other
            extensions that use the same hook functions. For example,
            <filename>pg_pathman</filename> may interfere with the
            <filename>pg_stat_statements</filename> extension as they both
            use <literal>ProcessUtility_hook</literal>. If you run into
            this issue, try reordering libraries specified in this
            parameter:
            <literal>shared_preload_libraries = 'pg_pathman, pg_stat_statements'</literal></para>
          </important>
      </listitem>
      <listitem>
        <para>
          Restart the <productname>&productname;</productname> instance for the settings to take
          effect.
        </para>
      </listitem>
      <listitem>
        <para>
          Create the <filename>pg_pathman</filename> extension using the
          following query:
        </para>
        <programlisting>
CREATE EXTENSION pg_pathman;
</programlisting>
      </listitem>
    </orderedlist>
    <para>
      Once <filename>pg_pathman</filename> is enabled, you can start
      partitioning tables.
    </para>
    <tip>
      <para>You can also build <filename>pg_pathman</filename> from source code by executing the following command in the <filename>pg_pathman</filename> directory:
      </para>
      <programlisting>
make install USE_PGXS=1
</programlisting>
      <para>When this operation is complete, follow the steps described above to complete the setup.
      </para>
      <para>In addition, do not forget to set the <envar>PG_CONFIG</envar> variable if you want to test <filename>pg_pathman</filename> on a custom build of <productname>&productname;</productname>. For details, see 
      <ulink url="https://wiki.postgresql.org/wiki/Building_and_Installing_PostgreSQL_Extension_Modules">Building and Installing PostgreSQL Extension Modules</ulink>.
      </para>
    </tip>
      <para>You can toggle <filename>pg_pathman</filename> or its specific custom
        nodes on and off using <acronym>GUC</acronym> variables. For details, see <xref linkend="pg-pathman-guc-variables">.</para>
      <para>
        If you want to permanently disable
        <filename>pg_pathman</filename> for a previously partitioned
        table, use the <function>disable_pathman_for()</function>
        function:
      </para>
      <programlisting>
SELECT disable_pathman_for('range_rel');
</programlisting>
      <para>
        All sections and data will remain unchanged and will be handled
        by the standard &productname; inheritance mechanism.
      </para>
      <sect3 id="pg-pathman-how-to-update">
      <title>Updating pg_pathman</title>
      <para>If you already have a previous version of <filename>pg_pathman</filename> installed, complete the following steps to upgrade to a newer version:</para>
      <orderedlist>
      <listitem><para>Install <productname>&productname;</productname>.</para>
      </listitem>
      <listitem><para>Restart your <productname>&productname;</productname> cluster.</para>
      </listitem>
      <listitem><para>Execute the following queries:</para>
<programlisting>
ALTER EXTENSION pg_pathman UPDATE TO <replaceable>version</replaceable>;
SET pg_pathman.enable = t;</programlisting>
<para>where <replaceable>version</replaceable> is the <filename>pg_pathman</filename> version number, such as 1.3.</para>
      </listitem>
      </orderedlist>
      </sect3>
    </sect2>
  <sect2 id="pg-pathman-usage">
    <title>Usage</title>
    <para>
      As your database grows, indexing mechanisms may become inefficient
      and cause high latency as you run queries. To improve performance,
      ensure scalability, and optimize database administration processes
      you can use partitioning &mdash; splitting a large table into smaller
      pieces, with each row moved to a single partition according to the
      partitioning key. <productname>&productname;</productname> supports partitioning via table
      inheritance. Each partition is created as a child table with a
      CHECK constraint. For example:
    </para>
    <programlisting>
CREATE TABLE test (id SERIAL PRIMARY KEY, title TEXT);
CREATE TABLE test_1 (CHECK ( id &gt;= 100 AND id &lt; 200 )) INHERITS (test);
CREATE TABLE test_2 (CHECK ( id &gt;= 200 AND id &lt; 300 )) INHERITS (test);
</programlisting>
    <para>
      However, too many partitions may cause significant planning
      overhead as the query planner has to perform an exhaustive search
      and check constraints on each partition to build a query plan. The
      <filename>pg_pathman</filename> extension resolves this issue with
      optimized planning algorithms and partition functions based on the
      internal structure of the partitioned tables. For details on
      <filename>pg_pathman</filename> implementation specifics, see
      <xref linkend="pg-pathman-internals">.
    </para>
<sect3 id="pg-pathman-choosing-partitioning-strategies">
      <title>Choosing Partitioning Strategies</title>
      <para>
        The <filename>pg_pathman</filename> extension supports the
        following partitioning strategies: </para>
        <itemizedlist>
        <listitem><para>Hash &mdash; maps rows to
        partitions using a generic hash function. Choose this strategy
        if most of your queries will be of the exact-match type.</para></listitem>
        <listitem><para>Range &mdash; maps rows to partitions based on partitioning key ranges
        assigned to each partition. Choose this strategy if your
        database contains numeric data that you are likely to query or
        manage by ranges. For example, you may want to query historical
        data by years, or review experiment results by specific numeric
        ranges. To achieve performance gains,
        <filename>pg_pathman</filename> uses the binary search algorithm.</para></listitem></itemizedlist>
        <para>By default, <filename>pg_pathman</filename> migrates all data from the parent table
        to the newly created partitions at once (<emphasis>blocking
        partitioning</emphasis>). This approach enables you to
        restructure the table in a single transaction, but may cause
        downtime if you have a lot of data. If it is critical to avoid
        downtime, you can use <emphasis>concurrent
        partitioning</emphasis>. In this case,
        <filename>pg_pathman</filename> writes all the updates to
        the newly created partitions, but keeps the original data in the
        parent table until you explicitly migrate it. This enables you
        to partition large databases without downtime, as you can choose
        convenient time for migration and copy data in small batches
        without blocking other transactions. For details on concurrent
        partitioning, see <xref linkend="pg-pathman-running-non-blocking-data-migration">.
      </para>
      <sect4 id="pg-pathman-setting-up-hash-partitioning">
        <title>Setting up Hash Partitioning</title>
        <para>
          To perform hash partitioning with
          <filename>pg_pathman</filename>, run the
          <function>create_hash_partitions()</function> function:
        </para>
        <programlisting>
create_hash_partitions(relation         REGCLASS,
                       attribute        TEXT,
                       partitions_count INTEGER,
                       partition_data   BOOLEAN DEFAULT TRUE,
                       partition_names  TEXT[] DEFAULT NULL,
                       tablespaces      TEXT[] DEFAULT NULL)
</programlisting>
        <para>
          The <filename>pg_pathman</filename> module creates the specified number of
          partitions based on the hash function. Optionally,
          you can specify partition names and tablespaces by setting
          <literal>partition_names</literal> and
          <literal>tablespaces</literal> options, respectively.</para>
          <para>You cannot add or remove partitions after the parent table is split. If required, you can replace the specified partition with another table:
          </para>
          <programlisting>
replace_hash_partition(old_partition       REGCLASS,
                       new_partition       REGCLASS,
                       lock_parent         BOOL DEFAULT TRUE);
</programlisting>
<para>When set to <literal>true</literal>, <literal>lock_parent</literal> parameter will prevent any <command>INSERT</command>/<command>UPDATE</command>/<command>ALTER TABLE</command> queries to parent table.</para>
          <para>If you omit the optional <literal>partition_data</literal> parameter
          or set it to <literal>true</literal>, all the data from the
          parent table gets migrated to partitions. The
          <filename>pg_pathman</filename> module blocks the table for
          other transactions until data migration completes. To avoid
          downtime, you can set the <literal>partition_data</literal>
          parameter to <literal>false</literal> and later use the
          <function>partition_table_concurrently()</function> function to
          migrate your data to partitions without blocking other
          queries. For details, see the <xref linkend="pg-pathman-running-non-blocking-data-migration">.
        </para>
      </sect4>
      <sect4 id="pg-pathman-setting-up-range-partitioning">
        <title>Setting up Range Partitioning</title>
        <para>
          The <filename>pg_pathman</filename> module provides the following functions for
          range partitioning:</para>
          <itemizedlist>
          <listitem><para><function>create_range_partitions()</function> &mdash; creates
          partitions based on the specified interval and the initial
          partitioning key. New partitions are created automatically
          when you insert data outside of the initial range. </para></listitem>
          <listitem><para><function>create_partitions_from_range()</function> &mdash; creates
          partitions within the specified range. If required, you can
          add new partitions manually using partition management functions. For details, see <xref linkend="pg-pathman-partition-management">.</para></listitem></itemizedlist>
        <para>
          If you are going to add new data outside of the existing
          range, run the <function>create_range_partitions()</function>
          function:
        </para>
        <programlisting>
create_range_partitions(relation       REGCLASS,
                        attribute      TEXT,
                        start_value    ANYELEMENT,
                        p_interval     ANYELEMENT | INTERVAL,
                        p_count        INTEGER DEFAULT NULL,
                        partition_data BOOLEAN DEFAULT TRUE)
</programlisting>
        <para>
          The <filename>pg_pathman</filename> module creates partitions
          based on the specified parameters. If you omit the optional
          <literal>p_count</literal> parameter,
          <filename>pg_pathman</filename> calculates the required number
          of partitions based on the specified start value and interval.
          If you insert new data outside of the existing partition
          range, <filename>pg_pathman</filename> creates new partitions
          automatically, keeping the specified interval. This approach
          ensures that all partitions are of the same size, which can
          improve query performance and facilitate database management.
        </para>
        <para>
          If your current data range is unlikely to change, run the
          <function>create_partitions_from_range()</function> function:
        </para>
        <programlisting>
create_partitions_from_range(relation       REGCLASS,
                             attribute      TEXT,
                             start_value    ANYELEMENT,
                             end_value      ANYELEMENT,
                             p_interval     ANYELEMENT | INTERVAL,
                             partition_data BOOLEAN DEFAULT TRUE)
</programlisting>
        <para>In this case, <filename>pg_pathman</filename> does not create new partitions automatically, but you can use <link linkend="pg-pathman-partition-management">partition management functions</link> to add partitions manually, if required.</para>
        <para>
          By default, all the data from the parent table gets migrated
          to the specified number of partitions. The <filename>pg_pathman</filename> module
          blocks the table for other transactions until data migration
          completes. To avoid
          downtime, you can set the <literal>partition_data</literal>
          parameter to <literal>false</literal> and later use the
          <function>partition_table_concurrently()</function> function to
          migrate your data to partitions without blocking other
          queries. For details, see the <xref linkend="pg-pathman-running-non-blocking-data-migration">.
        </para>
      </sect4>
    </sect3>
    <sect3 id="pg-pathman-running-non-blocking-data-migration">
      <title>Running Non-Blocking Data Migration</title>
      <para>
        If it is critical to avoid downtime, you can perform concurrent
        partitioning by setting the <literal>partition_data</literal>
        parameter of the partitioning function to
        <literal>false</literal>. In this case,
        <filename>pg_pathman</filename> creates empty partitions, keeping
        all the original data in the parent table. At the same time, all
        the database updates are written to the newly created
        partitions. You can later migrate the original data to
        partitions without blocking other queries using the
        <function>partition_table_concurrently()</function> function:
      </para>
      <programlisting>
partition_table_concurrently(relation   REGCLASS,
                             batch_size INTEGER DEFAULT 1000,
                             sleep_time FLOAT8 DEFAULT 1.0)
</programlisting>
      <para>
        where:</para>
        <itemizedlist><listitem><para><literal>relation</literal> is the parent table. </para></listitem>
        <listitem><para><literal>batch_size</literal> is the number of rows to copy from
        the parent table to partitions at a time. You can set this
        parameter to any integer value from 1 to 10000. </para></listitem>
        <listitem><para>
        <literal>sleep_time</literal> is the time interval between
        migration attempts, in seconds.</para></listitem></itemizedlist>
      <para>
        The <filename>pg_pathman</filename> module starts a background worker to move the data from the
        parent table to partitions in small batches of the specified
        <literal>batch_size</literal>. If one or more rows in the batch
        are locked by other queries, <filename>pg_pathman</filename> waits
        for the specified <literal>sleep_time</literal> and tries again,
        up to 60 times. You can monitor the migration process in the
        <structname>pathman_concurrent_part_tasks</structname> view that shows
        the number of rows migrated so far:
      </para>
      <programlisting>
[user]postgres: select * from pathman_concurrent_part_tasks ;
 userid |  pid  | dbid  | relid | processed | status
--------+-------+-------+-------+-----------+---------
 user   | 20012 | 12413 | test  |    334000 | working
(1 row)
</programlisting>
      <para>
        If you need to stop data migration, run the
        <function>stop_concurrent_part_task()</function> function at any
        time:
      </para>
      <programlisting>
SELECT stop_concurrent_part_task(relation REGCLASS);
</programlisting>
      <para>
        <filename>pg_pathman</filename> completes the migration of the
        current batch and terminates the migration process.
      </para>
      <tip><para>
        When <filename>pg_pathman</filename> migrates all the data
        from the parent table, you can exclude the parent table from the
        query plan. See the <function>set_enable_parent()</function>
        function description for details.
      </para></tip>
      </sect3>
      <sect3 id="pg-pathman-managing-partitions">
        <title>Managing Partitions</title>
        <para>
          <filename>pg_pathman</filename> provides multiple functions for
          easy partition management. For details, see <xref linkend="pg-pathman-partition-management">.
        </para>
      </sect3>
  </sect2>
   <sect2 id="pg-pathman-examples">
 <title>Examples</title>
         <sect3 id="common-tips">
      <title>Common Tips</title>
      <itemizedlist>
        <listitem>
          <para>
            You can add
            <literal>partition</literal>
            column containing the names of the underlying partitions
            using the system attribute called
            <literal>tableoid</literal>:
          </para>
          <programlisting>
SELECT tableoid::regclass AS partition, * FROM partitioned_table;
</programlisting>
        </listitem>
        <listitem>
          <para>
            Though indices on a parent table are not particularly useful
            (since the parent table is supposed to be empty), they act as prototypes
            for indices on partitions. For each index on the parent
            table, <filename>pg_pathman</filename> creates a similar
            index on each partition.
          </para>
        </listitem>
        <listitem>
          <para>
            All running concurrent partitioning tasks can be listed
            using the <structname>pathman_concurrent_part_tasks</structname>
            view:
          </para>
          <programlisting>
SELECT * FROM pathman_concurrent_part_tasks;
userid  | pid  | dbid  | relid | processed | status
--------+------+-------+-------+-----------+---------
user    | 7367 | 16384 | test  |    472000 | working
(1 row)
</programlisting>
        </listitem>
        <listitem>
          <para>
            The <structname>pathman_partition_list</structname> in conjunction
            with <function>drop_range_partition()</function> can be used
            to drop range partitions in a more flexible way compared to
            <command>DROP TABLE</command>:
          </para>
          <programlisting>
SELECT drop_range_partition(partition, false) /* move data to parent */
FROM pathman_partition_list
WHERE parent = 'part_test'::regclass AND range_min::int &lt; 500;
NOTICE:  1 rows copied from part_test_11
NOTICE:  100 rows copied from part_test_1
NOTICE:  100 rows copied from part_test_2
drop_range_partition 
----------------------
dummy_test_11
dummy_test_1
dummy_test_2
(3 rows)
</programlisting>
        </listitem>
      </itemizedlist>
    </sect3>
    <sect3 id="hash-partitioning">
      <title>Hash Partitioning</title>
      <para>
        Consider an example of hash partitioning. First create a table
        with an integer column:
      </para>
      <programlisting>
CREATE TABLE items (
id       SERIAL PRIMARY KEY,
name     TEXT,
code     BIGINT);

INSERT INTO items (id, name, code)
SELECT g, md5(g::text), random() * 100000
FROM generate_series(1, 100000) as g;
</programlisting>
      <para>
        Now run the <function>create_hash_partitions()</function> function
        with appropriate arguments:
      </para>
      <programlisting>
SELECT create_hash_partitions('items', 'id', 100);
</programlisting>
      <para>
        This will create new partitions and move the data from the parent table to
        partitions.
      </para>
      <para>
        Here is an example of the query performing filtering by
        partitioning key:
      </para>
      <programlisting>
SELECT * FROM items WHERE id = 1234;
  id  |               name               | code
------+----------------------------------+------
 1234 | 81dc9bdb52d04dc20036dbd8313ed055 | 1855
(1 row)

EXPLAIN SELECT * FROM items WHERE id = 1234;
QUERY PLAN
------------------------------------------------------------------------------------
Append  (cost=0.28..8.29 rows=0 width=0)
-&gt;  Index Scan using items_34_pkey on items_34  (cost=0.28..8.29 rows=0 width=0)
Index Cond: (id = 1234)
</programlisting>
      <para>
        Notice that the <literal>Append</literal> node contains only one
        child scan, which corresponds to the <literal>WHERE</literal> clause.
      </para>
      <important>
        <para>
          Pay attention to
          the fact that <filename>pg_pathman</filename> excludes the
          parent table from the query plan.
        </para>
      </important>
      <para>
        To access the parent table, use the <literal>ONLY</literal> modifier:
      </para>
      <programlisting>
EXPLAIN SELECT * FROM ONLY items;
QUERY PLAN
------------------------------------------------------
Seq Scan on items  (cost=0.00..0.00 rows=1 width=45)
</programlisting>
    </sect3>
    <sect3 id="range-partitioning">
      <title>Range Partitioning</title>
      <para>
        Consider an example of range partitioning. Let's create a table
        containing some dummy logs:
      </para>
      <programlisting>
CREATE TABLE journal (
id      SERIAL,
dt      TIMESTAMP NOT NULL,
level   INTEGER,
msg     TEXT);

-- similar index will also be created for each partition
CREATE INDEX ON journal(dt);

-- generate some data
INSERT INTO journal (dt, level, msg)
SELECT g, random() * 6, md5(g::text)
FROM generate_series('2015-01-01'::date, '2015-12-31'::date, '1 minute') as g;
</programlisting>
      <para>
        Run the <function>create_range_partitions()</function> function to
        create partitions so that each partition would contain the data
        for one day:
      </para>
      <programlisting>
SELECT create_range_partitions('journal', 'dt', '2015-01-01'::date, '1 day'::interval);
</programlisting>
      <para>
        It will create 364 partitions and move the data from the parent table to
        partitions.
      </para>
      <para>
        New partitions are appended automatically by insert trigger, but
        it can be done manually with the following functions:
      </para>
      <programlisting>
-- add new partition with specified range
SELECT add_range_partition('journal', '2016-01-01'::date, '2016-01-07'::date);

-- append new partition with default range
SELECT append_range_partition('journal');
</programlisting>
      <para>
        The first one creates a partition with specified range. The
        second one creates a partition with default interval and appends
        it to the partition list. It is also possible to attach an
        existing table as partition. For example, we may want to attach
        an archive table (or even foreign table from another server) for
        some outdated data:
      </para>
      <programlisting>
CREATE FOREIGN TABLE journal_archive (
id      INTEGER NOT NULL,
dt      TIMESTAMP NOT NULL,
level   INTEGER,
msg     TEXT)
SERVER archive_server;

SELECT attach_range_partition('journal', 'journal_archive', '2014-01-01'::date, '2015-01-01'::date);
</programlisting>
      <important>
        <para>
          The attached table must have the same columns as the partitioned table, except for the dropped columns. The attached columns must have the same type, collation, and not NULL settings as the original columns.
        </para>
      </important>
      <para>
        To merge to adjacent partitions, use the
        <literal>merge_range_partitions()</literal> function:
      </para>
      <programlisting>
SELECT merge_range_partitions('journal_archive', 'journal_1');
</programlisting>
      <para>
        To split partition by value, use the
        <literal>split_range_partition()</literal> function:
      </para>
      <programlisting>
SELECT split_range_partition('journal_366', '2016-01-03'::date);
</programlisting>
      <para>
        To detach partition, use the
        <literal>detach_range_partition()</literal> function:
      </para>
      <programlisting>
SELECT detach_range_partition('journal_archive');
</programlisting>
      <para>
        Here is an example of the query performing filtering by
        partitioning key:
      </para>
      <programlisting>
SELECT * FROM journal WHERE dt &gt;= '2015-06-01' AND dt &lt; '2015-06-03';
id      |         dt          | level |               msg
--------+---------------------+-------+----------------------------------
217441  | 2015-06-01 00:00:00 |     2 | 15053892d993ce19f580a128f87e3dbf
217442  | 2015-06-01 00:01:00 |     1 | 3a7c46f18a952d62ce5418ac2056010c
217443  | 2015-06-01 00:02:00 |     0 | 92c8de8f82faf0b139a3d99f2792311d
...
(2880 rows)

EXPLAIN SELECT * FROM journal WHERE dt &gt;= '2015-06-01' AND dt &lt; '2015-06-03';
QUERY PLAN
------------------------------------------------------------------
Append  (cost=0.00..58.80 rows=0 width=0)
-&gt;  Seq Scan on journal_152  (cost=0.00..29.40 rows=0 width=0)
-&gt;  Seq Scan on journal_153  (cost=0.00..29.40 rows=0 width=0)
(3 rows)
</programlisting>
    </sect3>
 </sect2>
  <sect2 id="pg-pathman-internals">
    <title>Internals</title>
    <para>
      <filename>pg_pathman</filename> stores partitioning configuration in
      the <structname>pathman_config</structname> table; each row contains a
      single entry for a partitioned table (relation name, partitioning
      column and its type). During the initialization stage the
      <filename>pg_pathman</filename> module caches some information about
      child partitions in the shared memory, which is used later for
      plan construction. Before a <literal>SELECT</literal> query is executed,
      <filename>pg_pathman</filename> traverses the condition tree in
      search of expressions like:
    </para>
    <programlisting>
VARIABLE OP CONST
</programlisting>
    <para>
      where <literal>VARIABLE</literal> is a partitioning key,
      <literal>OP</literal> is a comparison operator (supported
      operators are =, &lt;, &lt;=, &gt;, &gt;=),
      <literal>CONST</literal> is a scalar value. For example:
    </para>
    <programlisting>
WHERE id = 150
</programlisting>
    <para>
      Based on the partitioning type and condition's operator,
      <filename>pg_pathman</filename> searches for the corresponding
      partitions and builds the plan.
    </para>
    <sect3 id="pg-pathman-custom-plan-nodes">
      <title>Custom Plan Nodes</title>
    <para>
      <filename>pg_pathman</filename> provides a couple of
      <ulink url="https://wiki.postgresql.org/wiki/CustomScanAPI">custom
      plan nodes</ulink> which aim to reduce execution time, namely:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <literal>RuntimeAppend</literal> (overrides
          <literal>Append</literal> plan node)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>RuntimeMergeAppend</literal> (overrides
          <literal>MergeAppend</literal> plan node)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>PartitionFilter</literal> (drop-in replacement for
          INSERT triggers)
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <literal>PartitionFilter</literal> acts as a <emphasis>proxy
      node</emphasis> for INSERT's child scan, which means it can
      redirect output tuples to the corresponding partition:
    </para>
    <programlisting>
EXPLAIN (COSTS OFF)
INSERT INTO partitioned_table
SELECT generate_series(1, 10), random();
               QUERY PLAN
-----------------------------------------
 Insert on partitioned_table
   -&gt;  Custom Scan (PartitionFilter)
         -&gt;  Subquery Scan on &quot;*SELECT*&quot;
               -&gt;  Result
(4 rows)
</programlisting>
    <para>
      <literal>RuntimeAppend</literal> and
      <literal>RuntimeMergeAppend</literal> have much in common: they
      come in handy in a case when WHERE condition takes form of:
    </para>
    <programlisting>
VARIABLE OP PARAM
</programlisting>
    <para>
      This kind of expressions can no longer be optimized at planning
      time since the parameter's value is not known until the execution
      stage takes place. The problem can be solved by embedding the
      <emphasis>WHERE condition analysis routine</emphasis> into the
      original <literal>Append</literal>'s code, thus making it pick
      only required scans out of a whole bunch of planned partition
      scans. This effectively boils down to creation of a custom node
      capable of performing such a check.
    </para>
    <para>
      There are at least several cases that demonstrate usefulness of
      these nodes:
    </para>
    <programlisting>
/* create table we're going to partition */
CREATE TABLE partitioned_table(id INT NOT NULL, payload REAL);

/* insert some data */
INSERT INTO partitioned_table
SELECT generate_series(1, 1000), random();

/* perform partitioning */
SELECT create_hash_partitions('partitioned_table', 'id', 100);

/* create ordinary table */
CREATE TABLE some_table AS SELECT generate_series(1, 100) AS VAL;
    </programlisting>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis role="strong"><literal>id = (select ... limit 1)</literal></emphasis>
          <programlisting>
EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = (SELECT * FROM some_table LIMIT 1);
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Custom Scan (RuntimeAppend) (actual time=0.030..0.033 rows=1 loops=1)
   InitPlan 1 (returns $0)
     -&gt;  Limit (actual time=0.011..0.011 rows=1 loops=1)
           -&gt;  Seq Scan on some_table (actual time=0.010..0.010 rows=1 loops=1)
   -&gt;  Seq Scan on partitioned_table_70 partitioned_table (actual time=0.004..0.006 rows=1 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 9
 Planning time: 1.131 ms
 Execution time: 0.075 ms
(9 rows)

/* disable RuntimeAppend node */
SET pg_pathman.enable_runtimeappend = f;

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = (SELECT * FROM some_table LIMIT 1);
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Append (actual time=0.196..0.274 rows=1 loops=1)
   InitPlan 1 (returns $0)
     -&gt;  Limit (actual time=0.005..0.005 rows=1 loops=1)
           -&gt;  Seq Scan on some_table (actual time=0.003..0.003 rows=1 loops=1)
   -&gt;  Seq Scan on partitioned_table_0 (actual time=0.014..0.014 rows=0 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 6
   -&gt;  Seq Scan on partitioned_table_1 (actual time=0.003..0.003 rows=0 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 5
         ... /* more plans follow */
 Planning time: 1.140 ms
 Execution time: 0.855 ms
(306 rows)
          </programlisting>
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong"><literal>id = ANY (select ...)</literal></emphasis>
          <programlisting>
EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = any (SELECT * FROM some_table limit 4);
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Nested Loop (actual time=0.025..0.060 rows=4 loops=1)
   -&gt;  Limit (actual time=0.009..0.011 rows=4 loops=1)
         -&gt;  Seq Scan on some_table (actual time=0.008..0.010 rows=4 loops=1)
   -&gt;  Custom Scan (RuntimeAppend) (actual time=0.002..0.004 rows=1 loops=4)
         -&gt;  Seq Scan on partitioned_table_70 partitioned_table (actual time=0.001..0.001 rows=10 loops=1)
         -&gt;  Seq Scan on partitioned_table_26 partitioned_table (actual time=0.002..0.003 rows=9 loops=1)
         -&gt;  Seq Scan on partitioned_table_27 partitioned_table (actual time=0.001..0.002 rows=20 loops=1)
         -&gt;  Seq Scan on partitioned_table_63 partitioned_table (actual time=0.001..0.002 rows=9 loops=1)
 Planning time: 0.771 ms
 Execution time: 0.101 ms
(10 rows)

/* disable RuntimeAppend node */
SET pg_pathman.enable_runtimeappend = f;

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = any (SELECT * FROM some_table limit 4);
                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Nested Loop Semi Join (actual time=0.531..1.526 rows=4 loops=1)
   Join Filter: (partitioned_table.id = some_table.val)
   Rows Removed by Join Filter: 3990
   -&gt;  Append (actual time=0.190..0.470 rows=1000 loops=1)
         -&gt;  Seq Scan on partitioned_table (actual time=0.187..0.187 rows=0 loops=1)
         -&gt;  Seq Scan on partitioned_table_0 (actual time=0.002..0.004 rows=6 loops=1)
         -&gt;  Seq Scan on partitioned_table_1 (actual time=0.001..0.001 rows=5 loops=1)
         -&gt;  Seq Scan on partitioned_table_2 (actual time=0.002..0.004 rows=14 loops=1)
... /* 96 scans follow */
   -&gt;  Materialize (actual time=0.000..0.000 rows=4 loops=1000)
         -&gt;  Limit (actual time=0.005..0.006 rows=4 loops=1)
               -&gt;  Seq Scan on some_table (actual time=0.003..0.004 rows=4 loops=1)
 Planning time: 2.169 ms
 Execution time: 2.059 ms
(110 rows)
          </programlisting>
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong"><literal>NestLoop</literal> involving
            a partitioned table</emphasis>, which is omitted since it's
          occasionally shown above.
        </para>
          </listitem>
    </itemizedlist>
    <para>
      To learn more about custom nodes, see Alexander Korotkov's
      <ulink url="http://akorotkov.github.io/blog/2016/06/15/pg_pathman-runtime-append/">blog</ulink>.
    </para>
    </sect3>
  </sect2>
  <sect2 id="pg-pathman-reference">
    <title>Reference</title>
    <sect3 id="pg-pathman-guc-variables">
    <title>GUC Variables</title>
<para>
        There are several user-accessible <link linkend="config-setting">GUC</link>
        variables designed to toggle <filename>pg_pathman</filename> or its specific custom
        nodes on and off. 
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>pg_pathman.enable</literal> &mdash; enable/disable the 
            <filename>pg_pathman</filename> module.
          </para>
          <para>Default: <literal>on</literal></para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_runtimeappend</literal> &mdash;
            toggle the <literal>RuntimeAppend</literal> custom node on/off.
          </para>
          <para>Default: <literal>on</literal></para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_runtimemergeappend</literal> &mdash;
            toggle the <literal>RuntimeMergeAppend</literal> custom node on/off.
          </para>
          <para>Default: <literal>on</literal></para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_partitionfilter</literal> &mdash;
            toggle the <literal>PartitionFilter</literal> custom node on/off.
          </para>
          <para>Default: <literal>on</literal></para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_auto_partition</literal> &mdash;
            toggle automatic partition creation on/off (per session).
          </para>
          <para>Default: <literal>on</literal></para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.insert_into_fdw</literal> &mdash; allow
            <command>INSERT</command> operations into various foreign-data wrappers.
            Possible values: <literal>disabled</literal>, <literal>postgres</literal>, and <literal>any_fdw</literal>.
          </para>
          <para>Default: <literal>postgres</literal></para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.override_copy</literal> &mdash; toggle <command>COPY</command>
            statement hooking on/off.
          </para>
          <para>Default: <literal>on</literal></para>
        </listitem>
      </itemizedlist>
    </sect3>
      <sect3 id="views-and-tables">
    <title>Views and Tables</title>
    <sect4 id="pathman-config-main-config-storage">
      <title><literal>pathman_config</literal></title>
      <para>
        This table stores the list of partitioned tables. This is the main configuration storage.
      </para>
      <programlisting>
CREATE TABLE IF NOT EXISTS pathman_config (
    partrel         REGCLASS NOT NULL PRIMARY KEY,
    attname         TEXT NOT NULL,
    parttype        INTEGER NOT NULL,
    range_interval  TEXT);
</programlisting>
      
    </sect4>
    <sect4 id="pathman-config-params-optional-parameters">
      <title><literal>pathman_config_params</literal></title>
      <para>
        This table stores optional parameters that override standard <filename>pg_pathman</filename>
        behavior.
      </para>
      <programlisting>
CREATE TABLE IF NOT EXISTS pathman_config_params (
    partrel        REGCLASS NOT NULL PRIMARY KEY,
    enable_parent  BOOLEAN NOT NULL DEFAULT TRUE,
    auto           BOOLEAN NOT NULL DEFAULT TRUE,
    init_callback  REGPROCEDURE NOT NULL DEFAULT 0,
    spawn_using_bgw BOOLEAN NOT NULL DEFAULT FALSE);
</programlisting>
    </sect4>
    <sect4 id="pathman-concurrent-part-tasks-currently-running-partitioning-workers">
      <title><literal>pathman_concurrent_part_tasks</literal></title>
      <para>
        This view lists all currently running concurrent partitioning
        tasks.
      </para>
      <programlisting>
-- helper SRF function
CREATE OR REPLACE FUNCTION show_concurrent_part_tasks()
RETURNS TABLE (
    userid     REGROLE,
    pid        INT,
    dbid       OID,
    relid      REGCLASS,
    processed  INT,
    status     TEXT)
AS 'pg_pathman', 'show_concurrent_part_tasks_internal'
LANGUAGE C STRICT;

CREATE OR REPLACE VIEW pathman_concurrent_part_tasks
AS SELECT * FROM show_concurrent_part_tasks();
</programlisting>
    </sect4>
    <sect4 id="pathman-partition-list-list-of-all-existing-partitions">
      <title><literal>pathman_partition_list</literal></title>
      <para>
        This view lists all existing partitions, as well as their
        parents and range boundaries (NULL for hash partitions).
      </para>
      <programlisting>
-- helper SRF function
CREATE OR REPLACE FUNCTION show_partition_list()
RETURNS TABLE (
    parent     REGCLASS,
    partition  REGCLASS,
    parttype   INT4,
    partattr   TEXT,
    range_min  TEXT,
    range_max  TEXT)
AS 'pg_pathman', 'show_partition_list_internal'
LANGUAGE C STRICT;

CREATE OR REPLACE VIEW pathman_partition_list
AS SELECT * FROM show_partition_list();
</programlisting>
    </sect4>
  </sect3>
    <sect3><title>Functions</title>
    <sect4 id="pg-pathman-partition-creation">
      <title>Partitioning Functions</title>
      <programlisting>
create_hash_partitions(relation         REGCLASS,
                       attribute        TEXT,
                       partitions_count INTEGER,
                       partition_data   BOOLEAN DEFAULT TRUE,
                       partition_names  TEXT[] DEFAULT NULL,
                       tablespaces      TEXT[] DEFAULT NULL)
</programlisting>
      <para>
        Performs hash partitioning for <literal>relation</literal> by
        integer key <literal>attribute</literal>. The
        <literal>partitions_count</literal> parameter specifies the
        number of partitions to create; it cannot be changed afterwards.
        If <literal>partition_data</literal> is <literal>true</literal>,
        all the data will be automatically migrated from the parent
        table to partitions. Note that data migration may take a while
        to finish and the table will be locked until transaction
        commits. See <function>partition_table_concurrently()</function>
        for a lock-free way to migrate data. Partition creation callback
        is invoked for each partition if set beforehand
        (see <function>set_init_callback()</function>).
      </para>
      <programlisting>
create_range_partitions(relation       REGCLASS,
                        attribute      TEXT,
                        start_value    ANYELEMENT,
                        p_interval     ANYELEMENT,
                        p_count        INTEGER DEFAULT NULL,
                        partition_data BOOLEAN DEFAULT TRUE)

create_range_partitions(relation       REGCLASS,
                        attribute      TEXT,
                        start_value    ANYELEMENT,
                        p_interval     INTERVAL,
                        p_count        INTEGER DEFAULT NULL,
                        partition_data BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Performs range partitioning for <literal>relation</literal> by
        partitioning key <literal>attribute</literal>. The
        <literal>start_value</literal> argument specifies the initial value,
        <literal>p_interval</literal> sets the default range for automatically created partitions or partitions created with
        <function>append_range_partition()</function> or
        <function>prepend_range_partition()</function>
        If <literal>p_interval</literal> is set to <literal>NULL</literal>, automatic partition creation
        is disabled. <literal>p_count</literal> is the
        number of premade partitions. If <literal>p_count</literal> is not set, than
        <filename>pg_pathman</filename> tries to determine the number of partitions based
        on the <literal>attribute</literal> value. Partition creation callback is invoked
        for each partition if set beforehand.
      </para>
      <programlisting>
create_partitions_from_range(relation       REGCLASS,
                             attribute      TEXT,
                             start_value    ANYELEMENT,
                             end_value      ANYELEMENT,
                             p_interval     ANYELEMENT,
                             partition_data BOOLEAN DEFAULT TRUE)

create_partitions_from_range(relation       REGCLASS,
                             attribute      TEXT,
                             start_value    ANYELEMENT,
                             end_value      ANYELEMENT,
                             p_interval     INTERVAL,
                             partition_data BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Performs range partitioning from specified range for
        <literal>relation</literal> by partitioning key
        <literal>attribute</literal>. Partition creation callback is
        invoked for each partition if set beforehand.
      </para>
    </sect4>
    <sect4 id="pg-pathman-data-migration">
      <title>Data Migration</title>
      <programlisting>
partition_table_concurrently(relation REGCLASS)
</programlisting>
      <para>
        Starts a background worker to move data from parent table to
        partitions. The worker utilizes short transactions to copy small
        batches of data (up to 10K rows per transaction) and thus
        doesn't significantly interfere with user's activity.
      </para>
      <programlisting>
stop_concurrent_part_task(relation REGCLASS)
</programlisting>
      <para>
        Stops a background worker performing a concurrent partitioning
        task. Note: worker will exit after it finishes relocating a
        current batch.
      </para>
    </sect4>
    <sect4 id="pg-pathman-triggers">
      <title>Triggers</title>
      <programlisting>
create_hash_update_trigger(parent REGCLASS)
</programlisting>
      <para>
        Creates the trigger on <command>UPDATE</command> for hash partitions. The <command>UPDATE</command>
        trigger isn't created by default because of the overhead. It's
        useful in cases when the key attribute might change.
      </para>
      <programlisting>
create_range_update_trigger(parent REGCLASS)
</programlisting>
      <para>
        Same as above, but for a range-partitioned table.
      </para>
    </sect4>
    <sect4 id="pg-pathman-partition-management">
      <title>Partition Management Functions</title>
      <programlisting>      
replace_hash_partition(old_partition       REGCLASS,
                       new_partition       REGCLASS,
                       lock_parent         BOOL DEFAULT TRUE)
</programlisting>
      <para>
        Replaces the specified partition of hash-partitioned table with another table.
        When set to <literal>true</literal>, the <literal>lock_parent</literal> parameter prevents any <command>INSERT</command>/<command>UPDATE</command>/<command>ALTER TABLE</command> queries to the parent table.
      </para>

      <programlisting>
split_range_partition(partition      REGCLASS,
                      value          ANYELEMENT,
                      partition_name TEXT DEFAULT NULL)
</programlisting>
      <para>
        Split range <literal>partition</literal> in two by
        <literal>value</literal>, with the specified <literal>value</literal> included into the second partition.
        Partition creation callback is invoked
        for a new partition if available.
      </para>
      <programlisting>
merge_range_partitions(partition1 REGCLASS, partition2 REGCLASS)
</programlisting>
      <para>
        Merge two adjacent range partitions. First, data from
        <literal>partition2</literal> is copied to
        <literal>partition1</literal>, then
        <literal>partition2</literal> is removed.
      </para>
      <programlisting>
merge_range_partitions(partitions REGCLASS[])
      </programlisting>
      <para>
        Merge several adjacent range partitions (partitions must be specified
        in ascending or descending order). All the data will be accumulated in
        the first partition.
      </para>      
      <programlisting>
append_range_partition(p_relation     REGCLASS,
                       partition_name TEXT DEFAULT NULL,
                       tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Append new range partition with
        <literal>pathman_config.range_interval</literal> as interval.
      </para>
      <programlisting>
prepend_range_partition(p_relation     REGCLASS,
                        partition_name TEXT DEFAULT NULL,
                        tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Prepend new range partition with
        <literal>pathman_config.range_interval</literal> as interval.
      </para>
      <programlisting>
add_range_partition(relation       REGCLASS,
                    start_value    ANYELEMENT,
                    end_value      ANYELEMENT,
                    partition_name TEXT DEFAULT NULL,
                    tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Create new range partition for <literal>relation</literal> with
        specified range bounds. If <literal>start_value</literal>
        or <literal>end_value</literal> are NULL, than the corresponding
        range bound will be infinite.
      </para>
      <programlisting>
drop_range_partition(partition TEXT, delete_data BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Drop range partition and all of its data if
        <literal>delete_data</literal> is true.
      </para>
      <programlisting>
attach_range_partition(relation    REGCLASS,
                       partition   REGCLASS,
                       start_value ANYELEMENT,
                       end_value   ANYELEMENT)
</programlisting>
      <para>
        Attach partition to the existing range-partitioned relation. The
        attached table must have exactly the same structure as the
        parent table, including the dropped columns. Partition creation
        callback is invoked if set (see
        <literal>pathman_config_params</literal>).
      </para>
      <programlisting>
detach_range_partition(partition REGCLASS)
</programlisting>
      <para>
        Detach partition from the existing range-partitioned relation.
      </para>
      <programlisting>
disable_pathman_for(relation TEXT)
</programlisting>
      <para>
        Permanently disable <filename>pg_pathman</filename> partitioning
        mechanism for the specified parent table and remove the insert
        trigger if it exists. All partitions and data remain unchanged.
      </para>
      <programlisting>
drop_partitions(parent      REGCLASS,
                delete_data BOOLEAN DEFAULT FALSE)
</programlisting>
      <para>
        Drop partitions of the <literal>parent</literal> table (both
        foreign and local relations). If <literal>delete_data</literal>
        is <literal>false</literal>, the data is copied to the parent
        table first. Default is <literal>false</literal>.
      </para>
    </sect4>
    <sect4 id="pg-pathman-additional-parameters">
      <title>Additional Parameters</title>
      <programlisting>
set_interval(relation REGCLASS, value ANYELEMENT)
</programlisting>
      <para>
        Update range-partitioned table interval. Note that interval must not
        be negative and it must not be trivial, i.e. its value should be
        greater than zero for numeric types, at least 1 microsecond for
        <type>timestamp</type> and at least 1 day
        for <type>date</type>.
      </para>      
      <programlisting>
set_enable_parent(relation REGCLASS, value BOOLEAN)
</programlisting>
      <para>
        Include/exclude parent table into/from query plan. In original
        &productname; planner parent table is always included into query
        plan even if it's empty which can lead to additional overhead.
        You can use <literal>disable_parent()</literal> if you are never
        going to use parent table as a storage. Default value depends on
        the <literal>partition_data</literal> parameter that was
        specified during initial partitioning in
        <literal>create_range_partitions()</literal> or
        <literal>create_partitions_from_range()</literal> functions. If
        the <literal>partition_data</literal> parameter was
        <literal>true</literal> then all data have already been migrated
        to partitions and parent table disabled. Otherwise it is
        enabled.
      </para>
      <programlisting>
set_auto(relation REGCLASS, value BOOLEAN)
</programlisting>
      <para>
        Enable/disable auto partition propagation (only for range
        partitioning). It is enabled by default.
      </para>
      <programlisting>
set_init_callback(relation REGCLASS, callback REGPROC DEFAULT 0)
</programlisting>
      <para>
        Set partition creation callback to be invoked for each attached
        or created partition (both hash and range). The callback must
        have the following signature:
        <literal>part_init_callback(args JSONB) RETURNS VOID</literal>.
        Parameter <literal>arg</literal> consists of several fields
        whose presence depends on partitioning type:
      </para>
      <programlisting>
/* Range-partitioned table abc (child abc_4) */
{
    &quot;parent&quot;:    &quot;abc&quot;,
    &quot;parttype&quot;:  &quot;2&quot;,
    &quot;partition&quot;: &quot;abc_4&quot;,
    &quot;range_max&quot;: &quot;401&quot;,
    &quot;range_min&quot;: &quot;301&quot;
}

/* Hash-partitioned table abc (child abc_0) */
{
    &quot;parent&quot;:    &quot;abc&quot;,
    &quot;parttype&quot;:  &quot;1&quot;,
    &quot;partition&quot;: &quot;abc_0&quot;
}
      </programlisting>
      <programlisting>
set_spawn_using_bgw(relation REGCLASS, value BOOLEAN)
      </programlisting>
      <para>
        When inserting new data beyond the partitioning range,
        use SpawnPartitionsWorker to create new partitions in a
        separate transaction.
      </para>
    </sect4>
    </sect3>
  </sect2>
    <sect2 id="authors">
    <title>Authors</title>
     <itemizedlist spacing="compact">
      <listitem>
       <para>Ildar Musin <email>i.musin@postgrespro.ru</email> Postgres Professional Ltd., Russia</para>
      </listitem>
      <listitem>
       <para>Alexander Korotkov <email>a.korotkov@postgrespro.ru</email> Postgres Professional Ltd., Russia</para>
      </listitem>
      <listitem>
       <para>Dmitry Ivanov <email>d.ivanov@postgrespro.ru</email> Postgres Professional Ltd., Russia</para>
      </listitem>
     </itemizedlist>
  </sect2>
</sect1>
