<!--
doc/src/xml/ref/notify.xml
&productname; documentation
-->

<refentry id="sql-notify">
 <indexterm zone="sql-notify"><primary>NOTIFY</primary></indexterm>

 <refmeta>
  <refentrytitle>NOTIFY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>Операторы языка SQL</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>NOTIFY</refname>
  <refpurpose>сгенерировать уведомление</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>NOTIFY <replaceable class="parameter">канал</replaceable> [ , <replaceable class="parameter">сообщение</replaceable> ]</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Описание</title>

  <para>Команда <command>NOTIFY</command> отправляет событие уведомления вместе с дополнительной строкой <quote>сообщения</quote> всем клиентским приложениям, которые до этого выполнили в текущей базе данных <command>LISTEN <replaceable class="parameter">канал</replaceable></command> с указанным именем канала. Уведомления видны всем пользователям.</para>

  <para><command>NOTIFY</command> предоставляет простой механизм межпроцессного взаимодействия для множества процессов, работающих с одной базой данных <productname>&productname;</productname>. Вместе с уведомлением может быть передана строка сообщения, а передавая дополнительные данные через таблицы базы данных, можно создать более высокоуровневые механизмы обмена структурированными данными.</para>

  <para>Информация, передаваемая клиенту с уведомлением, включает имя канала уведомлений, <acronym>PID</acronym> серверного процесса, управляющего сеансом, который выдал уведомление, и строку сообщения (она будет пустой, если сообщение не задано).</para>

  <para>Выбор подходящих имён каналов и их назначения — дело проектировщика базы данных. Обычно имя канала совпадает с именем какой-либо таблицы в базе, а событие уведомления по сути означает <quote>я изменила эту таблицу, посмотрите, что она содержит теперь</quote>. Однако команды <command>NOTIFY</command> и <command>LISTEN</command> не навязывают именно такой подход. Например, проектировщик базы данных может выбрать разные имена каналов, чтобы сигнализировать о разных типах изменений в одной таблице. Кроме того, строку сообщения тоже можно использовать для выделения различных событий.</para>

  <para>Если требуется сигнализировать о факте изменений в определённой таблице, используя <command>NOTIFY</command>, можно применить полезный программный приём — поместить <command>NOTIFY</command> в триггер уровня оператора, который будет срабатывать при изменениях в таблице. При таком подходе уведомление будет выдаваться автоматически, так что прикладной программист не рискует случайно оставить какое-либо изменение без уведомления.</para>

  <para>Транзакции оказывают значительное влияние на работу <command>NOTIFY</command>. Во-первых, если <command>NOTIFY</command> выполняется внутри транзакции, уведомления доставляются получателям после фиксирования транзакции и только в этом случае. Это разумно, так как в случае прерывания транзакции действие всех команд в ней аннулируется, включая <command>NOTIFY</command>. Однако это может обескуражить тех, кто ожидает, что уведомления будут приходить немедленно. Во-вторых, если ожидающий сеанс получает уведомление внутри транзакции, это событие не будет доставлено подключённому клиенту до завершения (фиксации или отката) транзакции. Это опять же объясняется тем, что если уведомление будет доставлено в рамках транзакции, которая затем будет прервана, может возникнуть желание как-то отменить его &mdash; но сервер не может <quote>забрать назад</quote> уведомление после того, как оно было отправлено клиенту. Поэтому уведомления доставляются только между транзакциями. Учитывая вышесказанное, в приложениях, применяющих <command>NOTIFY</command> для сигнализации в реальном времени, следует минимизировать размер транзакций.</para>

  <para>Если в рамках одной транзакции в один канал поступило несколько уведомлений с одинаковым сообщением, сервер может решить доставить только одно уведомление. Если же сообщения различаются, уведомления будут всегда доставлены по отдельности. Так же уведомления, поступающие от разных транзакций, никогда не будут объединены в одно. Не считая фильтрации последующих экземпляров дублирующихся уведомлений, <command>NOTIFY</command> гарантирует, что уведомления от одной транзакции всегда поступают в том же порядке, в каком были отправлены. Также гарантируется, что сообщения от разных транзакций поступают в порядке фиксации этих транзакций.</para>

  <para>Часто бывает, что клиент, выполнивший <command>NOTIFY</command>, ожидает уведомления на этом же канале. В этом случае он получит своё же уведомление, как и любой другой сеанс, ожидающий уведомления. В зависимости от логики приложения, это может привести к бессмысленным операциям, например, поиску изменений в таблице, которые и были внесены этим же сеансом. Этой дополнительной работы можно избежать, если проверить, не совпадает ли <acronym>PID</acronym> сигнализирующего процесса (указанный в данных события) с собственным <acronym>PID</acronym> сеанса (его можно узнать, обратившись к <application>libpq</application>). Если они совпадают, значит сеанс получил уведомление о собственных действиях, так что его можно игнорировать.</para>
 </refsect1>

 <refsect1>
  <title>Параметры</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">канал</replaceable></term>
    <listitem>
     <para>Имя канала для передачи уведомления (любой идентификатор).</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><replaceable class="parameter">сообщение</replaceable></term>
    <listitem>
     <para>Строка <quote>сообщения</quote>, которая будет передана вместе с уведомлением. Она должна задаваться простой текстовой константой. В стандартной конфигурации её длина должна быть меньше 8000 байт. (Если требуется передать двоичные данные или большой объём информации, лучше поместить их в таблицу базы данных и передать ключ этой записи.)</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Замечания</title>

  <para>Уведомления, которые были отправлены, но ещё не обработаны всеми ожидающими сеансами, содержатся в очереди. Если эта очередь переполняется, транзакции, в которых вызывается <command>NOTIFY</command>, будут завершены ошибкой при попытке фиксации. Очередь довольно велика (8 ГБ в стандартной конфигурации), так что её размера должно хватать практически во всех случаях, но если в сеансе выполняется <command>LISTEN</command>, а затем продолжается очень длительная транзакция, очередь не очищается. Как только эта очередь заполняется наполовину, в журнал записываются предупреждения, в которых указывается, какой сеанс препятствует очистке очереди. В этом случае следует добиться завершения текущей транзакции в указанном сеансе, чтобы очередь была очищена.</para>
  <para>Функция <function>pg_notification_queue_usage</function> показывает, какой процент очереди в данный момент занят ожидающими уведомлениями. За дополнительными сведениями обратитесь к <xref remap="3" linkend="functions-info"/>.</para>
  <para>Транзакция, в которой выполняется <command>NOTIFY</command>, не может быть подготовлена для двухфазной фиксации.</para>

  <refsect2>
   <title>pg_notify</title>

   <indexterm><primary>pg_notify</primary></indexterm>

   <para>Также отправить уведомление можно, используя функцию <literal><function>pg_notify</function>(<type>text</type>, <type>text</type>)</literal>. Эта функция принимает в первом аргументе имя канала, а во втором текст сообщения. Гораздо удобнее использовать её, когда требуется работать с динамическими именами каналов и сообщениями.</para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Примеры</title>

  <para>Демонстрация процедуры ожидания/получения уведомления в <application>psql</application>: <programlisting>LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
NOTIFY virtual, 'This is the payload';
Asynchronous notification "virtual" with payload "This is the payload" received from server process with PID 8448.

LISTEN foo;
SELECT pg_notify('fo' || 'o', 'pay' || 'load');
Asynchronous notification "foo" with payload "payload" received from server process with PID 14728.</programlisting></para>
 </refsect1>

 <refsect1>
  <title>Совместимость</title>

  <para>Оператор <command>NOTIFY</command> отсутствует в стандарте SQL.</para>
 </refsect1>

 <refsect1>
  <title>См. также</title>

  <simplelist type="inline">
   <member><xref linkend="sql-listen"/></member>
   <member><xref linkend="sql-unlisten"/></member>
  </simplelist>
 </refsect1>
</refentry>
