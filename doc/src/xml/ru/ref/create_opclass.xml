<!--
doc/src/xml/ref/create_opclass.xml
&productname; documentation
-->

<refentry id="sql-createopclass">
 <indexterm zone="sql-createopclass"><primary>CREATE OPERATOR CLASS</primary></indexterm>

 <refmeta>
  <refentrytitle>CREATE OPERATOR CLASS</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>Операторы языка SQL</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE OPERATOR CLASS</refname>
  <refpurpose>создать класс операторов</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE OPERATOR CLASS <replaceable class="parameter">имя</replaceable> [ DEFAULT ] FOR TYPE <replaceable class="parameter">тип_данных</replaceable>
  USING <replaceable class="parameter">метод_индекса</replaceable> [ FAMILY <replaceable class="parameter">имя_семейства</replaceable> ] AS
  {  OPERATOR <replaceable class="parameter">номер_стратегии</replaceable> <replaceable class="parameter">имя_оператора</replaceable> [ ( <replaceable class="parameter">тип_операнда</replaceable>, <replaceable class="parameter">тип_операнда</replaceable> ) ] [ FOR SEARCH | FOR ORDER BY <replaceable class="parameter">семейство_сортировки</replaceable> ]
   | FUNCTION <replaceable class="parameter">номер_опорной_функции</replaceable> [ ( <replaceable class="parameter">тип_операнда</replaceable> [ , <replaceable class="parameter">тип_операнда</replaceable> ] ) ] <replaceable class="parameter">имя_функции</replaceable> ( <replaceable class="parameter">тип_аргумента</replaceable> [, ...] )
   | STORAGE <replaceable class="parameter">тип_хранения</replaceable>
  } [, ... ]</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Описание</title>

  <para><command>CREATE OPERATOR CLASS</command> создаёт класс операторов. Класс операторов устанавливает, как данный тип будет использоваться в индексе, определяя, какие операторы исполняют конкретные роли или <quote>стратегии</quote> для этого типа данных и метода индекса. Также класс операторов определяет вспомогательные процедуры, которые будет задействовать метод индекса в случае выбора данного класса для столбца индекса. Все операторы и функции, используемые классом операторов, должны существовать до создания этого класса.</para>

  <para>Если указывается имя схемы, класс операторов создаётся в указанной схеме, в противном случае — в текущей. Два класса операторов в одной схеме могут иметь одинаковые имена, только если они предназначены для разных методов индекса.</para>

  <para>Владельцем класса операторов становится пользователь, создавший его. В настоящее время создавать классы операторов могут только суперпользователи. (Это ограничение введено потому, что ошибочное определение класса может вызвать нарушения или даже сбой в работе сервера.)</para>

  <para><command>CREATE OPERATOR CLASS</command> в настоящее время не проверяет, включает ли определение класса операторов все операторы и функции, требуемые для метода индекса, и образуют ли они целостный набор. Ответственность за правильность определения класса операторов лежит на пользователе.</para>

  <para>Связанные классы операторов могут быть сгруппированы в <firstterm>семейства операторов</firstterm>. Чтобы поместить класс в существующее семейство, добавьте параметр <literal>FAMILY</literal> в <command>CREATE OPERATOR CLASS</command>. Без этого параметра новый класс помещается в семейство, имеющее то же имя, что и класс (если такое семейство не существует, оно создаётся).</para>

  <para>За дополнительными сведениями обратитесь к <xref remap="3" linkend="xindex"/>.</para>
 </refsect1>

 <refsect1>
  <title>Параметры</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">имя</replaceable></term>
    <listitem>
     <para>Имя создаваемого класса операторов, возможно, дополненное схемой.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
     <para>Если присутствует это указание, класс операторов становится классом по умолчанию для своего типа данных. Для определённого типа данных и метода индекса можно определить не больше одного класса операторов по умолчанию.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">тип_данных</replaceable></term>
    <listitem>
     <para>Тип данных столбца, для которого предназначен этот класс операторов.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">метод_индекса</replaceable></term>
    <listitem>
     <para>Имя индексного метода, для которого предназначен этот класс операторов.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">имя_семейства</replaceable></term>
    <listitem>
     <para>Имя существующего семейства операторов, в которое будет добавлен этот класс. Если не указано, подразумевается семейство с тем же именем, что и класс (если такое семейство не существует, оно создаётся).</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">номер_стратегии</replaceable></term>
    <listitem>
     <para>Номер стратегии индексного метода для оператора, связанного с данным классом операторов.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">имя_оператора</replaceable></term>
    <listitem>
     <para>Имя (возможно, дополненное схемой) оператора, связанного с данным классом операторов.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">тип_операнда</replaceable></term>
    <listitem>
     <para>В предложении <literal>OPERATOR</literal> это тип данных операнда, либо ключевое слово <literal>NONE</literal>, характеризующее левый унарный или правый унарный оператор. Типы операндов обычно можно опустить, когда они совпадают с типом данных класса операторов.</para>

     <para>В предложении <literal>FUNCTION</literal> это тип данных операнда, который должна поддерживать эта функция, если он отличается от входного типа данных функции (для функций сравнения в B-деревьях и хеш-функций) или типа данных класса (для функций поддержки сортировки в B-деревьях и всех функций в классах операторов GiST, SP-GiST, GIN и BRIN). Обычно предполагаемые по умолчанию типы оказываются верными, так что <replaceable class="parameter">тип_операнда</replaceable> указывать в <literal>FUNCTION</literal> не нужно, кроме функций сортировки B-дерева, предназначенных для сравнений разных типов данных.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">семейство_сортировки</replaceable></term>
    <listitem>
     <para>Имя (возможно, дополненное схемой) существующего семейства операторов <literal>btree</literal>, описывающего порядок сортировки, связанный с оператором сортировки.</para>

     <para>Если не указано ни <literal>FOR SEARCH</literal> (для поиска), ни <literal>FOR ORDER BY</literal> (для сортировки), подразумевается <literal>FOR SEARCH</literal>.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">номер_опорной_функции</replaceable></term>
    <listitem>
     <para>Номер опорной процедуры индексного метода для функции, связанной с данным классом операторов.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">имя_функции</replaceable></term>
    <listitem>
     <para>Имя (возможно, дополненное схемой) функции, которая является опорной процедурой индексного метода для данного класса операторов.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">тип_аргумента</replaceable></term>
    <listitem>
     <para>Тип данных параметра функции.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">тип_хранения</replaceable></term>
    <listitem>
     <para>Тип данных, фактически сохраняемых в индексе. Обычно это тип данных столбца, но некоторые методы индекса (в настоящее время, GiST, GIN и BRIN) могут работать с отличным от него типом. Предложение <literal>STORAGE</literal> может присутствовать, только если метод индекса позволяет использовать другой тип данных.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>Предложения <literal>OPERATOR</literal>, <literal>FUNCTION</literal> и <literal>STORAGE</literal> могут указываться в любом порядке.</para>
 </refsect1>

 <refsect1>
  <title>Замечания</title>

  <para>Так как механизмы индексов не проверяют права доступа к функциям, прежде чем вызывать их, включение функций или операторов в класс операторов по сути даёт всем право на выполнение их. Обычно это не проблема для таких функций, какие бывают полезны в классе операторов.</para>

  <para>Операторы не должны реализовываться в функциях на языке SQL. SQL-функция вероятнее всего будет встроена в вызывающий запрос, что помешает оптимизатору понять, что этот запрос соответствует индексу.</para>

  <para>До <productname>PostgreSQL</productname> 8.4 предложение <literal>OPERATOR</literal> могло включать указание <literal>RECHECK</literal>. Теперь это не поддерживается, так как оператор индекса может быть <quote>неточным</quote> и это определяется на ходу в момент выполнения. Это позволяет эффективно справляться с ситуациями, когда оператор может быть или не быть неточным.</para>
 </refsect1>

 <refsect1>
  <title>Примеры</title>

  <para>Команда в следующем примере определяет класс операторов индекса GiST для типа данных <literal>_int4</literal> (массива из <type>int4</type>). Полный пример приведён в модуле <xref linkend="intarray"/>.</para>

<programlisting>CREATE OPERATOR CLASS gist__int_ops
    DEFAULT FOR TYPE _int4 USING gist AS
        OPERATOR        3       &amp;&amp;,
        OPERATOR        6       = (anyarray, anyarray),
        OPERATOR        7       @&gt;,
        OPERATOR        8       &lt;@,
        OPERATOR        20      @@ (_int4, query_int),
        FUNCTION        1       g_int_consistent (internal, _int4, smallint, oid, internal),
        FUNCTION        2       g_int_union (internal, internal),
        FUNCTION        3       g_int_compress (internal),
        FUNCTION        4       g_int_decompress (internal),
        FUNCTION        5       g_int_penalty (internal, internal, internal),
        FUNCTION        6       g_int_picksplit (internal, internal),
        FUNCTION        7       g_int_same (_int4, _int4, internal);</programlisting>
 </refsect1>

 <refsect1>
  <title>Совместимость</title>

  <para><command>CREATE OPERATOR CLASS</command> является расширением <productname>&productname;</productname>. Команда <command>CREATE OPERATOR CLASS</command> отсутствует в стандарте SQL.</para>
 </refsect1>

 <refsect1>
  <title>См. также</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteropclass"/></member>
   <member><xref linkend="sql-dropopclass"/></member>
   <member><xref linkend="sql-createopfamily"/></member>
   <member><xref linkend="sql-alteropfamily"/></member>
  </simplelist>
 </refsect1>
</refentry>
