<!--
doc/src/xml/ref/prepare.xml
&productname; documentation
-->

<refentry id="sql-prepare">
 <indexterm zone="sql-prepare"><primary>PREPARE</primary></indexterm>

 <indexterm zone="sql-prepare"><primary>подготовленные операторы</primary> <secondary>создание</secondary></indexterm>

 <refmeta>
  <refentrytitle>PREPARE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>Операторы языка SQL</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>PREPARE</refname>
  <refpurpose>подготовить оператор к выполнению</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>PREPARE <replaceable class="parameter">имя</replaceable> [ ( <replaceable class="parameter">тип_данных</replaceable> [, ...] ) ] AS <replaceable class="parameter">оператор</replaceable></synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Описание</title>

  <para><command>PREPARE</command> создаёт подготовленный оператор. Подготовленный оператор представляет собой объект на стороне сервера, позволяющий оптимизировать производительность приложений. Когда выполняется <command>PREPARE</command>, указанный оператор разбирается, анализируется и переписывается. При последующем выполнении команды <command>EXECUTE</command> подготовленный оператор планируется и исполняется. Такое разделение труда исключает повторный разбор запроса, при этом позволяет выбрать наилучший план выполнения в зависимости от определённых значений параметров.</para>

  <para>Подготовленные операторы могут принимать параметры — значения, которые подставляются в оператор, когда он собственно выполняется. При создании подготовленного оператора к этим параметрам можно обращаться по порядковому номеру, используя запись <literal>$1</literal>, <literal>$2</literal> и т. д. Дополнительно можно указать список соответствующих типов данных параметров. Если тип данных параметра не указан или объявлен как <literal>unknown</literal> (неизвестный), тип выводится из контекста, в котором используется этот параметр (если это возможно). При выполнении оператора фактические значения параметров передаются команде <command>EXECUTE</command>. За подробностями обратитесь к <xref remap="3" linkend="sql-execute"/>.</para>

  <para>Подготовленные операторы существуют только в рамках текущего сеанса работы с БД. Когда сеанс завершается, система забывает подготовленный оператор, так что его надо будет создать снова, чтобы использовать дальше. Это также означает, что один подготовленный оператор не может использоваться одновременно несколькими клиентами базы данных; но каждый клиент может создать собственный подготовленный оператор и использовать его. Освободить подготовленный оператор можно вручную, выполнив команду <xref linkend="sql-deallocate"/>.</para>

  <para>Подготовленные операторы потенциально дают наибольший выигрыш в производительности, когда в одном сеансе выполняется большое число однотипных операторов. Отличие в производительности особенно значительно, если операторы достаточно сложны для планирования или перезаписи, например, когда в запросе объединяется множество таблиц или необходимо применить несколько правил. Если оператор относительно прост в этом плане, но сложен для выполнения, выигрыш от использования подготовленных операторов будет менее заметным.</para>
 </refsect1>

 <refsect1>
  <title>Параметры</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">имя</replaceable></term>
    <listitem>
     <para>Произвольное имя, назначаемое данному подготовленному оператору. Оно должно быть уникальным в рамках одного сеанса; это имя затем используется для выполнения или освобождения ранее подготовленного оператора.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">тип_данных</replaceable></term>
    <listitem>
     <para>Тип данных параметра подготовленного оператора. Если тип данных конкретного параметра не задан или задан как <literal>unknown</literal>, он будет выводиться из контекста, в котором используется параметр. Для обращения к параметрам в самом подготовленном операторе используется запись <literal>$1</literal>, <literal>$2</literal> и т. д.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">оператор</replaceable></term>
    <listitem>
     <para>Любой оператор <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command> или <command>VALUES</command>.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-prepare-notes">
  <title>Замечания</title>

  <para>Подготовленные операторы могут использовать общие планы, а не перестраивать план для каждого набора переданных значений <command>EXECUTE</command>. Для подготовленных операторов без параметров это происходит сразу; иначе общий план выбирается после пяти и более выполнений, при которых получаются планы с ожидаемой средней стоимостью (включая издержки планирования), превышающей оценку стоимости общего плана. Когда общий план выбран, он будет использоваться до конца жизни подготовленного оператора. При использовании значений <command>EXECUTE</command>, которые редко встречаются в столбцах со множеством дублирующихся значений, могут быть построены специализированные планы настолько выгоднее общего плана, что даже с издержками планирования общий план может не использоваться никогда.</para>

  <para>Для общего плана предполагается, что значения, передаваемые в <command>EXECUTE</command>, являются уникальными значениями в столбце и что эти значения распределены равномерно. Например, если в статистике записаны три различных значения столбца, с общим планом предполагается, что проверке на равенство для столбца будут соответствовать 33% обработанных строк. Статистика по столбцам также позволяет общим планам точно вычислять избирательность для уникальных столбцов. Сравнения по столбцам с неоднородным распределением и указания несуществующих значений влияют на среднюю стоимость плана и следовательно, на то, будет ли выбран общий план и когда.</para>

  <para>Чтобы узнать, какой план выполнения выбирает <productname>&productname;</productname> для подготовленного оператора, воспользуйтесь <xref linkend="sql-explain"/> (например, напишите <command>EXPLAIN EXECUTE</command>). Если применяется общий план, он будет содержать символы параметров <literal>$<replaceable>n</replaceable></literal>, тогда как в специализированном плане будут подставлены фактические значения параметров. Оценки строк в общем плане отражают избирательность, вычисленную для конкретных параметров.</para>

  <para>Более подробно о планировании запросов и статистике, которую собирает <productname>&productname;</productname> для этих целей, можно узнать в документации <xref linkend="sql-analyze"/>.</para>

  <para>Хотя основной смысл подготовленных операторов в том, чтобы избежать многократного разбора и планирования оператора, <productname>&productname;</productname> будет принудительно заново анализировать и планировать выполнение оператора всякий раз, когда объекты базы данных, задействованные в операторе, подвергаются изменениям определения (DDL) со времени предыдущего использования подготовленного оператора. Кроме того, если от одного использования оператора к другому меняется значение <xref linkend="guc-search-path"/>, оператор будет так же разобран заново с новым <varname>search_path</varname>. (Последнее поведение появилось в <productname>PostgreSQL</productname> 9.3.) С этими правилами использование подготовленного оператора по сути почти не отличается от выполнения одного и того же запроса снова и снова, но даёт выигрыш по скорости (если определения объектов не меняются), особенно если оптимальный план от раза к разу не меняется. Однако различия всё же могут проявиться — например, когда оператор обращается к таблице по неполному имени, а затем в схеме, стоящей в пути <varname>search_path</varname> раньше, создаётся другая таблица с таким же именем, автоматический пересмотр запроса не происходит, так как никакой объект в определении оператора не изменился. Однако, если автоматический пересмотр произойдёт в результате других изменений, при последующем выполнении запроса будет задействована новая таблица.</para>

  <para>Получить список всех доступных в сеансе подготовленных операторов можно, обратившись к системному представлению <link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link>.</para>
 </refsect1>

 <refsect1 id="sql-prepare-examples">
  <title id="sql-prepare-examples-title">Примеры</title>
  <para>Создание подготовленного оператора для команды <command>INSERT</command>, который затем выполняется: <programlisting>PREPARE fooplan (int, text, bool, numeric) AS
    INSERT INTO foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, 'Hunter Valley', 't', 200.00);</programlisting></para>

  <para>Создание подготовленного оператора для команды <command>SELECT</command>, который затем выполняется: <programlisting>PREPARE usrrptplan (int) AS
    SELECT * FROM users u, logs l WHERE u.usrid=$1 AND u.usrid=l.usrid
    AND l.date = $2;
EXECUTE usrrptplan(1, current_date);</programlisting> Заметьте, что тип данных второго параметра не указывается, так что он выводится из контекста, в котором используется <literal>$2</literal>.</para>
 </refsect1>
 <refsect1>
  <title>Совместимость</title>

  <para>В стандарте SQL есть оператор <command>PREPARE</command>, но он предназначен только для применения во встраиваемом SQL. Эта версия оператора <command>PREPARE</command> имеет также несколько другой синтаксис.</para>
 </refsect1>

 <refsect1>
  <title>См. также</title>

  <simplelist type="inline">
   <member><xref linkend="sql-deallocate"/></member>
   <member><xref linkend="sql-execute"/></member>
  </simplelist>
 </refsect1>
</refentry>
