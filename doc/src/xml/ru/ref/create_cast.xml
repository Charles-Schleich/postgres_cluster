<!-- doc/src/xml/ref/create_cast.xml -->

<refentry id="sql-createcast">
 <indexterm zone="sql-createcast"><primary>CREATE CAST</primary></indexterm>

 <refmeta>
  <refentrytitle>CREATE CAST</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>Операторы языка SQL</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE CAST</refname>
  <refpurpose>создать приведение</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>CREATE CAST (<replaceable>исходный_тип</replaceable> AS <replaceable>целевой_тип</replaceable>)
    WITH FUNCTION <replaceable>имя_функции</replaceable> (<replaceable>тип_аргумента</replaceable> [, ...])
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>исходный_тип</replaceable> AS <replaceable>целевой_тип</replaceable>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>исходный_тип</replaceable> AS <replaceable>целевой_тип</replaceable>)
    WITH INOUT
    [ AS ASSIGNMENT | AS IMPLICIT ]</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createcast-description">
  <title>Описание</title>

  <para><command>CREATE CAST</command> создаёт новое приведение. Приведение определяет, как выполнить преобразование из одного типа в другой. Например, <programlisting>SELECT CAST(42 AS float8);</programlisting> преобразует целочисленную константу 42 к типу <type>float8</type>, вызывая ранее определённую функцию, в данном случае <literal>float8(int4)</literal>. (Если подходящее приведение не определено, возникнет ошибка преобразования.)</para>

  <para>Два типа могут быть <firstterm>двоично-сводимыми</firstterm>; это означает, что преобразование может быть выполнено <quote>бесплатно</quote>, без вызова какой-либо функции. Для этого требуется, чтобы соответствующие значения имели одинаковое внутреннее представление. Например, типы <type>text</type> и <type>varchar</type> двоично-сводимые в обе стороны. Отношение двоичной сводимости не обязательно симметрично. Например, приведение типа <type>xml</type> к типу <type>text</type> в текущей реализации можно выполнить бесплатно, но для преобразования в обратном направлении требуется функция, выполняющая как минимум синтаксическую проверку. (Два типа, двоично-сводимые в обе стороны, также называются двоично-совместимыми.)</para>

  <para>Приведение можно определить как <firstterm>преобразование ввода/вывода</firstterm>, используя указание <literal>WITH INOUT</literal>. В этом случае для приведения одного типа к другому вызывается функция вывода исходного типа данных, а выданная ей строка передаётся функции ввода целевого типа. Во многих случаях эта возможность избавляет от необходимости писать для преобразования всех типов отдельные функции приведения. Преобразование ввода/вывода работает так же, как и обычное приведение с функцией; отличается только реализация.</para>

  <para>По умолчанию, приведение можно вызвать, только записав его явно, то есть применив конструкцию <literal>CAST(<replaceable>x</replaceable> AS <replaceable>имя_типа</replaceable>)</literal> или <replaceable>x</replaceable><literal>::</literal><replaceable>имя_типа</replaceable>.</para>

  <para>Если приведение помечено <literal>AS ASSIGNMENT</literal>, его можно вызывать неявно, присваивая значение столбцу с целевым типом данных. Например, если <literal>foo.f1</literal> — столбец типа <type>text</type>, то команда: <programlisting>INSERT INTO foo (f1) VALUES (42);</programlisting> будет допустимой, если приведение типа <type>integer</type> к <type>text</type> помечено <literal>AS ASSIGNMENT</literal>, и не будет в противном случае. (Для описания такого типа приведений мы обычно используем термин <firstterm>приведение присваивания</firstterm>.)</para>

  <para>Если приведение помечено <literal>AS IMPLICIT</literal>, оно будет вызываться неявно в любом контексте, будь то присваивание или внутреннее преобразование в выражении. (Обычно мы называет приведение такого типа <firstterm>неявным приведением</firstterm>.) Например, рассмотрите этот запрос: <programlisting>SELECT 2 + 4.0;</programlisting> При разборе запроса константам сначала назначаются типы <type>integer</type> и <type>numeric</type>. Однако в системных каталогах нет оператора <type>integer</type> <literal>+</literal> <type>numeric</type>, хотя есть оператор <type>numeric</type> <literal>+</literal> <type>numeric</type>. Таким образом, запрос выполнится успешно, если существует преобразование типа <type>integer</type> к <type>numeric</type> с пометкой <literal>AS IMPLICIT</literal> &mdash; и на самом деле это так. Анализатор запроса применит неявное приведение и запрос будет обработан, как если бы он был записан в виде <programlisting>SELECT CAST ( 2 AS numeric ) + 4.0;</programlisting></para>

  <para>Системные каталоги также содержат приведение типа <type>numeric</type> к <type>integer</type>. Если бы это приведение тоже было бы помечено <literal>AS IMPLICIT</literal> (на самом деле это не так), анализатору запроса пришлось бы выбирать между предыдущим вариантом и приведением константы <type>numeric</type> к типу <type>integer</type> с последующим применением оператора <type>integer</type> <literal>+</literal> <type>integer</type>. Не имея возможности выбрать лучший вариант, анализатор бы не смог разрешить запрос и объявил бы его неоднозначным. Именно благодаря тому, что только одно из двух приведений сделано неявным, анализатор приходит к пониманию, что предпочитаемым является преобразование выражения <type>numeric</type>-и-<type>integer</type> в <type>numeric</type>; отдельного встроенного знания об этом нет.</para>

  <para>Определяя, объявлять ли приведения неявными, разумно проявлять консерватизм. При чрезмерном количестве способов неявного приведения <productname>&productname;</productname> может выбирать неожиданные интерпретации команд, или вовсе не сможет выполнить команды из-за наличия множества возможных интерпретаций. Как правило, следует делать приведение неявно вызываемым только для преобразований, сохраняющих информацию, между типами в одной общей категории типов. Например, приведение <type>int2</type> к <type>int4</type> разумно сделать неявным, но приведение <type>float8</type> к <type>int4</type>, возможно, лучше сделать только приведением присваивания. Приведения типов разных категорий, например, <type>text</type> к <type>int4</type>, лучше делать только явными.</para>

  <note>
   <para>Иногда ради удобства или соответствия стандартам требуется ввести множество неявных преобразований для нескольких типов, что приводит к неизбежной неоднозначности. Чтобы анализатор запроса мог обеспечить желаемое поведение в таких случаях, он дополнительно принимает во внимание <firstterm>категории типов</firstterm> и <firstterm>предпочитаемые типы</firstterm>. Подробнее это описано в <xref remap="6" linkend="sql-createtype"/>.</para>
  </note>

  <para>Чтобы создать приведение, необходимо быть владельцем одного (исходного или целевого) типа и иметь право <literal>USAGE</literal> для другого типа. Создать двоично-сводимое приведение могут только суперпользователи. (Это ограничение введено потому, что преобразование данных с ошибочным двоичным сведением может легко вызывать сбой сервера.)</para>
 </refsect1>

 <refsect1>
  <title>Параметры</title>

   <variablelist>
    <varlistentry>
     <term><replaceable>исходный_тип</replaceable></term>

     <listitem>
      <para>Имя исходного типа данных для приведения.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>целевой_тип</replaceable></term>

     <listitem>
      <para>Имя целевого типа данных для приведения.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>имя_функции</replaceable>(<replaceable>тип_аргумента</replaceable> [, ...])</term>

     <listitem>
      <para>Функция, вызываемая для выполнения приведения. Имя функции может быть дополнено схемой, в противном случае для поиска функции просматривается путь поиска. Тип данных результата должен соответствовать целевому типу приведения. Аргументы функции рассматриваются ниже.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITHOUT FUNCTION</literal></term>

     <listitem>
      <para>Обозначает, что исходный тип сводится к целевому на двоичном уровне, так что функция для приведения не требуется.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITH INOUT</literal></term>

     <listitem>
      <para>Обозначает, что приведение выполняется как преобразование ввода/вывода, то есть вызывается функция вывода исходного типа данных, а её результат-строка передаётся функции ввода целевого типа.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS ASSIGNMENT</literal></term>

     <listitem>
      <para>Обозначает, что приведение может вызываться неявно в контексте присваивания.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS IMPLICIT</literal></term>

     <listitem>
      <para>Обозначает, что приведение может вызываться неявно в любом контексте.</para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>Функции, реализующие приведение, могут иметь от одного до трёх аргументов. Тип первого аргумента должен быть идентичен или двоично-сводимым к исходному типу приведения. Второй аргумент, если он есть, должен иметь тип <type>integer</type>; в нём передаётся модификатор типа, связанный с целевым типом, или <literal>-1</literal>, если он отсутствует. Третий аргумент, если он есть, должен иметь тип <type>boolean</type>; в нём передаётся <literal>true</literal>, если приведение выполняется явно, либо <literal>false</literal> в противном случае. (Это довольно экстравагантно, но стандарт SQL предусматривает разное поведение для явного и неявного приведения в некоторых случаях. Этот аргумент предназначен для функций, которые должны реализовывать такие приведения. Однако создавать собственные типы данных, для которых это имело бы значение, не рекомендуется.)</para>

  <para>Возвращаемый тип функции приведения должен быть идентичным или двоично-сводимым к целевому типу приведения.</para>

  <para>Обычно исходный и целевой типы в приведении различаются, однако можно объявить приведение одного типа к такому же, если функция, реализующая преобразование, имеет более одного аргумента. Это используется для представления в системных каталогах функций, сводящих разные длины типов. Реализующая такое приведение функция будет сводить значение типа к значению с определённым модификатором, заданному вторым аргументом.</para>

  <para>Когда исходный и целевой типы приведения различаются и функция принимает более одного аргумента, преобразование типа из одного в другой и сведение к нужной длине может выполняться за один шаг. Если же соответствующей записи не находится, приведение к типу с определённым модификатором выполняется в два этапа: сначала выполняется преобразование типа, а затем применяется модификатор типа.</para>

  <para>Приведение типа домена или к типу домена в настоящее время не осуществляется. При попытке выполнить такое приведение вместо него выполняется приведение, связанное с базовым типом домена.</para>

 </refsect1>

 <refsect1 id="sql-createcast-notes">
  <title>Замечания</title>

  <para>Для удаления приведений, созданных пользователем, применяется <xref linkend="sql-dropcast"/>.</para>

  <para>Помните, что когда требуется преобразовывать типы в обе стороны, необходимо явно описать два приведения.</para>

 <indexterm zone="sql-createcast"><primary>приведение</primary> <secondary>преобразование ввода/вывода</secondary></indexterm>

  <para>Обычно не требуется создавать приведения между пользовательскими типами и стандартными строковыми типами (<type>text</type>, <type>varchar</type> и <type>char(<replaceable>n</replaceable>)</type>, а также пользовательскими типами, относящимися к категории строковых). Для них <productname>&productname;</productname> предоставляет автоматическое преобразование ввода/вывода. Автоматические приведения к строковым типам считаются приведениями присваивания, а автоматические приведения строковых типов к другим могут быть только явными. Это поведение можно переопределить, создав собственное приведение, заменяющее автоматическое, но обычно это нужно, только чтобы сделать вызов более удобным, чем стандартное только присваивание или явное указание. Возможен и другой повод для такого переопределения — желание создать приведение, работающее не так, как функция ввода/вывода типа; но это настолько удивительно, что следует дважды подумать, хороша ли эта идея. (На самом деле у небольшого количества встроенных типов имеются подобные специфические приведения, в основном из-за требований стандарта SQL.)</para>

  <para>Хотя это и не обязательно, но рекомендуется следовать старому соглашению называть функции, реализующие приведение, по целевому типу данных. Многие привыкли выполнять преобразование типов данных, записывая его в стиле функций, т. е. <replaceable>имя_типа</replaceable>(<replaceable>x</replaceable>). Эта запись на самом деле ни больше ни меньше как просто вызов функции, реализующей приведение; такой вызов не воспринимается как именно приведение. Если называть функции, не следуя этому соглашению, это может оказаться неожиданным для пользователей. Так как <productname>&productname;</productname> позволяет перегружать одно и то же имя функции с разными типами аргументов, ничто не мешает создать множество функций приведения разных типов к одному, названных по имени этого целевого типа.</para>

  <note>
   <para>Вообще говоря, в предыдущем абзаце допущено некоторое упрощение: есть два случая, когда конструкция с вызовом функции исполняется как приведение, без сопоставления с фактической функцией. Если вызову функции <replaceable>имя</replaceable>(<replaceable>x</replaceable>) в точности не соответствует существующая функция, но имеется тип данных <replaceable>имя</replaceable> и в <structname>pg_cast</structname> есть двоично-сводимое приведение типа <replaceable>x</replaceable> к этому типу, такой вызов будет воспринят как приведение. Это исключение введено, чтобы двоично-сводимое приведение можно было вызывать, используя синтаксис функций, несмотря на то, что никакой функции преобразования у него нет. Аналогично, если запись приведения в <structname>pg_cast</structname> отсутствует, но в случае приведения это было бы преобразование в/из строкового типа, такой вызов будет выполнен как преобразование ввода/вывода. Это исключение позволяет вызывать преобразование ввода/вывода, используя синтаксис вызова функции.</para>
  </note>

  <note>
   <para>Но есть исключение и из этого исключения: преобразование ввода/вывода из составных типов в строковые нельзя вызвать в виде функции, его необходимо записать как явное приведение (используя <literal>CAST</literal> или запись <literal>::</literal>). Это исключение было добавлено, потому что после введения автоматически предоставляемых преобразований ввода/вывода, оказалось слишком легко случайно вызвать такое приведение, тогда как имелась в виду ссылка на столбец или функцию.</para>
  </note>
 </refsect1>


 <refsect1 id="sql-createcast-examples">
  <title>Примеры</title>

  <para>Создание приведения присваивания типа <type>bigint</type> к типу <type>int4</type> с помощью функции <literal>int4(bigint)</literal>: <programlisting>CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;</programlisting> (Это приведение уже предопределено в системе.)</para>
 </refsect1>

 <refsect1 id="sql-createcast-compat">
  <title>Совместимость</title>

  <para>Команда <command>CREATE CAST</command> соответствует стандарту <acronym>SQL</acronym>, за исключением того, что в стандарте ничего не говорится о двоично-сводимых типах и дополнительных аргументах реализующих функций. Указание <literal>AS IMPLICIT</literal> тоже является расширением <productname>&productname;</productname>.</para>
 </refsect1>


 <refsect1 id="sql-createcast-seealso">
  <title>См. также</title>

  <para><xref linkend="sql-createfunction"/>, <xref linkend="sql-createtype"/>, <xref linkend="sql-dropcast"/></para>
 </refsect1>

</refentry>
