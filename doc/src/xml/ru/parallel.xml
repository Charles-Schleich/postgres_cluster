<!-- doc/src/xml/parallel.xml -->

 <chapter id="parallel-query">
  <title>Параллельный запрос</title>

  <indexterm zone="parallel-query"><primary>параллельный запрос</primary></indexterm>

  <para><productname>&productname;</productname> может вырабатывать такие планы запросов, которые будут задействовать несколько CPU, чтобы получить ответ на запросы быстрее. Эта возможность называется распараллеливанием запросов. Для многих запросов параллельное выполнение не даёт никакого выигрыша, либо из-за ограничений текущей реализации, либо из-за принципиальной невозможности построить параллельный план, который был бы быстрее последовательного. Однако для запросов, в которых это может быть полезно, распараллеливание часто даёт очень значительное ускорение. Многие такие запросы могут выполняться в параллельном режиме как минимум двое быстрее, а некоторые — быстрее в четыре и даже более раз. Обычно наибольший выигрыш можно получить с запросами, обрабатывающими большой объём данных, но возвращающими пользователю всего несколько строк. В этой главе достаточно подробно рассказывается, как работают параллельные запросы и в каких ситуациях их можно использовать, чтобы пользователи, желающие применять их, понимали, чего ожидать.</para>

 <sect1 id="how-parallel-query-works">
  <title>Как работают параллельно выполняемые запросы</title>

   <para>Когда оптимизатор определяет, что параллельное выполнение будет наилучшей стратегией для конкретного запроса, он создаёт план запроса, включающий <firstterm>узел Gather</firstterm> (Сбор). Взгляните на простой пример: <screen>
EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Gather  (cost=1000.00..217018.43 rows=1 width=97)
   Workers Planned: 2
   -&gt;  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 rows=1 width=97)
         Filter: (filler ~~ '%x%'::text)
(4 rows)
</screen></para>

   <para>Во всех случаях узел <literal>Gather</literal> будет иметь ровно один дочерний план, представляющий часть общего плана, выполняемую в параллельном режиме. Если узел <literal>Gather</literal> располагается на самом верху дерева плана, в параллельном режиме будет выполняться весь запрос. Если он находится где-то в другом месте плана, параллельно будет выполняться только соответствующая часть плана. В приведённом выше примере запрос обращается только к одной таблице, так что помимо узла <literal>Gather</literal> есть только ещё один узел плана; и так как этот узел является потомком узла <literal>Gather</literal>, он будет выполняться в параллельном режиме.</para>

   <para><link linkend="using-explain">Используя EXPLAIN</link>, вы можете узнать количество исполнителей, выбранное планировщиком для данного запроса. Когда при выполнении запроса достигается узел <literal>Gather</literal>, процесс, обслуживающий сеанс пользователя, запрашивает <link linkend="bgworker">фоновые рабочие процессы</link> в этом количестве. Общее число фоновых рабочих процессов, которые могут существовать одновременно, ограничивается параметром <xref linkend="guc-max-worker-processes"/>, так что вполне возможно, что параллельный запрос будет выполняться меньшим числом рабочих процессов, чем планировалось, либо вообще без дополнительных рабочих процессов. Оптимальность плана может зависеть от числа доступных рабочих процессов, так что их нехватка может повлечь значительное снижение производительности. Если это наблюдается часто, имеет смысл увеличить <varname>max_worker_processes</varname>, чтобы одновременно могло работать больше процессов, либо уменьшить <xref linkend="guc-max-parallel-workers-per-gather"/>, чтобы планировщик ожидал их наличия в меньшем количестве.</para>

   <para>Каждый фоновый рабочий процесс, успешно запущенный для данного параллельного запроса, будет выполнять часть плана, подчинённую узлу <literal>Gather</literal>. Ведущий процесс также будет выполнять эту часть плана, но он несёт дополнительную ответственность: он должен также прочитать все кортежи, выданные рабочими процессами. Когда параллельная часть плана выдаёт лишь небольшое количество кортежей, ведущий часто ведёт себя просто как один из рабочих процессов, ускоряя выполнение запроса. И напротив, когда параллельная часть плана выдаёт множество кортежей, ведущий может быть почти всё время занят чтением кортежей, выдаваемых другими рабочими процессами, и выполнять другие шаги обработки, связанные с узлами плана выше узла <literal>Gather</literal>. В таких случаях ведущий процесс может вносить лишь минимальный вклад в выполнение параллельной части плана.</para>
 </sect1>

 <sect1 id="when-can-parallel-query-be-used">
  <title>Когда может применяться распараллеливание запросов?</title>

  <para>Планировщик запросов может отказаться от построения параллельных планов запросов в любом случае под влиянием нескольких параметров. Чтобы он строил параллельные планы запросов при каких-бы то ни было условиях, описанные далее параметры необходимо настроить указанным образом.</para>

  <itemizedlist>
    <listitem>
      <para><xref linkend="guc-max-parallel-workers-per-gather"/> должен иметь значение, большее нуля. Это особый вариант более общего ограничения на суммарное число используемых рабочих процессов, задаваемого параметром <varname>max_parallel_workers_per_gather</varname>.</para>
    </listitem>

    <listitem>
      <para><xref linkend="guc-dynamic-shared-memory-type"/> должен иметь значение, отличное от <literal>none</literal>. Для параллельного выполнения запросов нужна динамическая общая память, через которую будут передаваться данные между взаимодействующими процессами.</para>
    </listitem>
  </itemizedlist>

  <para>В дополнение к этому, система должна работать не в однопользовательском режиме. Так как в этом режиме вся СУБД работает в одном процессе, фоновые рабочие процессы в нём недоступны.</para>

  <para>Даже если принципиально возможно построить параллельные планы выполнения, планировщик не будет строить такой план для определённого запроса, если имеет место одно из следующих обстоятельств:</para>

  <itemizedlist>
    <listitem>
      <para>Запрос выполняет запись данных или блокирует строки в базе данных. Если запрос содержит операцию, изменяющую данные либо на верхнем уровне, либо внутри CTE, для такого запроса не будут строиться параллельные планы. Это ограничение текущей реализации, которое может быть смягчено в будущих версиях.</para>
    </listitem>

    <listitem>
      <para>Запрос может быть приостановлен в процессе выполнения. В ситуациях, когда система решает, что может иметь место частичное или дополнительное выполнение, план параллельного выполнения не строится. Например, курсор, созданный предложением <link linkend="sql-declare">DECLARE CURSOR</link>, никогда не будет использовать параллельный план. Подобным образом, цикл PL/pgSQL вида <literal>FOR x IN query LOOP .. END LOOP</literal> никогда не будет использовать параллельный план, так как система параллельных запросов не сможет определить, может ли безопасно выполняться код внутри цикла во время параллельного выполнения запроса.</para>
    </listitem>

    <listitem>
      <para>В запросе используются функции, помеченные как <literal>PARALLEL UNSAFE</literal>. Большинство системных функций безопасны для параллельного выполнения (<literal>PARALLEL SAFE</literal>), но пользовательские функции по умолчанию помечаются как небезопасные (<literal>PARALLEL UNSAFE</literal>). Эта характеристика функции рассматривается в <xref remap="6" linkend="parallel-safety"/>.</para>
    </listitem>

    <listitem>
      <para>Запрос работает внутри другого запроса, уже параллельного. Например, если функция, вызываемая в параллельном запросе, сама выполняет SQL-запрос, последний запрос никогда не будет выполняться параллельно. Это ограничение текущей реализации, но убирать его вряд ли следует, так как это может привести к использованию одним запросом чрезмерного количества процессов.</para>
    </listitem>

    <listitem>
      <para>Для транзакции установлен сериализуемый уровень изоляции. Это ограничение текущей реализации.</para>
    </listitem>
  </itemizedlist>

  <para>Даже когда для определённого запроса построен параллельный план, возможны различные обстоятельства, при которых этот план нельзя будет выполнить в параллельном режиме. В этих случаях ведущий процесс выполнит часть плана ниже узла <literal>Gather</literal> полностью самостоятельно, как если бы узла <literal>Gather</literal> вовсе не было. Это произойдёт только при выполнении одного из следующих условий:</para>

  <itemizedlist>
    <listitem>
      <para>Невозможно получить ни одного фонового рабочего процесса из-за ограничения общего числа этих процессов значением <xref linkend="guc-max-worker-processes"/>.</para>
    </listitem>

    <listitem>
      <para>Клиент передаёт сообщение Execute с ненулевым количеством выбираемых кортежей. За подробностями обратитесь к описанию <link linkend="protocol-flow-ext-query">протокола расширенных запросов</link>. Так как <link linkend="libpq">libpq</link> в настоящее время не позволяет передавать такие сообщения, это возможно только с клиентом, задействующим не libpq. Если это происходит часто, имеет смысл установить <xref linkend="guc-max-parallel-workers-per-gather"/> в сеансах, для которых это актуально, чтобы система не пыталась строить планы, которые могут быть неэффективны при последовательном выполнении.</para>
    </listitem>

    <listitem>
      <para>Подготовленный оператор выполняется в конструкции <literal>CREATE TABLE .. AS EXECUTE ..</literal>. Эта конструкция меняет характер операции с «только чтение» на «чтение+запись», что исключает параллельное выполнение этой операции.</para>
    </listitem>

    <listitem>
      <para>Для транзакции установлен сериализуемый уровень изоляции. Обычно эта ситуация не возникает, так как при таком уровне изоляции не строятся параллельные планы выполнения. Однако она возможна, если уровень изоляции транзакции меняется на сериализуемый после построения плана и до его выполнения.</para>
    </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="parallel-plans">
  <title>Параллельные планы</title>

  <para>Так как каждый рабочий процесс выполняет параллельную часть плана до конца, нельзя просто взять обычный план запроса и запустить его в нескольких исполнителях. В этом случае все исполнители выдавали бы полные копии выходного набора результатов, так что запрос выполнится не быстрее, чем обычно, а его результаты могут быть некорректными. Вместо этого параллельной частью плана должно быть то, что для оптимизатора представляется как <firstterm>частичный план</firstterm>; то есть такой план, при выполнении которого в отдельном процессе будет получено только подмножество выходных строк, а каждая требующаяся строка результата будет гарантированно выдана ровно одним из сотрудничающих процессов.</para>

 <sect2 id="parallel-scans">
  <title>Параллельные сканирования</title>

  <para>В настоящее время единственным вариантом сканирования, адаптированным для работы в параллельном режиме, является последовательное сканирование. Таким образом, целевая таблица в параллельном плане всегда будет сканироваться узлом <literal>Parallel Seq Scan</literal>. Блоки отношения разделяются между сотрудничающими процессами и выдаются им по одному, так что доступ к отношению остаётся последовательным. Каждый отдельный процесс сначала посещает все кортежи на назначенной ему странице, и только затем переходит к новой.</para>
 </sect2>

 <sect2 id="parallel-joins">
  <title>Параллельные соединения</title>

  <para>Целевая таблица может соединяться с одной или несколькими другими таблицами с использованием вложенных циклов или соединений по хешу. Внутренней стороной соединения может быть любой вид не параллельного плана, который в остальном поддерживается планировщиком, при условии, что он безопасен для выполнения в параллельном исполнителе. Например, это может быть сканирование индекса, при котором находится значение, взятое из внешней стороны соединения. Каждый рабочий процесс будет выполнять внутреннюю сторону соединения в полном объёме, что для соединения по хешу означает, что в каждом рабочем процессе будет строиться одна и та же хеш-таблица.</para>
 </sect2>

 <sect2 id="parallel-aggregation">
  <title>Параллельное агрегирование</title>
  <para><productname>&productname;</productname> поддерживает параллельное агрегирование, выполняя агрегирование в два этапа. Сначала каждый процесс, задействованный в параллельной части запроса, выполняет шаг агрегирования, выдавая частичный результат для каждой известной ему группы. В плане это отражает узел <literal>Partial Aggregate</literal>. Затем эти промежуточные результаты передаются ведущему через узел <literal>Gather</literal>. И наконец, ведущий заново агрегирует результаты всех рабочих процессов, чтобы получить окончательный результат. Это отражает в плане узел <literal>Finalize Aggregate</literal>.</para>
  
  <para>Так как узел <literal>Finalize Aggregate</literal> выполняется в ведущем процессе, запросы, выдающие достаточно большое количество групп по отношению к числу входных строк, будут расцениваться планировщиком как менее предпочтительные. Например, в худшем случае количество групп, выявленных узлом <literal>Finalize Aggregate</literal>, может равняться числу входных строк, обработанных всеми рабочими процессами на этапе <literal>Partial Aggregate</literal>. Очевидно, что в такой ситуации использование параллельного агрегирования не даст никакого выигрыша производительности. Планировщик запросов учитывает это в процессе планирования, так что выбор параллельного агрегирования в подобных случаях очень маловероятен.</para>

  <para>Параллельное агрегирование поддерживается не во всех случаях. Чтобы оно поддерживалось, агрегатная функция должна быть <link linkend="parallel-safety">безопасной</link> для распараллеливания и должна иметь комбинирующую функцию. Если переходное состояние агрегатной функции имеет тип <literal>internal</literal>, она должна также иметь функции сериализации и десериализации. За подробностями обратитесь к <xref remap="3" linkend="sql-createaggregate"/>. Параллельное агрегирование не поддерживается, если вызов агрегатной функции содержит предложение <literal>DISTINCT</literal> или <literal>ORDER BY</literal>. Также оно не поддерживается для сортирующих агрегатов или когда запрос включает предложение <literal>GROUPING SETS</literal>. Оно может использоваться только когда все соединения, задействованные в запросе, также входят в параллельную часть плана.</para>

 </sect2>

 <sect2 id="parallel-plan-tips">
  <title>Советы по параллельным планам</title>

  <para>Если для запроса ожидается параллельный план, но такой план не строится, можно попытаться уменьшить <xref linkend="guc-parallel-setup-cost"/> или <xref linkend="guc-parallel-tuple-cost"/>. Разумеется, этот план может оказаться медленнее последовательного плана, предпочитаемого планировщиком, но не всегда. Если вы не получаете параллельный план даже с очень маленькими значениями этих параметров (например, сбросив оба их в ноль), может быть какая-то веская причина тому, что планировщик запросов не может построить параллельный план для вашего запроса. За информацией о возможных причинах обратитесь к <xref remap="3" linkend="when-can-parallel-query-be-used"/> и <xref remap="3" linkend="parallel-safety"/>.</para>

  <para>Когда выполняется параллельный план, вы можете применить <literal>EXPLAIN (ANALYZE, VERBOSE)</literal>, чтобы просмотреть статистику по каждому узлу плана в разрезе рабочих процессов. Это может помочь определить, равномерно ли распределяется работа между всеми узлами плана, и на более общем уровне понимать характеристики производительности плана.</para>

 </sect2>
 </sect1>

 <sect1 id="parallel-safety">
  <title>Безопасность распараллеливания</title>

  <para>Планировщик классифицирует операции, вовлечённые в выполнение запроса, как либо <firstterm>безопасные для распараллеливания</firstterm>, либо <firstterm>ограниченно распараллеливаемые</firstterm>, либо <firstterm>небезопасные для распараллеливания</firstterm>. Безопасной для распараллеливания операцией считается такая, которая не мешает параллельному выполнению запроса. Ограниченно распараллеливаемой операцией считается такая, которая не может выполняться в параллельном рабочем процессе, но может выполняться в ведущем процессе, когда запрос выполняется параллельно. Таким образом, ограниченно параллельные операции никогда не могут оказаться ниже узла <literal>Gather</literal>, но могут встречаться в других местах плана с узлом <literal>Gather</literal>. Небезопасные для распараллеливания операции не могут выполняться в параллельных запросах, даже в ведущем процессе. Когда запрос содержит что-либо небезопасное для распараллеливания, параллельное выполнение для такого запроса полностью исключается.</para>

  <para>Параллельное выполнение всегда запрещается для следующих операций.</para>

  <itemizedlist>
    <listitem>
      <para>Сканирование общих табличных выражений (CTE).</para>
    </listitem>

    <listitem>
      <para>Сканирование временных таблиц.</para>
    </listitem>

    <listitem>
      <para>Сканирование сторонних таблиц, если только обёртка сторонних данных не предоставляет функцию <literal>IsForeignScanParallelSafe</literal>, которая допускает распараллеливание.</para>
    </listitem>

    <listitem>
      <para>Доступ к <literal>InitPlan</literal> или <literal>SubPlan</literal>.</para>
    </listitem>
  </itemizedlist>

 <sect2 id="parallel-labeling">
  <title>Пометки параллельности для функций и агрегатов</title>

  <para>Планировщик не может автоматически определить, является ли пользовательская обычная или агрегатная функция безопасной для распараллеливания, так как это потребовало бы предсказания действия каждой операции, которую могла бы выполнять функция. В общем случае это равнозначно решению проблемы остановки, а значит, невозможно. Даже для простых функций, где это в принципе возможно, мы не пытаемся это делать, так как это будет слишком дорогой и потенциально неточной процедурой. Вместо этого, все определяемые пользователем функции полагаются небезопасными для распараллеливания, если явно не отмечено обратное. Когда используется <xref linkend="sql-createfunction"/> или <xref linkend="sql-alterfunction"/>, функции можно назначить отметку <literal>PARALLEL SAFE</literal>, <literal>PARALLEL RESTRICTED</literal> или <literal>PARALLEL UNSAFE</literal>, отражающую её характер. В команде <xref linkend="sql-createaggregate"/> для параметра <literal>PARALLEL</literal> можно задать <literal>SAFE</literal>, <literal>RESTRICTED</literal> или <literal>UNSAFE</literal> в виде соответствующего значения.</para>

  <para>Обычные и агрегатные функции должны помечаться небезопасными для распараллеливания (<literal>PARALLEL UNSAFE</literal>), если они пишут в базу данных, обращаются к последовательностям, изменяют состояние транзакции, даже временно (как, например, функция PL/pgSQL, устанавливающая блок <literal>EXCEPTION</literal> для перехвата ошибок), либо производят постоянные изменения параметров. Подобным образом, функции должны помечаться как ограниченно распараллеливаемые (<literal>PARALLEL RESTRICTED</literal>), если они обращаются к временным таблицам, состоянию клиентского подключения, курсорам, подготовленным операторам или разнообразному локальному состоянию обслуживающего процесса, которое система не может синхронизировать между рабочими процессами. Например, по этой причине ограниченно параллельными являются функции <literal>setseed</literal> и <literal>random</literal>.</para>

  <para>В целом, если функция помечена как безопасная, когда на самом деле она небезопасна или ограниченно безопасна, или если она помечена как ограниченно безопасная, когда на самом деле она небезопасная, такая функция может выдавать ошибки или возвращать неправильные ответы при использовании в параллельном запросе. Функции на языке C могут теоретически проявлять полностью неопределённое появление при некорректной пометке, так как система никаким образом не может защитить себя от произвольного кода C, но чаще всего результат будет не хуже, чем с любой другой функцией. В случае сомнений, вероятно, лучше всего будет помечать функции как небезопасные (<literal>UNSAFE</literal>).</para>

  <para>Если функция, выполняемая в параллельном рабочем процессе, затребует блокировки, которыми не владеет ведущий, например, обращаясь к таблице, не упомянутой в запросе, эти блокировки будут освобождены по завершении процесса, а не в конце транзакции. Если вы разрабатываете функцию с таким поведением, и эта особенность выполнения оказывается критичной, пометьте такую функцию как <literal>PARALLEL RESTRICTED</literal>, чтобы она выполнялась только в ведущем процессе.</para>

  <para>Заметьте, что планировщик запросов не рассматривает возможность отложенного выполнения ограниченно распараллеливаемых обычных или агрегатных функций, задействованных в запросе, для получения лучшего плана. Поэтому, например, если предложение <literal>WHERE</literal>, применяемое к конкретной таблице, является ограниченно параллельным, планировщик запросов не будет помещать сканирование этой таблицы под узел <literal>Gather</literal>. В некоторых случаях возможно (и, вероятно, более эффективно) включить сканирование этой таблицы в параллельную часть запроса и отложить вычисление предложения <literal>WHERE</literal>, чтобы оно происходило над узлом <literal>Gather</literal>, но планировщик этого не делает.</para>

 </sect2>

 </sect1>

 </chapter>
