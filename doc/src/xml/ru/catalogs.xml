<!-- doc/src/xml/catalogs.xml -->
<!--
 Documentation of the system catalogs, directed toward &productname; developers
 -->

<chapter id="catalogs">
 <title>Системные каталоги</title>

  <para>Системные каталоги — это место, где система управления реляционной базой данных хранит метаданные схемы, в частности информацию о таблицах и столбцах, а также служебные сведения. Системные каталоги <productname>&productname;</productname> представляют собой обычные таблицы. Поэтому вы можете удалить и пересоздать их, добавить столбцы, изменить и добавить строки, т. е. разными способами вмешаться в работу системы. Обычно модифицировать системные каталоги вручную не следует, для всего этого, как правило, есть команды SQL. (Например, <command>CREATE DATABASE</command> вставляет строку в каталог <structname>pg_database</structname> &mdash; и фактически создаёт базу данных на диске.) Исключение составляют только особенные эзотерические операции, но многие из них со временем становятся выполнимыми посредством SQL-команд, так что потребность напрямую модифицировать системные каталоги постоянно уменьшается.</para>

 <sect1 id="catalogs-overview">
  <title>Обзор</title>

  <para>В <xref remap="6" linkend="catalog-table"/> кратко перечислены системные каталоги. Более подробное описание каждого каталога следует далее.</para>

  <para>Большинство системных каталогов копируются из базы-шаблона при создании базы данных и затем принадлежат этой базе. Но некоторые каталоги физически разделяются всеми базами данных в кластере; это отмечено в их описаниях.</para>

  <table id="catalog-table">
   <title>Системные каталоги</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Имя каталога</entry>
      <entry>Предназначение</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>агрегатные функции</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>методы доступа индексов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>операторы методов доступа</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>опорные процедуры методов доступа</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>значения столбцов по умолчанию</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>столбцы таблиц (<quote>атрибуты</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>идентификаторы для авторизации (роли)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>отношения членства для объектов авторизации</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>приведения (преобразования типов данных)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>таблицы, индексы, последовательности, представления (<quote>отношения</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link></entry>
      <entry>правила сортировки (параметры локали)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>ограничения-проверки, ограничения уникальности, ограничения первичного ключа и внешних ключей</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>информация о перекодировках</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>базы данных в этом кластере</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-db-role-setting"><structname>pg_db_role_setting</structname></link></entry>
      <entry>параметры, задаваемые на уровне ролей и баз данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-default-acl"><structname>pg_default_acl</structname></link></entry>
      <entry>права по умолчанию для различных типов объектов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>зависимости между объектами базы данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>описания или комментарии к объектам базы данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <entry>определения меток и значений перечислений</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-event-trigger"><structname>pg_event_trigger</structname></link></entry>
      <entry>событийные триггеры</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-extension"><structname>pg_extension</structname></link></entry>
      <entry>установленные расширения</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link></entry>
      <entry>определения обёрток сторонних данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link></entry>
      <entry>определения сторонних серверов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-table"><structname>pg_foreign_table</structname></link></entry>
      <entry>дополнительные свойства сторонних таблиц</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>дополнительные свойства индексов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>иерархия наследования таблиц</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link></entry>
      <entry>начальные права для объектов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>языки для написания функций</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>страницы данных для больших объектов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link></entry>
      <entry>метаданные для больших объектов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>схемы</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>классы операторов методов доступа</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>операторы</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <entry>семейства операторов методов доступа</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>данные шаблонов для процедурных языков</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-policy"><structname>pg_policy</structname></link></entry>
      <entry>политики защиты строк</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>функции и процедуры</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-range"><structname>pg_range</structname></link></entry>
      <entry>информация о типах диапазонов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link></entry>
      <entry>зарегистрированные источники репликации</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>правила перезаписи запросов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link></entry>
      <entry>метки безопасности для объектов базы данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>зависимости общих объектов</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>комментарии к общим объектам</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link></entry>
      <entry>метки безопасности для общих объектов баз данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>статистика планировщика</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry>табличные пространства в этом кластере баз данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-transform"><structname>pg_transform</structname></link></entry>
      <entry>трансформации (тип данных для преобразований процедурных языков)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>триггеры</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <entry>конфигурации текстового поиска</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <entry>сопоставления фрагментов в конфигурациях текстового поиска</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <entry>словари текстового поиска</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <entry>анализаторы текстового поиска</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <entry>шаблоны текстового поиска</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>типы данных</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link></entry>
      <entry>сопоставления пользователей для сторонних серверов</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate"><primary>pg_aggregate</primary></indexterm>

  <para>В каталоге <structname>pg_aggregate</structname> хранится информация об агрегатных функциях. Агрегатная функция — это такая функция, которая работает с множеством значений (обычно, с содержимым одного столбца всех строк, удовлетворяющих условию запроса) и возвращает одно значение, вычисленное по этому множеству. Типичные агрегатные функции — <function>sum</function>, <function>count</function> и <function>max</function>. Все записи в <structname>pg_aggregate</structname> представляют собой дополнение записей в <structname>pg_proc</structname>. Запись в <structname>pg_proc</structname> определяет имя агрегатной функции, типы входных и выходных данных, а также другие свойства, подобные имеющимся у обычных функций.</para>

  <table>
   <title>Столбцы <structname>pg_aggregate</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID агрегатной функции в <structname>pg_proc</structname></entry>
     </row>
     <row>
      <entry><structfield>aggkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Тип агрегатной функции: <literal>n</literal> — обычная (<quote>normal</quote>), <literal>o</literal> — сортирующая (<quote>ordered-set</quote>) или <literal>h</literal> — гипотезирующая (<quote>hypothetical-set</quote>)</entry>
     </row>
     <row>
      <entry><structfield>aggnumdirectargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Число непосредственных (не агрегируемых) аргументов для сортирующей или гипотезирующей агрегатной функции (переменный массив аргументов считается одним аргументом). Если равняется <structfield>pronargs</structfield>, агрегатная функция должна принимать переменный массив и этот массив описывает как агрегатные аргументы, так и окончательные непосредственные аргументы. Всегда равно нулю для обычных агрегатных функций.</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция перехода</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция завершения (0, если её нет)</entry>
     </row>
     <row>
      <entry><structfield>aggcombinefn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Комбинирующая функция (0, если её нет)</entry>
     </row>
     <row>
      <entry><structfield>aggserialfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция сериализации (0, если её нет)</entry>
     </row>
     <row>
      <entry><structfield>aggdeserialfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция десериализации (0, если её нет)</entry>
     </row>
     <row>
      <entry><structfield>aggmtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция прямого перехода для режима движущегося агрегата (0, если её нет)</entry>
     </row>
     <row>
      <entry><structfield>aggminvtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция обратного перехода для режима движущегося агрегата (0, если её нет)</entry>
     </row>
     <row>
      <entry><structfield>aggmfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция завершения для режима движущегося агрегата (0, если её нет)</entry>
     </row>
     <row>
      <entry><structfield>aggfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Со значением True в <structfield>aggfinalfn</structfield> передаются дополнительные фиктивные аргументы</entry>
     </row>
     <row>
      <entry><structfield>aggmfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Со значением True в <structfield>aggmfinalfn</structfield> передаются дополнительные фиктивные аргументы</entry>
     </row>
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Связанный оператор сортировки (0, если его нет)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных внутреннего состояния (перехода) агрегатной функции</entry>
     </row>
     <row>
      <entry><structfield>aggtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Приблизительный средний размер (в байтах) данных состояния перехода, либо 0 для выбора значения по умолчанию</entry>
     </row>
     <row>
      <entry><structfield>aggmtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных внутреннего состояния (перехода) для агрегатной функции в режиме движущегося агрегата (0 в случае отсутствия)</entry>
     </row>
     <row>
      <entry><structfield>aggmtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Приблизительный средний размер (в байтах) данных состояния перехода для режима движущегося агрегата, либо 0 для выбора значения по умолчанию</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Начальное значение для состояния перехода. Это текстовое поле, содержащее значение в виде внешнего строкового представления. Если это поле содержит NULL, начальным значением состояния перехода будет NULL.</entry>
     </row>
     <row>
      <entry><structfield>aggminitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Начальное значение для состояния перехода в режиме движущегося агрегата. Это текстовое поле, содержащее значение в виде внешнего строкового представления. Если это поле содержит NULL, начальным значением состояния перехода будет NULL.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Новые агрегатные функции создаются командой <xref linkend="sql-createaggregate"/>. За дополнительными сведениями о разработке агрегатных функций, значении функций перехода и т. д. обратитесь к <xref remap="3" linkend="xaggr"/>.</para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am"><primary>pg_am</primary></indexterm>

  <para>В каталоге <structname>pg_am</structname> хранится информация о методах доступа отношений. Каждая строка в нём описывает один метода доступа, поддерживаемый системой. В настоящее время методы доступа задаются только для индексов. Требования для реализации методов доступа индексов подробно рассматриваются в <xref remap="6" linkend="indexam"/>.</para>

  <table>
   <title>Столбцы <structname>pg_am</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя метода доступа</entry>
     </row>

     <row>
      <entry><structfield>amhandler</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции-обработчика, предоставляющей информацию о методе доступа</entry>
     </row>

     <row>
      <entry><structfield>amtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>На данный момент это всегда <literal>i</literal>, что указывает, что это метод доступа индекса; в будущем могут появиться и другие значения</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>До <productname>&productname;</productname> 9.6, в <structname>pg_am</structname> было много дополнительных столбцов, представляющих свойства методов доступа индексов. Теперь эти данные непосредственно видны только на уровне кода C. Однако, чтобы SQL-запросы всё же могли проверять свойства методов доступа индексов, была введена функция <function>pg_index_column_has_property()</function> и ряд связанных функций; см. <xref remap="4" linkend="functions-info-catalog-table"/>.</para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop"><primary>pg_amop</primary></indexterm>

  <para>В каталоге <structname>pg_amop</structname> хранится информация об операторах, связанных с семействами операторов методов доступа. Каждая строка в нём описывает оператор, являющийся членом семейства операторов. Членом семейства может быть либо оператор <firstterm>поиска</firstterm>, либо оператор <firstterm>упорядочивания</firstterm>. Оператор может относиться к нескольким семействам, но он не может находиться в одном семействе в более чем одной позиции поиска или позиции упорядочивания. (Допустимо, хотя и маловероятно, что оператор будет использоваться и для поиска, и для упорядочивания.)</para>

  <table>
   <title>Столбцы <structname>pg_amop</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>amopfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>Семейство операторов, к которому относится эта запись</entry>
     </row>

     <row>
      <entry><structfield>amoplefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных левого операнда оператора</entry>
     </row>

     <row>
      <entry><structfield>amoprighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных правого операнда оператора</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Номер стратегии оператора</entry>
     </row>

     <row>
      <entry><structfield>amoppurpose</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Предназначение оператора: <literal>s</literal> — поиск (search), <literal>o</literal> — упорядочивание (ordering)</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID оператора</entry>
     </row>

     <row>
      <entry><structfield>amopmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Метод доступа индекса, для которого предназначено семейство операторов</entry>
     </row>

     <row>
      <entry><structfield>amopsortfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>Семейство операторов B-дерева, в соответствии с которым сортирует данный оператор, если это оператор упорядочивания; 0, если это оператор поиска</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Запись оператора <quote>поиска</quote> указывает, что по индексу этого семейства операторов можно производить поиск и найти все строки, удовлетворяющие условию <literal>WHERE</literal> <replaceable>столбец_индекса</replaceable> <replaceable>оператор</replaceable> <replaceable>константа</replaceable>. Очевидно, такой оператор должен возвращать тип <type>boolean</type>, а тип его левого операнда должен соответствовать типу данных столбца индекса.</para>

  <para>Запись оператора <quote>упорядочивания</quote> указывает, что по индексу этого семейства операторов можно провести сканирование и получить строки в порядке, заданном предложением <literal>ORDER BY</literal> <replaceable>столбец_индекса</replaceable> <replaceable>оператор</replaceable> <replaceable>константа</replaceable>. Такой оператор может возвращать любой сортируемый тип данных, хотя тип левого операнда должен так же соответствовать типу данных столбца индекса. Точная семантика <literal>ORDER BY</literal> определяется столбцом <structfield>amopsortfamily</structfield>, который должна указывать на семейство операторов B-дерева для типа, возвращаемого оператором.</para>

  <note>
   <para>В настоящее время предполагается, что порядком сортировки для упорядочивающего оператора будет порядок по умолчанию для соответствующего семейства операторов, то есть, <literal>ASC NULLS LAST</literal>. Когда-нибудь для большей гибкости могут быть добавлены дополнительные столбцы, позволяющие явно задавать параметры сортировки.</para>
  </note>

  <para>Поле <structfield>amopmethod</structfield> в записи оператора должно соответствовать полю <structname>opfmethod</structname> содержащего его семейства (<structfield>amopmethod</structfield> добавлен сюда намеренно, эта денормализация структуры каталога объясняется соображениями производительности). Также, поля <structfield>amoplefttype</structfield> и <structfield>amoprighttype</structfield> должны соответствовать полям <structfield>oprleft</structfield> и <structfield>oprright</structfield> в записи <structname>pg_operator</structname>, на которую ссылается данная.</para>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc"><primary>pg_amproc</primary></indexterm>

  <para>В каталоге <structname>pg_amproc</structname> хранится информация об опорных процедурах, связанных с семействами операторов методов доступа. Строки в нём описывают все опорные процедуры, принадлежащие семейству операторов.</para>

  <table>
   <title>Столбцы <structname>pg_amproc</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>amprocfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>Семейство операторов, к которому относится эта запись</entry>
     </row>

     <row>
      <entry><structfield>amproclefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных левого операнда связанного оператора</entry>
     </row>

     <row>
      <entry><structfield>amprocrighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных правого операнда связанного оператора</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Номер опорной процедуры</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID процедуры</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Обычно принято, что <structfield>amproclefttype</structfield> и <structfield>amprocrighttype</structfield> определяют типы левого и правого операнда оператора(ов), которые поддерживает конкретная опорная процедура. Для некоторых методов доступа они соответствуют типам входных данных самой опорной процедуры, для других — нет. Есть понятие <quote>стандартных</quote> опорных процедур для индекса; это такие процедуры, у которых <structfield>amproclefttype</structfield> и <structfield>amprocrighttype</structfield> равняются <structfield>opcintype</structfield> класса оператора индекса.</para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef"><primary>pg_attrdef</primary></indexterm>

  <para>В каталоге <structname>pg_attrdef</structname> хранятся значения столбцов по умолчанию. Основная информация о столбцах хранится в <structname>pg_attribute</structname> (см. ниже). В этой таблице записи будут только для тех столбцов, для которых явно задаётся значение по умолчанию (при создании таблицы или добавлении столбца).</para>

  <table>
   <title>Столбцы <structname>pg_attrdef</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица, к которой принадлежит столбец</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Номер столбца</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Внутреннее представление значения столбца по умолчанию</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Понятное человеку представление значения по умолчанию</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <para>Поле <structfield>adsrc</structfield> присутствует по исторически причинам, его не стоит использовать, так как в нём не отражаются внешние факторы, способные повлиять на представление значения по умолчанию. Для отображения значения по умолчанию лучше декомпилировать поле <structfield>adbin</structfield> (применив, например <function>pg_get_expr</function> ).</para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute"><primary>pg_attribute</primary></indexterm>

  <para>В каталоге <structname>pg_attribute</structname> хранится информация о столбцах таблицы. Для каждого столбца каждой таблицы в <structname>pg_attribute</structname> существует ровно одна строка. (Также в этом каталоге будут записи для индексов и на самом деле для всех объектов, присутствующих в <structname>pg_class</structname>.)</para>

  <para>Термин &laquo;атрибут&raquo; равнозначен &laquo;столбцу&raquo; и употребляется по историческим причинам.</para>

  <table>
   <title>Столбцы <structname>pg_attribute</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица, к которой принадлежит столбец</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя столбца</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных этого столбца</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Столбец <structfield>attstattarget</structfield> управляет детализацией статистики, собираемой по этому столбцу командой <xref linkend="sql-analyze"/>. Нулевое значение указывает, что статистика не собирается. При отрицательном значении используется системное ограничение статистики по умолчанию. Точное значение положительных величин определяется типом данных. Для скалярных типов данных, <structfield>attstattarget</structfield> задаёт и целевое число собираемых <quote>самых частых значений</quote>, и целевое число создаваемых групп гистограммы.</entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Копия <literal>pg_type.typlen</literal> из записи типа столбца</entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Порядковый номер столбца. Обычные столбцы нумеруются по возрастанию, начиная с 1. Системные столбцы, такие как <structfield>oid</structfield>, имеют (обычно) отрицательные номера.</entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Число размерностей, если столбец имеет тип массива; 0 в противном случае. (В настоящее время число размерностей массива не контролируется, поэтому любое ненулевое значение по сути означает <quote>это массив</quote>.)</entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Всегда -1 в постоянном хранилище, но когда запись загружается в память, в этом поле может кешироваться смещение атрибута в строке</entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>В поле <structfield>atttypmod</structfield> записывается дополнительное число, связанное с определённым типом данных, указываемое при создании таблицы (например, максимальный размер столбца <type>varchar</type>). Это значение передаётся функциям ввода и преобразования длины конкретного типа. Для типов, которым не нужен <structfield>atttypmod</structfield>, это обычно -1.</entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Копия <literal>pg_type.typbyval</literal> из записи типа столбца</entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Обычно копия <literal>pg_type.typstorage</literal> из записи типа столбца. Для типов, поддерживающих TOAST, можно изменять это значение после создания столбца и таким образом управлять политикой хранения.</entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Копия <literal>pg_type.typalign</literal> из записи типа столбца</entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Представляет ограничение NOT NULL.</entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Столбец имеет значение по умолчанию, в этом случае в каталоге <structname>pg_attrdef</structname> будет соответствующая запись, определяющая это значение.</entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Столбец была удалён и теперь не является рабочим. Удалённый столбец может по-прежнему физически присутствовать в таблице, но анализатор запросов его игнорирует, так что обратиться к нему из SQL нельзя.</entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Столбец определён локально в данном отношении. Заметьте, что столбец может быть определён локально и при этом наследоваться.</entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Число прямых предков этого столбца. Столбец с ненулевым числом предков нельзя удалить или переименовать.</entry>
     </row>

     <row>
      <entry><structfield>attcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>Заданное для столбца правило сортировки, либо 0, если тип столбца не сортируемый.</entry>
     </row>

     <row>
      <entry><structfield>attacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа к столбцу, если они были заданы непосредственно для этого столбца</entry>
     </row>

     <row>
      <entry><structfield>attoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Параметры уровня атрибута, в виде строк <quote>ключ=значение</quote></entry>
     </row>

     <row>
      <entry><structfield>attfdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Параметры уровня атрибута для обёрток сторонних данных, в виде строк <quote>ключ=значение</quote></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>В записи удалённого столбца в <structname>pg_attribute</structname> поле <structfield>atttypid</structfield> сбрасывается в ноль, но <structfield>attlen</structfield> и другие поля, копируемые из <structname>pg_type</structname>, сохраняют актуальные значения. Это нужно, чтобы справиться с ситуацией, когда после удаления столбца удаляется и его тип данных, так что записи в <structname>pg_type</structname> больше не будет. В таких случаях для интерпретации содержимого строки таблицы могут использоваться <structfield>attlen</structfield> и другие поля.</para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid"><primary>pg_authid</primary></indexterm>

  <para>В каталоге <structname>pg_authid</structname> содержится информация об идентификаторах для авторизации (ролях). Роль включает в себя концепции <quote>пользователей</quote> и <quote>групп</quote>. Пользователь по существу представляет собой частный случай роли, с флагом <structfield>rolcanlogin</structfield>. Любая роль (с или без флага <structfield>rolcanlogin</structfield>) может включать другие роли в качестве членов; см. <link remap="4" linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.</para>

  <para>Так как в этом каталоге содержатся пароли, он не должен быть открыт для всех. Для общего пользования предназначено представление <link linkend="view-pg-roles"><structname>pg_roles</structname></link> на базе <structname>pg_authid</structname>, в котором поле пароля очищено.</para>

  <para>За подробной информацией о пользователях и управлении правами обратитесь к <xref remap="3" linkend="user-manag"/>.</para>

  <para>Так как пользователи определяются глобально, каталог <structname>pg_authid</structname> разделяется всеми базами данных кластера; есть только единственная копия <structname>pg_authid</structname> в кластере, а не отдельные в каждой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_authid</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Имя роли</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Роли имеет права суперпользователя</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Роль автоматически наследует права ролей, в которые она включена</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Роль может создавать другие роли</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Роль может создавать базы данных</entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Роль может подключаться к серверу. То есть эта роль может быть указана в качестве начального идентификатора авторизации сеанса</entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Роль является ролью репликации. Такие роли могут устанавливать соединения для репликации и создавать/удалять слоты репликации.</entry>
     </row>

     <row>
      <entry><structfield>rolbypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Роль не подчиняется никаким политикам защиты на уровне строк; за подробностями обратитесь к <xref remap="3" linkend="ddl-rowsecurity"/>.</entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>Для ролей, которые могут подключаться к серверу, это значение задаёт максимально разрешённое для этой роли число одновременных подключений. При значении -1 ограничения нет.</entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Пароль (возможно, зашифрованный) или NULL, если его нет. Если пароль зашифрован MD5, это значение начинается со строки <literal>md5</literal>, за которой идёт 32-символьный шестнадцатеричный хеш MD5. Хеш MD5 вычисляется для пароля пользователя с добавленным за ним его именем. Например, если у пользователя <literal>joe</literal> пароль <literal>xyzzy</literal>, <productname>&productname;</productname> сохранит в этом поле md5-хеш строки <literal>xyzzyjoe</literal>. Если пароль зашифрован алгоритмом SCRAM-SHA-256, это поле содержит 4 поля, разделённые двоеточиями. Первое поле — это соль, закодированная в base-64. Второе поле содержит число итераций при генерировании пароля. Третье поле содержит сохранённый ключ в шестнадцатеричном виде. В четвёртом поле содержится ключ сервера в шестнадцатеричном виде. Если пароль не соответствует этим форматам, считается, что он не зашифрован.</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Срок действия пароля (используется только при аутентификации по паролю); NULL, если срок действия не ограничен</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members"><primary>pg_auth_members</primary></indexterm>

  <para>Каталог <structname>pg_auth_members</structname> представляет отношения членства между ролями. Допускается любая не зацикленная иерархия отношений.</para>

  <para>Так как пользователи определяются глобально, <structname>pg_auth_members</structname> разделяется всеми базами данных кластера; есть только единственная копия <structname>pg_auth_members</structname> в кластере, а не отдельные в каждой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_auth_members</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Идентификатор роли, включающей другую</entry>
     </row>

     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Идентификатор роли, включаемой в роль <structfield>roleid</structfield></entry>
     </row>

     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Идентификатор роли, разрешившей членство</entry>
     </row>

     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если <structfield>member</structfield> может разрешать членство в <structfield>roleid</structfield> другим ролям</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast"><primary>pg_cast</primary></indexterm>

  <para>В каталоге <structname>pg_cast</structname> хранятся пути приведения типов (как встроенных, так и пользовательских).</para>

  <para>Следует заметить, что <structname>pg_cast</structname> представляет не каждое приведение, которое может выполнять система, а только те, которые нельзя вывести по некоторым общим правилам. Например, приведение типа домена к его базовому типу не представляется явно в <structname>pg_cast</structname>. Ещё одно важное исключение составляют <quote>автоматические приведения ввода/вывода</quote>, которые выполняются с применением собственных функций ввода/вывода типа данных, преобразующих тип в <type>text</type> или другие строковые типы — они также не представляются явно в <structname>pg_cast</structname>.</para>

  <table>
   <title>Столбцы <structname>pg_cast</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID исходного типа данных</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID целевого типа данных</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции, выполняющей приведение, или 0, если для данного метода приведения не требуется функция.</entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Определяет, в каких контекстах может выполняться приведение. Символ <literal>e</literal> означает только явное приведение (explicit), с применением синтаксиса <literal>CAST</literal> или <literal>::</literal>. Символ <literal>a</literal> означает неявное присваивание (assignment) целевому столбцу, а также явное приведение. Символ <literal>i</literal> разрешает неявное приведение (implicit), а также все остальные варианты.</entry>
     </row>
     <row>
      <entry><structfield>castmethod</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Показывает, как выполняется приведение. Символ <literal>f</literal> означает, что используется функция, указанная в поле <structfield>castfunc</structfield>. Символ <literal>i</literal> означает, что используются функции ввода/вывода. Символ <literal>b</literal> означают, что типы являются двоично-сводимыми, так что преобразование не требуется.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Функции приведения, перечисленные в <structname>pg_cast</structname>, должны всегда принимать исходный тип приведения в качестве типа первого аргумента и возвращать результат, имеющий целевой тип. Функция приведения может иметь до трёх аргументов. Второй аргумент, если он присутствует, должен иметь тип <type>integer</type>; в нём передаётся модификатор типа, связанный с целевым типом, либо -1, если такого модификатора нет. Третий аргумент, если он присутствует, должен иметь тип <type>boolean</type>; в нём передаётся <literal>true</literal>, если приведение выполняется явно, и <literal>false</literal> в противном случае.</para>

  <para>Вполне возможно создать запись в <structname>pg_cast</structname>, в которой исходный тип будет совпадать с целевым, если связанная функция приведения принимает больше одного аргумента. Такие записи представляют <quote>функции преобразования длины</quote>, которые приводят значения некоторого типа в соответствие с заданным значением модификатора.</para>

  <para>Когда в записи <structname>pg_cast</structname> исходный и целевой типы приведения различаются и функция принимает более одного аргумента, эта запись представляет преобразование типа из одного в другой и сведение к нужной длине за один шаг. Если же такой записи не находится, приведение к типу с определённым модификатором выполняется в два этапа, сначала выполняется преобразование типа, а затем применяется модификатор типа.</para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class"><primary>pg_class</primary></indexterm>

  <para>В каталоге <structname>pg_class</structname> описываются таблицы и практически всё, что имеет столбцы или каким-то образом подобно таблице. Сюда входят индексы (но смотрите также <structname>pg_index</structname>), последовательности, представления, материализованные представления, составные типы и таблицы TOAST; см. <structfield>relkind</structfield>. Далее, подразумевая все эти типы объектов, мы будем говорить об <quote>отношениях</quote>. Не все столбцы здесь имеют смысл для всех типов отношений.</para>

  <table>
   <title>Столбцы <structname>pg_class</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя таблицы, индекса, представления и т. п.</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего это отношение</entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID типа данных, соответствующего типу строки этой таблицы, если таковой есть (ноль для индексов, так как они не имеют записи в <structname>pg_type</structname>)</entry>
     </row>

     <row>
      <entry><structfield>reloftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Для типизированных таблиц, OID нижележащего составного типа, или ноль для всех других отношений</entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец отношения</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Если это индекс, применяемый метод доступа (B-дерево, хеш и т. д.)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Имя файла на диске с этим отношением; ноль означает, что это <quote>отображённое</quote> представление, имя файла для которого определяется состоянием на нижнем уровне</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>Табличное пространство, в котором хранится это отношение. Если ноль, подразумевается пространство базы данных по умолчанию. (Не имеет значения, если с отношением не связан файл на диске.)</entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Размер представления этой таблицы на диске (в страницах размера <symbol>BLCKSZ</symbol>). Это лишь примерная оценка, используемая планировщиком. Она обновляется командами <command>VACUUM</command>, <command>ANALYZE</command> и несколькими командами DDL, например, <command>CREATE INDEX</command>.</entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry/>
      <entry>Число строк в таблице. Это лишь примерная оценка, используемая планировщиком. Она обновляется командами <command>VACUUM</command>, <command>ANALYZE</command> и несколькими командами DDL, например, <command>CREATE INDEX</command>.</entry>
     </row>

     <row>
      <entry><structfield>relallvisible</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Число страниц, помеченных как &laquo;полностью видимые&raquo; в карте видимости таблицы. Это лишь примерная оценка, используемая планировщиком. Она обновляется командами <command>VACUUM</command>, <command>ANALYZE</command> и несколькими командами DDL, например, <command>CREATE INDEX</command>.</entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID таблицы TOAST, связанной с данной таблицей, или 0, если таковой нет. В таблицу TOAST, как во вторичную, <quote>выносятся</quote> большие атрибуты.</entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если это таблица и она имеет (или недавно имела) индексы</entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если эта таблица разделяется всеми базами данных в кластере. Разделяемыми являются только некоторые системные каталоги (как например, <structname>pg_database</structname>).</entry>
     </row>

     <row>
      <entry><structfield>relpersistence</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry><literal>p</literal> = постоянная таблица (permanent), <literal>u</literal> = нежурналируемая таблица (unlogged), <literal>t</literal> = временная таблица (temporary)</entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry><literal>r</literal> = обычная таблица, <literal>i</literal> = индекс (index), <literal>S</literal> = последовательность (sequence), <literal>v</literal> = представление (view), <literal>m</literal> = материализованное представление (materialized view), <literal>c</literal> = составной тип (composite), <literal>t</literal> = таблица TOAST, <literal>f</literal> = сторонняя таблица (foreign)</entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Число пользовательских столбцов в отношении (системные столбцы не считаются). Столько же соответствующих строк должно быть в <structname>pg_attribute</structname>. См. также <literal>pg_attribute.attnum</literal>.</entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Число ограничений <literal>CHECK</literal> в таблице; см. каталог <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если для каждой строки отношения генерируется OID</entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если в таблице имеется (или имелся) первичный ключ</entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если для таблицы определены (или были определены) правила; см. каталог <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
     </row>

     <row>
      <entry><structfield>relhastriggers</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если для таблицы определены (или были определены) триггеры; см. каталог <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если у таблицы есть (или были) потомки в иерархии наследования</entry>
     </row>

     <row>
      <entry><structfield>relrowsecurity</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если для таблицы включена защита на уровне строк; см. каталог <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link></entry>
     </row>

     <row>
      <entry><structfield>relforcerowsecurity</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если защита на уровне строк (когда она включена) также применяется к владельцу таблицы; см. каталог <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link></entry>
     </row>

     <row>
      <entry><structfield>relispopulated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если отношение наполнено данными (это истинно для всех отношений, кроме некоторых материализованных представлений)</entry>
     </row>

     <row>
      <entry><structfield>relreplident</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Столбцы, формирующие <quote>идентификатор реплики</quote> для строк: <literal>d</literal> = по умолчанию (первичный ключ, если есть), <literal>n</literal> = никакие (nothing), <literal>f</literal> = все столбцы, <literal>i</literal> = индекс (index), если задано значение <structfield>indisreplident</structfield>, либо набор по умолчанию</entry>
     </row>

     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Идентификаторы транзакций, предшествующие данному, в этой таблице заменены постоянным (<quote>замороженным</quote>) идентификатором транзакции. Это нужно для определения, когда требуется очищать таблицу для сокращения объёма <literal>pg_clog</literal>. Если это отношение — не таблица, значение равно нулю (<symbol>InvalidTransactionId</symbol>).</entry>
     </row>

     <row>
      <entry><structfield>relminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Идентификаторы мультитранзакций, предшествующие данному, в этой таблице заменены другим идентификатором транзакции. Это нужно для определения, когда требуется очищать таблицу для сокращения объёма <literal>pg_multixact</literal>. Если это отношение — не таблица, значение равно нулю (<symbol>InvalidMultiXactId</symbol>).</entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>

     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Специальные параметры для методов доступа, в виде строк <quote>ключ=значение</quote></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Некоторые логические флаги в <structname>pg_class</structname> поддерживаются не строго: гарантируется, что они будут установлены при переходе в определённое состояние, но они могут не сбрасываться немедленно, когда условия поменяются. Например, <structfield>relhasindex</structfield> устанавливается командой <command>CREATE INDEX</command>, но никогда не сбрасывается командой <command>DROP INDEX</command>. Вместо этого, флаг <structfield>relhasindex</structfield> сбрасывается командой <command>VACUUM</command>, если она находит, что в таблице нет индексов. Такая организация позволяет избежать состояния гонки и способствует параллельному использованию.</para>
 </sect1>

 <sect1 id="catalog-pg-collation">
  <title><structname>pg_collation</structname></title>

  <indexterm zone="catalog-pg-collation"><primary>pg_collation</primary></indexterm>

  <para>В каталоге <structname>pg_collation</structname> описываются доступные правила сортировки, которые по сути представляют собой сопоставления идентификаторов SQL с категориями локалей операционной системы. За дополнительными сведениями обратитесь к <xref remap="3" linkend="collation"/>.</para>

  <table>
   <title>Столбцы <structname>pg_collation</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>collname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя правила сортировки (уникальное для пространства имён и кодировки)</entry>
     </row>

     <row>
      <entry><structfield>collnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего это правило сортировки</entry>
     </row>

     <row>
      <entry><structfield>collowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец правила сортировки</entry>
     </row>

     <row>
      <entry><structfield>collencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Кодировка, для которой применимо это правило, или -1, если оно работает с любой кодировкой</entry>
     </row>

     <row>
      <entry><structfield>collcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry><symbol>LC_COLLATE</symbol> для данного объекта</entry>
     </row>

     <row>
      <entry><structfield>collctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry><symbol>LC_CTYPE</symbol> для данного объекта</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Заметьте, что уникальный ключ в этом каталоге определён как (<structfield>collname</structfield>, <structfield>collencoding</structfield>, <structfield>collnamespace</structfield>), а не просто как (<structfield>collname</structfield>, <structfield>collnamespace</structfield>). Вообще <productname>&productname;</productname> игнорирует все правила сортировки, для которых <structfield>collencoding</structfield> не равняется кодировке текущей базы данных или -1, а создание новых записей с тем же именем, которое уже имеет запись с <structfield>collencoding</structfield> = -1, запрещено. Таким образом, достаточно использовать полное имя SQL (<replaceable>схема</replaceable>.<replaceable>имя</replaceable>) для указания правила сортировки, несмотря на то, что оно может быть неуникальным согласно определению каталога. Такая организация каталога объясняется тем, что программа <application>initdb</application> наполняет его в момент инициализации кластера записями для всех локалей, обнаруженных в системе, так что она должна иметь возможность сохранить записи для всех кодировок, которые могут вообще когда-либо применяться в кластере.</para>

  <para>В базе данных <literal>template0</literal> может быть полезно создать правила сортировки, кодировки которых не соответствуют кодировке этой базы, но которые могут оказаться у баз данных, скопированных впоследствии из <literal>template0</literal>. В настоящее время это придётся проделать вручную.</para>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint"><primary>pg_constraint</primary></indexterm>

  <para>В каталоге <structname>pg_constraint</structname> хранятся ограничения-проверки, ограничения-исключения, а также ограничения первичного ключа, уникальности и внешних ключей, определённые для таблиц. (Ограничения столбцов описываются как и все остальные. Любое ограничение столбца равнозначно некоторому ограничению таблицы.) Ограничения на NULL представляются не здесь, а в каталоге <structname>pg_attribute</structname>.</para>

  <para>Для пользовательских триггеров ограничений (создаваемых командой <command>CREATE CONSTRAINT TRIGGER</command>) в этой таблице также создаётся запись.</para>

  <para>Здесь также хранятся ограничения доменов.</para>

  <table>
   <title>Столбцы <structname>pg_constraint</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя ограничения (не обязательно уникальное!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего это ограничение</entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry><literal>c</literal> = ограничение-проверка (check), <literal>f</literal> = внешний ключ (foreign key), <literal>p</literal> = первичный ключ (primary key), <literal>u</literal> = ограничение уникальности (unique), <literal>t</literal> = триггер ограничения (trigger), <literal>x</literal> = ограничение-исключение (exclusion)</entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Является ли ограничение откладываемым?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Является ли ограничение отложенным по умолчанию?</entry>
     </row>

     <row>
      <entry><structfield>convalidated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Было ли ограничение проверено? В настоящее время значение false возможно только для внешних ключей и ограничений CHECK</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица, для которой установлено это ограничение; 0, если это не ограничение таблицы</entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Домен, к которому относится это ограничение; 0, если это не ограничение домена</entry>
     </row>

     <row>
      <entry><structfield>conindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Индекс, поддерживающий это ограничение, если это ограничение уникальности, первичного или внешнего ключа, либо ограничение-исключение; в противном случае — 0</entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Если это внешний ключ, таблица, на которую он ссылается; иначе 0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Код действия при изменении внешнего ключа: <literal>a</literal> = нет действия, <literal>r</literal> = ограничить (restrict), <literal>c</literal> = каскадное действие (cascade), <literal>n</literal> = присвоить NULL, <literal>d</literal> = поведение по умолчанию</entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Код действия при удалении внешнего ключа: <literal>a</literal> = нет действия, <literal>r</literal> = ограничить (restrict), <literal>c</literal> = каскадное действие (cascade), <literal>n</literal> = присвоить NULL, <literal>d</literal> = поведение по умолчанию</entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Тип сопоставления внешнего ключа: <literal>f</literal> = полное (full), <literal>p</literal> = частичное (partial), <literal>s</literal> = простое (simple)</entry>
     </row>

     <row>
      <entry><structfield>conislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Ограничение определено локально в данном отношении. Заметьте, что ограничение может быть определено локально и при этом наследоваться.</entry>
     </row>

     <row>
      <entry><structfield>coninhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Число прямых предков этого ограничения. Ограничение с ненулевым числом предков нельзя удалить или переименовать.</entry>
     </row>

     <row>
      <entry><structfield>connoinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Ограничение определено локально для данного отношения и является ненаследуемым.</entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Для ограничений таблицы (включая внешние ключи, но не триггеры ограничений), определяет список столбцов, образующих ограничение</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Для внешнего ключа определяет список столбцов, на которые он ссылается</entry>
     </row>

     <row>
      <entry><structfield>conpfeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Для внешнего ключа список операторов равенства для сравнений PK = FK</entry>
     </row>

     <row>
      <entry><structfield>conppeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Для внешнего ключа список операторов равенства для сравнений PK = PK</entry>
     </row>

     <row>
      <entry><structfield>conffeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Для внешнего ключа список операторов равенства для сравнений FK = FK</entry>
     </row>

     <row>
      <entry><structfield>conexclop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Для ограничения-исключения список операторов исключения по столбцам</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Для ограничения-проверки внутреннее представление выражения</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Для ограничения-проверки понятное человеку представление выражения</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>В случае с ограничением-исключением значение <structfield>conkey</structfield> полезно только для элементов ограничений, представляющих простые ссылки на столбцы. Для других случаев в <structfield>conkey</structfield> задаётся ноль, и чтобы получить выражение, определяющее ограничение, надо обратиться к соответствующему индексу. (Таким образом, поле <structfield>conkey</structfield> имеет то же содержимое, что и <structname>pg_index</structname>.<structfield>indkey</structfield> для индекса.)</para>

  <note>
   <para>Поле <structfield>consrc</structfield> не меняется при изменении задействованных в выражении объектов; например, в нём не отслеживается переименование столбцов. Поэтому лучше не полагаться на него, а воспользоваться функцией <function>pg_get_constraintdef()</function>, чтобы получить определение ограничения-проверки.</para>
  </note>

  <note>
   <para>Поле <literal>pg_class.relchecks</literal> должно согласовываться с числом ограничений-проверок, описанных в данной таблице для каждого отношения.</para>
  </note>
 </sect1>


 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion"><primary>pg_conversion</primary></indexterm>

  <para>В каталоге <structname>pg_conversion</structname> описываются процедуры преобразования кодировки. За дополнительными сведениями обратитесь к <xref remap="3" linkend="sql-createconversion"/>.</para>

  <table>
   <title>Столбцы <structname>pg_conversion</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя перекодировки (уникальное в пространстве имён)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего эту перекодировку</entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец перекодировки</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Идентификатор исходной кодировки</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Идентификатор целевой кодировки</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Процедура преобразования</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если это перекодировка по умолчанию</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database"><primary>pg_database</primary></indexterm>

  <para>В каталоге <structname>pg_database</structname> хранится информация о доступных базах данных. Базы данных создаются командой <xref linkend="sql-createdatabase"/>. Подробнее о предназначении некоторых свойств баз можно узнать в <xref remap="6" linkend="managing-databases"/>.</para>

  <para>В отличие от большинства системных каталогов, <structname>pg_database</structname> разделяется всеми базами данных кластера: есть только один экземпляр <structname>pg_database</structname> в кластере, а не отдельные в каждой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_database</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя базы данных</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец базы данных, обычно пользователь, создавший её</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Кодировка символов для этой базы данных (<function>pg_encoding_to_char()</function> может преобразовать этот номер в имя кодировки)</entry>
     </row>

     <row>
      <entry><structfield>datcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>LC_COLLATE для этой базы данных</entry>
     </row>

     <row>
      <entry><structfield>datctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>LC_CTYPE для этой базы данных</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, базу данных сможет клонировать любой пользователь с правами <literal>CREATEDB</literal>; в противном случае, клонировать эту базу смогут только суперпользователи и её владелец.</entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если false, никто не сможет подключаться к этой базе данных. Это позволяет защитить базу данных <literal>template0</literal> от модификаций.</entry>
     </row>

     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Задаёт максимально допустимое число одновременных подключений к этой базе данных. С -1 ограничения нет.</entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Последний системный OID в базе данных; в частности, полезен для <application>pg_dump</application></entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Все идентификаторы транзакций, предшествующие данному, в этой базе данных заменены постоянным (<quote>замороженным</quote>) идентификатором транзакции. Это нужно для определения, когда требуется очищать базу данных для сокращения объёма <literal>pg_clog</literal>. Это значение вычисляется как минимум значений <structname>pg_class</structname>.<structfield>relfrozenxid</structfield> для всех таблиц.</entry>
     </row>

     <row>
      <entry><structfield>datminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Идентификаторы мультитранзакций, предшествующие данному, в этой базе данных заменены другим идентификатором транзакции. Это нужно для определения, когда требуется очищать базу данных для сокращения объёма <literal>pg_multixact</literal>. Это значение вычисляется как минимум значений <structname>pg_class</structname>.<structfield>relminmxid</structfield> для всех таблиц.</entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>Табличное пространство по умолчанию для данной базы данных. Если таблица базы находится в этом пространстве, для неё значение <structname>pg_class</structname>.<structfield>reltablespace</structfield> будет нулевым; в частности, в нём окажутся все частные системные каталоги этой базы.</entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-db-role-setting">
  <title><structname>pg_db_role_setting</structname></title>

  <indexterm zone="catalog-pg-db-role-setting"><primary>pg_db_role_setting</primary></indexterm>

  <para>В каталоге <structname>pg_db_role_setting</structname> записываются значения по умолчанию, присваиваемые переменным конфигурации во время выполнения, для различных комбинаций ролей и баз данных.</para>

  <para>В отличие от большинства системных каталогов, <structname>pg_db_role_setting</structname> разделяется всеми базами данных кластера: есть только один экземпляр <structname>pg_db_role_setting</structname> в кластере, а не отдельные в каждой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_db_role_setting</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>setdatabase</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>OID базы данных, к которой относится это присвоение переменных, или ноль, если оно не связано с базой данных</entry>
     </row>

     <row>
      <entry><structfield>setrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID роли, к которой применимо это присвоение переменных, или ноль, если оно не связано с ролью</entry>
     </row>

     <row>
      <entry><structfield>setconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Значения по умолчанию для переменных конфигурации времени выполнения</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-default-acl">
  <title><structname>pg_default_acl</structname></title>

  <indexterm zone="catalog-pg-default-acl"><primary>pg_default_acl</primary></indexterm>

  <para>В каталоге <structname>pg_default_acl</structname> хранятся определения прав, изначально присваиваемые создаваемым объектам.</para>

  <table>
   <title>Столбцы <structname>pg_default_acl</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>defaclrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID роли, связанной с этой записью</entry>
     </row>

     <row>
      <entry><structfield>defaclnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, связанного с этой записью, или 0, если запись глобальная</entry>
     </row>

     <row>
      <entry><structfield>defaclobjtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Тип объекта, права для которого определяет эта запись: <literal>r</literal> = отношение (relation) (таблица, представление), <literal>S</literal> = последовательность (sequence), <literal>f</literal> = функция (function), <literal>T</literal> = тип (type)</entry>
     </row>

     <row>
      <entry><structfield>defaclacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа, назначаемые объекту данного типа при создании</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>В каталоге <structname>pg_default_acl</structname> описываются начальные права доступа, которые будут связаны с объектом, принадлежащим заданному пользователю. В настоящее время есть два типа записей: <quote>глобальные</quote>, с <structfield>defaclnamespace</structfield> = 0, и <quote>внутрисхемные</quote>, относящиеся к конкретной схеме. Если присутствует глобальная запись, она <emphasis>переопределяет</emphasis> обычный жёстко фиксированный набор прав для данного типа объектов. Если присутствует внутрисхемная запись, она представляет набор прав, <emphasis>добавляемый</emphasis> к набору прав, определённых глобально или жёстко заданных по умолчанию.</para>

  <para>Заметьте, что когда поле ACL в другом каталоге содержит NULL, под этим подразумеваются жёстко заданные права по умолчанию для этого объекта, а <emphasis>не</emphasis> те, которые могут быть в <structname>pg_default_acl</structname> в данный момент. Права в <structname>pg_default_acl</structname> учитываются только при создании объекта.</para>

 </sect1>


 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend"><primary>pg_depend</primary></indexterm>

  <para>В каталоге <structname>pg_depend</structname> записываются отношения зависимости между объектами базы данных. Благодаря этой информации, команды <command>DROP</command> могут найти, какие объекты должны удаляться при использовании <command>DROP CASCADE</command>, или когда нужно запрещать удаление при <command>DROP RESTRICT</command>.</para>

  <para>Также смотрите описание каталога <link remap="4" linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>, который играет подобную роль в отношении совместно используемых объектов в кластере баз данных.</para>

  <table>
   <title>Столбцы <structname>pg_depend</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, в котором находится зависимый объект</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID определённого зависимого объекта</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для столбца таблицы это номер столбца (<structfield>objid</structfield> и <structfield>classid</structfield> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, в котором находится вышестоящий объект</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID определённого вышестоящего объекта</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для столбца таблицы это номер столбца (<structfield>refobjid</structfield> и <structfield>refclassid</structfield> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Код, определяющий конкретную семантику данного отношения зависимости; см. текст</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Во всех случаях, запись в <structname>pg_depend</structname> показывает, что вышестоящий объект нельзя удалить, не удаляя подчинённый объект. Однако есть несколько подвидов зависимости, задаваемых в поле <structfield>deptype</structfield>: <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</symbol> (<literal>n</literal>)</term>
     <listitem>
      <para>Обычное отношение между отдельно создаваемыми объектами. Подчинённый объект можно удалить, не затрагивая вышестоящий объект. Вышестоящий объект можно удалить только с указанием <literal>CASCADE</literal>, при этом будет удалён и подчинённый объект. Например, столбец таблицы находится в обычной зависимости от своего типа данных.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>Подчинённый объект может быть удалён отдельно от вышестоящего и должен быть удалён автоматически (вне зависимости от указаний <literal>RESTRICT</literal> и <literal>CASCADE</literal>), если удаляется вышестоящий объект. Например, именованное ограничение для таблицы находится в автоматической зависимости от таблицы, так что оно исчезнет при удалении таблицы.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>Подчинённый объект был создан в процессе создания вышестоящего и на самом деле является только частью его внутренней реализации. Для такого объекта будет запрещена команда <command>DROP</command> (мы подскажем пользователю, что вместо этого надо выполнить <command>DROP</command> вышестоящий объект). Действие <command>DROP</command> для вышестоящего объекта будет распространено и на этот подчинённый объект, вне зависимости от присутствия указания <command>CASCADE</command>. Например, триггер, созданный для обеспечения ограничения внешнего ключа, становится внутренне зависимым от записи ограничения в <structname>pg_constraint</structname>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_EXTENSION</symbol> (<literal>e</literal>)</term>
     <listitem>
      <para>Подчинённый объект входит в состав <firstterm>расширения</firstterm>, которое является вышестоящим объектом (см. <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>). Удалить подчинённый объект можно, только выполнив команду <command>DROP EXTENSION</command> для вышестоящего объекта. Функционально этот тип зависимости действует так же, как и внутренняя зависимость, но он выделен для наглядности и упрощения <application>pg_dump</application>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO_EXTENSION</symbol> (<literal>x</literal>)</term>
     <listitem>
      <para>Подчинённый объект не входит в состав расширения, которое является вышестоящим объектом (и поэтому не должен игнорироваться утилитой pg_dump), но не может функционировать без него, и поэтому должен удаляться при удалении расширения. При этом подчинённый объект может быть удалён и сам по себе.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>Зависимый объект отсутствует; этот тип записи показывает, что система сама зависит от вышестоящего объекта, так что этот объект нельзя удалять ни при каких условиях. Записи этого типа создаются только командой <command>initdb</command>. Поля зависимого объекта в такой записи содержат нули.</para>
     </listitem>
    </varlistentry>
   </variablelist> В будущем могут появиться и другие подвиды зависимости.</para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description"><primary>pg_description</primary></indexterm>

  <para>В каталоге <structname>pg_description</structname> хранятся дополнительные описания (комментарии) для объектов баз данных. Описания можно задавать с помощью команды <xref linkend="sql-comment"/> и просматривать в <application>psql</application>, используя команды <literal>\d</literal>. В начальном содержимом <structname>pg_description</structname> представлены описания многих встроенных системных объектов.</para>

  <para>Также смотрите каталог <link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>, который играет подобную роль в отношении совместно используемых объектов в кластере баз данных.</para>

  <table>
   <title>Столбцы <structname>pg_description</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID объекта, к которому относится это описание</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, к которому относится этот объект</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для комментария к столбцу таблицы это номер столбца (<structfield>objoid</structfield> и <structfield>classoid</structfield> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Произвольный текст, служащий описанием данного объекта</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-enum">
  <title><structname>pg_enum</structname></title>

  <indexterm zone="catalog-pg-enum"><primary>pg_enum</primary></indexterm>

  <para>В каталоге <structname>pg_enum</structname> содержатся записи, определяющие значения и метки для всех типов-перечислений. Внутренним представлением значения перечисления на самом деле является OID соответствующей строки в <structname>pg_enum</structname>.</para>

  <table>
   <title>Столбцы <structname>pg_enum</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>enumtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID типа в <structname>pg_type</structname>, к которому относится данное значение перечисления</entry>
     </row>

     <row>
      <entry><structfield>enumsortorder</structfield></entry>
      <entry><type>float4</type></entry>
      <entry/>
      <entry>Порядок сортировки этого значения внутри перечисления</entry>
     </row>

     <row>
      <entry><structfield>enumlabel</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Текстовая метка данного значения перечисления</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Идентификаторы OID в строках <structname>pg_enum</structname> подчиняются особому правилу: чётные OID гарантированно упорядочиваются по порядку сортировки их типа перечисления. То есть, если к одному перечислению относятся два чётных OID, меньшему OID должно соответствовать меньшее значение <structfield>enumsortorder</structfield>. Нечётные значения OID могут быть не связаны с этим порядком сортировки. Это правило позволяет во многих случаях сравнивать значения перечислений, не обращаясь к каталогам. Процедуры, создающие и изменяющие перечисления, пытаются присваивать значениям перечислений чётные OID, если это возможно.</para>

  <para>Когда создаётся тип перечисления, его членам назначаются позиции по порядку сортировки 1..<replaceable>n</replaceable>. Но у членов, добавляемых позже, могут оказаться отрицательные или дробные значения <structfield>enumsortorder</structfield>. Единственное, что требуется — чтобы эти значения были правильно упорядочены и уникальны в рамках перечисления.</para>
 </sect1>


 <sect1 id="catalog-pg-event-trigger">
  <title><structname>pg_event_trigger</structname></title>

  <indexterm zone="catalog-pg-event-trigger"><primary>pg_event_trigger</primary></indexterm>

  <para>В каталоге <structname>pg_event_trigger</structname> хранится информация о событийных триггерах. За дополнительными сведениями обратитесь к <xref remap="3" linkend="event-triggers"/>.</para>

  <table>
   <title>Столбцы <structname>pg_event_trigger</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>evtname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя триггера (должно быть уникальным)</entry>
     </row>

     <row>
      <entry><structfield>evtevent</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Указывает, для какого события срабатывает данный триггер</entry>
     </row>

     <row>
      <entry><structfield>evtowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец событийного триггера</entry>
     </row>

     <row>
      <entry><structfield>evtfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Вызываемая функция</entry>
     </row>

     <row>
      <entry><structfield>evtenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Устанавливает, в каких режимах <xref linkend="guc-session-replication-role"/> срабатывает событийный триггер: <literal>O</literal> = триггер срабатывает в режимах <quote>origin</quote> (источник) и <quote>local</quote> (локально), <literal>D</literal> = триггер отключён, <literal>R</literal> = триггер срабатывает в режиме <quote>replica</quote> (реплика), <literal>A</literal> = триггер срабатывает всегда.</entry>
     </row>

     <row>
      <entry><structfield>evttags</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Теги команд, для которых будет срабатывать триггер. Если NULL, срабатывание триггера не будет ограничено в зависимости от тега команды.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-extension">
  <title><structname>pg_extension</structname></title>

  <indexterm zone="catalog-pg-extension"><primary>pg_extension</primary></indexterm>

  <para>В каталоге <structname>pg_extension</structname> хранится информация об установленных расширениях. Подробнее о расширениях можно узнать в <xref remap="6" linkend="extend-extensions"/>.</para>

  <table>
   <title>Столбцы <structname>pg_extension</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>extname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя расширения</entry>
     </row>

     <row>
      <entry><structfield>extowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец расширения</entry>
     </row>

     <row>
      <entry><structfield>extnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Схема, содержащая экспортируемые расширением объекты</entry>
     </row>

     <row>
      <entry><structfield>extrelocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если расширение можно переместить в другую схему</entry>
     </row>

     <row>
      <entry><structfield>extversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Имя версии расширения</entry>
     </row>

     <row>
      <entry><structfield>extconfig</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Массив с идентификаторами <type>regclass</type>, указывающими на таблицы конфигурации расширения, либо <literal>NULL</literal>, если таких таблиц нет</entry>
     </row>

     <row>
      <entry><structfield>extcondition</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Массив с условиями фильтра <literal>WHERE</literal> для таблиц конфигурации расширения, либо <literal>NULL</literal>, если таких условий нет</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Заметьте, что в отличие от большинства каталогов со столбцом <quote>namespace</quote>, здесь <structfield>extnamespace</structfield> не подразумевает, что расширение принадлежит данной схеме. Имена расширений никогда не дополняются схемой. Вместо этого, <structfield>extnamespace</structfield> показывает, что в этой схеме содержатся все или большинство объектов расширения. Если <structfield>extrelocatable</structfield> имеет значение true, эта схема должна фактически содержать все относящиеся к схеме объекты, составляющие это расширение.</para>
 </sect1>


 <sect1 id="catalog-pg-foreign-data-wrapper">
  <title><structname>pg_foreign_data_wrapper</structname></title>

  <indexterm zone="catalog-pg-foreign-data-wrapper"><primary>pg_foreign_data_wrapper</primary></indexterm>

  <para>В каталоге <structname>pg_foreign_data_wrapper</structname> хранятся определения обёрток сторонних данных. Обёрткой сторонних данных называется механизм, через который становятся доступны внешние данные, расположенные на сторонних серверах.</para>

  <table>
   <title>Столбцы <structname>pg_foreign_data_wrapper</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>fdwname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя обёртки сторонних данных</entry>
     </row>

     <row>
      <entry><structfield>fdwowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец обёртки сторонних данных</entry>
     </row>

     <row>
      <entry><structfield>fdwhandler</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Указывает на функцию-обработчик, отвечающую за выдачу набора исполняемых процедур для обёртки сторонних данных. Ноль говорит об отсутствии такого обработчика</entry>
     </row>

     <row>
      <entry><structfield>fdwvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Указывает на функцию проверки, которая отвечает за проверку правильности параметров, передаваемых обёртке сторонних данных, а также параметров для сторонних серверов и сопоставлений пользователей, задаваемых через эту обёртку. Ноль говорит об отсутствии такой функции</entry>
     </row>

     <row>
      <entry><structfield>fdwacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>

     <row>
      <entry><structfield>fdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Специальные параметры обёртки сторонних данных, в виде строк <quote>ключ=значение</quote></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-server">
  <title><structname>pg_foreign_server</structname></title>

  <indexterm zone="catalog-pg-foreign-server"><primary>pg_foreign_server</primary></indexterm>

  <para>В каталоге <structname>pg_foreign_server</structname> хранятся определения сторонних серверов. Запись стороннего сервера описывает источник внешних данных, например удалённый сервер. Обращение к сторонним серверам происходит через обёртки сторонних данных.</para>

  <table>
   <title>Столбцы <structname>pg_foreign_server</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя стороннего сервера</entry>
     </row>

     <row>
      <entry><structfield>srvowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец стороннего сервера</entry>
     </row>

     <row>
      <entry><structfield>srvfdw</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link>.oid</literal></entry>
      <entry>OID обёртки сторонних данных для этого стороннего сервера</entry>
     </row>

     <row>
      <entry><structfield>srvtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Тип сервера (необязателен)</entry>
     </row>

     <row>
      <entry><structfield>srvversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Версия сервера (необязательна)</entry>
     </row>

     <row>
      <entry><structfield>srvacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>

     <row>
      <entry><structfield>srvoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Специальные параметры стороннего сервера, в виде строк <quote>ключ=значение</quote></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-table">
  <title><structname>pg_foreign_table</structname></title>

  <indexterm zone="catalog-pg-foreign-table"><primary>pg_foreign_table</primary></indexterm>

  <para>В каталоге <structname>pg_foreign_table</structname> содержится дополнительная информация о сторонних таблицах. Прежде всего сторонняя таблица представляется записью в <structname>pg_class</structname>, как и обычная. Запись в <structname>pg_foreign_table</structname> для неё содержит свойства, применимые только к сторонним таблицам, но не к каким-либо другим типам отношений.</para>

  <table>
   <title>Столбцы <structname>pg_foreign_table</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>ftrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID записи в <structname>pg_class</structname> для этой сторонней таблицы</entry>
     </row>

     <row>
      <entry><structfield>ftserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>OID стороннего сервера для этой сторонней таблицы</entry>
     </row>

     <row>
      <entry><structfield>ftoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Параметры сторонней таблицы, в виде строк <quote>ключ=значение</quote></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index"><primary>pg_index</primary></indexterm>

  <para>В каталоге <structname>pg_index</structname> содержится часть информации об индексах. Остальная информация в основном находится в <structname>pg_class</structname>.</para>

  <table>
   <title>Столбцы <structname>pg_index</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID записи в <structname>pg_class</structname> для этого индекса</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID записи в <structname>pg_class</structname> для таблицы, к которой относится этот индекс</entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Число столбцов в индексе (повторяет значение <literal>pg_class.relnatts</literal>)</entry>
     </row>

      <row>
      <entry><structfield>indnkeyatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Количество ключевых столбцов в индексе. &laquo;Ключевые столбцы&raquo; это обычные столбцы, в отличие от &laquo;включённых&raquo; столбцов.</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, это уникальный индекс</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, этот индекс представляет первичный ключ таблицы (в этом случае и в поле <structfield>indisunique</structfield> должно быть значение true)</entry>
     </row>

     <row>
      <entry><structfield>indisexclusion</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, этот индекс поддерживает ограничение-исключение</entry>
     </row>

     <row>
      <entry><structfield>indimmediate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, проверка уникальности осуществляется непосредственно при добавлении данных (неприменимо, если значение <structfield>indisunique</structfield> не true)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, таблица в последний раз кластеризовалась по этому индексу</entry>
     </row>

     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, индекс можно применять в запросах. Значение false означает, что индекс, возможно, неполный: он будет, тем не менее, изменяться командами <command>INSERT</command>/<command>UPDATE</command>, но безопасно применять его в запросах нельзя. Если он уникальный, свойство уникальности так же не гарантируется.</entry>
     </row>

     <row>
      <entry><structfield>indcheckxmin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, запросы не должны использовать этот индекс, пока поле <structfield>xmin</structfield> данной записи в <structname>pg_index</structname> не окажется ниже их горизонта событий <symbol>TransactionXmin</symbol>, так как таблица может содержать оборванные цепочки HOT, с видимыми несовместимыми строками</entry>
     </row>

     <row>
      <entry><structfield>indisready</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, индекс готов к добавлению данных. Значение false означает, что индекс игнорируется операциями <command>INSERT</command>/<command>UPDATE</command>.</entry>
     </row>

     <row>
      <entry><structfield>indislive</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если false, индекс находится в процессе удаления и его следует игнорировать для любых целей (включая вопрос применимости HOT)</entry>
     </row>

     <row>
      <entry><structfield>indisreplident</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, этот индекс выбран в качестве <quote>идентификатора реплики</quote> командой <command>ALTER TABLE ... REPLICA IDENTITY USING INDEX ...</command></entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Это массив значений <structfield>indnatts</structfield>, указывающий, какие столбцы таблицы индексирует этот индекс. Например, значения <literal>1 3</literal> будут означать, что ключ индекса составляют первый и третий столбцы таблицы. Ноль в этом массиве означает, что соответствующий атрибут индекса определяется выражением со столбцами таблицы, а не просто ссылкой на столбец.</entry>
     </row>

     <row>
      <entry><structfield>indcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>Для каждого столбца в ключе индекса этот массив содержит OID правила сортировки для применения в этом индексе.</entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>Для каждого столбца в ключе индекса этот массив содержит OID применяемых классов операторов. Подробнее это рассматривается в описании <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.</entry>
     </row>

     <row>
      <entry><structfield>indoption</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry/>
      <entry>Это массив значений <structfield>indnatts</structfield>, в которых хранятся битовые флаги для отдельных столбцов. Значение этих флагов определяет метод доступа индекса.</entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Деревья выражений (в представлении <function>nodeToString()</function>) для атрибутов индекса, не являющихся простыми ссылками на столбцы. Этот список содержит один элемент для каждого нулевого значения в <structfield>indkey</structfield>. Значением может быть NULL, если все атрибуты индекса представляют собой простые ссылки.</entry>
     </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Дерево выражения (в представлении <function>nodeToString()</function>) для предиката частичного индекса, либо NULL, если это не частичный индекс.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits"><primary>pg_inherits</primary></indexterm>

  <para>В каталоге <structname>pg_inherits</structname> содержится информация об иерархиях наследования таблиц. Для каждой непосредственно дочерней таблицы в ней содержится одна запись. (Косвенное наследование можно определить, просмотрев цепочку записей.)</para>

  <table>
   <title>Столбцы <structname>pg_inherits</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID дочерней таблицы</entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID родительской таблицы</entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Если у дочерней таблицы есть несколько непосредственных родителей (множественное наследование), это число определяет порядок, в котором располагаются наследованные столбцы. Нумерация начинается с 1.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-init-privs">
  <title><structname>pg_init_privs</structname></title>

  <indexterm zone="catalog-pg-init-privs"><primary>pg_init_privs</primary></indexterm>

  <para>В каталоге <structname>pg_init_privs</structname> содержится информация об изначально назначаемых правах для объектов в системе. Для каждого объекта в базе данных, имеющего нестандартный (отличный от NULL) начальный набор прав, в ней содержится одна запись.</para>

  <para>Начальные права доступа для объектов могут задаваться либо при инициализации базы данных (программой <application>initdb</application>), либо когда объект создаётся в процессе <command>CREATE EXTENSION</command> и скрипт расширения задаёт права, задействуя систему <command>GRANT</command>. Заметьте, что эта система автоматически записывает права, устанавливаемые скриптом расширения, так что авторам расширений достаточно использовать в своих скриптах только <command>GRANT</command> и <command>REVOKE</command>, чтобы права были сохранены. Столбец <literal>privtype</literal> показывает, были ли начальные права заданы программой <application>initdb</application> или в процессе выполнения команды <command>CREATE EXTENSION</command>.</para>

  <para>Для объектов, которым начальные права были назначены программой <application>initdb</application>, записи в <literal>privtype</literal> помечаются буквой <literal>'i'</literal>, а для объектов, которым права назначались в процессе <command>CREATE EXTENSION</command>, — буквой <literal>'e'</literal>.</para>

  <table>
   <title>Столбцы <structname>pg_init_privs</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID определённого объекта</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, в котором находится объект</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для столбца таблицы это номер столбца (<structfield>objoid</structfield> и <structfield>classoid</structfield> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</entry>
     </row>

     <row>
      <entry><structfield>privtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Код, определяющий тип начального права для объекта; см. текст</entry>
     </row>

     <row>
      <entry><structfield>initprivs</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Начальные права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language"><primary>pg_language</primary></indexterm>

  <para>В каталоге <structname>pg_language</structname> регистрируются языки, на которых возможно писать функции или хранимые процедуры. За дополнительной информацией о языковых обработчиках обратитесь к описанию <xref linkend="sql-createlanguage"/> и <xref remap="3" linkend="xplang"/>.</para>

  <table>
   <title>Столбцы <structname>pg_language</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя языка</entry>
     </row>

     <row>
      <entry><structfield>lanowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец языка</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Для внутренних языков (например, <acronym>SQL</acronym>) содержит false, а для пользовательских языков — true. В настоящее время, <application>pg_dump</application> всё ещё пользуется этим признаком, чтобы определить, какие языки нужно выгружать, но в будущем ему на смену может прийти другой механизм.</entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если это доверенный язык, что означает, что можно рассчитывать на то, что он не открывает доступ куда-либо за пределы обычной среды исполнения SQL. Создавать функции на недоверенных языках могут только суперпользователи.</entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Для не внутренних языков это значение указывает на языковой обработчик, который представляет собой специальную функцию, отвечающую за выполнение всех процедур, написанных на этом языке</entry>
     </row>

     <row>
      <entry><structfield>laninline</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Это значение указывает на функцию, отвечающую за выполнение <quote>внедрённых</quote> анонимных блоков кода (блоков <xref remap="4" linkend="sql-do"/>). Ноль, если внедрённые блоки не поддерживаются.</entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Это значение указывает на функцию проверки языка, которая отвечает за проверку синтаксиса и правильности новых функций в момент их создания. Ноль, если функция проверки отсутствует.</entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject"><primary>pg_largeobject</primary></indexterm>

  <para>В каталоге <structname>pg_largeobject</structname> содержатся данные, образующие <quote>большие объекты</quote>. Большой объект идентифицируется по OID, назначаемому при его создании. Каждый большой объект разделяется на сегменты или <quote>страницы</quote>, достаточно небольшие для удобного размещения в строках таблицы <structname>pg_largeobject</structname>. Объём данных на странице определяется как <symbol>LOBLKSIZE</symbol> (что в настоящее время составляет <literal>BLCKSZ/4</literal>, то есть обычно 2 Кб).</para>

  <para>До <productname>PostgreSQL</productname> 9.0 большие объекты не были связаны с механизмом разрешений. В результате таблица <structname>pg_largeobject</structname> была доступны на чтение для всех и через неё можно было получить OID (и содержимое) всех больших объектов в системе. Теперь это не так; для получения списка OID больших объектов нужно обратиться к <link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.</para>

  <table>
   <title>Столбцы <structname>pg_largeobject</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.oid</literal></entry>
      <entry>Идентификатор большого объекта, включающего эту страницу</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Номер этой страницы в большом объекте (начиная с нуля)</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry/>
      <entry>Собственно данные, хранящиеся в большом объекте. Их объём не может превышать <symbol>LOBLKSIZE</symbol>, но может быть меньше.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>В каждой строке <structname>pg_largeobject</structname> содержатся данные для одной строки большого объекта, начиная со смещения (<literal>pageno * LOBLKSIZE</literal>) внутри него (в байтах). Эта реализация допускает разреженное хранилище: страницы могут отсутствовать и могут быть короче <literal>LOBLKSIZE</literal>, даже если это не последние страницы объектов. Пропущенные области в большом объекте будут считываться как нулевые.</para>

 </sect1>

 <sect1 id="catalog-pg-largeobject-metadata">
  <title><structname>pg_largeobject_metadata</structname></title>

  <indexterm zone="catalog-pg-largeobject-metadata"><primary>pg_largeobject_metadata</primary></indexterm>

  <para>В каталоге <structname>pg_largeobject_metadata</structname> содержатся метаданные, связанные с большими объектами. Собственно данные больших объектов хранятся в <link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link>.</para>

  <table>
   <title>Столбцы <structname>pg_largeobject_metadata</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>lomowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец большого объекта</entry>
     </row>

     <row>
      <entry><structfield>lomacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace"><primary>pg_namespace</primary></indexterm>

  <para>В <structname>pg_namespace</structname> сохраняются пространства имён. Пространство имён представляет собой структуру, на которой основываются схемы SQL: в каждом пространстве имён без конфликтов может существовать отдельный набор отношений, типов и т. д.</para>

  <table>
   <title>Столбцы <structname>pg_namespace</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя пространства имён</entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец пространства имён</entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass"><primary>pg_opclass</primary></indexterm>

  <para>В каталоге <structname>pg_opclass</structname> определяются классы операторов для методов доступа индексов. Каждый класс операторов устанавливает конкретную операцию для индексируемых столбцов определённого типа данных и определённого метода доступа. Класс операторов по сути устанавливает, что некоторое семейство операторов применимо к определённому индексируемому типу столбца. Набор операторов из семейства, которые действительно можно использовать с индексируемым столбцом, образуют те, что принимают тип данных столбца в качестве левого операнда.</para>

  <para>Классы операторов углублённо рассматриваются в <xref remap="6" linkend="xindex"/>.</para>

  <table>
   <title>Столбцы <structname>pg_opclass</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>opcmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Метод доступа индекса, для которого создан этот класс операторов</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя этого класса операторов</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Пространство имён этого класса операторов</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец класса операторов</entry>
     </row>

     <row>
      <entry><structfield>opcfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>Семейство операторов, содержащее этот класс операторов</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных, индексируемый данным классом операторов</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если этот класс операторов применяется по умолчанию для <structfield>opcintype</structfield></entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных, хранимых в индексе, или ноль, если он совпадает с <structfield>opcintype</structfield></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Значение <structfield>opcmethod</structfield> класса операторов должно совпадать с <structname>opfmethod</structname> для содержащего его семейства операторов. Кроме того, должно быть не больше одной строки в <structname>pg_opclass</structname>, в которой <structname>opcdefault</structname> равно true для любой данной комбинации <structname>opcmethod</structname> и <structname>opcintype</structname>.</para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator"><primary>pg_operator</primary></indexterm>

  <para>В каталоге <structname>pg_operator</structname> хранится информация об операторах. За дополнительными сведениями обратитесь к описанию <xref linkend="sql-createoperator"/> и <xref remap="3" linkend="xoper"/>.</para>

  <table>
   <title>Столбцы <structname>pg_operator</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя оператора</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего этот оператор</entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец оператора</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry><literal>b</literal> = инфиксный (<quote>both</quote>), <literal>l</literal> = префиксный (<quote>left</quote>), <literal>r</literal> = постфиксный (<quote>right</quote>)</entry>
     </row>

     <row>
      <entry><structfield>oprcanmerge</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Этот оператор поддерживает соединение слиянием</entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Этот оператор поддерживает соединение по хешу</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип левого операнда</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип правого операнда</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип результата</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Коммутирующий для данного оператор, если есть</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Обратный для данного оператор, если есть</entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция, реализующая этот оператор</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция оценки избирательности ограничения для данного оператора</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция оценки избирательности соединения для данного оператора</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Неиспользуемые поля содержат нули. Например, поле <structfield>oprleft</structfield> будет содержать ноль для префиксного оператора.</para>

 </sect1>


 <sect1 id="catalog-pg-opfamily">
  <title><structname>pg_opfamily</structname></title>

  <indexterm zone="catalog-pg-opfamily"><primary>pg_opfamily</primary></indexterm>

  <para>В каталоге <structname>pg_opfamily</structname> определяются семейства операторов. Каждое семейство операторов представляет собой набор операторов и связанных с ними опорных процедур, реализующих операции, требуемые для определённого метода доступа. Более того, все операторы в семействе являются <quote>совместимыми</quote>, в том смысле, который определяется методом доступа. Концепция семейства операторов позволяет использовать в индексах операторы смешанных типов и рассматривать их, используя знание семантики метода доступа.</para>

  <para>Семейства операторов углублённо рассматриваются в <xref remap="6" linkend="xindex"/>.</para>

  <table>
   <title>Столбцы <structname>pg_opfamily</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>opfmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Метод доступа индекса, для которого предназначено семейство операторов</entry>
     </row>

     <row>
      <entry><structfield>opfname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя семейства операторов</entry>
     </row>

     <row>
      <entry><structfield>opfnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Пространство имён семейства операторов</entry>
     </row>

     <row>
      <entry><structfield>opfowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец семейства операторов</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Основная часть информации, определяющей семейство операторов, находится не в строке <structname>pg_opfamily</structname>, а в связанных строках в <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>, <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link> и <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.</para>

 </sect1>


 <sect1 id="catalog-pg-pltemplate">
  <title><structname>pg_pltemplate</structname></title>

  <indexterm zone="catalog-pg-pltemplate"><primary>pg_pltemplate</primary></indexterm>

  <para>В каталоге <structname>pg_pltemplate</structname> хранится информация о <quote>шаблонах</quote> для процедурных языков. Шаблон для языка позволяет создать язык в определённой базе данных простой командой <command>CREATE LANGUAGE</command>, без необходимости указывать подробности реализации.</para>

  <para>В отличие от большинства системных каталогов, <structname>pg_pltemplate</structname> разделяется всеми базами данных в кластере: есть только один экземпляр <structname>pg_pltemplate</structname> в кластере, а не отдельные в базе данных. Благодаря этому, к данной информации при необходимости можно обращаться в любой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_pltemplate</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Имя языка, для которого предназначен этот шаблон</entry>
     </row>

     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True, если язык считается доверенным</entry>
     </row>

     <row>
      <entry><structfield>tmpldbacreate</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True, если язык может быть создан владельцем базы данных</entry>
     </row>

     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя функции-обработчика вызова</entry>
     </row>

     <row>
      <entry><structfield>tmplinline</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя функции-обработчика анонимного кода, либо NULL, если её нет</entry>
     </row>

     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя функции проверки, либо NULL, если её нет</entry>
     </row>

     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Путь к разделяемой библиотеке, реализующей этот язык</entry>
     </row>

     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry>Права доступа для шаблона (фактически не используются)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>В настоящее время для управления шаблонами процедурных языков нет никаких команд; чтобы изменить встроенную информацию, суперпользователь должен модифицировать эту таблицу, выполняя обычные команды <command>INSERT</command>, <command>DELETE</command> или <command>UPDATE</command>.</para>

  <note>
   <para>Скорее всего каталог <structname>pg_pltemplate</structname> будет ликвидирован в каком-нибудь будущем выпуске <productname>&productname;</productname>, а эти знания о процедурных языках будут храниться в соответствующих скриптах установки расширений.</para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-policy">
  <title><structname>pg_policy</structname></title>

  <indexterm zone="catalog-pg-policy"><primary>pg_policy</primary></indexterm>

  <para>В каталоге <structname>pg_policy</structname> хранятся политики защиты на уровне строк для таблиц. Описание политики включает тип команды, к которой она применяется (это могут быть все команды), роли, к которым она применяется, выражение, добавляемое к условию барьера безопасности в запросы, обращающиеся к таблице, и выражение, добавляемое к условию <literal>WITH CHECK</literal> в запросы, которые пытаются добавить в таблицу новые записи.</para>

  <table>

   <title>Столбцы <structname>pg_policy</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>polname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя политики.</entry>
     </row>

     <row>
      <entry><structfield>polrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица, к которой применяется политика</entry>
     </row>

     <row>
      <entry><structfield>polcmd</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Тип команды, к которой применяется политика: <literal>r</literal> обозначает <command>SELECT</command>, <literal>a</literal> — <command>INSERT</command>, <literal>w</literal> — <command>UPDATE</command>, <literal>d</literal> — <command>DELETE</command>, а <literal>*</literal> — все команды</entry>
     </row>

     <row>
      <entry><structfield>polroles</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Роли, к которым применяется политика.</entry>
     </row>

     <row>
      <entry><structfield>polqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Дерево выражения, добавляемое к условиям барьера безопасности в запросы, использующие таблицу</entry>
     </row>

     <row>
      <entry><structfield>polwithcheck</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Дерево выражения, добавляемое к условиям WITH CHECK в запросы, которые пытаются добавлять строки в таблицу</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <note>
   <para>Политики хранятся в <structname>pg_policy</structname> и применяются только когда для этой таблицы установлено свойство <structname>pg_class</structname>.<structfield>relrowsecurity</structfield>.</para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc"><primary>pg_proc</primary></indexterm>

  <para>В каталоге <structname>pg_proc</structname> хранится информация о функциях (или процедурах). За дополнительными сведениями обратитесь к описанию <xref linkend="sql-createfunction"/> и <xref remap="3" linkend="xfunc"/>.</para>

  <para>В этой таблице содержатся данные и агрегатных, и обычных функций. Если признак <structfield>proisagg</structfield> равен true, для этой функции должна быть ещё строка в <structfield>pg_aggregate</structfield>.</para>

  <table>
   <title>Столбцы <structname>pg_proc</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя функции</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего эту функцию</entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец функции</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>Язык реализации или интерфейс вызова для этой функции</entry>
     </row>

     <row>
      <entry><structfield>procost</structfield></entry>
      <entry><type>float4</type></entry>
      <entry/>
      <entry>Примерная стоимость выполнения (в единицах <xref linkend="guc-cpu-operator-cost"/>); если установлен признак <structfield>proretset</structfield>, это стоимость выдачи одной строки</entry>
     </row>

     <row>
      <entry><structfield>prorows</structfield></entry>
      <entry><type>float4</type></entry>
      <entry/>
      <entry>Примерное число возвращаемых строк (ноль, если признак <structfield>proretset</structfield> не установлен)</entry>
     </row>

     <row>
      <entry><structfield>provariadic</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных элементов переменного массива параметров, либо 0, если функция не принимает переменное число параметров</entry>
     </row>

     <row>
      <entry><structfield>protransform</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Вызовы этой функции могут быть упрощены заданной функцией (см. <xref remap="4" linkend="xfunc-transform-functions"/>)</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Функция является агрегатной</entry>
     </row>

     <row>
      <entry><structfield>proiswindow</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Функция является оконной</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Функция определяет контекст безопасности (т. е. это функция <quote>setuid</quote>)</entry>
     </row>

     <row>
      <entry><structfield>proleakproof</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Функция не имеет побочных эффектов. Никакая информация о её аргументах не выдаётся, кроме как через возвращаемое значение. Любая функция, которая может выдать ошибку, в зависимости от значений аргументов, не является герметичной.</entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Функция возвращает NULL, если любой из аргументов при вызове NULL. В этом случае функция фактически не будет вызываться вовсе. Функции, не являющиеся <quote>строгими</quote>, должны быть готовы принять значения NULL.</entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Функция возвращает множество (т. е. множество значений указанного типа данных)</entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Свойство <structfield>provolatile</structfield> говорит, зависит ли результат функции только от её входных аргументов, либо на него влияют внешние факторы. Буквой <literal>i</literal> обозначаются постоянные функции (<quote>immutable</quote>), которые всегда возвращают один результат для одних и тех же аргументов. Буквой <literal>s</literal> обозначаются стабильные функции (<quote>stable</quote>), результаты которых (для одних и тех же аргументов) не меняются в ходе одного сканирования. Буквой <literal>v</literal> обозначаются изменчивые функции (<quote>volatile</quote>), результаты которых могут меняться в любое время. (Так же <literal>v</literal> следует выбирать для функций с побочными эффектами, чтобы система не оптимизировала их вызовы.)</entry>
     </row>

     <row>
      <entry><structfield>proparallel</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Свойство <structfield>proparallel</structfield> говорит, может ли эта функция безопасно выполняться в параллельном режиме. Символом <literal>s</literal> в нём обозначаются функции, которые могут выполняться в параллельном режиме без ограничений. Символом <literal>r</literal> обозначаются функции, которые могут выполняться в параллельном режиме, но только в ведущем процессе группы; в параллельных рабочих процессах вызывать их нельзя. Символом <literal>u</literal> отмечаются функции небезопасные в параллельном режиме; присутствие такой функции влечёт выбор последовательного плана выполнения запроса.</entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Число входных аргументов</entry>
     </row>

     <row>
      <entry><structfield>pronargdefaults</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Число аргументов, для которых определены значения по умолчанию</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Тип данных возвращаемого значения</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Массив с типами данных аргументов функции. В нём учитываются только входные аргументы функции (включая аргументы <literal>INOUT</literal> и <literal>VARIADIC</literal>), так что он представляет сигнатуру вызова функции.</entry>
     </row>

     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Массив с типами данных аргументов функции. В нём учитываются все аргументы (включая аргументы <literal>OUT</literal> и <literal>INOUT</literal>); однако, если все аргументы только входные (<literal>IN</literal>), это поле будет содержать NULL. Заметьте, что индексы в нём начинаются с 1, тогда как в <structfield>proargtypes</structfield> по историческим причинами они начинаются с 0.</entry>
     </row>

     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry/>
      <entry>Массив с режимами аргументов функций, закодированными как <literal>i</literal> для входных аргументов (<literal>IN</literal>), <literal>o</literal> для выходных аргументов (<literal>OUT</literal>), <literal>b</literal> для аргументов входных и выходных одновременно (<literal>INOUT</literal>), <literal>v</literal> для переменных аргументов (<literal>VARIADIC</literal>) и <literal>t</literal> для табличных аргументов (<literal>TABLE</literal>). Если все аргументы являются аргументами <literal>IN</literal>, это поле может содержать NULL. Заметьте, что индексы в этом массиве соответствуют позициям в <structfield>proallargtypes</structfield>, а не в <structfield>proargtypes</structfield>.</entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Массив с именами аргументов функции. Для аргументов без имени в этом массиве задаются пустые строки. Если все аргументы функции безымянные, это поле может содержать NULL. Заметьте, что индексы в этом массиве соответствуют позициям в <structfield>proallargtypes</structfield>, а не в <structfield>proargtypes</structfield>.</entry>
     </row>

     <row>
      <entry><structfield>proargdefaults</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Деревья выражений (в представлении <function>nodeToString()</function>) для значений аргументов по умолчанию. Это список, содержащий <structfield>pronargdefaults</structfield> элементов, соответствующих последним <replaceable>N</replaceable> <emphasis>входным</emphasis> аргументам (т. е., последним <replaceable>N</replaceable> позициям в <structfield>proargtypes</structfield>). Если значение по умолчанию не имеет никакой аргумент, это поле может содержать NULL.</entry>
     </row>

     <row>
      <entry><structfield>protrftypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry/>
      <entry>OID типов данных, к которым будут применяться трансформации.</entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Это значение говорит обработчику функции, как вызывать данную функцию. Это может быть собственно исходный код функции для интерпретируемых языков, объектный символ, имя файла или что-то другое, в зависимости от языка реализации/соглашения о вызовах.</entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Дополнительная информация о том, как вызывать функцию. Интерпретация этого значения так же зависит от языка.</entry>
     </row>

     <row>
      <entry><structfield>proconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Локальные присвоения конфигурационных переменных времени выполнения, действующие в рамках функции</entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Для скомпилированных функций, как встроенных, так и динамически загружаемых, поле <structfield>prosrc</structfield> содержит имя функции на языке C (объектный символ). Для всех других известных сегодня типов языков поле <structfield>prosrc</structfield> содержит исходный код функции. Поле <structfield>probin</structfield> используется только для динамически загружаемых функций на C, для которых оно задаёт имя разделяемой библиотеки, содержащей эти функции.</para>

 </sect1>

 <sect1 id="catalog-pg-range">
  <title><structname>pg_range</structname></title>

  <indexterm zone="catalog-pg-range"><primary>pg_range</primary></indexterm>

  <para>В каталоге <structname>pg_range</structname> хранится информация о типах диапазонов. Эта информация дополняет записи типов в <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.</para>

  <table>
   <title>Столбцы <structname>pg_range</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rngtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID типа диапазона</entry>
     </row>

     <row>
      <entry><structfield>rngsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID типа элемента (подтипа) данного типа диапазона</entry>
     </row>

     <row>
      <entry><structfield>rngcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>OID правила сортировки, применяемого для сравнения диапазонов, либо 0 в случае его отсутствия</entry>
     </row>

     <row>
      <entry><structfield>rngsubopc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>OID класса операторов подтипа, применяемого для сравнения диапазонов</entry>
     </row>

     <row>
      <entry><structfield>rngcanonical</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции, преобразующей значение диапазона в каноническую форму, либо 0 в случае её отсутствия</entry>
     </row>

     <row>
      <entry><structfield>rngsubdiff</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции, возвращающей разницу между значениями двух элементов в значении <type>double precision</type>, либо 0 в случае её отсутствия</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Значение <structfield>rngsubopc</structfield> (в сочетании с <structfield>rngcollation</structfield>, если тип элемента сортируемый) определяет порядок сортировки для типа диапазона. Значение <structfield>rngcanonical</structfield> используется, когда тип элемента дискретный. Значение <structfield>rngsubdiff</structfield> может отсутствовать, но его рекомендуется задавать для увеличения производительности индексов GiST с диапазонным типом.</para>

 </sect1>

 <sect1 id="catalog-pg-replication-origin">
  <title><structname>pg_replication_origin</structname></title>

  <indexterm zone="catalog-pg-replication-origin"><primary>pg_replication_origin</primary></indexterm>

  <para>В каталоге <structname>pg_replication_origin</structname> содержатся все созданные источники репликации. Подробно источники репликации описаны в <xref remap="6" linkend="replication-origins"/>.</para>

  <table>

   <title>Столбцы <structname>pg_replication_origin</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roident</structfield></entry>
      <entry><type>Oid</type></entry>
      <entry/>
      <entry>Уникальный в рамках кластера идентификатор для источника репликации. Не должен покидать пределы системы.</entry>
     </row>

     <row>
      <entry><structfield>roname</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Определяемое пользователем внешнее имя источника репликации.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite"><primary>pg_rewrite</primary></indexterm>

  <para>В каталоге <structname>pg_rewrite</structname> хранятся правила перезаписи для таблиц и представлений.</para>

  <table>
   <title>Столбцы <structname>pg_rewrite</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя правила</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица, к которой относится это правило</entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Тип события, для которого предназначено это правило: 1 = <command>SELECT</command>, 2 = <command>UPDATE</command>, 3 = <command>INSERT</command>, 4 = <command>DELETE</command></entry>
     </row>

     <row>
      <entry><structfield>ev_enabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Устанавливает, в каких режимах <xref linkend="guc-session-replication-role"/> срабатывает правило: <literal>O</literal> = правило срабатывает в режимах <quote>origin</quote> (источник) и <quote>local</quote> (локально), <literal>D</literal> = правило отключено, <literal>R</literal> = правило срабатывает в режиме <quote>replica</quote> (реплика), <literal>A</literal> = правило срабатывает всегда.</entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если это правило <literal>INSTEAD</literal></entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Дерево выражения (в форме представления <function>nodeToString()</function>) для условия применения правила</entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Дерево запроса (в форме представления <function>nodeToString()</function>) для действия правила</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>Если для таблицы есть какие-либо правила в этом каталоге, значением <literal>pg_class.relhasrules</literal> для неё должно быть true.</para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-seclabel">
  <title><structname>pg_seclabel</structname></title>

  <indexterm zone="catalog-pg-seclabel"><primary>pg_seclabel</primary></indexterm>

  <para>В каталоге <structname>pg_seclabel</structname> хранятся метки безопасности для объектов баз данных. Управлять метками безопасности можно с помощью команды <xref linkend="sql-security-label"/>. Более простой способ просмотра меток безопасности описан в <xref remap="6" linkend="view-pg-seclabels"/>.</para>

  <para>Также обратите внимание на каталог <link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link>, который выполняет ту же функцию для меток безопасности глобальных объектов в кластере баз данных.</para>

  <table>
   <title>Столбцы <structname>pg_seclabel</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID объекта, к которому относится эта метка безопасности</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, к которому относится этот объект</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для метки безопасности, связанной со столбцом таблицы, это номер столбца (<structfield>objoid</structfield> и <structfield>classoid</structfield> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</entry>
     </row>

     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Поставщик меток безопасности, связанный с этой меткой.</entry>
     </row>

     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Метка безопасности, применённая к этому объекту.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend"><primary>pg_shdepend</primary></indexterm>

  <para>В каталоге <structname>pg_shdepend</structname> записываются отношения зависимости между объектами баз данных и разделяемыми объектами, такими как роли. Эта информация позволяет <productname>&productname;</productname> удостовериться, что эти объекты не используется, прежде чем удалять их.</para>

  <para>Также смотрите каталог <link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>, который играет подобную роль в отношении зависимостей объектов в одной базе данных.</para>

  <para>В отличие от большинства системных каталогов, <structname>pg_shdepend</structname> разделяется всеми базами данных кластера: есть только один экземпляр <structname>pg_shdepend</structname> в кластере, а не отдельные в каждой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_shdepend</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>OID базы данных, в которой находится зависимый объект, или ноль, если это глобальный объект</entry>
     </row>

     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, в котором находится зависимый объект</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID определённого зависимого объекта</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для столбца таблицы это номер столбца (<structfield>objid</structfield> и <structfield>classid</structfield> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, к которому относится вышестоящий объект (это должен быть разделяемый каталог)</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID определённого вышестоящего объекта</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Код, определяющий конкретную семантику данного отношения зависимости; см. текст</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Во всех случаях, запись в <structname>pg_shdepend</structname> показывает, что вышестоящий объект нельзя удалить, не удаляя подчинённый объект. Однако есть несколько подвидов зависимости, задаваемых в поле <structfield>deptype</structfield>: <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</symbol> (<literal>o</literal>)</term>
     <listitem>
      <para>Вышестоящий объект (это должна быть роль) является владельцем зависимого объекта.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>Вышестоящий объект (это должна быть роль) упоминается в ACL (списке управления доступом, то есть списке прав) подчинённого объекта. (Запись <symbol>SHARED_DEPENDENCY_ACL</symbol> не создаётся для владельца объекта, так как для владельца всё равно имеется запись <symbol>SHARED_DEPENDENCY_OWNER</symbol>.)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_POLICY</symbol> (<literal>r</literal>)</term>
     <listitem>
      <para>Вышестоящий объект (это должна быть роль) упомянут в качестве целевого в объекте зависимой политики.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>Зависимый объект отсутствует; этот тип записи показывает, что система сама зависит от вышестоящего объекта, так что этот объект нельзя удалять ни при каких условиях. Записи этого типа создаются только командой <command>initdb</command>. Поля зависимого объекта в такой записи содержат нули.</para>
     </listitem>
    </varlistentry>
   </variablelist> В будущем могут появиться и другие подвиды зависимости. Заметьте в частности, что с текущим определением вышестоящими объектами могут быть только роли.</para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
  <title><structname>pg_shdescription</structname></title>

  <indexterm zone="catalog-pg-shdescription"><primary>pg_shdescription</primary></indexterm>

  <para>В каталоге <structname>pg_shdescription</structname> хранятся дополнительные описания (комментарии) для глобальных объектов баз данных. Описания можно задавать с помощью команды <xref linkend="sql-comment"/> и просматривать в <application>psql</application>, используя команды <literal>\d</literal>.</para>

  <para>Также смотрите каталог <link linkend="catalog-pg-description"><structname>pg_description</structname></link>, который играет подобную роль в отношении описаний объектов в одной базе данных.</para>

  <para>В отличие от большинства системных каталогов, <structname>pg_shdescription</structname> разделяется всеми базами данных кластера: есть только один экземпляр <structname>pg_shdescription</structname> в кластере, а не отдельные в каждой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_shdescription</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID объекта, к которому относится это описание</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, к которому относится этот объект</entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Произвольный текст, служащий описанием данного объекта</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-shseclabel">
  <title><structname>pg_shseclabel</structname></title>

  <indexterm zone="catalog-pg-shseclabel"><primary>pg_shseclabel</primary></indexterm>

  <para>В каталоге <structname>pg_shseclabel</structname> хранятся метки безопасности для глобальных объектов баз данных. Управлять метками безопасности можно с помощью команды <xref linkend="sql-security-label"/>. Более простой способ просмотра меток безопасности описан в <xref remap="6" linkend="view-pg-seclabels"/>.</para>

  <para>Также смотрите каталог <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>, который играет подобную роль в отношении меток безопасности объектов в одной базе данных.</para>

  <para>В отличие от большинства системных каталогов, <structname>pg_shseclabel</structname> разделяется всеми базами данных кластера: есть только один экземпляр <structname>pg_shseclabel</structname> в кластере, а не отдельные в каждой базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_shseclabel</structname></title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID объекта, к которому относится эта метка безопасности</entry>
     </row>
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, к которому относится этот объект</entry>
     </row>
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Поставщик меток безопасности, связанный с этой меткой.</entry>
     </row>
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Метка безопасности, применённая к этому объекту.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic"><primary>pg_statistic</primary></indexterm>

  <para>В каталоге <structname>pg_statistic</structname> хранится статистическая информация о содержимом базы данных. Записи в нём создаются командой <xref linkend="sql-analyze"/>, а затем используются планировщиком запросов. Заметьте, что все эти данные по природе своей неточные, даже если предполагается, что они актуальны.</para>

  <para>Обычно для каждого столбца, подлежащего анализу, в этом каталоге есть одна запись со значением <structfield>stainherit</structfield> = <literal>false</literal>. Если у таблицы имеются потомки в иерархии наследования, также создаётся вторая запись с <structfield>stainherit</structfield> = <literal>true</literal>. Эта строка представляет статистику по столбцу в дереве наследования, то есть статистику по данным, которые возвратит запрос <literal>SELECT <replaceable>столбец</replaceable> FROM <replaceable>таблица</replaceable>*</literal>, тогда как строка с <structfield>stainherit</structfield> = <literal>false</literal> представляет результаты запроса <literal>SELECT <replaceable>столбец</replaceable> FROM ONLY <replaceable>таблица</replaceable></literal>.</para>

  <para>В <structname>pg_statistic</structname> также хранится статистическая информация о значениях выражений индексов. Она описывается так же, как если бы это были столбцы данных; в частности, <structfield>starelid</structfield> ссылается на индекс. Однако для столбцов, задействуемых в индексе без выражений, дополнительная запись не добавляется, так как она повторяла бы запись для нижележащего столбца таблицы. В настоящее время во всех записях для выражений индексов <structfield>stainherit</structfield> = <literal>false</literal>.</para>

  <para>Так как для различных типов данных могут быть уместны различные типы статистики, в каталоге <structname>pg_statistic</structname> не делается конкретных предположений о том, какая статистика в нём хранится. Отдельные столбцы в <structname>pg_statistic</structname> выделены только для самых общих свойств (например, доля NULL). Всё остальное хранится в <quote>слотах</quote>, представляющих собой группы связанных столбцов, содержимое которых определяется кодовым числом в одном из столбцов слотов. За подробностями обратитесь к <filename>src/include/catalog/pg_statistic.h</filename>.</para>

  <para>Каталог <structname>pg_statistic</structname> не должен быть доступен на чтение всем, так как даже статистическая информация о содержимом таблицы может считаться конфиденциальной. (Например, довольно интересны могут быть минимальные и максимальные значения в столбце зарплаты.) Поэтому существует <link linkend="view-pg-stats"><structname>pg_stats</structname></link> — доступное всем для чтения представление на базе <structname>pg_statistic</structname>, в котором выдаётся информация только по тем таблицам, которые может читать текущий пользователь.</para>

  <table>
   <title>Столбцы <structname>pg_statistic</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица (или индекс), к которой принадлежит описываемый столбец</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Номер описываемого столбца</entry>
     </row>

     <row>
      <entry><structfield>stainherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, в статистике учитываются значения в дочерних столбцах, а не только в указанном отношении</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry/>
      <entry>Доля записей, в которых этот столбец содержит NULL</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Средний размер хранения элементов не-NULL, в байтах</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry/>
      <entry>Число различных и отличных от NULL значений в столбце. Число, большее нуля, представляет фактическое количество различных значений. Если это число меньше нуля, его модуль представляет множитель для общего количества строк в таблице; например, для столбца, в котором примерно 80% значений не NULL, и каждое отличное от NULL значение в среднем повторяется дважды, может быть представлено значение <structfield>stadistinct</structfield> = -0.4. Ноль означает, что количество различных значений неизвестно.</entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</replaceable></structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Кодовое число, определяющее род статистики, хранящейся в <replaceable>N</replaceable>-ном <quote>слоте</quote> строки <structname>pg_statistic</structname> row.</entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Оператор, с которым была получена статистика, хранящаяся в <replaceable>N</replaceable>-ном <quote>слоте</quote>. Например, для слота гистограммы это будет оператор <literal>&lt;</literal>, определяющий порядок сортировки данных.</entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</replaceable></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry/>
      <entry>Численная статистика соответствующего рода для <replaceable>N</replaceable>-ного <quote>слота</quote>, либо NULL, если с этим родом слота не связаны числовые значения</entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</replaceable></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry/>
      <entry>Значения столбцов соответствующего рода для <replaceable>N</replaceable>-го <quote>слота</quote>, либо NULL, если для этого рода слота не хранятся никакие значения. Все значения элементов массива фактически имеют тип данных столбца или связанный тип, например, тип элемента массива, так что определить типы эти столбцов более конкретно, чем <type>anyarray</type>, нельзя.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
  <title><structname>pg_tablespace</structname></title>

  <indexterm zone="catalog-pg-tablespace"><primary>pg_tablespace</primary></indexterm>

  <para>В каталоге <structname>pg_tablespace</structname> хранится информация о доступных табличных пространствах. Таблицы могут быть распределены по разным табличным пространствам для эффективного использования дискового хранилища.</para>

  <para>В отличие от большинства системных каталогов, <structname>pg_tablespace</structname> разделяется всеми базами данных кластера: есть только один экземпляр <structname>pg_tablespace</structname> в кластере, а не отдельные для каждой базы данных.</para>

  <table>
   <title>Столбцы <structname>pg_tablespace</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>spcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя табличного пространства</entry>
     </row>

     <row>
      <entry><structfield>spcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец табличного пространства, обычно пользователь, создавший его</entry>
     </row>

     <row>
      <entry><structfield>spcacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>

     <row>
      <entry><structfield>spcoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Параметры уровня табличного пространства, в виде строк <quote>ключ=значение</quote></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-transform">
  <title><structname>pg_transform</structname></title>

  <indexterm zone="catalog-pg-transform"><primary>pg_transform</primary></indexterm>

  <para>В каталоге <structname>pg_transform</structname> хранятся сведения о трансформациях, которые представляют собой механизм адаптирования типов данных для процедурных языков. За дополнительной информацией обратитесь к <xref remap="3" linkend="sql-createtransform"/>.</para>

  <table>
   <title>Столбцы <structname>pg_transform</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>trftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID типа данных, для которого предназначена трансформация</entry>
     </row>

     <row>
      <entry><structfield>trflang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>OID языка, для которого предназначена трансформация</entry>
     </row>

     <row>
      <entry><structfield>trffromsql</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции, вызываемой для преобразования типа данных, подаваемого на вход процедурному языку (например, в параметрах функции). Ноль, если эта операция не поддерживается.</entry>
     </row>

     <row>
      <entry><structfield>trftosql</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции, вызываемой для преобразования значения, выдаваемого процедурным языком, (например, возвращаемых значений) к типу данных. Ноль, если эта операция не поддерживается.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger"><primary>pg_trigger</primary></indexterm>

  <para>В каталоге <structname>pg_trigger</structname> хранятся триггеры для таблиц и представлений. За дополнительными сведениями обратитесь к описанию <xref linkend="sql-createtrigger"/>.</para>

  <table>
   <title>Столбцы <structname>pg_trigger</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица, к которой относится этот триггер</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя триггера (должно быть уникальным среди триггеров одной таблицы)</entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Вызываемая функция</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Битовая маска, задающая условия срабатывания триггера</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Устанавливает, в каких режимах <xref linkend="guc-session-replication-role"/> срабатывает триггер: <literal>O</literal> = триггер срабатывает в режимах <quote>origin</quote> (источник) и <quote>local</quote> (локально), <literal>D</literal> = триггер отключён, <literal>R</literal> = триггер срабатывает в режиме <quote>replica</quote> (реплика), <literal>A</literal> = триггер срабатывает всегда.</entry>
     </row>

     <row>
      <entry><structfield>tgisinternal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если триггер создан внутри системы (обычно, для реализации ограничения, заданного в <structfield>tgconstraint</structfield>)</entry>
     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Таблица, задействованная в ограничении ссылочной целостности</entry>
     </row>

     <row>
      <entry><structfield>tgconstrindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Индекс, поддерживающий ограничение уникальности, первичного ключа или ссылочной целостности, либо ограничение-исключение</entry>
     </row>

     <row>
      <entry><structfield>tgconstraint</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>Запись в <structname>pg_constraint</structname>, связанная этим триггером, если такая имеется</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если триггер ограничения является откладываемым</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если триггер ограничения изначально отложенный</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Число аргументов, передаваемых функции триггера</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Номера столбцов, если триггер привязан к столбцам; в противном случае пустой массив</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry/>
      <entry>Аргументы строкового типа, передаваемые триггеру, с NULL в конце каждого</entry>
     </row>

     <row>
      <entry><structfield>tgqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry>Дерево выражения (в представлении <function>nodeToString()</function>) для условия триггера <literal>WHEN</literal>, либо NULL, если оно отсутствует</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>В настоящее время триггеры, привязанные к столбцам, поддерживаются только для событий <literal>UPDATE</literal>, так что <structfield>tgattr</structfield> применимо только к событиям такого типа. Поле <structfield>tgtype</structfield> может содержать биты и для других типов событий, но они распространяются только на таблицы, вне зависимости от значения <structfield>tgattr</structfield>.</para>

  <note>
   <para>Когда <structfield>tgconstraint</structfield> содержит не ноль, то есть ссылается на запись в <structname>pg_constraint</structname>, поля <structfield>tgconstrrelid</structfield>, <structfield>tgconstrindid</structfield>, <structfield>tgdeferrable</structfield> и <structfield>tginitdeferred</structfield> по большому счёту избыточны, они повторяют значения в этой записи. Однако, возможно связать неоткладываемый триггер с откладываемым ограничением: с ограничениями внешнего ключа могут быть связаны и откладываемые, и неоткладываемые триггеры.</para>
  </note>

  <note>
   <para>Если для отношения есть какие-либо триггеры в этом каталоге, значением <literal>pg_class.relhastriggers</literal> для неё должно быть true.</para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-ts-config">
  <title><structname>pg_ts_config</structname></title>

  <indexterm zone="catalog-pg-ts-config"><primary>pg_ts_config</primary></indexterm>

  <para>Каталог <structname>pg_ts_config</structname> содержит записи, представляющие конфигурации текстового поиска. Конфигурация задаёт определённый анализатор текстового поиска и список словарей, которые будут использоваться для каждого из фрагментов, выдаваемых анализатором. Анализатор задаётся в записи в <structname>pg_ts_config</structname>, а сопоставления фрагментов со словарями определяются в подчинённых записях в <link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>.</para>

  <para>Возможности текстового поиска <productname>&productname;</productname> углублённо рассматриваются в <xref remap="6" linkend="textsearch"/>.</para>

  <table>
   <title>Столбцы <structname>pg_ts_config</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>cfgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя конфигурации текстового поиска</entry>
     </row>

     <row>
      <entry><structfield>cfgnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего эту конфигурацию</entry>
     </row>

     <row>
      <entry><structfield>cfgowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец конфигурации</entry>
     </row>

     <row>
      <entry><structfield>cfgparser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.oid</literal></entry>
      <entry>OID анализатора текстового поиска для этой конфигурации</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-config-map">
  <title><structname>pg_ts_config_map</structname></title>

  <indexterm zone="catalog-pg-ts-config-map"><primary>pg_ts_config_map</primary></indexterm>

  <para>В каталоге <structname>pg_ts_config_map</structname> содержатся записи, показывающие, к каким словарям текстового поиска и в каком порядке следует обращаться для каждого типа фрагмента, выдаваемого каждым анализатором текстового поиска.</para>

  <para>Возможности текстового поиска <productname>&productname;</productname> углублённо рассматриваются в <xref remap="6" linkend="textsearch"/>.</para>

  <table>
   <title>Столбцы <structname>pg_ts_config_map</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>mapcfg</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.oid</literal></entry>
      <entry>OID записи в <structname>pg_ts_config</structname>, к которой относится эта запись сопоставления</entry>
     </row>

     <row>
      <entry><structfield>maptokentype</structfield></entry>
      <entry><type>integer</type></entry>
      <entry/>
      <entry>Тип фрагмента, выдаваемый анализатором текстового поиска</entry>
     </row>

     <row>
      <entry><structfield>mapseqno</structfield></entry>
      <entry><type>integer</type></entry>
      <entry/>
      <entry>Порядок, в котором нужно просматривать эту запись (меньшие <structfield>mapseqno</structfield> просматриваются сначала)</entry>
     </row>

     <row>
      <entry><structfield>mapdict</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.oid</literal></entry>
      <entry>OID словаря текстового поиска, к которому нужно обратиться</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-dict">
  <title><structname>pg_ts_dict</structname></title>

  <indexterm zone="catalog-pg-ts-dict"><primary>pg_ts_dict</primary></indexterm>

  <para>В каталоге <structname>pg_ts_dict</structname> содержатся записи, определяющие словари текстового поиска. Словарь зависит от шаблона текстового поиска, в котором задаются все требуемые функции реализации; сам словарь предоставляет значения для настраиваемых параметров, поддерживаемых шаблонов. Такое разделение позволяет создавать словари непривилегированным пользователям. Параметры задаются текстовой строкой <structfield>dictinitoption</structfield>, их формат и значение зависят от шаблона.</para>

  <para>Возможности текстового поиска <productname>&productname;</productname> углублённо рассматриваются в <xref remap="6" linkend="textsearch"/>.</para>

  <table>
   <title>Столбцы <structname>pg_ts_dict</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>dictname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя словаря текстового поиска</entry>
     </row>

     <row>
      <entry><structfield>dictnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего этот словарь</entry>
     </row>

     <row>
      <entry><structfield>dictowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец словаря</entry>
     </row>

     <row>
      <entry><structfield>dicttemplate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.oid</literal></entry>
      <entry>OID шаблона текстового поиска для этого словаря</entry>
     </row>

     <row>
      <entry><structfield>dictinitoption</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Строка с параметрами инициализации для шаблона</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-parser">
  <title><structname>pg_ts_parser</structname></title>

  <indexterm zone="catalog-pg-ts-parser"><primary>pg_ts_parser</primary></indexterm>

  <para>В каталоге <structname>pg_ts_parser</structname> содержатся записи, определяющие анализаторы текстового поиска. Анализатор отвечает за разделение входного текста на лексемы и назначение типа фрагмента каждой лексеме. Так как анализатор должен быть реализован в функции на языке уровня C, создавать новые анализаторы разрешено только суперпользователям баз данных.</para>

  <para>Возможности текстового поиска <productname>&productname;</productname> углублённо рассматриваются в <xref remap="6" linkend="textsearch"/>.</para>

  <table>
   <title>Столбцы <structname>pg_ts_parser</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>prsname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя анализатора текстового поиска</entry>
     </row>

     <row>
      <entry><structfield>prsnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего этот анализатор</entry>
     </row>

     <row>
      <entry><structfield>prsstart</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции запуска анализатора</entry>
     </row>

     <row>
      <entry><structfield>prstoken</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции анализатора, выдающей следующий фрагмент</entry>
     </row>

     <row>
      <entry><structfield>prsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции анализатора, оканчивающей разбор</entry>
     </row>

     <row>
      <entry><structfield>prsheadline</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции анализатора, выдающей выдержки</entry>
     </row>

     <row>
      <entry><structfield>prslextype</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции анализатора лексических типов</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-template">
  <title><structname>pg_ts_template</structname></title>

  <indexterm zone="catalog-pg-ts-template"><primary>pg_ts_template</primary></indexterm>

  <para>В каталоге <structname>pg_ts_template</structname> содержатся записи, определяющие шаблоны текстового поиска. Шаблон представляет собой заготовку для класса словарей текстового поиска. Так как шаблон должен быть реализован в функциях на уровне языка C, создавать новые шаблоны разрешено только суперпользователям базы.</para>

  <para>Возможности текстового поиска <productname>&productname;</productname> углублённо рассматриваются в <xref remap="6" linkend="textsearch"/>.</para>

  <table>
   <title>Столбцы <structname>pg_ts_template</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя шаблона текстового поиска</entry>
     </row>

     <row>
      <entry><structfield>tmplnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего этот шаблон</entry>
     </row>

     <row>
      <entry><structfield>tmplinit</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции инициализации шаблона</entry>
     </row>

     <row>
      <entry><structfield>tmpllexize</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID функции выделения лексем</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type"><primary>pg_type</primary></indexterm>

  <para>В каталоге <structname>pg_type</structname> хранится информация о типах данных. Базовые типы и типы-перечисления (скалярные типы) создаются командой <xref linkend="sql-createtype"/>, а домены — командой <xref linkend="sql-createdomain"/>. При добавлении любой таблицы в базу данных автоматически создаётся составной тип, представляющий структуру строки таблицы. Также возможно создавать составные типы с помощью команды <command>CREATE TYPE AS</command>.</para>

  <table>
   <title>Столбцы <structname>pg_type</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя типа данных</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён, содержащего этот тип</entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Владелец типа</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry/>
      <entry>Для типа фиксированного размера в <structfield>typlen</structfield> задаётся число байт во внутреннем представлении типа. Но для типов переменной длины, <structfield>typlen</structfield> будет отрицательным. Значение -1 обозначает тип <quote>varlena</quote> (он содержит машинное слово, определяющее длину), а -2 обозначает строку в стиле C, оканчивающуюся нулём.</entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Поле <structfield>typbyval</structfield> определяет, будут ли внутренние процедуры передавать переменные этого типа по значению или по ссылке. Полю <structfield>typbyval</structfield> лучше присвоить false, если длина <structfield>typlen</structfield> не равна 1, 2 или 4 (либо 8, на 64-битных машинах). Типы переменной длины всегда передаются по ссылке. Заметьте, что <structfield>typbyval</structfield> может быть false, даже если размер типа позволяет передачу по значению.</entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Поле <structfield>typtype</structfield> принимает значение <literal>b</literal> для базового типа (base), <literal>c</literal> для составного (composite), то есть типа строки таблицы, <literal>d</literal> для домена (domain), <literal>e</literal> для перечисления (enum), <literal>p</literal> для псевдотипа (pseudo-type) или <literal>r</literal> для диапазона (range). См. также <structfield>typrelid</structfield> и <structfield>typbasetype</structfield>.</entry>
     </row>

     <row>
      <entry><structfield>typcategory</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>В поле <structfield>typcategory</structfield> задаётся произвольная классификация типов данных, на основе которой анализатор запросов может определить, какие неявные приведения будут <quote>предпочитаемыми</quote>. См. <xref remap="4" linkend="catalog-typcategory-table"/>.</entry>
     </row>

     <row>
      <entry><structfield>typispreferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если этот тип является предпочитаемым целевым типом в своей категории (<structfield>typcategory</structfield>)</entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>True, если тип определён, и false, если это тип-заготовка для ещё не определённого типа. Когда значение <structfield>typisdefined</structfield> — false, можно полагаться только на заданное имя, пространство имён и OID типа.</entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry>Символ, разделяющий два значения этого типа при разборе вводимого массива. Заметьте, что этот разделитель связывается с типом данных элемента массива, а не с типом самого массива.</entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Если это составной тип (см. <structfield>typtype</structfield>), этот столбец указывает на запись <structname>pg_class</structname>, определяющую соответствующую таблицу. (Для независимого составного типа запись в <structname>pg_class</structname> на самом деле не представляет таблицу, но она всё равно нужна для связывания с записями <structname>pg_attribute</structname> этого типа.) Для не составных типов содержит ноль.</entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Если значение <structfield>typelem</structfield> не 0, оно указывает на другую строку в <structname>pg_type</structname>. В этом случае к текущему типу можно обращаться по индексу, как к массиву, и получать значения типа <structfield>typelem</structfield>. <quote>Настоящий</quote> тип массива имеет переменную длину (<structfield>typlen</structfield> = -1), но для некоторых типов фиксированной длины (<structfield>typlen</structfield> &gt; 0) также определяется <structfield>typelem</structfield>, например, для <type>name</type> и <type>point</type>. Если для типа фиксированной длины определён <structfield>typelem</structfield>, его внутренним представлением будет некоторое количество значений типа <structfield>typelem</structfield>, без других данных. Типы массивов переменной длины также содержат заголовок, определяемый подпрограммами массива.</entry>
     </row>

     <row>
      <entry><structfield>typarray</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Если поле <structfield>typarray</structfield> не равно 0, оно указывает на другую запись в <structname>pg_type</structname>, описывающую <quote>настоящий</quote> тип массива, в которой этот тип будет элементом</entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция преобразования ввода (из текстового формата)</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция преобразования вывода (в текстовый формат)</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция преобразования ввода (из двоичного формата), либо 0, если её нет</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция преобразования вывода (в двоичный формат), либо 0, если её нет</entry>
     </row>

     <row>
      <entry><structfield>typmodin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция ввода модификатора типа, либо 0, если тип не поддерживает модификаторы</entry>
     </row>

     <row>
      <entry><structfield>typmodout</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Функция вывода модификатора типа, либо 0 для использования стандартного формата</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Нестандартная функция <command>ANALYZE</command>, либо 0 для использования стандартной функции</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry><para>Переменная <structfield>typalign</structfield> определяет выравнивание, требуемое при хранении значения этого типа. Эта величина применяется при хранении на диске, а также для большинства представлений значений внутри <productname>&productname;</productname>. Когда последовательно хранятся несколько значений, как например в представлении полной строки на диске, дополнительные байты добавляются перед значением этого типа, чтобы оно начиналось с указанной границы. Заданное выравнивание определяет смещение первого элемента последовательности.</para>

      <para>Возможные значения: <itemizedlist>
        <listitem>
         <para><literal>c</literal> = выравнивание по символам (<type>char</type>), то есть выравнивание не требуется.</para>
        </listitem>
        <listitem>
         <para><literal>s</literal> = выравнивание по коротким словам (<type>short</type>), 2 байта для большинства машин.</para>
        </listitem>
        <listitem>
         <para><literal>i</literal> = выравнивание по целым (<type>int</type>), 4 байта для большинства машин.</para>
        </listitem>
        <listitem>
         <para><literal>d</literal> = выравнивание по двойным словам (<type>double</type>), 8 байт для большинства машин, но не для всех.</para>
        </listitem>
       </itemizedlist></para><note>
       <para>Для типов, используемых в системных таблицах, важно, чтобы размер и выравнивание, определённые в <structname>pg_type</structname>, согласовывались с тем, как компилятор располагает этот столбец в структуре, представляющей строку таблицы.</para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry/>
      <entry><para>Значение <structfield>typstorage</structfield> для типов varlena (типов с <structfield>typlen</structfield> = -1) говорит, готов ли тип для помещения в TOAST, и какова стратегия по умолчанию для атрибутов этого типа. Возможные значения: <itemizedlist>
        <listitem>
         <para><literal>p</literal>: Значение всегда должно храниться простым образом (plain).</para>
        </listitem>
        <listitem>
         <para><literal>e</literal>: Значение может храниться во <quote>вторичном</quote> отношении (если оно есть, см. <literal>pg_class.reltoastrelid</literal>).</para>
        </listitem>
        <listitem>
         <para><literal>m</literal>: Значение может храниться сжатым внутри строки.</para>
        </listitem>
        <listitem>
         <para><literal>x</literal>: Значение может храниться сжатым внутри строки или во <quote>вторичном</quote> хранилище.</para>
        </listitem>
       </itemizedlist> Заметьте, что столбцы <literal>m</literal> тоже могут быть перемещены во вторичное хранилище, но только в качестве последней меры (столбцы <literal>e</literal> и <literal>x</literal> перемещаются в первую очередь).</para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry><para>Поле <structfield>typnotnull</structfield> представляет ограничение &laquo;не NULL&raquo; для типа. Применяется только для доменов.</para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>Если это домен (см. <structfield>typtype</structfield>), то <structfield>typbasetype</structfield> указывает на тип, на котором он основан. Ноль, если это не домен.</para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry><para>Домены используют <structfield>typtypmod</structfield> для записи модификатора (<literal>typmod</literal>), применяемого к их базовому типу (-1, если базовый тип не использует <literal>typmod</literal>). Если тип не является доменом, принимает значение -1.</para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry><para>Значение <structfield>typndims</structfield> задаёт число размерностей массива для домена, определённого поверх массива (то есть, когда <structfield>typbasetype</structfield> — тип массива). Для типов, отличных от доменов поверх типов массивов, принимает значение 0.</para></entry>
     </row>

     <row>
      <entry><structfield>typcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry><para>Значение <structfield>typcollation</structfield> задаёт правило сортировки для типа. Если тип не поддерживает сортировки, оно должно быть нулевым. У базового типа, поддерживающего сортировки, в этом поле будет <symbol>DEFAULT_COLLATION_OID</symbol>. Домен на базе сортируемого типа может иметь другой OID правила сортировки, если оно было изменено для домена.</para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry/>
      <entry><para>Если поле <structfield>typdefaultbin</structfield> не NULL, в нём содержится представление выражения по умолчанию для этого типа (совместимое с <function>nodeToString()</function>. Это поле используется только для доменов.</para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry><para>Поле <structfield>typdefault</structfield> содержит NULL, если с типом не связано значение по умолчанию. Если <structfield>typdefaultbin</structfield> не NULL, <structfield>typdefault</structfield> должно содержать понятную человеку версию выражения значения по умолчанию, записанного в <structfield>typdefaultbin</structfield>. Если <structfield>typdefaultbin</structfield> содержит NULL, а <structfield>typdefault</structfield> нет, то в <structfield>typdefault</structfield> находится внешнее представление значения по умолчанию, которое можно передать функции преобразования ввода и получить константу.</para></entry>
     </row>

     <row>
      <entry><structfield>typacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry/>
      <entry>Права доступа; за подробностями обратитесь к описанию <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>В <xref remap="6" linkend="catalog-typcategory-table"/> перечисляются определённые в системе значения <structfield>typcategory</structfield>. Если этот список будет дополняться в будущем, в него будут добавляться тоже буквы ASCII в верхнем регистре. Все другие символы ASCII зарезервированы для категорий, определяемых пользователями.</para>

  <table id="catalog-typcategory-table">
   <title>Коды <structfield>typcategory</structfield></title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Код</entry>
      <entry>Категория</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>A</literal></entry>
      <entry>Типы массивов</entry>
     </row>
     <row>
      <entry><literal>B</literal></entry>
      <entry>Логические типы</entry>
     </row>
     <row>
      <entry><literal>C</literal></entry>
      <entry>Составные типы</entry>
     </row>
     <row>
      <entry><literal>D</literal></entry>
      <entry>Типы даты/времени</entry>
     </row>
     <row>
      <entry><literal>E</literal></entry>
      <entry>Типы-перечисления</entry>
     </row>
     <row>
      <entry><literal>G</literal></entry>
      <entry>Геометрические типы</entry>
     </row>
     <row>
      <entry><literal>I</literal></entry>
      <entry>Типы, описывающие сетевые адреса</entry>
     </row>
     <row>
      <entry><literal>N</literal></entry>
      <entry>Числовые типы</entry>
     </row>
     <row>
      <entry><literal>P</literal></entry>
      <entry>Псевдотипы</entry>
     </row>
     <row>
      <entry><literal>R</literal></entry>
      <entry>Диапазонные типы</entry>
     </row>
     <row>
      <entry><literal>S</literal></entry>
      <entry>Строковые типы</entry>
     </row>
     <row>
      <entry><literal>T</literal></entry>
      <entry>Интервальные типы</entry>
     </row>
     <row>
      <entry><literal>U</literal></entry>
      <entry>Пользовательские типы</entry>
     </row>
     <row>
      <entry><literal>V</literal></entry>
      <entry>Типы битовых строк</entry>
     </row>
     <row>
      <entry><literal>X</literal></entry>
      <entry>Неизвестный тип (<type>unknown</type>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-user-mapping">
  <title><structname>pg_user_mapping</structname></title>

  <indexterm zone="catalog-pg-user-mapping"><primary>pg_user_mapping</primary></indexterm>

  <para>В каталоге <structname>pg_user_mapping</structname> хранятся сопоставления локальных пользователей с удалёнными. Обычные пользователи не имеют доступа к этому каталогу, они должны использовать представление <link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>.</para>

  <table>
   <title>Столбцы <structname>pg_user_mapping</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry/>
      <entry>Идентификатор строки (скрытый атрибут; должен выбираться явно)</entry>
     </row>

     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID сопоставляемой локальной роли, либо 0, если сопоставление задаётся для всех</entry>
     </row>

     <row>
      <entry><structfield>umserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>OID стороннего сервера, содержащего это сопоставление</entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Специальные параметры сопоставления пользователей, в виде строк <quote>ключ=значение</quote></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="views-overview">
  <title>Системные представления</title>

  <para>В дополнение к системным каталогам, в <productname>&productname;</productname> есть набор встроенных представлений. Некоторые системные представления содержат в себе некоторые популярные запросы к системным каталогам, а другие дают доступ к внутреннему состоянию сервера.</para>

  <para>Информационная схема (см. <xref remap="4" linkend="information-schema"/>) содержит другой набор представлений, пересекающихся по функциональности с системными представлениям. Так как информационная схема соответствует стандарту SQL, тогда как описанные здесь представления свойственны только для <productname>&productname;</productname>, обычно лучше использовать информационную схему, если через неё можно получить всю требуемую информацию.</para>

  <para>В <xref remap="6" linkend="view-table"/> кратко перечислены описываемые здесь системные представления. Более подробное описание каждого представления следует далее. Есть также дополнительные представления, дающие доступ к результатам работы сборщика статистики; они перечисляются в <xref remap="6" linkend="monitoring-stats-views-table"/>.</para>

  <para>Кроме явно отмеченных исключений, все описанные здесь представления доступны только для чтения.</para>

  <table id="view-table">
   <title>Системные представления</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Имя представления</entry>
      <entry>Предназначение</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-available-extensions"><structname>pg_available_extensions</structname></link></entry>
      <entry>доступные расширения</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-available-extension-versions"><structname>pg_available_extension_versions</structname></link></entry>
      <entry>доступные версии расширений</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-config"><structname>pg_config</structname></link></entry>
      <entry>параметры конфигурации времени компиляции</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <entry>открытые курсоры</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link></entry>
      <entry>сводка содержимого файла конфигурации</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>группы пользователей баз данных</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>индексы</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>блокировки, установленные или ожидаемые в данный момент</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-matviews"><structname>pg_matviews</structname></link></entry>
      <entry>материализованные представления</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-policies"><structname>pg_policies</structname></link></entry>
      <entry>policies</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <entry>подготовленные операторы</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>подготовленные транзакции</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link></entry>
      <entry>информация об источниках репликации, включая данные прогресса репликации</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link></entry>
      <entry>информация о слотах репликации</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>роли баз данных</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>правила</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-seclabels"><structname>pg_seclabels</structname></link></entry>
      <entry>метки безопасности</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>значения параметров</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>пользователи базы данных</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>статистика планировщика</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>таблицы</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <entry>аббревиатуры часовых поясов</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <entry>имена часовых поясов</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>пользователи базы данных</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link></entry>
      <entry>сопоставления пользователей</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>представления</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-available-extensions">
  <title><structname>pg_available_extensions</structname></title>

  <indexterm zone="view-pg-available-extensions"><primary>pg_available_extensions</primary></indexterm>

  <para>В представлении <structname>pg_available_extensions</structname> перечисляются расширения, доступные для установки. Также обратите внимание на каталог <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>, в котором перечисляются уже установленные расширения.</para>

  <table>
   <title>Столбцы <structname>pg_available_extensions</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Имя расширения</entry>
     </row>

     <row>
      <entry><structfield>default_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя версии по умолчанию, либо <literal>NULL</literal>, если это имя не определено</entry>
     </row>

     <row>
      <entry><structfield>installed_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Текущая установленная версия расширения, либо <literal>NULL</literal>, если расширение не установлено</entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Строка комментария из управляющего файла расширения</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Представление <structname>pg_available_extensions</structname> доступно только для чтения.</para>
 </sect1>

 <sect1 id="view-pg-available-extension-versions">
  <title><structname>pg_available_extension_versions</structname></title>

  <indexterm zone="view-pg-available-extension-versions"><primary>pg_available_extension_versions</primary></indexterm>

  <para>В представлении <structname>pg_available_extension_versions</structname> перечислены определённые версии расширений, доступные для установки. Также обратите внимание на каталог <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>, в котором перечисляются уже установленные расширения.</para>

  <table>
   <title>Столбцы <structname>pg_available_extension_versions</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Имя расширения</entry>
     </row>

     <row>
      <entry><structfield>version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя версии</entry>
     </row>

     <row>
      <entry><structfield>installed</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True, если эта версия расширения уже установлена</entry>
     </row>

     <row>
      <entry><structfield>superuser</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True, если устанавливать это расширение разрешено только суперпользователям</entry>
     </row>

     <row>
      <entry><structfield>relocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True, если расширение можно переместить в другую схему</entry>
     </row>

     <row>
      <entry><structfield>schema</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Имя схемы, в которую должно быть установлено расширение, либо <literal>NULL</literal>, если оно частично или полностью переместимо</entry>
     </row>

     <row>
      <entry><structfield>requires</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry>Имена расширений, требующихся для данного, либо <literal>NULL</literal>, если таких нет</entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Строка комментария из управляющего файла расширения</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Представление <structname>pg_available_extension_versions</structname> доступно только для чтения.</para>
 </sect1>

 <sect1 id="view-pg-config">
  <title><structname>pg_config</structname></title>

  <indexterm zone="view-pg-config"><primary>pg_config</primary></indexterm>

  <para>В представлении <structname>pg_config</structname> описываются конфигурационные параметры времени компиляции для текущей установленной версии <productname>&productname;</productname>. Оно предназначено, например, для программных средств, которым может потребоваться узнать у <productname>&productname;</productname> расположение требуемых заголовочных файлов и библиотек. Оно выдаёт ту же базовую информацию, что и клиентская утилита <productname>&productname;</productname> <xref linkend="app-pgconfig"/>.</para>

  <para>По умолчанию представление <structname>pg_config</structname> доступно только суперпользователям и только для чтения.</para>

  <table>
   <title>Столбцы <structname>pg_config</structname></title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя параметра</entry>
     </row>

     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Значение параметра</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-cursors">
  <title><structname>pg_cursors</structname></title>

  <indexterm zone="view-pg-cursors"><primary>pg_cursors</primary></indexterm>

  <para>В представлении <structname>pg_cursors</structname> перечисляются курсоры, доступные в данный момент. Курсоры могут быть созданы несколькими способами: <itemizedlist>
    <listitem>
     <para>через оператор <xref linkend="sql-declare"/> в SQL</para>
    </listitem>

    <listitem>
     <para>через сообщение Bind в клиент-серверном протоколе, как описано в <xref remap="6" linkend="protocol-flow-ext-query"/></para>
    </listitem>

    <listitem>
     <para>через интерфейс программирования сервера (SPI, Server Programming Interface), как описано в <xref remap="6" linkend="spi-interface"/></para>
    </listitem>
   </itemizedlist> В представлении <structname>pg_cursors</structname> показываются курсоры, полученные любым способом. Курсор существует только на протяжении транзакции, в которой он определён, если только он не был объявлен с указанием <literal>WITH HOLD</literal>. Поэтому не удерживаемые курсоры показываются в этом представлении только пока не завершится создавшая их транзакция. <note>
    <para>Курсоры используются внутри системы для реализации некоторых компонентов <productname>&productname;</productname>, таких как процедурные языки. Таким образом, в представлении <structname>pg_cursors</structname> могут быть курсоры, которые пользователи не создавали явно.</para>
   </note></para>

  <table>
   <title>Столбцы <structname>pg_cursors</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя курсора</entry>
     </row>

     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Дословная строка запроса, создавшего данный курсор</entry>
     </row>

     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>True</literal>, если курсор удерживаемый (то есть, к нему можно обращаться после того, как будет зафиксирована транзакция, в которой он объявлен); в противном случае — <literal>false</literal></entry>
     </row>

     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>True</literal>, если курсор был объявлен с указанием <literal>BINARY</literal>; в противном случае — <literal>false</literal></entry>
     </row>

     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>True</literal>, если курсор прокручиваемый (то есть, позволяет получать строки непоследовательным образом); в противном случае — <literal>false</literal></entry>
     </row>

     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Время, в которое был объявлен курсор</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Представление <structname>pg_cursors</structname> доступно только для чтения.</para>

 </sect1>

 <sect1 id="view-pg-file-settings">
  <title><structname>pg_file_settings</structname></title>

  <indexterm zone="view-pg-file-settings"><primary>pg_file_settings</primary></indexterm>

  <para>В представлении <structname>pg_file_settings</structname> показывается сводное содержимое файлов конфигурации сервера. Для каждой имеющейся в этих файлах записи <quote>имя = значение</quote> это представление содержит строку с отметкой, показывающей, может ли это значение быть успешно применено. Также это представление может содержать дополнительные строки, говорящие о проблемах, не связанных с записями <quote>имя = значение</quote>, например, синтаксических ошибках в этих файлах.</para>

  <para>Это представление полезно для проверки, будут ли работать планируемые изменения в файлах конфигурации, или для диагностики возникшей ранее проблемы. Заметьте, что в этом представлении отражается <emphasis>текущее</emphasis> содержимое файлов, а не то, что было применено сервером в последний раз. (Чтобы получить то состояние, обычно достаточно обратиться к представлению <link linkend="view-pg-settings"><structname>pg_settings</structname></link>.)</para>

  <para>По умолчанию представление <structname>pg_file_settings</structname> доступно только суперпользователям и только для чтения.</para>

  <table>
   <title>Столбцы <structname>pg_file_settings</structname></title>

  <tgroup cols="3">
   <thead>
    <row>
     <entry>Имя</entry>
     <entry>Тип</entry>
     <entry>Описание</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><structfield>sourcefile</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Полный путь и имя файла конфигурации</entry>
    </row>
    <row>
     <entry><structfield>sourceline</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>Номер строки в файле конфигурации, из которой получена эта запись</entry>
    </row>
    <row>
     <entry><structfield>seqno</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>Порядок, в котором обрабатываются записи (1..<replaceable>n</replaceable>)</entry>
    </row>
    <row>
     <entry><structfield>name</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Имя параметра конфигурации</entry>
    </row>
    <row>
     <entry><structfield>setting</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Значение, присваиваемое параметру</entry>
    </row>
    <row>
     <entry><structfield>applied</structfield></entry>
     <entry><structfield>boolean</structfield></entry>
     <entry>True, если значение может быть применено успешно</entry>
    </row>
    <row>
     <entry><structfield>error</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Сообщение об ошибке, говорящее, почему эта запись не может быть применена, либо NULL</entry>
    </row>
   </tbody>
  </tgroup>
  </table>

  <para>Если файл конфигурации содержит синтаксические ошибки или недопустимые имена параметров, сервер не будет пытаться применять никакие параметры из него, так что все поля <structfield>applied</structfield> будут равны False. В этом случае представление будет содержать одну или несколько строк, в которых поле <structfield>error</structfield> описывает проблему. Иначе отдельные записи этого файла будут применяться по возможности. Если заданное в некоторой записи присвоение выполнить нельзя (например, из-за неверного значения или если параметр нельзя изменять после запуска сервера), в поле <structfield>error</structfield> для неё будет записано соответствующее сообщение. Поле <structfield>applied</structfield> также может содержать False, если данная запись переопределяется последующей записью с тем же именем параметра; это не считается ошибкой, так что поле <structfield>error</structfield> будет пустым.</para>

  <para>Чтобы узнать больше о различных способах изменения параметров времени выполнения, обратитесь к <xref remap="3" linkend="config-setting"/>.</para>

</sect1>

 <sect1 id="view-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="view-pg-group"><primary>pg_group</primary></indexterm>

  <para>Представление <structname>pg_group</structname> существует для обратной совместимости: оно эмулирует каталог, существовавший в <productname>PostgreSQL</productname> до версии 8.1. В нём показываются имена и члены всех ролей без признака <structfield>rolcanlogin</structfield>, что приблизительно соответствует списку ролей, которые использовались как группы.</para>

  <table>
   <title>Столбцы <structname>pg_group</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Имя группы</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID этой группы</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Массив, содержащий идентификаторы ролей в этой группе</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes"><primary>pg_indexes</primary></indexterm>

  <para>Представление <structname>pg_indexes</structname> даёт доступ к полезной информации обо всех индексах в базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_indexes</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Имя схемы, содержащей таблицу и индекс</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя таблицы, для которой создан индекс</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя индекса</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Имя табличного пространства, содержащего индекс (NULL, если это пространство по умолчанию)</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Определение индекса (реконструированная команда <command>CREATE INDEX</command>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks"><primary>pg_locks</primary></indexterm>

  <para>Представление <structname>pg_locks</structname> даёт доступ к информации о блокировках, удерживаемых активными процессами на сервере баз данных. Подробнее блокировки рассматриваются в <xref remap="6" linkend="mvcc"/>.</para>

  <para>Представление <structname>pg_locks</structname> содержит одну строку для каждого активного блокируемого объекта, запрошенного режима блокировки и блокирующего процесса. Таким образом, один и тот же блокируемый объект может фигурировать в этом представлении неоднократно, если его блокируют или ожидают блокировки несколько процессов. Однако объекты, свободные от блокировок, в этом представлении отсутствуют вовсе.</para>

  <para>Существует несколько различных типов блокируемых объектов: отношения целиком (например, таблицы), отдельные страницы отношений, отдельные кортежи отношений, идентификаторы транзакций (виртуальные и постоянные) и произвольные объекты баз данных (идентифицируемые по OID класса и OID объекта, так же как в <structname>pg_description</structname> или <structname>pg_depend</structname>). Кроме того, в виде отдельного блокируемого объекта представлено право расширения отношения. Также могут быть установлены <quote>рекомендательные</quote> блокировки, не имеющие предопределённого значения.</para>

  <table>
   <title>Столбцы <structname>pg_locks</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Тип блокируемого объекта: <literal>relation</literal> (отношение), <literal>extend</literal> (расширение отношения), <literal>page</literal> (страница), <literal>tuple</literal> (кортеж), <literal>transactionid</literal> (идентификатор транзакции), <literal>virtualxid</literal> (виртуальный идентификатор), <literal>object</literal> (объект), <literal>userlock</literal> (пользовательская блокировка) или <literal>advisory</literal> (рекомендательная)</entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>OID базы данных, к которой относится цель блокировки, ноль, если это разделяемый объект, либо NULL, если целью является идентификатор транзакции</entry>
     </row>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID отношения, являющегося целью блокировки, либо NULL, если цель блокировки — не отношение или часть отношения</entry>
     </row>
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry/>
      <entry>Номер страницы в отношении, являющейся целью блокировки, либо NULL, если цель блокировки — не страница или кортеж отношения</entry>
     </row>
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry/>
      <entry>Номер кортежа на странице, являющегося целью блокировки, либо NULL, если цель блокировки — не кортеж</entry>
     </row>
     <row>
      <entry><structfield>virtualxid</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Виртуальный идентификатор транзакции, являющийся целью блокировки, либо NULL, если цель блокировки — другой объект</entry>
     </row>
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Идентификатор транзакции, являющийся целью блокировки, либо NULL, если цель блокировки — другой объект</entry>
     </row>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, содержащего цель блокировки, либо NULL, если цель блокировки — не обычный объект базы данных</entry>
     </row>
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID цели блокировки в соответствующем системном каталоге, либо NULL, если цель блокировки — не обычный объект базы данных</entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry/>
      <entry>Номер столбца, являющегося целью блокировки (на саму таблицу указывают <structfield>classid</structfield> и <structfield>objid</structfield>), ноль, если это некоторый другой обычный объект базы данных, либо NULL, если цель не обычный объект</entry>
     </row>
     <row>
      <entry><structfield>virtualtransaction</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Виртуальный идентификатор транзакции, удерживающей или ожидающей блокировку</entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry/>
      <entry>Идентификатор серверного процесса (PID, Process ID), удерживающего или ожидающего эту блокировку, либо NULL, если блокировка удерживается подготовленной транзакцией</entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Режим, в котором удерживается или запрашивается блокировка этим процессом (см. <xref remap="4" linkend="locking-tables"/> и <xref remap="4" linkend="xact-serializable"/>)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry/>
      <entry>True, если блокировка получена, и false, если она ожидается</entry>
     </row>
     <row>
      <entry><structfield>fastpath</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry/>
      <entry>True, если блокировка получена по короткому пути, и false, если она получена через основную таблицу блокировок</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Признак <structfield>granted</structfield> устанавливается в строке, представляющей блокировку, удерживаемую указанным процессом. Если он сброшен, этот процесс ждёт блокировки, из чего следует что как минимум один другой процесс удерживает или ожидает блокировку того же объекта в конфликтующем режиме. Ожидающий процесс будет приостановлен до освобождения другой блокировки (или выявления ситуации взаимоблокировки). Один процесс в один момент времени может ожидать получения максимум одной блокировки.</para>

  <para>На протяжении транзакции серверный процесс удерживает исключительную блокировку виртуального идентификатора транзакции. Если транзакции назначается постоянный идентификатор (что обычно происходит, только если транзакция изменяет состояние базы данных), он также удерживает до её завершения блокировку этого постоянного идентификатора. Когда процесс находит необходимым ожидать именно какую-то другую транзакцию, он делает это, запрашивая разделяемую блокировку для идентификатора этой транзакции (виртуального или постоянного, в зависимости от ситуации). Этот запрос будет выполнен, только когда другая транзакция завершится и освободит свои блокировки.</para>

  <para>Хотя кортежи тоже представляют собой блокируемый объект, информация о блокировках строк хранится на диске, а не в памяти, поэтому такие блокировки обычно не показываются в этом представлении. Если процесс ожидает блокировки на уровне строки, он обычно виден в нём как ожидающий постоянного идентификатора транзакции текущего владельца этой блокировки.</para>

  <para>Рекомендательные блокировки могут быть получены по ключам, состоящим из одного значения <type>bigint</type> или из двух значений integer. Старшая половина <type>bigint</type> выводится в столбце <structfield>classid</structfield>, а младшая половина в столбце <structfield>objid</structfield>, и <structfield>objsubid</structfield> равен 1. Исходное значение <type>bigint</type> может быть восстановлено выражением <literal>(classid::bigint &lt;&lt; 32) | objid::bigint</literal>. Для ключей integer первая часть ключа находится в <structfield>classid</structfield>, а вторая часть в <structfield>objid</structfield>, и <structfield>objsubid</structfield> равна 2. Конкретное предназначение этих ключей определяет пользователь. Рекомендательные блокировки существуют в рамках базы данных, поэтому столбец <structfield>database</structfield> имеет значение для таких блокировок.</para>

  <para>Представление <structname>pg_locks</structname> даёт общую информацию по всем блокировкам в кластере баз данных, а не только по тем, что относятся к текущей базе. Хотя соединив <structfield>relation</structfield> с <structname>pg_class</structname>.<structfield>oid</structfield>, можно получить заблокированные отношения, это будет работать корректно только для отношений в текущей базе данных (для тех, в блокировках которых столбец <structfield>database</structfield> содержит OID текущей базы данных или ноль).</para>

  <para>Соединив столбец <structfield>pid</structfield> со столбцом <structfield>pid</structfield> представления <link linkend="pg-stat-activity-view"><structname>pg_stat_activity</structname></link>, можно получить дополнительную информацию о сеансах, удерживающих или ожидающих каждую блокировку, например так: <programlisting>SELECT * FROM pg_locks pl LEFT JOIN pg_stat_activity psa
    ON pl.pid = psa.pid;</programlisting> Также, если вы используете подготовленные транзакции, столбец <structfield>virtualtransaction</structfield> можно соединить со столбцом <structfield>transaction</structfield> представления <link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link> для получения дополнительной информации о подготовленных транзакциях, удерживающих блокировки. (Подготовленная транзакция не может ожидать блокировок, но она может продолжать удерживать блокировки, полученные ей в процессе выполнения.) Например: <programlisting>SELECT * FROM pg_locks pl LEFT JOIN pg_prepared_xacts ppx
    ON pl.virtualtransaction = '-1/' || ppx.transaction;</programlisting></para>

  <para>Хотя в принципе возможно получить информацию о процессах, которые блокируют другие процессы, соединив представление <structname>pg_locks</structname> с ним же, очень трудно сделать это правильно во всех деталях. В частности потому, что такой запрос должен будет знать, какие режимы блокировки конфликтуют с другими. Мало того, представление <structname>pg_locks</structname> не показывает, какие процессы стоят перед какими в очередях ожидания блокировок, а также какие процессы являются параллельными рабочими процессами и к каким клиентским сеансам они относятся. Чтобы узнать, каким процессом или процессами блокируется ожидающий процесс, лучше использовать функцию <function>pg_blocking_pids()</function> (см. <xref remap="4" linkend="functions-info-session-table"/>).</para>

  <para>В представлении <structname>pg_locks</structname> показываются данные и из менеджера обычных блокировок, и из менеджера предикатных блокировок, которые являются отдельными механизмами; кроме того, менеджер обычных блокировок подразделяет свои блокировки на обычные и полученные <firstterm>быстрым путём</firstterm>. Абсолютная согласованность всех этих данных не гарантируется. При обращении к этому представлению данные блокировок по быстрому пути (с <structfield>fastpath</structfield> = <literal>true</literal>) собираются по очереди с каждого серверного процесса, без замораживания состояния всего менеджера блокировок, так что существует возможность, что в процессе сбора этой информации блокировки будут освобождены или получены. Заметьте, однако, что эти блокировки не должны конфликтовать с любыми другими актуальными блокировками. После того как от всех процессов получены блокировки по быстрому пути, менеджер обычных блокировок замораживается целиком и информация обо всех оставшихся блокировках собирается в атомарной операции. После размораживания этого менеджера, также замораживается менеджер предикатных блокировок, и информация об этих блокировках собирается атомарно. Таким образом, за исключением блокировок по быстрому пути, каждый менеджер блокировок выдаёт согласованный набор результатов, но так как мы не блокируем оба этих менеджера одновременно, блокировки могут быть получены или освобождены после того, как опрашивается менеджер обычных блокировок, и до того, как опрашивается менеджер предикатных блокировок.</para>

  <para>Блокировка менеджера обычных или предикатных блокировок может отразиться на производительности базы данных, если обращаться к этому представлению часто. Эта блокировка удерживается не дольше, чем необходимо для получения данных от менеджеров, но это не исключает возможность снижения производительности.</para>

 </sect1>

 <sect1 id="view-pg-matviews">
  <title><structname>pg_matviews</structname></title>

  <indexterm zone="view-pg-matviews"><primary>pg_matviews</primary></indexterm>

  <indexterm zone="view-pg-matviews"><primary>материализованные представления</primary></indexterm>

  <para>Представление <structname>pg_matviews</structname> даёт доступ к полезной информации обо всех материализованных представлениях в базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_matviews</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Имя схемы, содержащей материализованное представление</entry>
     </row>
     <row>
      <entry><structfield>matviewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя материализованного представления</entry>
     </row>
     <row>
      <entry><structfield>matviewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Имя владельца материализованного представления</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Имя табличного пространства, содержащего материализованное представление (NULL, если это пространство по умолчанию)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry/>
      <entry>True, если материализованное представление имеет (или недавно имело) индексы</entry>
     </row>
     <row>
      <entry><structfield>ispopulated</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry/>
      <entry>True, если материализованное представление в данный момент наполнено</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Определение материализованного представления (реконструированный запрос <command>SELECT</command>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-policies">
  <title><structname>pg_policies</structname></title>

  <indexterm zone="view-pg-policies"><primary>pg_policies</primary></indexterm>

  <para>Представление <structname>pg_policies</structname> даёт доступ к полезной информации обо всех политиках защиты на уровне строк в базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_policies</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Имя схемы, содержащей таблицу с этой политикой</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя таблицы с этой политикой</entry>
     </row>
     <row>
      <entry><structfield>policyname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-policy"><structname>pg_policy</structname></link>.polname</literal></entry>
      <entry>Имя политики</entry>
     </row>
     <row>
      <entry><structfield>roles</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry/>
      <entry>Роли, к которым применяется политика</entry>
     </row>
     <row>
      <entry><structfield>cmd</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Тип команды, к которому применяется политика</entry>
     </row>
     <row>
      <entry><structfield>qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Выражение, добавляемое к условиям барьера безопасности в запросы, к которым применяется политика</entry>
     </row>
     <row>
      <entry><structfield>with_check</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Выражение, добавляемое к условиям WITH CHECK в запросы, которые пытаются добавлять строки в таблицу</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-prepared-statements">
  <title><structname>pg_prepared_statements</structname></title>

  <indexterm zone="view-pg-prepared-statements"><primary>pg_prepared_statements</primary></indexterm>

  <para>В представлении <structname>pg_prepared_statements</structname> отображаются все подготовленные операторы, существующие в текущем сеансе. За дополнительными сведениями о подготовленных операторах обратитесь к <xref remap="3" linkend="sql-prepare"/>.</para>

  <para>Представление <structname>pg_prepared_statements</structname> содержит отдельную строку для каждого подготовленного оператора. Строки добавляются в него, когда создаётся новый подготовленный оператор, и удаляются, когда подготовленный оператор освобождается (например, командой <xref linkend="sql-deallocate"/>).</para>

  <table>
   <title>Столбцы <structname>pg_prepared_statements</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Идентификатор подготовленного оператора</entry>
     </row>
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Строка запроса, переданного клиентом и создавшего этот подготовленный оператор. Для подготовленных операторов, создаваемых через SQL, это оператор <command>PREPARE</command>, переданный клиентом. Для подготовленных операторов, созданных через клиент-серверный протокол, этот текст представляет сам подготовленный оператор.</entry>
     </row>
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Время, в которое был создан подготовленный оператор</entry>
     </row>
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>Ожидаемые типы параметров для подготовленного оператора в форме массива <type>regtype</type>. OID, соответствующий элементу этого массива, может быть получен в результате приведения значения <type>regtype</type> к <type>oid</type>.</entry>
     </row>
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>Значение <literal>true</literal>, если подготовленный оператор был создан SQL-командой <command>PREPARE</command>; <literal>false</literal>, если оператор был подготовлен через клиент-серверный протокол</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Представление <structname>pg_prepared_statements</structname> доступно только для чтения.</para>
 </sect1>

 <sect1 id="view-pg-prepared-xacts">
  <title><structname>pg_prepared_xacts</structname></title>

  <indexterm zone="view-pg-prepared-xacts"><primary>pg_prepared_xacts</primary></indexterm>

  <para>Представление <structname>pg_prepared_xacts</structname> содержит информацию о транзакциях, которые в настоящее время подготовлены для двухфазной фиксации (за подробностями обратитесь к <xref remap="3" linkend="sql-prepare-transaction"/>).</para>

  <para>Представление <structname>pg_prepared_xacts</structname> содержит отдельную запись для каждой подготовленной транзакции. Эта запись удаляется, когда транзакция фиксируется или откатывается.</para>

  <table>
   <title>Столбцы <structname>pg_prepared_xacts</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Числовой идентификатор подготовленной транзакции</entry>
     </row>
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Глобальный идентификатор транзакции, назначаемый транзакции</entry>
     </row>
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry/>
      <entry>Время, в которое транзакция была подготовлена для фиксации</entry>
     </row>
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Имя пользователя, выполнявшего транзакцию</entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>Имя базы данных, в которой выполнялась транзакция</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Когда запрашивается представление <structname>pg_prepared_xacts</structname>, внутренние структуры данных менеджера транзакций на мгновение блокируются и создаётся их копия для вывода через это представление. Это гарантирует, что представление выдаёт согласованный набор результатов, при этом не задерживая обычные операции на более продолжительное время, чем необходимо. Тем не менее, это может отрицательно сказаться на производительности базы данных при частых обращениях к представлению.</para>

 </sect1>

  <sect1 id="view-pg-replication-origin-status">
  <title><structname>pg_replication_origin_status</structname></title>

  <indexterm zone="view-pg-replication-origin-status"><primary>pg_replication_origin_status</primary></indexterm>

  <para>Представление <structname>pg_replication_origin_status</structname> содержит информацию о позиции воспроизведения записей репликации, достигнутой для определённого источника. Подробно источники репликации описаны в <xref remap="6" linkend="replication-origins"/>.</para>

  <table>

   <title>Столбцы <structname>pg_replication_origin_status</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>local_id</structfield></entry>
      <entry><type>Oid</type></entry>
      <entry><literal><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link>.roident</literal></entry>
      <entry>внутренний идентификатор узла</entry>
     </row>

     <row>
      <entry><structfield>external_id</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link>.roname</literal></entry>
      <entry>внешний идентификатор узла</entry>
     </row>

     <row>
      <entry><structfield>remote_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry/>
      <entry>LSN исходного узла, до которого были реплицированы данные.</entry>
     </row>

     <row>
      <entry><structfield>local_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry/>
      <entry>LSN данного узла, с которым был реплицирован <literal>remote_lsn</literal>. Применяется при асинхронной фиксации для сброса на диск записей фиксации до сохранения данных.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-replication-slots">
  <title><structname>pg_replication_slots</structname></title>

  <indexterm zone="view-pg-replication-slots"><primary>pg_replication_slots</primary></indexterm>

  <para>Представление <structname>pg_replication_slots</structname> содержит список всех слотов репликации, существующих в данный момент в кластере баз данных, а также их текущее состояние.</para>

  <para>За дополнительной информацией о слотах репликации обратитесь к <xref remap="3" linkend="streaming-replication-slots"/> и <xref remap="3" linkend="logicaldecoding"/>.</para>

  <table>

   <title>Столбцы <structname>pg_replication_slots</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>slot_name</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Уникальный в рамках кластера идентификатор для слота репликации</entry>
     </row>

     <row>
      <entry><structfield>plugin</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Базовое имя разделяемого объекта, содержащего модуль вывода, который используется этим логическим слотом, либо NULL для физических слотов.</entry>
     </row>

     <row>
      <entry><structfield>slot_type</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Тип слота — <literal>physical</literal> (физический) или <literal>logical</literal> (логический)</entry>
     </row>

     <row>
      <entry><structfield>datoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>OID базы данных, с которой связан этот слот, либо NULL. С базой данных могут быть связаны только логические слоты.</entry>
     </row>

     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>Имя базы данных, с которой связан этот слот, либо NULL. С базой данных могут быть связаны только логические слоты.</entry>
     </row>

     <row>
      <entry><structfield>active</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry/>
      <entry>True, если слот активно используется в данный момент</entry>
     </row>

     <row>
      <entry><structfield>active_pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry/>
      <entry>ID процесса сеанса, занимающего этот слот, если данный слот активно используется в данный момент. <literal>NULL</literal>, если он не используется.</entry>
     </row>

     <row>
      <entry><structfield>xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Старейшая транзакция, которая должна сохраняться в базе данных для этого слота. <literal>VACUUM</literal> не сможет удалять кортежи, удалённые более поздними транзакциями.</entry>
     </row>

     <row>
      <entry><structfield>catalog_xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry/>
      <entry>Старейшая транзакция, затрагивающая системные каталоги, которая должна сохраняться в базе данных для этого слота. <literal>VACUUM</literal> не сможет удалять кортежи, удалённые более поздними транзакциями.</entry>
     </row>

     <row>
      <entry><structfield>restart_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry/>
      <entry>Адрес (<literal>LSN</literal>) старейшей записи в WAL, которая по-прежнему может быть нужна пользователям этого слота и, таким образом, не будет автоматически удаляться при контрольных точках.</entry>
     </row>

     <row>
      <entry><structfield>confirmed_flush_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry/>
      <entry>Адрес (<literal>LSN</literal>), до которого потребитель логического слота подтвердил получение данных. Данные старее этого LSN уже недоступны. Для физических слотов — <literal>NULL</literal>.</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-roles">
  <title><structname>pg_roles</structname></title>

  <indexterm zone="view-pg-roles"><primary>pg_roles</primary></indexterm>

  <para>Представление <structname>pg_roles</structname> открывает доступ к информации о ролях в базах данных. Это просто доступное для всех отображение каталога <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>, в котором очищено поле пароля.</para>

  <para>В этом представлении выводится OID из нижележащей таблицы, так как это необходимо для соединений с другими каталогами.</para>

  <table>
   <title>Столбцы <structname>pg_roles</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя роли</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Роли имеет права суперпользователя</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Роль автоматически наследует права ролей, в которые она включена</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Роль может создавать другие роли</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Роль может создавать базы данных</entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Роль может подключаться к серверу. То есть эта роль может быть указана в качестве начального идентификатора авторизации сеанса</entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Роль является ролью репликации. Такие роли могут устанавливать соединения для репликации и создавать/удалять слоты репликации.</entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для ролей, которые могут подключаться к серверу, это значение задаёт максимально разрешённое для этой роли число одновременных подключений. При значении -1 ограничения нет.</entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Не пароль (всегда выводится как <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry/>
      <entry>Срок действия пароля (используется только при аутентификации по паролю); NULL, если срок действия не ограничен</entry>
     </row>

     <row>
      <entry><structfield>rolbypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Роль не подчиняется никаким политикам защиты на уровне строк; за подробностями обратитесь к <xref remap="3" linkend="ddl-rowsecurity"/>.</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Заданные для роли значения по умолчанию переменных времени конфигурации</entry>
     </row>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Идентификатор роли</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules"><primary>pg_rules</primary></indexterm>

  <para>Представление <structname>pg_rules</structname> открывает доступ к полезной информации о правилах перезаписи запросов.</para>

  <table>
   <title>Столбцы <structname>pg_rules</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Имя схемы, содержащей таблицу</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя таблицы, с которой связано это правило</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>Имя правила</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Определение правила (реконструированная команда создания)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Из представления <structname>pg_rules</structname> исключены правила <literal>ON SELECT</literal> для представлений и материализованных представлений; их можно увидеть в <structname>pg_views</structname> и <structname>pg_matviews</structname>.</para>

 </sect1>

 <sect1 id="view-pg-seclabels">
  <title><structname>pg_seclabels</structname></title>

  <indexterm zone="view-pg-seclabels"><primary>pg_seclabels</primary></indexterm>

  <para>Представление <structname>pg_seclabels</structname> содержит информацию о метках безопасности. Это более простая в использовании версия каталога <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.</para>

  <table>
   <title>Столбцы <structname>pg_seclabels</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>любой столбец OID</entry>
      <entry>OID объекта, к которому относится эта метка безопасности</entry>
     </row>
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID системного каталога, к которому относится этот объект</entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry/>
      <entry>Для метки безопасности, связанной со столбцом таблицы, это номер столбца (<structfield>objoid</structfield> и <structfield>classoid</structfield> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</entry>
     </row>
     <row>
      <entry><structfield>objtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Тип объекта, к которому применяется эта метка, в текстовом виде.</entry>
     </row>
     <row>
      <entry><structfield>objnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>OID пространства имён объекта, если применимо; иначе NULL.</entry>
     </row>
     <row>
      <entry><structfield>objname</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Имя объекта, к которому применяется эта метка, в текстовом виде.</entry>
     </row>
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.provider</literal></entry>
      <entry>Поставщик меток безопасности, связанный с этой меткой.</entry>
     </row>
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.label</literal></entry>
      <entry>Метка безопасности, применённая к этому объекту.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings"><primary>pg_settings</primary></indexterm>

  <para>Представление <structname>pg_settings</structname> открывает доступ к параметрам времени выполнения сервера. По сути оно представляет собой альтернативный интерфейс для команд <xref linkend="sql-show"/> и <xref linkend="sql-set"/>. Оно также позволяет получить некоторые свойства каждого параметра, которые нельзя получить непосредственно, используя команду <command>SHOW</command>, например, минимальные и максимальные значения.</para>

  <table>
   <title>Столбцы <structname>pg_settings</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Имя параметра конфигурации времени выполнения</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Текущее значение параметра</entry>
     </row>
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Неявно подразумеваемая единица измерения параметра</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Логическая группа параметра</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Краткое описание параметра</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Дополнительное, более подробное, описание параметра</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Контекст, в котором может задаваться значение параметра (см. ниже)</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Тип параметра (<literal>bool</literal>, <literal>enum</literal>, <literal>integer</literal>, <literal>real</literal> или <literal>string</literal>)</entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Источник текущего значения параметра</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Минимальное допустимое значение параметра (NULL для нечисловых значений)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Максимально допустимое значение параметра (NULL для нечисловых значений)</entry>
     </row>
     <row>
      <entry><structfield>enumvals</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Допустимые значения параметра-перечисления (NULL для значений не перечислений)</entry>
     </row>
     <row>
      <entry><structfield>boot_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Значение параметра, устанавливаемое при запуске сервера, если параметр не устанавливается другим образом</entry>
     </row>
     <row>
      <entry><structfield>reset_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Значение, к которому будет сбрасывать параметр команда <command>RESET</command> в текущем сеансе</entry>
     </row>
     <row>
      <entry><structfield>sourcefile</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Файл конфигурации, в котором было задано текущее значение (NULL для значений, полученных не из файлов конфигурации, или при чтении этого поля не суперпользователем); полезно при использовании указаний <literal>include</literal> в файлах конфигурации</entry>
     </row>
     <row>
      <entry><structfield>sourceline</structfield></entry>
      <entry><type>integer</type></entry>
      <entry>Номер строки в файле конфигурации, в которой было задано текущее значение (NULL для значений, полученных не из файлов конфигурации, или при чтении этого поля не суперпользователем)</entry>
     </row>
     <row>
      <entry><structfield>pending_restart</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal>, если значение изменено в файле конфигурации, но требуется перезапуск; в противном случае — <literal>false</literal>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Поле <structfield>context</structfield> может содержать одно из следующих значений (они перечислены в порядке уменьшения сложности изменения параметров):</para>

  <variablelist>
   <varlistentry>
    <!-- PGC_INTERNAL -->
    <term><literal>internal</literal></term>
    <listitem>
     <para>Эти параметры нельзя изменить непосредственно; они отражают значения, определяемые внутри системы. Некоторые из них можно изменить, пересобрав сервер с другими параметрами конфигурации, либо передав другие аргументы команде <command>initdb</command>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_POSTMASTER -->
    <term><literal>postmaster</literal></term>
    <listitem>
     <para>Эти параметры могут быть применены только при запуске сервера, так что любое изменение требует перезапуска сервера. Значения этих параметров обычно задаются в <filename>postgresql.conf</filename>, либо передаются в командной строке при запуске сервера. Разумеется, параметры более низкого уровня <structfield>context</structfield> также можно задать в момент запуска сервера.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_SIGHUP -->
    <term><literal>sighup</literal></term>
    <listitem>
     <para>Внесённые в <filename>postgresql.conf</filename> изменения этих параметров можно применить, не перезапуская сервер. Если передать управляющему процессу сигнал <systemitem>SIGHUP</systemitem>, он перечитает <filename>postgresql.conf</filename> и применит изменения. Управляющий процесс также перешлёт сигнал <systemitem>SIGHUP</systemitem> всем своим дочерним процессам, чтобы они тоже приняли новое значение.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_SU_BACKEND -->
    <term><literal>superuser-backend</literal></term>
    <listitem>
     <para>Внесённые в <filename>postgresql.conf</filename> изменения этих параметров можно применить без перезапуска сервера; их также можно задать для определённого сеанса в пакете запроса соединения (например, через переменную окружения <literal>PGOPTIONS</literal>, учитываемую библиотекой <application>libpq</application>), но сделать это может только суперпользователь. Однако эти параметры никогда не меняются в сеансе, когда он уже начат. Если вы измените их в <filename>postgresql.conf</filename>, отправьте сигнал <systemitem>SIGHUP</systemitem> управляющему процессу, чтобы он перечитал <filename>postgresql.conf</filename>. Новые значения подействуют только на сеансы, запускаемые после этого.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_BACKEND -->
    <term><literal>backend</literal></term>
    <listitem>
     <para>Внесённые в <filename>postgresql.conf</filename> изменения этих параметров можно применить без перезапуска сервера; их также можно задать для определённого сеанса в пакете запроса соединения (например, через переменную окружения <literal>PGOPTIONS</literal>, учитываемую библиотекой <application>libpq</application>); это может сделать любой пользователь в своём сеансе. Однако эти параметры никогда не меняются в сеансе, когда он уже начат. Если вы измените их в <filename>postgresql.conf</filename>, отправьте сигнал <systemitem>SIGHUP</systemitem> управляющему процессу, чтобы он перечитал <filename>postgresql.conf</filename>. Новые значения подействуют только на сеансы, запускаемые после этого.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_SUSET -->
    <term><literal>superuser</literal></term>
    <listitem>
     <para>Эти параметры можно изменить в <filename>postgresql.conf</filename>, либо в рамках сеанса, командой <command>SET</command>; но только суперпользователи могут менять их, используя <command>SET</command>. Изменения в <filename>postgresql.conf</filename> будут отражены в существующих сеансах, только если в них командой <command>SET</command> не были заданы локальные значения.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_USERSET -->
    <term><literal>user</literal></term>
    <listitem>
     <para>Эти параметры можно задать в <filename>postgresql.conf</filename>, либо в рамках сеанса, командой <command>SET</command>. В рамках сеанса изменять их разрешено всем пользователям. Изменения в <filename>postgresql.conf</filename> будут отражены в существующих сеансах, только если в них командой <command>SET</command> не были заданы локальные значения.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>Чтобы узнать больше о различных способах изменения этих параметров, обратитесь к <xref remap="3" linkend="config-setting"/>.</para>

  <para>Представление <structname>pg_settings</structname> не допускает добавление и удаление строк, но допускает изменение. Команда <command>UPDATE</command>, применённая к строке <structname>pg_settings</structname>, равнозначна выполнению команды <xref linkend="sql-set"/> для этого параметра. Изменение повлияет только на значение в текущем сеансе. Если <command>UPDATE</command> выполняется в транзакции, которая затем прерывается, эффект <command>UPDATE</command> пропадает, когда транзакция откатывается. После фиксирования окружающей транзакции этот эффект сохраняется до завершения сеанса, если он не будет переопределён другой командой <command>UPDATE</command> или <command>SET</command>.</para>

 </sect1>

 <sect1 id="view-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="view-pg-shadow"><primary>pg_shadow</primary></indexterm>

  <para>Представление <structname>pg_shadow</structname> существует для обратной совместимости: оно эмулирует каталог, существовавший в <productname>PostgreSQL</productname> до версии 8.1. В нём показываются свойства всех ролей с признаком <structfield>rolcanlogin</structfield> в <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.</para>

  <para>Такое имя (&laquo;тень&raquo;) объясняется тем фактом, что эта таблица не должна быть доступна на чтение всем, так как она содержит пароли. Представление <link linkend="view-pg-user"><structname>pg_user</structname></link> является доступным всем отображением <structname>pg_shadow</structname>, в котором очищено поле пароля.</para>

  <table>
   <title>Столбцы <structname>pg_shadow</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Имя пользователя</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID этого пользователя</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Пользователь может создавать базы данных</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Пользователь является суперпользователем</entry>
     </row>

     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Пользователь может инициировать потоковую репликацию, включать и отключать режим резервного копирования.</entry>
     </row>

     <row>
      <entry><structfield>usebypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Пользователь не подчиняется никаким политикам защиты на уровне строк; за подробностями обратитесь к <xref remap="3" linkend="ddl-rowsecurity"/>.</entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Пароль (возможно зашифрованный); NULL, если он не задан. Подробнее хранение зашифрованных паролей описано в <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry/>
      <entry>Срок действия пароля (используется только при аутентификации по паролю)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Сеансовые значения по умолчанию для переменных конфигурации времени выполнения</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats"><primary>pg_stats</primary></indexterm>

  <para>Представление <structname>pg_stats</structname> открывает доступ к информации, хранящейся в каталоге <link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>. Это представление даёт доступ только к тем строкам каталога <structname>pg_statistic</structname>, что соответствуют таблицам, которые пользователь может читать, таким образом это представление можно безопасно разрешить читать всем.</para>

  <para>Кроме того, представление <structname>pg_stats</structname> сконструировано так, чтобы представлять информацию в более понятном формате, чем нижележащий каталог &mdash; ценой того, что его схему приходится расширять всякий раз, когда для <structname>pg_statistic</structname> определяются новые типы слотов.</para>

  <table>
   <title>Столбцы <structname>pg_stats</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Имя схемы, содержащей таблицу</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя таблицы</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>Имя столбца, описываемого этой строкой</entry>
     </row>

     <row>
      <entry><structfield>inherited</structfield></entry>
      <entry><type>bool</type></entry>
      <entry/>
      <entry>Если true, в данных этой строки учитываются значения в дочерних столбцах, а не только в указанной таблице</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry/>
      <entry>Доля записей, в которых этот столбец содержит NULL</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry/>
      <entry>Средний размер элементов в столбце, в байтах</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry/>
      <entry>Число, большее нуля, представляет примерное количество различных значений в столбце. Если это число меньше нуля, его модуль представляет количество различных значений, делённое на количество строк. (Отрицательная форма применяется, когда <command>ANALYZE</command> полагает, что число различных значений, скорее всего, будет расти по мере роста таблицы; положительная, когда в столбце, вероятно, будет фиксированное количество возможных значений.) Например, -1 указывает на столбец с уникальным содержимым, в котором количество различных значений совпадает с количеством строк.</entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry/>
      <entry>Список самых частых значений в столбце. (NULL, если не находятся значения, появляющиеся чаще других.)</entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry/>
      <entry>Список частот самых частых значений, то есть число их вхождений, делённое на общее количество строк. (NULL, вместе с <structfield>most_common_vals</structfield>.)</entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry/>
      <entry>Список значений, разделяющих значения столбца на примерно одинаковые популяции. Значения <structfield>most_common_vals</structfield>, если они присутствуют, не рассматриваются при вычислении этой гистограммы. (Этот столбец содержит NULL, если для типа данных столбца не определён оператор <literal>&lt;</literal>, либо если в <structfield>most_common_vals</structfield> перечисляется вся популяция.)</entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry/>
      <entry>Статистическая корреляция между физическим порядком строк и логическим порядком значений столбца. Допустимые значения лежат в диапазоне -1 .. +1. Когда значение около -1 или +1, сканирование индекса по столбцу будет считаться дешевле, чем когда это значение около нуля, как результат уменьшения случайного доступа к диску. (Этот столбец содержит NULL, если для типа данных столбца не определён оператор <literal>&lt;</literal>.)</entry>
     </row>

     <row>
      <entry><structfield>most_common_elems</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry/>
      <entry>Список элементов, отличных от NULL, наиболее часто присутствующих в значениях столбца. (NULL для скалярных типов.)</entry>
     </row>

     <row>
      <entry><structfield>most_common_elem_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry/>
      <entry>Список частот самых частых элементов, то есть доля строк, содержащих минимум один экземпляр данного значения. За частотами по элементам следуют два или три дополнительных значения: минимум и максимум предшествующих частот по элементам и дополнительно частота элементов NULL. (Принимает значение NULL вместе с <structfield>most_common_elems</structfield>.)</entry>
     </row>

     <row>
      <entry><structfield>elem_count_histogram</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry/>
      <entry>Гистограмма количеств различных и отличных от NULL элементов в значениях этого столбца, за которой следует среднее количество элементов, отличных от NULL. (Принимает значение NULL для скалярных типов.)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Максимальным числом записей в полях-массивах можно управлять на уровне столбцов, используя команду <command>ALTER TABLE SET STATISTICS</command>, или глобально, задав параметр времени выполнения <xref linkend="guc-default-statistics-target"/>.</para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables"><primary>pg_tables</primary></indexterm>

  <para>Представление <structname>pg_tables</structname> даёт доступ к полезной информации обо всех таблицах в базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_tables</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Имя схемы, содержащей таблицу</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя таблицы</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Имя владельца таблицы</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Имя табличного пространства, содержащего таблицу (NULL, если это пространство по умолчанию)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>True, если эта таблица имеет (или недавно имела) индексы</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>True, если для таблицы определены (или были определены) правила</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhastriggers</literal></entry>
      <entry>True, если для таблицы определены (или были определены) триггеры</entry>
     </row>
     <row>
      <entry><structfield>rowsecurity</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relrowsecurity</literal></entry>
      <entry>True, если для таблицы включена защита строк</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-abbrevs">
  <title><structname>pg_timezone_abbrevs</structname></title>

  <indexterm zone="view-pg-timezone-abbrevs"><primary>pg_timezone_abbrevs</primary></indexterm>

  <para>Представление <structname>pg_timezone_abbrevs</structname> содержит список аббревиатур часовых поясов, которые в настоящее время распознаются процедурами ввода даты/времени. Содержимое этого представления меняется при изменении параметра времени выполнения <xref linkend="guc-timezone-abbreviations"/>.</para>

  <table>
   <title>Столбцы <structname>pg_timezone_abbrevs</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Сокращение часового пояса</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Смещение от UTC (положительное — к востоку от Гринвича)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True, если эта аббревиатура задаёт летнее время</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Большинство аббревиатур часовых поясов представляют фиксированные смещения от UTC, но в некоторые поясах смещение менялось в ходе истории (за подробностями обратитесь к <xref remap="3" linkend="datetime-config-files"/>). В таких случаях данное представление отображает текущее значение.</para>

 </sect1>

 <sect1 id="view-pg-timezone-names">
  <title><structname>pg_timezone_names</structname></title>

  <indexterm zone="view-pg-timezone-names"><primary>pg_timezone_names</primary></indexterm>

  <para>В представлении <structname>pg_timezone_names</structname> содержится список имён часовых поясов, распознаваемых командой <command>SET TIMEZONE</command>, вместе с соответствующими аббревиатурами, смещением UTC и статусом летнего времени. (Говоря технически строго, в <productname>&productname;</productname> используется не UTC, так как не учитываются секунды координации.) В отличие от аббревиатур, представленных в <link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>, многие из этих имён подразумевают некоторый набор правил перехода на летнее время. Поэтому сопутствующая информация меняется при пересечении границ перехода на летнее время. Отображаемая информация вычисляется, исходя из текущего значения <function>CURRENT_TIMESTAMP</function>.</para>

  <table>
   <title>Столбцы <structname>pg_timezone_names</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Название часового пояса</entry>
     </row>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Сокращение часового пояса</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Смещение от UTC (положительное — к востоку от Гринвича)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True, если текущие данные отражают летнее время</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user"><primary>pg_user</primary></indexterm>

  <para>Представление <structname>pg_user</structname> открывает доступ к информации о пользователях базы данных. Это просто доступное для всех отображение представления <link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>, в котором очищено поле пароля.</para>

  <table>
   <title>Столбцы <structname>pg_user</structname></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Имя пользователя</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>ID этого пользователя</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Пользователь может создавать базы данных</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Пользователь является суперпользователем</entry>
     </row>

     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Пользователь может инициировать потоковую репликацию, включать и отключать режим резервного копирования.</entry>
     </row>

     <row>
      <entry><structfield>usebypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Пользователь не подчиняется никаким политикам защиты на уровне строк; за подробностями обратитесь к <xref remap="3" linkend="ddl-rowsecurity"/>.</entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Не пароль (всегда выводится как <literal>********</literal>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry>Срок действия пароля (используется только при аутентификации по паролю)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Сеансовые значения по умолчанию для переменных конфигурации времени выполнения</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user-mappings">
  <title><structname>pg_user_mappings</structname></title>

  <indexterm zone="view-pg-user-mappings"><primary>pg_user_mappings</primary></indexterm>

  <para>Представление <structname>pg_user_mappings</structname> открывает доступ к информации о сопоставлениях пользователей. По сути это просто доступное для чтения всеми отображение <link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>, в котором поле параметров показывается, только если у пользователя есть права читать его.</para>

  <table>
   <title>Столбцы <structname>pg_user_mappings</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>umid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>.oid</literal></entry>
      <entry>OID сопоставления пользователей</entry>
     </row>

     <row>
      <entry><structfield>srvid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>OID стороннего сервера, содержащего это сопоставление</entry>
     </row>

     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.srvname</literal></entry>
      <entry>Имя стороннего сервера</entry>
     </row>

     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID сопоставляемой локальной роли, либо 0, если сопоставление задаётся для всех</entry>
     </row>

     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry/>
      <entry>Имя локального пользователя, для которого задано сопоставление</entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry/>
      <entry>Специальные параметры сопоставления пользователей, в виде строк <quote>ключ=значение</quote></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Для защиты информации о паролях, хранящейся в свойствах сопоставления пользователей, столбец <structfield>umoptions</structfield> при чтении будет содержать не NULL, если только выполняется одно из этих условий: <itemizedlist>
    <listitem>
     <para>текущий пользователь является объектом сопоставления и владельцем сервера или имеет право <literal>USAGE</literal> для него</para>
    </listitem>
    <listitem>
     <para>текущий пользователь является владельцем сервера и прочитывается сопоставление для <literal>PUBLIC</literal></para>
    </listitem>
    <listitem>
     <para>текущий пользователь является суперпользователем</para>
    </listitem>
   </itemizedlist></para>

 </sect1>


 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views"><primary>pg_views</primary></indexterm>

  <para>Представление <structname>pg_views</structname> даёт доступ к полезной информации обо всех представлениях в базе данных.</para>

  <table>
   <title>Столбцы <structname>pg_views</structname></title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Имя</entry>
      <entry>Тип</entry>
      <entry>Ссылки</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Имя схемы, содержащей представление</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Имя представления</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Имя владельца представления</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry/>
      <entry>Определение представления (реконструированный запрос <command>SELECT</command>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>
