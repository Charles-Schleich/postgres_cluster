<!-- doc/src/xml/lo.xml -->

<sect1 id="lo" xreflabel="lo">
 <title>lo</title>

 <indexterm zone="lo"><primary>lo</primary></indexterm>

 <para>Модуль <filename>lo</filename> поддерживает управление большими объектами (БО или LO, Large Objects, иногда BLOB, Binary Large OBjects). Он реализует тип данных <type>lo</type> и триггер <function>lo_manage</function>.</para>

 <sect2>
  <title>Обоснование</title>

  <para>Одна из проблема драйвера JDBC (она распространяется и на драйвер ODBC) в том, что спецификация типа предполагает, что ссылки на BLOB хранятся в таблице, и если запись меняется, связанный BLOB удаляется из базы.</para>

  <para>Но с <productname>&productname;</productname> этого не происходит. Большие объекты обрабатываются как самостоятельные объекты; запись в таблице может ссылаться на большой объект по OID, но при этом на один и тот же объект могут ссылаться несколько записей таблицы, так что система не удаляет большой объект, только потому что вы меняете или удаляете такую запись.</para>

  <para>Это не проблема для приложений, ориентированных на <productname>&productname;</productname>, но стандартный код, использующий JDBC или ODBC, не будет удалять эти объекты, в результате чего они окажутся потерянными &mdash; объектами, которые никак не задействованы, а просто занимают место на диске.</para>

  <para>Модуль <filename>lo</filename> позволяет решить эту проблему, добавляя триггер к таблицам, которые содержат столбцы, ссылающиеся на БО. Этот триггер по сути просто вызывает <function>lo_unlink</function>, когда вы удаляете или изменяете значение, ссылающееся на большой объект. Данный триггер предполагает, что на любой большой объект, на который ссылается контролируемый им столбец, указывает только одна ссылка!</para>

  <para>Этот модуль также предоставляет тип данных <type>lo</type>, который просто является доменом на базе <type>oid</type>. Он может быть полезен для выделения столбцов, содержащих ссылки на большие объекты, среди столбцов, содержащих другие OID. Для использования триггера применять тип <type>lo</type> необязательно, но этот тип может быть полезен для отслеживания столбцов в вашей базе, представляющих большие объекты, с которыми работает триггер. Кроме того, поступали сообщения, что драйвер ODBC не работает корректно, если для столбцов BLOB используется не тип <type>lo</type>.</para>
 </sect2>

 <sect2>
  <title>Как его использовать</title>

  <para>Пример его использования:</para>

<programlisting>CREATE TABLE image (title TEXT, raster lo);

CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON image
    FOR EACH ROW EXECUTE PROCEDURE lo_manage(raster);</programlisting>

  <para>Для каждого столбца, который будет содержать уникальные ссылки на большие объекты, создайте триггер <literal>BEFORE UPDATE OR DELETE</literal> и передайте имя столбца в качестве единственного аргумента триггера. Вы также можете сделать, чтобы триггер срабатывал только при изменениях в столбце, указав <literal>BEFORE UPDATE OF</literal> <replaceable class="parameter">имя_столбца</replaceable>. Если вам нужно иметь в одной таблице несколько столбцов <type>lo</type>, создайте отдельный триггер для каждого (при этом обязательно нужно дать всем триггерам в одной таблице разные имена).</para>
 </sect2>

 <sect2>
  <title>Ограничения</title>

  <itemizedlist>
   <listitem>
    <para>При удалении таблицы, однако, всё равно будут потеряны относящиеся к ней объекты, так как триггер не будет выполняться. Этого можно избежать, выполнив перед <command>DROP TABLE</command> команду <command>DELETE FROM <replaceable>таблица</replaceable></command>.</para>

    <para>То же касается и команды <command>TRUNCATE</command>.</para>

    <para>Если у вас уже есть, или вы подозреваете, что есть потерянные большие объекты, обратите внимание на модуль <xref linkend="vacuumlo"/>, который может помочь вычистить их. Имеет смысл периодически запускать <application>vacuumlo</application> в качестве меры, дополняющей действие триггера <function>lo_manage</function>.</para>
   </listitem>

   <listitem>
    <para>Некоторые клиентские программы могут создавать собственные таблицы, но не создавать для них соответствующие триггеры. Кроме того, и пользователи могут не создавать такие триггеры (забывая о них, либо не зная, как это сделать).</para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Автор</title>

  <para>Питер Маунт <email>peter@retep.org.uk</email></para>
 </sect2>

</sect1>
