<!-- doc/src/xml/auto-explain.xml -->

<sect1 id="auto-explain" xreflabel="auto_explain">
 <title>auto_explain</title>

 <indexterm zone="auto-explain"><primary>auto_explain</primary></indexterm>

 <para>Модуль <filename>auto_explain</filename> предоставляет возможность автоматического протоколирования планов выполнения медленных операторов, что позволяет обойтись без выполнения <xref linkend="sql-explain"/> вручную. Это особенно полезно для выявления неоптимизированных запросов в больших приложениях.</para>

 <para>Этот модуль не предоставляет функций, доступных из SQL. Чтобы использовать его, просто загрузите его в процесс сервера. Это можно сделать в отдельном сеансе: <programlisting>LOAD 'auto_explain';</programlisting> (Для этого нужно быть суперпользователем.) Более типична конфигурация, когда он загружается в некоторые или все сеансы в результате включения <literal>auto_explain</literal> в переменную <xref linkend="guc-session-preload-libraries"/> или в <xref linkend="guc-shared-preload-libraries"/> в файле <filename>postgresql.conf</filename>. Загрузив этот модуль, вы можете отслеживать исключительно медленные запросы, вне зависимости от того, когда они происходят. Конечно, это имеет свою цену.</para>

 <sect2>
  <title>Параметры конфигурации</title>

 <para>Есть несколько параметров конфигурации, которые управляют поведением <filename>auto_explain</filename>. Заметьте, что поведение по умолчанию сводится к бездействию, так что необходимо установить как минимум переменную <varname>auto_explain.log_min_duration</varname>, если вы хотите получить какие-либо результаты.</para>

  <variablelist>
   <varlistentry>
    <term><varname>auto_explain.log_min_duration</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_min_duration</varname></primary></indexterm></term>
    <listitem>
     <para>Переменная <varname>auto_explain.log_min_duration</varname> задаёт время выполнения оператора, в миллисекундах, при превышении которого план оператора будет протоколироваться. Если это значение равно 0, протоколироваться будут планы всех операторов. При значении -1 (по умолчанию) протоколирование планов полностью отключается. Например, если вы установите значение <literal>250ms</literal>, протоколироваться будут все запросы, выполняющиеся 250 мс и дольше. Изменить этот параметр могут только суперпользователи.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.log_analyze</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_analyze</varname></primary></indexterm></term>
    <listitem>
     <para>При включении параметра <varname>auto_explain.log_analyze</varname> в протокол будет записываться вывод команды <command>EXPLAIN ANALYZE</command>, а не простой <command>EXPLAIN</command>. По умолчанию этот параметр отключён. Изменить его могут только суперпользователи.</para>
     <note>
      <para>Когда этот параметр включён, замер времени на уровне узлов плана производится для всех операторов, даже если они выполняются недостаточно долго для протоколирования. Это может оказать крайне негативное влияние на производительность. Отключение <varname>auto_explain.log_timing</varname> исключает это влияние, но при этом собирается меньше информации.</para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.log_buffers</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_buffers</varname></primary></indexterm></term>
    <listitem>
     <para>Параметр <varname>auto_explain.log_buffers</varname> определяет, будет ли при протоколировании плана выполнения выводиться статистика об использовании буферов; он равносилен указанию <literal>BUFFERS</literal> команды <command>EXPLAIN</command>. Этот параметр действует, только если включён параметр <varname>auto_explain.log_analyze</varname>. По умолчанию этот параметр отключён. Изменить его могут только суперпользователи.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.log_timing</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_timing</varname></primary></indexterm></term>
    <listitem>
     <para>Параметр <varname>auto_explain.log_timing</varname> определяет, будет ли при протоколировании плана выполнения выводиться длительность на уровне узлов: он равнозначен указанию <literal>TIMING</literal> команды <command>EXPLAIN</command>. Издержки от постоянного чтения системных часов могут значительно замедлить запросы в некоторых системах, так что может иметь смысл отключать этот параметр, когда нужно знать только знать количество строк, но не точную длительность каждого узла. Этот параметр действует, только если включён <varname>auto_explain.log_analyze</varname>. По умолчанию этот параметр отключён. Изменить его могут только суперпользователи.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.log_triggers</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_triggers</varname></primary></indexterm></term>
    <listitem>
     <para>При включении параметра <varname>auto_explain.log_triggers</varname> в протокол будет записываться статистика выполнения триггеров. Этот параметр действует, только если включён параметр <varname>auto_explain.log_analyze</varname>. По умолчанию этот параметр отключён. Изменить его могут только суперпользователи.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.log_verbose</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_verbose</varname> configuration parameter</primary></indexterm></term>
    <listitem>
     <para>Параметр <varname>auto_explain.log_verbose</varname> определяет, будут ли при протоколировании плана выполнения выводиться подробные сведения; он равнозначен указанию <literal>VERBOSE</literal> команды <command>EXPLAIN</command>. По умолчанию этот параметр отключён. Изменить его могут только суперпользователи.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.log_format</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_format</varname></primary></indexterm></term>
    <listitem>
     <para>Параметр <varname>auto_explain.log_format</varname> выбирает формат вывода для <command>EXPLAIN</command>. Он может принимать значение <literal>text</literal>, <literal>xml</literal>, <literal>json</literal> и <literal>yaml</literal>. Значение по умолчанию — text. Изменить этот параметр могут только суперпользователи.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.log_nested_statements</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.log_nested_statements</varname></primary></indexterm></term>
    <listitem>
     <para>При включении параметра <varname>auto_explain.log_nested_statements</varname> протоколированию могут подлежать и вложенные операторы (операторы, выполняемые внутри функции). Когда он отключён, протоколируются планы запросов только верхнего уровня. Изменить этот параметр могут только суперпользователи.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><varname>auto_explain.sample_rate</varname> (<type>real</type>) <indexterm><primary>параметр конфигурации <varname>auto_explain.sample_rate</varname></primary></indexterm></term>
    <listitem>
     <para>Параметр <varname>auto_explain.sample_rate</varname> задаёт для auto_explain процент операторов, которые будут отслеживаться в каждом сеансе. Значение по умолчанию — 1, то есть отслеживаются все запросы. Вложенные операторы отслеживаются совместно — либо все, либо никакой из них. Изменить этот параметр могут только суперпользователи.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>В обычной ситуации эти параметры устанавливаются в <filename>postgresql.conf</filename>, хотя суперпользователи могут изменить их &laquo;на лету&raquo; в рамках своих сеансов. Типичное их использование может выглядеть так:</para>

<programlisting># postgresql.conf
session_preload_libraries = 'auto_explain'

auto_explain.log_min_duration = '3s'</programlisting>
 </sect2>

 <sect2>
  <title>Пример</title>

<programlisting>postgres=# LOAD 'auto_explain';
postgres=# SET auto_explain.log_min_duration = 0;
postgres=# SET auto_explain.log_analyze = true;
postgres=# SELECT count(*)
           FROM pg_class, pg_index
           WHERE oid = indrelid AND indisunique;</programlisting>

  <para>В результате этих команд может быть получен такой вывод:</para>

<screen><![CDATA[
LOG:  duration: 3.651 ms  plan:
  Query Text: SELECT count(*)
              FROM pg_class, pg_index
              WHERE oid = indrelid AND indisunique;
  Aggregate  (cost=16.79..16.80 rows=1 width=0) (actual time=3.626..3.627 rows=1 loops=1)
    ->  Hash Join  (cost=4.17..16.55 rows=92 width=0) (actual time=3.349..3.594 rows=92 loops=1)
          Hash Cond: (pg_class.oid = pg_index.indrelid)
          ->  Seq Scan on pg_class  (cost=0.00..9.55 rows=255 width=4) (actual time=0.016..0.140 rows=255 loops=1)
          ->  Hash  (cost=3.02..3.02 rows=92 width=4) (actual time=3.238..3.238 rows=92 loops=1)
                Buckets: 1024  Batches: 1  Memory Usage: 4kB
                ->  Seq Scan on pg_index  (cost=0.00..3.02 rows=92 width=4) (actual time=0.008..3.187 rows=92 loops=1)
                      Filter: indisunique
]]></screen>
 </sect2>

 <sect2>
  <title>Автор</title>

  <para>Такахиро Итагаки <email>itagaki.takahiro@oss.ntt.co.jp</email></para>
 </sect2>

</sect1>
