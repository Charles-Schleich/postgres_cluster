<!-- doc/src/xml/typeconv.xml -->

<chapter id="typeconv">
<title>Преобразование типов</title>

<indexterm zone="typeconv"><primary>тип данных</primary> <secondary>преобразование</secondary></indexterm>

<para><acronym>SQL</acronym>-операторы, намеренно или нет, требуют совмещать данные разных типов в одном выражении. Для вычисления подобных выражений со смешанными типами <productname>&productname;</productname> предоставляет широкий набор возможностей.</para>

<para>Очень часто пользователю не нужно понимать все тонкости механизма преобразования. Однако следует учитывать, что неявные преобразования, производимые <productname>&productname;</productname>, могут влиять на результат запроса. Поэтому при необходимости нужные результаты можно получить, применив <emphasis>явное</emphasis> преобразование типов.</para>

<para>В этой главе описываются общие механизмы преобразования типов и соглашения, принятые в <productname>&productname;</productname>. За дополнительной информацией о конкретных типах данных и разрешённых для них функциях и операторах обратитесь к соответствующим разделам в <xref remap="6" linkend="datatype"/> и <xref remap="6" linkend="functions"/>.</para>

<sect1 id="typeconv-overview">
<title>Обзор</title>

<para><acronym>SQL</acronym> &mdash; язык со строгой типизацией. То есть каждый элемент данных в нём имеет некоторый тип, определяющий его поведение и допустимое использование. <productname>&productname;</productname> наделён расширяемой системой типов, более универсальной и гибкой по сравнению с другими реализациями <acronym>SQL</acronym>. При этом преобразования типов в <productname>&productname;</productname> в основном подчиняются определённым общим правилам, для их понимания не нужен <foreignphrase>эвристический</foreignphrase> анализ. Благодаря этому в выражениях со смешанными типами можно использовать даже типы, определённые пользователями.</para>

<para>Анализатор выражений <productname>&productname;</productname> разделяет их лексические элементы на пять основных категорий: целые числа, другие числовые значения, текстовые строки, идентификаторы и ключевые слова. Константы большинства не числовых типов сначала классифицируются как строки. В определении языка <acronym>SQL</acronym> допускается указывать имена типов в строках и это можно использовать в <productname>&productname;</productname>, чтобы направить анализатор по верному пути. Например, запрос: <screen>
SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)
</screen> содержит две строковых константы, типа <type>text</type> и типа <type>point</type>. Если для такой константы не указан тип, для неё первоначально предполагается тип <type>unknown</type>, который затем может быть уточнён, как описано ниже.</para>

<para>В <acronym>SQL</acronym> есть четыре фундаментальных фактора, определяющих правила преобразования типов для анализатора выражений <productname>&productname;</productname>: <variablelist>
<varlistentry>
<term>Вызовы функций</term>
<listitem>
<para>Система типов <productname>&productname;</productname> во многом построена как дополнение к богатым возможностям функций. Функции могут иметь один или несколько аргументов, и при этом <productname>&productname;</productname> разрешает перегружать имена функций, так что имя функции само по себе не идентифицирует вызываемую функцию; анализатор выбирает правильную функцию в зависимости от типов переданных аргументов.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Операторы</term>
<listitem>
<para><productname>&productname;</productname> позволяет использовать в выражениях префиксные и постфиксные операторы с одним аргументом, а также операторы с двумя аргументами. Как и функции, операторы можно перегружать, так что и с ними существует проблема выбора правильного оператора.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Сохранение значений</term>
<listitem>
<para><acronym>SQL</acronym>-операторы <command>INSERT</command> и <command>UPDATE</command> помещают результаты выражений в таблицы. При этом получаемые значения должны соответствовать типам целевых столбцов или, возможно, приводиться к ним.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>UNION</literal>, <literal>CASE</literal> и связанные конструкции</term>
<listitem>
<para>Так как все результаты запроса объединяющего оператора <command>SELECT</command> должны оказаться в одном наборе столбцов, результаты каждого подзапроса <command>SELECT</command> должны приводиться к одному набору типов. Подобным образом, результирующие выражения конструкции <literal>CASE</literal> должны приводиться к общему типу, так как выражение <literal>CASE</literal> в целом должно иметь определённый выходной тип. То же справедливо в отношении конструкций <literal>ARRAY</literal> и функций <function>GREATEST</function> и <function>LEAST</function>.</para>
</listitem>
</varlistentry>
</variablelist></para>

<para>Информация о существующих преобразованиях или <firstterm>приведениях</firstterm> типов, для каких типов они определены и как их выполнять, хранится в системных каталогах. Пользователь также может добавить дополнительные преобразования с помощью команды <xref linkend="sql-createcast"/>. (Обычно это делается, когда определяются новые типы данных. Набор приведений для встроенных типов достаточно хорошо проработан, так что его лучше не менять.)</para>

<indexterm><primary>тип данных</primary> <secondary>категория</secondary></indexterm>

<para>Дополнительная логика анализа помогает выбрать оптимальное приведение в группах типов, допускающих неявные преобразования. Для этого типы данных разделяются на несколько базовых <firstterm>категорий</firstterm>, которые включают: <type>boolean</type>, <type>numeric</type>, <type>string</type>, <type>bitstring</type>, <type>datetime</type>, <type>timespan</type>, <type>geometric</type>, <type>network</type> и пользовательские типы. (Полный список категорий приведён в <xref remap="6" linkend="catalog-typcategory-table"/>; хотя его тоже можно расширить, определив свои категории.) В каждой категории могут быть выбраны один или несколько <firstterm>предпочитаемых типов</firstterm>, которые будут считаться наиболее подходящими при рассмотрении нескольких вариантов. Аккуратно выбирая предпочитаемые типы и допустимые неявные преобразования, можно добиться того, что выражения с неоднозначностями (в которых возможны разные решения задачи преобразования) будут разрешаться наилучшим образом.</para>

<para>Все правила преобразования типов разработаны с учётом следующих принципов: <itemizedlist>
<listitem>
<para>Результат неявных преобразованиях всегда должен быть предсказуемым и понятным.</para>
</listitem>

<listitem>
<para>Если в неявном преобразовании нет нужды, анализатор и исполнитель запроса не должны тратить лишнее время на это. То есть, если запрос хорошо сформулирован и типы значений совпадают, он должен выполняться без дополнительной обработки в анализаторе и без лишних вызовов неявных преобразований.</para>
</listitem>

<listitem>
<para>Кроме того, если запрос изначально требовал неявного преобразования для функции, а пользователь определил новую функцию с точно совпадающими типами аргументов, анализатор должен переключиться на новую функцию и больше не выполнять преобразование для вызова старой.</para>
</listitem>
</itemizedlist></para>

</sect1>

<sect1 id="typeconv-oper">
<title>Операторы</title>

<indexterm zone="typeconv-oper"><primary>оператор</primary> <secondary>разрешение типов при вызове</secondary></indexterm>

  <para>При выборе конкретного оператора, задействованного в выражении, <productname>PostgreSQL</productname> следует описанному ниже алгоритму. Заметьте, что на этот выбор могут неявно влиять приоритеты остальных операторов в данном выражении, так как они определяют, какие подвыражения будут аргументами операторов. Подробнее об этом рассказывается в <xref remap="6" linkend="sql-precedence"/>.</para>

<procedure>
<title>Выбор оператора по типу</title>

<step id="op-resol-select" performance="required">
<para>Выбрать операторы для рассмотрения из системного каталога <classname>pg_operator</classname>. Если имя оператора не дополнено именем схемы (обычно это так), будут рассматриваться все операторы с подходящим именем и числом аргументов, видимые в текущем пути поиска (см. <xref remap="4" linkend="ddl-schemas-path"/>). Если имя оператора определено полностью, в рассмотрение принимаются только операторы из указанной схемы.</para>

<substeps>
<step performance="optional">
<para>Если в пути поиска оказывается несколько операторов с одинаковыми типами аргументов, учитываются только те из них, которые находятся в пути раньше. Операторы с разными типами аргументов рассматриваются на равных правах вне зависимости от их положения в пути поиска.</para>
</step>
</substeps>
</step>

<step id="op-resol-exact-match" performance="required">
<para>Проверить, нет ли среди них оператора с точно совпадающими типами аргументов. Если такой оператор есть (он может быть только одним в отобранном ранее наборе), использовать его.</para>

<substeps>
<step id="op-resol-exact-unknown" performance="optional">
<para>Если один аргумент при вызове бинарного оператора имеет тип <type>unknown</type>, для данной проверки предполагается, что он имеет тот же тип, что и второй его аргумент. При вызове бинарного оператора с двумя аргументами <type>unknown</type> или унарного с одним <type>unknown</type>, оператор не будет выбран на этом шаге.</para>
</step>
<step id="op-resol-exact-domain" performance="optional">
<para>Если один аргумент при вызове бинарного оператора имеет тип <type>unknown</type>, а другой &mdash; домен, проверить, есть ли оператор, принимающий базовый тип домена с обеих сторон; если таковой находится, использовать его.</para>
</step>
</substeps>
</step>

<step id="op-resol-best-match" performance="required">
<para>Найти самый подходящий.</para>
<substeps>
<step performance="required">
<para>Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразованы (неявным образом) так, чтобы они совпали. В данном случае считается, что константы типа <type>unknown</type> можно преобразовать во что угодно. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step performance="required">
<para>Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена. Благодаря этому при поиске неоднозначно заданного оператора домены будут подобны свои базовым типам.</para>
</step>
<step performance="required">
<para>Просмотреть все кандидаты и оставить только те, для которых точно совпадают как можно больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step performance="required">
<para>Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые типы (из категории типов входных значений) в наибольшем числе позиций, где требуется преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитаемые типы. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step performance="required">
<para>Если какие-либо значения имеют тип <type>unknown</type>, проверить категории типов, принимаемых в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать категорию <type>string</type>, если какой-либо кандидат принимает эту категорию. (Эта склонность к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать её; в противном случае констатировать неудачу &mdash; сделать правильный выбор без дополнительных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы выбранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step id="op-resol-last-unknown" performance="required">
<para>Если в списке аргументов есть аргументы и типа <type>unknown</type>, и известного типа, и этот известный тип один для всех аргументов, предположить, что аргументы типа <type>unknown</type> также имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргумента <type>unknown</type>. Если остаётся только один кандидат, использовать его, в противном случае констатировать неудачу.</para>
</step>
</substeps>
</step>
</procedure>

<para>Ниже это проиллюстрировано на примерах.</para>

<example>
<title>Разрешение оператора факториала</title>

<para>В стандартном каталоге определён только один оператор факториала (постфиксный <literal>!</literal>) и он принимает аргумент типа <type>bigint</type>. При просмотре следующего выражения его аргументу изначально назначается тип <type>integer</type>: <screen>
SELECT 40 ! AS "40 factorial";

                   40 factorial
--------------------------------------------------
 815915283247897734345611269596115894272000000000
(1 row)
</screen> Анализатор выполняет преобразование типа для этого операнда и запрос становится равносильным: <screen>
SELECT CAST(40 AS bigint) ! AS "40 factorial";
</screen></para>
</example>

<example>
<title>Разрешение оператора конкатенации строк</title>

<para>Синтаксис текстовых строк используется как для записи строковых типов, так и для сложных типов расширений. Если тип не указан явно, такие строки сопоставляются по тому же алгоритму с наиболее подходящими операторами.</para>

<para>Пример с одним неопределённым аргументом: <screen>
SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
------------------
 abcdef
(1 row)
</screen></para>

<para>В этом случае анализатор смотрит, есть ли оператор, у которого оба аргумента имеют тип <type>text</type>. Такой оператор находится, поэтому предполагается, что второй аргумент следует воспринимать как аргумент типа <type>text</type>.</para>

<para>Конкатенация двух значений неопределённых типов: <screen>
SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-------------
 abcdef
(1 row)
</screen></para>

<para>В данном случае нет подсказки для выбора типа, так как в данном запросе никакие типы не указаны. Поэтому анализатор просматривает все возможные операторы и находит в них кандидаты, принимающие аргументы категорий string и bit-string. Так как категория string является предпочтительной, выбирается она, а затем для разрешения типа не типизированной константы выбирается предпочтительный тип этой категории, <type>text</type>.</para>
</example>

<example>
<title>Разрешение оператора абсолютного значения и отрицания</title>

<para>В каталоге операторов <productname>&productname;</productname> для префиксного оператора <literal>@</literal> есть несколько записей, описывающих операции получения абсолютного значения для различных числовых типов данных. Одна из записей соответствует типу <type>float8</type>, предпочтительного в категории числовых типов. Таким образом, столкнувшись со значением типа <type>unknown</type>, <productname>&productname;</productname> выберет эту запись: <screen>
SELECT @ '-4.5' AS "abs";
 abs
-----
 4.5
(1 row)
</screen> Здесь система неявно привела константу неизвестного типа к типу <type>float8</type>, прежде чем применять выбранный оператор. Можно убедиться в том, что выбран именно тип <type>float8</type>, а не какой-то другой: <screen>
SELECT @ '-4.5e500' AS "abs";

ОШИБКА:  "-4.5e500" вне диапазона для типа double precision
</screen></para>

<para>С другой стороны, префиксный оператор <literal>~</literal> (побитовое отрицание) определён только для целочисленных типов данных, но не для <type>float8</type>. Поэтому, если попытаться выполнить похожий запрос с <literal>~</literal>, мы получаем: <screen>
SELECT ~ '20' AS "negation";

ОШИБКА: оператор не уникален: ~ "unknown"
ПОДСКАЗКА: Не удалось выбрать лучшую кандидатуру оператора. Возможно, вам следует
добавить явные преобразования типов.
</screen> Это происходит оттого, что система не может решить, какой оператор предпочесть из нескольких возможных вариантов <literal>~</literal>. Мы можем облегчить её задачу, добавив явное преобразование: <screen>
SELECT ~ CAST('20' AS int8) AS "negation";

 negation
----------
      -21
(1 row)
</screen></para>
</example>

<example>
<title>Разрешение оператора включения в массив</title>

<para>Ещё один пример разрешения оператора с одним аргументом известного типа и другим неизвестного: <screen>
SELECT array[1,2] &lt;@ '{1,2,3}' as "is subset";

 is subset
-----------
 t
(1 row)
</screen> В каталоге операторов <productname>&productname;</productname> есть несколько записей для инфиксного оператора <literal>&lt;@</literal>, но только два из них могут принять целочисленный массива слева: оператор включения массива (<type>anyarray</type><literal>&lt;@</literal><type>anyarray</type>) и оператор включения диапазона (<type>anyelement</type><literal>&lt;@</literal><type>anyrange</type>). Так как ни один из этих полиморфных псевдотипов (см. <xref remap="4" linkend="datatype-pseudo"/>) не считается предпочтительным, анализатор не может избавиться от неоднозначности на данном этапе. Однако, в <xref remap="6" linkend="op-resol-last-unknown"/> говорится, что константа неизвестного типа должна рассматриваться как значение типа другого аргумента, в данном случае это целочисленный массив. После этого подходящим считается только один из двух операторов, так что выбирается оператор с целочисленными массивами. (Если бы был выбран оператор включения диапазона, мы получили бы ошибку, так как значение в строке не соответствует формату значений диапазона.)</para>
</example>

<example>
<title>Нестандартный оператор с доменом</title>

<para>Иногда пользователи пытаются ввести операторы, применимые только к определённому домену. Это возможно, но вовсе не так полезно, как может показаться, ведь правила разрешения операторов применяются к базовому типу домена. Взгляните на этот пример: <screen>
CREATE DOMAIN mytext AS text CHECK(...);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
CREATE TABLE mytable (val mytext);

SELECT * FROM mytable WHERE val = 'foo';
</screen> В этом запросе не будет использоваться нововведённый оператор. При разборе запроса сначала будет проверено, есть ли оператор <type>mytext</type> <literal>=</literal> <type>mytext</type> (см. <xref remap="4" linkend="op-resol-exact-unknown"/>), но это не так; затем будет рассмотрен базовый тип домена (<type>text</type>) и проверено наличие оператора <type>text</type> <literal>=</literal> <type>text</type> (см. <xref remap="4" linkend="op-resol-exact-domain"/>), и таковой действительно есть; в итоге строковое значение типа <type>unknown</type> будет воспринято как <type>text</type> и будет применён оператор <type>text</type> <literal>=</literal> <type>text</type>. Единственный вариант задействовать нововведённый оператор &mdash; добавить явное приведение: <screen>
SELECT * FROM mytable WHERE val = text 'foo';
</screen> так, чтобы оператор <type>mytext</type> <literal>=</literal> <type>text</type> был найден сразу, согласно правилу точного совпадения. Если дело доходит до правил наибольшего соответствия, они активно дискредитируют операторы доменных типов. Если бы они этого не делали, с таким оператором возникало бы слишком много ошибок разрешения операторов, потому что правила приведения всегда считают домен приводимым к базовому типу и наоборот, так что доменный оператор применялся бы во всех случаях, где применяется одноимённый оператор с базовым типом.</para>
</example>

</sect1>

<sect1 id="typeconv-func">
<title>Функции</title>

<indexterm zone="typeconv-func"><primary>функции</primary> <secondary>разрешение типов при вызове</secondary></indexterm>

  <para>При выборе конкретной функции, задействованной в выражении, <productname>PostgreSQL</productname> следует описанному ниже алгоритму.</para>

<procedure>
<title>Разрешение функции по типу</title>

<step performance="required">
<para>Выбрать функции для рассмотрения из системного каталога <classname>pg_proc</classname>. Если имя функции не дополнено именем схемы, будут рассматриваться все функции с подходящим именем и числом аргументов, видимые в текущем пути поиска (см. <xref remap="4" linkend="ddl-schemas-path"/>). Если имя функции определено полностью, в рассмотрение принимаются только функции из указанной схемы.</para>

<substeps>
<step performance="optional">
<para>Если в пути поиска оказывается несколько функций с одинаковыми типами аргументов, учитываются только те из них, которые находятся в пути раньше. Функции с разными типами аргументов рассматриваются на равных правах вне зависимости от их положения в пути поиска.</para>
</step>
<step performance="optional">
<para>Если в числе параметров функции есть массив <literal>VARIADIC</literal> и при вызове не указывается ключевое слово <literal>VARIADIC</literal>, функция обрабатывается, как если бы этот параметр был заменён одним или несколькими параметрами типа элементов массива, по числу аргументов при вызове. После такого расширения по фактическим типам аргументов она может совпасть с некоторой функцией с постоянным числом аргументов. В этом случае используется функция, которая находится в пути раньше, а если они оказываются в одной схеме, предпочитается вариант с постоянными аргументами.</para>
</step>
<step performance="optional">
<para>Функции, для которых определены значения параметров по умолчанию, считаются совпадающими с вызовом, в котором опущено ноль или более параметров в соответствующих позициях. Если для вызова подходят несколько функций, используется та, что обнаруживается в пути поиска раньше. Если в одной схеме оказываются несколько функций с одинаковыми типами в позициях обязательных параметров (что возможно, если в них определены разные наборы пропускаемых параметров), система не сможет выбрать оптимальную, и выдаст ошибку <quote>неоднозначный вызов функции</quote>, если лучшее соответствие для вызова не будет найдено.</para>
</step>
</substeps>
</step>

<step performance="required">
<para>Проверить, нет ли среди них функций с точно совпадающими типами аргументов. Если такая функция есть (она может быть только одной в отобранном ранее наборе), использовать её. (В случаях с типами <type>unknown</type> функция не будет выбрана на этом шаге.)</para>
</step>

<step performance="required">
<para>Если точное совпадение не найдено, проверить, не похож ли вызов функции на особую форму преобразования типов. Это имеет место, когда при вызове функции передаётся всего один аргумент и имя функции совпадает с именем (внутренним) некоторого типа данных. Более того, аргументом функции должна быть либо строка неопределённого типа, либо значение типа, двоично-совместимого с указанным или приводимого к нему с помощью функций ввода/вывода типа (то есть, преобразований в стандартный строковый тип и обратно). Если эти условия выполняются, вызов функции воспринимается как особая форма конструкции <literal>CAST</literal>. <footnote>
   <para>Этот шаг нужен для поддержки приведений типов в стиле вызова функции, когда на самом деле соответствующей функции приведения нет. Если такая функция приведения есть, она обычно называется именем выходного типа и необходимости в особом подходе нет. За дополнительными комментариями обратитесь к <xref remap="3" linkend="sql-createcast"/>.</para>
  </footnote></para>
</step>
<step performance="required">
<para>Найти самый подходящий.</para>
<substeps>
<step performance="required">
<para>Отбросить кандидаты, для которых входные типы не совпадают и не могут быть преобразованы (неявным образом) так, чтобы они совпали. В данном случае считается, что константы типа <type>unknown</type> можно преобразовать во что угодно. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step performance="required">
<para>Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена. Благодаря этому при поиске неоднозначно заданной функции домены будут подобны свои базовым типам.</para>
</step>
<step performance="required">
<para>Просмотреть все кандидаты и оставить только те, для которых точно совпадают как можно больше типов аргументов. Оставить все кандидаты, если точных совпадений нет. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step performance="required">
<para>Просмотреть все кандидаты и оставить только те, которые принимают предпочитаемые типы (из категории типов входных значений) в наибольшем числе позиций, где требуется преобразование типов. Оставить все кандидаты, если ни один не принимает предпочитаемые типы. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step performance="required">
<para>Если какие-либо значения имеют тип <type>unknown</type>, проверить категории типов, принимаемых в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать категорию <type>string</type>, если какой-либо кандидат принимает эту категорию. (Эта склонность к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать её; в противном случае констатировать неудачу &mdash; сделать правильный выбор без дополнительных подсказок нельзя. Затем отбросить кандидаты, которые не принимают типы выбранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из этой категории, отбросить кандидаты, принимающие другие, не предпочитаемые типы для данного аргумента. Оставить все кандидаты, если эти проверки не прошёл ни один. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</para>
</step>
<step performance="required">
<para>Если в списке аргументов есть аргументы и типа <type>unknown</type>, и известного типа, и этот известный тип один для всех аргументов, предположить, что аргументы типа <type>unknown</type> также имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргумента <type>unknown</type>. Если остаётся только один кандидат, использовать его, в противном случае констатировать неудачу.</para>
</step>
</substeps>
</step>
</procedure>

<para>Заметьте, что для функций действуют те же правила <quote>оптимального соответствия</quote>, что и для операторов. Они проиллюстрированы следующими примерами.</para>

<example>
<title>Разрешение функции округления по типам аргументов</title>

<para>В <productname>PostgreSQL</productname> есть только одна функция <function>round</function>, принимающая два аргумента: первый типа <type>numeric</type>, а второй &mdash; <type>integer</type>. Поэтому в следующем запросе первый аргумент <type>integer</type> автоматически приводится к типу <type>numeric</type>: <screen>
SELECT round(4, 4);

 round
--------
 4.0000
(1 row)
</screen> Таким образом, анализатор преобразует этот запрос в: <screen>
SELECT round(CAST (4 AS numeric), 4);
</screen></para>

<para>Та как числовые константы с десятичными точками изначально относятся к типу <type>numeric</type>, для следующего запроса преобразование типов не потребуется, так что он немного эффективнее: <screen>
SELECT round(4.0, 4);
</screen></para>
</example>

<example>
<title>Разрешение функции извлечения подстроки</title>

<para>В <productname>PostgreSQL</productname> есть несколько вариантов функции <function>substr</function>, и один из них принимает аргументы типов <type>text</type> и <type>integer</type>. Если эта функция вызывается со строковой константой неопределённого типа, система выбирает функцию, принимающую аргумент предпочитаемой категории <literal>string</literal> (а конкретнее, типа <type>text</type>). <screen>
SELECT substr('1234', 3);

 substr
--------
     34
(1 row)
</screen></para>

<para>Если текстовая строка имеет тип <type>varchar</type>, например когда данные поступают из таблицы, анализатор попытается привести её к типу <type>text</type>: <screen>
SELECT substr (varchar '1234', 3);

 substr
--------
     34
(1 row)
</screen> Этот запрос анализатор фактически преобразует в: <screen>
SELECT substr(CAST (varchar '1234' AS text), 3);
</screen></para>
<para>
<note>
<para>Анализатор узнаёт из каталога <structname>pg_cast</structname>, что типы <type>text</type> и <type>varchar</type> двоично-совместимы, что означает, что один тип можно передать функции, принимающей другой, не выполняя физического преобразования. Таким образом, в данном случае операция преобразования на самом не добавляется.</para>
</note>
</para>

<para>И если функция вызывается с аргументом типа <type>integer</type>, анализатор попытается преобразовать его в тип <type>text</type>: <screen>
SELECT substr(1234, 3);
ОШИБКА: функция substr(integer, integer) не существует
ПОДСКАЗКА: Функция с данными именем и типами аргументов не найдена. Возможно, вам
следует добавить явные преобразования типов.
</screen> Этот вариант не работает, так как <type>integer</type> нельзя неявно преобразовать в <type>text</type>. Однако с явным преобразованием запрос выполняется: <screen>
SELECT substr(CAST (1234 AS text), 3);

 substr
--------
     34
(1 row)
</screen></para>
</example>

</sect1>

<sect1 id="typeconv-query">
<title>Хранимое значение</title>

  <para>Значения, вставляемые в таблицу, преобразуется в тип данных целевого столбца по следующему алгоритму.</para>

<procedure>
<title>Преобразование по типу хранения</title>

<step performance="required">
<para>Проверить точное совпадение с целевым типом.</para>
</step>

<step performance="required">
<para>Если типы не совпадают, попытаться привести тип к целевому. Это возможно, если в каталоге <structname>pg_cast</structname> (см. <xref remap="4" linkend="sql-createcast"/>) зарегистрировано <firstterm>приведение присваивания</firstterm> между двумя типами. Если же результат выражения &mdash; строка неизвестного типа, содержимое этой строки будет подано на вход процедуре ввода целевого типа.</para>
</step>

<step performance="required">
<para>Проверить, не требуется ли приведение размера для целевого типа. Приведение размера &mdash; это преобразование типа к такому же. Если это приведение описано в каталоге <structname>pg_cast</structname>, применить к его к результату выражения, прежде чем сохранить в целевом столбце. Функция, реализующая такое приведение, всегда принимает дополнительный параметр типа <type>integer</type>, в котором передаётся значение <structfield>atttypmod</structfield> для целевого столбца (обычно это её объявленный размер, хотя интерпретироваться значение <structfield>atttypmod</structfield> для разных типов данных может по-разному), и третий параметр типа <type>boolean</type>, передающий признак явное/неявное преобразование. Функция приведения отвечает за все операции с длиной, включая её проверку и усечение данных.</para>
</step>

</procedure>

<example>
<title>Преобразование для типа хранения <type>character</type></title>

<para>Следующие запросы показывают, что сохраняемое значение подгоняется под размер целевого столбца, объявленного как <type>character(20)</type>: <screen>
CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT 'abc' || 'def';
SELECT v, octet_length(v) FROM vv;

          v           | octet_length
----------------------+--------------
 abcdef               |           20
(1 row)
</screen></para>

<para>Суть происходящего здесь в том, что две константы неизвестного типа по умолчанию воспринимаются как значения <type>text</type>, что позволяет применить к ним оператор <literal>||</literal> как оператор конкатенации значений <type>text</type>. Затем результат оператора, имеющий тип <type>text</type>, приводится к типу <type>bpchar</type> (<quote>blank-padded char</quote> (символы, дополненные пробелами), внутреннее имя типа <type>character</type>) в соответствии с типом целевого столбца. (Так как типы <type>text</type> и <type>bpchar</type> двоично-совместимы, при этом преобразовании реальный вызов функции не добавляется.) Наконец, в системном каталоге находится функция изменения размера <literal>bpchar(bpchar, integer, boolean)</literal> и применяется для результата оператора и длины столбца. Эта связанная с типом функция проверяет длину данных и добавляет недостающие пробелы.</para>
</example>
</sect1>

<sect1 id="typeconv-union-case">
<title><literal>UNION</literal>, <literal>CASE</literal> и связанные конструкции</title>

<indexterm zone="typeconv-union-case"><primary>UNION</primary> <secondary>определение типа результата</secondary></indexterm>

<indexterm zone="typeconv-union-case"><primary>CASE</primary> <secondary>определение типа результата</secondary></indexterm>

<indexterm zone="typeconv-union-case"><primary>ARRAY</primary> <secondary>определение типа результата</secondary></indexterm>

<indexterm zone="typeconv-union-case"><primary>VALUES</primary> <secondary>определение типа результата</secondary></indexterm>

<indexterm zone="typeconv-union-case"><primary>GREATEST</primary> <secondary>определение типа результата</secondary></indexterm>

<indexterm zone="typeconv-union-case"><primary>LEAST</primary> <secondary>определение типа результата</secondary></indexterm>

<para>SQL-конструкция <literal>UNION</literal> взаимодействует с системой типов, так как ей приходится объединять значения возможно различных типов в единый результирующий набор. Алгоритм разрешения типов при этом применяется независимо к каждому отдельному столбцу запроса. Подобным образом различные типы сопоставляются при выполнении <literal>INTERSECT</literal> и <literal>EXCEPT</literal> сопоставляют различные типы подобно <literal>UNION</literal>. По такому же алгоритму сопоставляют типы выражений и определяют тип своего результата конструкции <literal>CASE</literal>, <literal>ARRAY</literal>, <literal>VALUES</literal>, <function>GREATEST</function> и <function>LEAST</function>.</para>

<procedure>
<title>Разрешение типов для <literal>UNION</literal>, <literal>CASE</literal> и связанных конструкций</title>

<step performance="required">
<para>Если все данные одного типа и это не тип <type>unknown</type>, выбрать его.</para>
</step>

<step performance="required">
<para>Если тип данных &mdash; домен, далее считать их типом базовый тип домена. <footnote>
   <para>Так же, как домены воспринимаются при выборе операторов и функций, доменные типы могут сохраняться в конструкции <literal>UNION</literal> или подобной, если пользователь позаботится о том, чтобы все входные данные приводились к этому типу явно или неявно. В противном случае предпочтение будет отдано базовому типу домена.</para>
  </footnote></para>
</step>

<step performance="required">
<para>Если все данные типа <type>unknown</type>, выбрать для результата тип <type>text</type> (предпочитаемый для категории string). В противном случае значения <type>unknown</type> игнорируются.</para>
</step>

<step performance="required">
<para>Если известные типы входных данных оказываются не из одной категории, констатировать неудачу.</para>
</step>

<step performance="required">
<para>Выбрать первый известный предпочитаемый тип из этой категории, если такой есть.</para>
</step>

<step performance="required">
<para>В противном случае выбрать последний известный тип, в который можно неявно преобразовать все данные предшествующих известных типов. (Такой тип есть всегда, в крайнем случае этому условию удовлетворяет первый тип.)</para>
</step>

<step performance="required">
<para>Привести все данные к выбранном типу. Констатировать неудачу, если для каких-либо данных преобразование в этот тип невозможно.</para>
</step>
</procedure>

<para>Ниже это проиллюстрировано на примерах.</para>

<example>
<title>Разрешение типов с частичным определением в Union</title>

<para><screen>
SELECT text 'a' AS "text" UNION SELECT 'b';

 text
------
 a
 b
(2 rows)
</screen> В данном случае константа <literal>'b'</literal> неизвестного типа будет преобразована в тип <type>text</type>.</para>
</example>

<example>
<title>Разрешение типов в простом объединении</title>

<para><screen>
SELECT 1.2 AS "numeric" UNION SELECT 1;

 numeric
---------
       1
     1.2
(2 rows)
</screen> Константа <literal>1.2</literal> имеет тип <type>numeric</type> и целочисленное значение <literal>1</literal> может быть неявно приведено к типу <type>numeric</type>, так что используется этот тип.</para>
</example>

<example>
<title>Разрешение типов в противоположном объединении</title>

<para><screen>
SELECT 1 AS "real" UNION SELECT CAST('2.2' AS REAL);

 real
------
    1
  2.2
(2 rows)
</screen> Здесь значение типа <type>real</type> нельзя неявно привести к <type>integer</type>, но <type>integer</type> можно неявно привести к <type>real</type>, поэтому типом результата объединения будет <type>real</type>.</para>
</example>

</sect1>
</chapter>
