<!-- doc/src/xml/syntax.xml -->

<chapter id="sql-syntax">
 <title>Синтаксис SQL</title>

 <indexterm zone="sql-syntax"><primary>синтаксис</primary> <secondary>SQL</secondary></indexterm>

 <para>В этой главе описывается синтаксис языка SQL. Тем самым закладывается фундамент для следующих глав, где будет подробно рассмотрено, как с помощью команд SQL описывать и изменять данные.</para>

 <para>Мы советуем прочитать эту главу и тем, кто уже знаком SQL, так как в ней описываются несколько правил и концепций, которые реализованы в разных базах данных SQL по-разному или относятся только к <productname>&productname;</productname>.</para>

 <sect1 id="sql-syntax-lexical">
  <title>Лексическая структура</title>

  <indexterm><primary>компонент</primary></indexterm>

  <para>SQL-программа состоит из последовательности <firstterm>команд</firstterm>. Команда, в свою очередь, представляет собой последовательность <firstterm>компонентов</firstterm>, оканчивающуюся точкой с запятой (<quote>;</quote>). Конец входного потока также считается концом команды. Какие именно компоненты допустимы для конкретной команды, зависит от её синтаксиса.</para>

  <para>Компонентом команды может быть <firstterm>ключевое слово</firstterm>, <firstterm>идентификатор</firstterm>, <firstterm>идентификатор в кавычках</firstterm>, <firstterm>строка</firstterm> (или константа) или специальный символ. Компоненты обычно разделяются пробельными символами (пробел, табуляция, перевод строки), но это не требуется, если нет неоднозначности (например, когда спецсимвол оказывается рядом с компонентом другого типа).</para>

   <para>Например, следующий текст является правильной (синтаксически) SQL-программой: <programlisting>SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');</programlisting> Это последовательность трёх команд, по одной в строке (хотя их можно было разместить и в одну строку или наоборот, разделить команды на несколько строк).</para>

  <para>Кроме этого, SQL-программы могут содержать <firstterm>комментарии</firstterm>. Они не являются компонентами команд, а по сути равносильны пробельным символам.</para>

  <para>Синтаксис SQL не очень строго определяет, какие компоненты идентифицируют команды, а какие &mdash; их операнды или параметры. Первые несколько компонентов обычно содержат имя команды, так что в данном примере мы можем говорить о командах <quote>SELECT</quote>, <quote>UPDATE</quote> и <quote>INSERT</quote>. Но например, команда <command>UPDATE</command> требует, чтобы также в определённом положении всегда стоял компонент <token>SET</token>, а <command>INSERT</command> в приведённом виде требует наличия компонента <token>VALUES</token>. Точные синтаксические правила для каждой команды описаны в <xref remap="6" linkend="reference"/>.</para>

  <sect2 id="sql-syntax-identifiers">
   <title>Идентификаторы и ключевые слова</title>

   <indexterm zone="sql-syntax-identifiers"><primary>идентификатор</primary> <secondary>синтаксис</secondary></indexterm>

   <indexterm zone="sql-syntax-identifiers"><primary>имя</primary> <secondary>синтаксис</secondary></indexterm>

   <indexterm zone="sql-syntax-identifiers"><primary>ключевое слово</primary> <secondary>синтаксис</secondary></indexterm>

   <para>Показанные выше команды содержали компоненты <token>SELECT</token>, <token>UPDATE</token> и <token>VALUES</token>, которые являются примерами <firstterm>ключевых слов</firstterm>, то есть слов, имеющих фиксированное значение в языке SQL. Компоненты <token>MY_TABLE</token> и <token>A</token> являются примерами <firstterm>идентификаторов</firstterm>. Они идентифицируют имена таблиц, столбцов или других объектов баз данных, в зависимости от того, где они используются. Поэтому иногда их называют просто <quote>именами</quote>. Ключевые слова и идентификаторы имеют одинаковую лексическую структуру, то есть, не зная языка, нельзя определить, является ли некоторый компонент ключевым словом или идентификатором. Полный список ключевых слов приведён в <xref remap="6" linkend="sql-keywords-appendix"/>.</para>

   <para>Идентификаторы и ключевые слова SQL должны начинаться с буквы (<literal>a</literal>-<literal>z</literal>, хотя допускаются также не латинские буквы и буквы с диакритическими знаками) или подчёркивания (<literal>_</literal>). Последующими символами в идентификаторе или ключевом слове могут быть буквы, цифры (<literal>0</literal>-<literal>9</literal>), знаки доллара (<literal>$</literal>) или подчёркивания. Заметьте, что строго следуя букве стандарта SQL, знаки доллара нельзя использовать в идентификаторах, так что их использование вредит переносимости приложений. В стандарте SQL гарантированно не будет ключевых слов с цифрами и начинающихся или заканчивающихся подчёркиванием, так что идентификаторы такого вида защищены от возможных конфликтов с будущими расширениями стандарта.</para>

   <para><indexterm><primary>идентификатор</primary> <secondary>длина</secondary></indexterm> Система выделяет для идентификатора не более <symbol>NAMEDATALEN</symbol>-1 байт, а более длинные имена усекаются. По умолчанию <symbol>NAMEDATALEN</symbol> равно 64, так что максимальная длина идентификатора равна 63 байтам. Если этого недостаточно, этот предел можно увеличить, изменив константу <symbol>NAMEDATALEN</symbol> в файле <filename>src/include/pg_config_manual.h</filename>.</para>

   <para><indexterm><primary>чувствительность к регистру</primary> <secondary>в командах SQL</secondary></indexterm> Ключевые слова и идентификаторы без кавычек воспринимаются системой без учёта регистра. Таким образом: <programlisting>UPDATE MY_TABLE SET A = 5;</programlisting> равносильно записи: <programlisting>uPDaTE my_TabLE SeT a = 5;</programlisting> Часто используется неформальное соглашение записывать ключевые слова заглавными буквами, а имена строчными, например: <programlisting>UPDATE my_table SET a = 5;</programlisting></para>

   <para><indexterm><primary>кавычки</primary> <secondary>и идентификаторы</secondary></indexterm> Есть и другой тип идентификаторов: <firstterm>отделённые идентификаторы</firstterm> или <firstterm>идентификаторы в кавычках</firstterm>. Они образуются при заключении обычного набора символов в двойные кавычки (<literal>"</literal>). Такие идентификаторы всегда будут считаться идентификаторами, но не ключевыми словами. Так <literal>"select"</literal> можно использовать для обозначения столбца или таблицы <quote>select</quote>, тогда как <literal>select</literal> без кавычек будет воспринят как ключевое слово и приведёт к ошибке разбора команды в месте, где ожидается имя таблицы или столбца. Тот же пример можно переписать с идентификаторами в кавычках следующим образом: <programlisting>UPDATE "my_table" SET "a" = 5;</programlisting></para>

   <para>Идентификаторы в кавычках могут содержать любые символы, за исключением символа с кодом 0. (Чтобы включить в такой идентификатор кавычки, продублируйте их.) Это позволяет создавать таблицы и столбцы с именами, которые иначе были бы невозможны, например, с пробелами или амперсандами. Ограничение длины при этом сохраняется.</para>

   <indexterm><primary>Символы Unicode</primary> <secondary>в идентификаторах</secondary></indexterm>

   <para>Ещё один вариант идентификаторов в кавычках позволяет использовать символы Unicode по их кодам. Такой идентификатор начинается с <literal>U&amp;</literal> (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт двойная кавычка, например <literal>U&amp;"foo"</literal>. (Заметьте, что при этом возникает неоднозначность с оператором <literal>&amp;</literal>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в кавычках можно записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, идентификатор <literal>"data"</literal> можно записать так: <programlisting>U&amp;"d\0061t\+000061"</programlisting> В следующем менее тривиальном примере закодировано русское слово <quote>слон</quote>, записанное кириллицей: <programlisting>U&amp;"\0441\043B\043E\043D"</programlisting></para>

   <para>Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <literal>UESCAPE</literal> <indexterm><primary>UESCAPE</primary></indexterm> после строки, например: <programlisting>U&amp;"d!0061t!+000061" UESCAPE '!'</programlisting> В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки или пробельного символа. Заметьте, что спецсимвол заключается не в двойные кавычки, а в апострофы.</para>

   <para>Чтобы сделать спецсимволом знак апострофа, напишите его дважды.</para>

   <para>Unicode-формат полностью поддерживается только при использовании на сервере кодировки <literal>UTF8</literal>. Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами до <literal>\007F</literal>). И в четырёх, и в шестизначной форме можно записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шестизначной формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно, а объединяются в один символ, который затем кодируется в UTF-8.)</para>

   <para>Идентификатор, заключённый в кавычки, становится зависимым от регистра, тогда как идентификаторы без кавычек всегда переводятся в нижний регистр. Например, идентификаторы <literal>FOO</literal>, <literal>foo</literal> и <literal>"foo"</literal> считаются одинаковыми в <productname>&productname;</productname>, но <literal>"Foo"</literal> и <literal>"FOO"</literal> отличны друг от друга и от предыдущих трёх. (Приведение имён без кавычек к нижнему регистру, как это делает <productname>&productname;</productname>, несовместимо со стандартом SQL, который говорит о том, что имена должны приводиться к верхнему регистру. То есть, согласно стандарту <literal>foo</literal> должно быть эквивалентно <literal>"FOO"</literal>, а не <literal>"foo"</literal>. Поэтому при создании переносимых приложений рекомендуется либо всегда заключать определённое имя в кавычки, либо не заключать никогда.)</para>
  </sect2>


  <sect2 id="sql-syntax-constants">
   <title>Константы</title>

   <indexterm zone="sql-syntax-constants"><primary>константа</primary></indexterm>

   <para>В <productname>&productname;</productname> есть три типа констант <firstterm>подразумеваемых типов</firstterm>: строки, битовые строки и числа. Константы можно также записывать, указывая типы явно, что позволяет представить их более точно и обработать более эффективно. Эти варианты рассматриваются в следующих подразделах.</para>

   <sect3 id="sql-syntax-strings">
    <title>Строковые константы</title>

    <indexterm zone="sql-syntax-strings"><primary>текстовая строка</primary> <secondary>константа</secondary></indexterm>

    <para><indexterm><primary>кавычки</primary> <secondary>спецсимволы</secondary></indexterm> Строковая константа в SQL &mdash; это обычная последовательность символов, заключённая в апострофы (<literal>'</literal>), например: <literal>'Это строка'</literal>. Чтобы включить апостроф в строку, напишите в ней два апострофа рядом, например: <literal>'Жанна д''Арк'</literal>. Заметьте, это <emphasis>не</emphasis> то же самое, что двойная кавычка (<literal>"</literal>).</para>

    <para>Две строковые константы, разделённые пробельными символами <emphasis>и минимум одним переводом строки</emphasis>, объединяются в одну и обрабатываются, как если бы строка была записана в одной константе. Например: <programlisting>SELECT 'foo'
'bar';</programlisting> эквивалентно: <programlisting>SELECT 'foobar';</programlisting> но эта запись: <programlisting>SELECT 'foo'      'bar';</programlisting> считается синтаксической ошибкой. (Это несколько странное поведение определено в стандарте <acronym>SQL</acronym>, <productname>&productname;</productname> просто следует ему.)</para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
    <title>Строковые константы со спецпоследовательностями в стиле C</title>

     <indexterm zone="sql-syntax-strings-escape"><primary>синтаксис спецпоследовательностей</primary></indexterm>
     <indexterm zone="sql-syntax-strings-escape"><primary>спецсимвол обратная косая черта</primary></indexterm>

    <para><productname>&productname;</productname> также принимает <quote>спецпоследовательности</quote>, что является расширением стандарта SQL. Строка со спецпоследовательностями начинается с буквы <literal>E</literal> (заглавной или строчной), стоящей непосредственно перед апострофом, например: <literal>E'foo'</literal>. (Когда константа со спецпоследовательностью разбивается на несколько строк, букву <literal>E</literal> нужно поставить только перед первым открывающим апострофом.) Внутри таких строк символ обратной косой черты (<literal>\</literal>) начинает C-подобные <firstterm>спецпоследовательности</firstterm>, в которых сочетание обратной косой черты со следующим символом(ами) даёт определённое байтовое значение, как показано в <xref remap="6" linkend="sql-backslash-table"/>.</para>

     <table id="sql-backslash-table">
      <title>Спецпоследовательности</title>
      <tgroup cols="2">
      <thead>
       <row>
        <entry>Спецпоследовательность</entry>
        <entry>Интерпретация</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
        <entry>символ &laquo;забой&raquo;</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
        <entry>подача формы</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>новая строка</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>возврат каретки</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>табуляция</entry>
       </row>
       <row>
        <entry><literal>\<replaceable>o</replaceable></literal>, <literal>\<replaceable>oo</replaceable></literal>, <literal>\<replaceable>ooo</replaceable></literal> (<replaceable>o</replaceable> = 0 - 7)</entry>
        <entry>восьмеричное значение байта</entry>
       </row>
       <row>
        <entry><literal>\x<replaceable>h</replaceable></literal>, <literal>\x<replaceable>hh</replaceable></literal> (<replaceable>h</replaceable> = 0 — 9, A — F)</entry>
        <entry>шестнадцатеричное значение байта</entry>
       </row>
       <row>
        <entry><literal>\u<replaceable>xxxx</replaceable></literal>, <literal>\U<replaceable>xxxxxxxx</replaceable></literal> (<replaceable>x</replaceable> = 0 — 9, A — F)</entry>
        <entry>16- или 32-битный шестнадцатеричный код символа Unicode</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

    <para>Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (<literal>\\</literal>). Так же можно включить в строку апостроф, написав <literal>\'</literal>, в дополнение к обычному способу <literal>''</literal>.</para>

    <para>Вы должны позаботиться, чтобы байтовые последовательности, которые вы создаёте таким образом, особенно в восьмеричной и шестнадцатеричной записи, образовывали допустимые символы в серверной кодировке. Когда сервер работает с кодировкой UTF-8, вместо такой записи байт следует использовать спецпоследовательности Unicode или альтернативный синтаксис Unicode, описанный в <xref remap="6" linkend="sql-syntax-strings-uescape"/>. (В противном случае придётся кодировать символы UTF-8 вручную и выписывать их по байтам, что очень неудобно.)</para>

    <para>Спецпоследовательности с Unicode полностью поддерживаются только при использовании на сервере кодировки <literal>UTF8</literal>. Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами до <literal>\u007F</literal>). И в четырёх, и в восьмизначной форме можно записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие восьмизначной формы технически делает это ненужным. (Когда суррогатные пары используются с серверной кодировкой <literal>UTF8</literal>, они сначала объединяются в один символ, который затем кодируется в UTF-8.)</para>

    <caution>
    <para>Если параметр конфигурации <xref linkend="guc-standard-conforming-strings"/> имеет значение <literal>off</literal>, <productname>&productname;</productname> распознаёт обратную косую черту как спецсимвол и в обычных строках, и в строках со спецпоследовательностями. Однако, начиная с версии <productname>PostgreSQL</productname> 9.1, по умолчанию принято значение <literal>on</literal>, и в этом случае обратная косая черта распознаётся только в спецстроках. Это поведение больше соответствует стандарту, хотя может нарушить работу приложений, рассчитанных на предыдущий режим, когда обратная косая черта распознавалась везде. В качестве временного решения вы можете изменить этот параметр на <literal>off</literal>, но лучше уйти от такой практики. Если вам нужно, чтобы обратная косая черта представляла специальный символ, задайте строковую константу с <literal>E</literal>.</para>

    <para>В дополнение к <varname>standard_conforming_strings</varname> поведением обратной косой черты в строковых константах управляют параметры <xref linkend="guc-escape-string-warning"/> и <xref linkend="guc-backslash-quote"/>.</para>
    </caution>

    <para>Строковая константа не может включать символ с кодом 0.</para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
    <title>Строковые константы со спецпоследовательностями Unicode</title>

    <indexterm zone="sql-syntax-strings-uescape"><primary>Спецкоды Unicode</primary> <secondary>в строковых константах</secondary></indexterm>

    <para><productname>&productname;</productname> также поддерживает ещё один вариант спецпоследовательностей, позволяющий включать в строки символы Unicode по их кодам. Строковая константа со спецпоследовательностями Unicode начинается с <literal>U&amp;</literal> (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт апостроф, например <literal>U&amp;'foo'</literal>. (Заметьте, что при этом возникает неоднозначность с оператором <literal>&amp;</literal>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в апострофах можно записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, строку <literal>'data'</literal> можно записать так:<programlisting>U&amp;'d\0061t\+000061'</programlisting> В следующем менее тривиальном примере закодировано русское слово <quote>слон</quote>, записанное кириллицей: <programlisting>U&amp;'\0441\043B\043E\043D'</programlisting></para>

    <para>Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm> после строки, например: <programlisting>U&amp;'d!0061t!+000061' UESCAPE '!'</programlisting> В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки или пробельного символа.</para>

    <para>Спецпоследовательности с Unicode поддерживаются только при использовании на сервере кодировки <literal>UTF8</literal>. Когда используются другие кодировки, допускается указание только ASCII-символов (с кодами до <literal>\007F</literal>). И в четырёх, и в шестизначной форме можно записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, хотя наличие шестизначной формы технически делает это ненужным. (Когда суррогатные пары используются с серверной кодировкой <literal>UTF8</literal>, они сначала объединяются в один символ, который затем кодируется в UTF-8.)</para>

    <para>Также заметьте, что спецпоследовательности Unicode в строковых константах работают, только когда параметр конфигурации <xref linkend="guc-standard-conforming-strings"/> равен <literal>on</literal>. Это объясняется тем, что иначе клиентские программы, проверяющие SQL-операторы, можно будет ввести в заблуждение и эксплуатировать это как уязвимость, например, для SQL-инъекций. Если этот параметр имеет значение <literal>off</literal>, эти спецпоследовательности будут вызывать ошибку.</para>

    <para>Чтобы включить спецсимвол в строку буквально, напишите его дважды.</para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
    <title>Строковые константы, заключённые в доллары</title>

     <indexterm><primary>заключение строк в доллары</primary></indexterm>

    <para>Хотя стандартный синтаксис для строковых констант обычно достаточно удобен, он может плохо читаться, когда строка содержит много апострофов или обратных косых черт, так как каждый такой символ приходится дублировать. Чтобы и в таких случаях запросы оставались читаемыми, <productname>&productname;</productname> предлагает ещё один способ записи строковых констант &mdash; <quote>заключение строк в доллары</quote>. Строковая константа, заключённая в доллары, начинается со знака доллара (<literal>$</literal>), необязательного <quote>тега</quote> из нескольких символов и ещё одного знака доллара, затем содержит обычную последовательность символов, составляющую строку, и оканчивается знаком доллара, тем же тегом и замыкающим знаком доллара. Например, строку <quote>Жанна д'Арк</quote> можно записать в долларах двумя способами: <programlisting>$$Жанна д'Арк$$
$SomeTag$Жанна д'Арк$SomeTag$</programlisting> Заметьте, что внутри такой строки апострофы не нужно записывать особым образом. На самом деле, в строке, заключённой в доллары, все символы можно записывать в чистом виде: содержимое строки всегда записывается буквально. Ни обратная косая черта, ни даже знак доллара не являются спецсимволами, если только они не образуют последовательность, соответствующую открывающему тегу.</para>

    <para>Строковые константы в долларах можно вкладывать друг в друга, выбирая на разных уровнях вложенности разные теги. Чаще всего это используется при написании определений функций. Например: <programlisting>$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$</programlisting> Здесь последовательность <literal>$q$[\t\r\n\v\\]$q$</literal> представляет в долларах текстовую строку <literal>[\t\r\n\v\\]</literal>, которая будет обработана, когда <productname>&productname;</productname> будет выполнять эту функцию. Но так как эта последовательность не соответствует внешнему тегу в долларах (<literal>$function$</literal>), с точки зрения внешней строки это просто обычные символы внутри константы.</para>

    <para>Тег строки в долларах, если он присутствует, должен соответствовать правилам, определённым для идентификаторов без кавычек, и к тому же не должен содержать знак доллара. Теги регистрозависимы, так что <literal>$tag$String content$tag$</literal> &mdash; правильная строка, а <literal>$TAG$String content$tag$</literal> &mdash; нет.</para>

    <para>Строка в долларах, следующая за ключевым словом или идентификатором, должна отделяться от него пробельными символами, иначе доллар будет считаться продолжением предыдущего идентификатора.</para>

    <para>Заключение строк в доллары не является частью стандарта SQL, но часто это более удобный способ записывать сложные строки, чем стандартный вариант с апострофами. Он особенно полезен, когда нужно представить строковую константу внутри другой строки, что часто требуется в определениях процедурных функций. Ограничившись только апострофами, каждую обратную косую черту в приведённом примере пришлось бы записывать четырьмя такими символами, которые бы затем уменьшились до двух при разборе внешней строки, и наконец до одного при обработке внутренней строки во время выполнения функции.</para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
    <title>Битовые строковые константы</title>

    <indexterm zone="sql-syntax-bit-strings"><primary>битовая строковая</primary> <secondary>константа</secondary></indexterm>

    <para>Битовые строковые константы похожи на обычные с дополнительной буквой <literal>B</literal> (заглавной или строчной), добавленной непосредственно перед открывающим апострофом (без промежуточных пробелов), например: <literal>B'1001'</literal>. В битовых строковых константах допускаются лишь символы <literal>0</literal> и <literal>1</literal>.</para>

    <para>Битовые константы могут быть записаны и по-другому, в шестнадцатеричном виде, с начальной буквой <literal>X</literal> (заглавной или строчной), например: <literal>X'1FF'</literal>. Такая запись эквивалентна двоичной, только четыре двоичных цифры заменяются одной шестнадцатеричной.</para>

    <para>Обе формы записи допускают перенос строк так же, как и обычные строковые константы. Однако заключать в доллары битовые строки нельзя.</para>
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
    <title>Числовые константы</title>

    <indexterm><primary>числовые</primary> <secondary>константы</secondary></indexterm>

    <para>Числовые константы могут быть заданы в следующем общем виде: <synopsis>
<replaceable>цифры</replaceable>
<replaceable>цифры</replaceable>.<optional><replaceable>цифры</replaceable></optional><optional>e<optional>+-</optional><replaceable>цифры</replaceable></optional>
<optional><replaceable>цифры</replaceable></optional>.<replaceable>цифры</replaceable><optional>e<optional>+-</optional><replaceable>цифры</replaceable></optional>
<replaceable>цифры</replaceable>e<optional>+-</optional><replaceable>цифры</replaceable>
</synopsis> где <replaceable>цифры</replaceable> &mdash; это одна или несколько десятичных цифр (0..9). До или после десятичной точки (при её наличии) должна быть минимум одна цифра. Как минимум одна цифра должна следовать за обозначением экспоненты (<literal>e</literal>), если оно присутствует. В числовой константе не может быть пробелов или других символов. Заметьте, что любой знак минус или плюс в начале строки не считается частью числа; это оператор, применённый к константе.</para>

    <para>Несколько примеров допустимых числовых констант: <literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout></para>

    <para><indexterm><primary>integer</primary></indexterm> <indexterm><primary>bigint</primary></indexterm> <indexterm><primary>numeric</primary></indexterm> Числовая константа, не содержащая точки и экспоненты, изначально рассматривается как константа типа <type>integer</type>, если её значение умещается в 32-битный тип <type>integer</type>; затем как константа типа <type>bigint</type>, если её значение умещается в 64-битный <type>bigint</type>; в противном случае она принимает тип <type>numeric</type>. Константы, содержащие десятичные точки и/или экспоненты, всегда считаются константами типа <type>numeric</type>.</para>

    <para>Изначально назначенный тип данных числовой константы это только отправная точка для алгоритмов определения типа. В большинстве случаев константа будет автоматически приведена к наиболее подходящему типу для данного контекста. При необходимости вы можете принудительно интерпретировать числовое значение как значение определённого типа, приведя его тип к нужному.<indexterm><primary>приведение типа</primary></indexterm> Например, вы можете сделать, чтобы числовое значение рассматривалось как имеющее тип <type>real</type> (<type>float4</type>), написав: <programlisting>REAL '1.23'  -- строковый стиль
1.23::REAL   -- стиль &productname; (исторический)</programlisting> На самом деле это только частные случаи синтаксиса приведения типов, который будет рассматриваться далее.</para>
   </sect3>

   <sect3 id="sql-syntax-constants-generic">
    <title>Константы других типов</title>

    <indexterm><primary>типы данных</primary> <secondary>константы</secondary></indexterm>

    <para>Константу <emphasis>обычного</emphasis> типа можно ввести одним из следующих способов: <synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis> Текст строковой константы передаётся процедуре преобразования ввода для типа, обозначенного здесь <replaceable>type</replaceable>. Результатом становится константа указанного типа. Явное приведение типа можно опустить, если нужный тип константы определяется однозначно (например, когда она присваивается непосредственно столбцу таблицы), так как в этом случае приведение происходит автоматически.</para>

    <para>Строковую константу можно записать, используя как обычный синтаксис SQL, так и формат с долларами.</para>

    <para>Также можно записать приведение типов, используя синтаксис функций: <synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>но это работает не для всех имён типов; подробнее об этом написано в <xref remap="6" linkend="sql-syntax-type-casts"/>.</para>

    <para>Конструкцию <literal>::</literal>, <literal>CAST()</literal> и синтаксис вызова функции можно также использовать для преобразования типов обычных выражений во время выполнения, как описано в <xref remap="6" linkend="sql-syntax-type-casts"/>. Во избежание синтаксической неопределённости, запись <literal><replaceable>тип</replaceable> '<replaceable>строка</replaceable>'</literal> можно использовать только для указания типа простой текстовой константы. Ещё одно ограничение записи <literal><replaceable>тип</replaceable> '<replaceable>строка</replaceable>'</literal>: она не работает для массивов; для таких констант следует использовать <literal>::</literal> или <literal>CAST()</literal>.</para>

    <para>Синтаксис <literal>CAST()</literal> соответствует SQL, а запись <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal> является обобщением стандарта: в SQL такой синтаксис поддерживает только некоторые типы данных, но <productname>&productname;</productname> позволяет использовать его для всех. Синтаксис с <literal>::</literal> имеет исторические корни в <productname>&productname;</productname>, как и запись в виде вызова функции.</para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
   <title>Операторы</title>

   <indexterm zone="sql-syntax-operators"><primary>оператор</primary> <secondary>синтаксис</secondary></indexterm>

   <para>Имя оператора образует последовательность не более чем <symbol>NAMEDATALEN</symbol>-1 (по умолчанию 63) символов из следующего списка: <literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout> Однако для имён операторов есть ещё несколько ограничений: <itemizedlist>
     <listitem>
      <para>Сочетания символов <literal>--</literal> и <literal>/*</literal> не могут присутствовать в имени оператора, так как они будут обозначать начало комментария.</para>
     </listitem>

     <listitem>
      <para>Многосимвольное имя оператора не может заканчиваться знаком <literal>+</literal> или <literal>-</literal>, если только оно не содержит также один из этих символов: <literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout> Например, <literal>@-</literal> &mdash; допустимое имя оператора, а <literal>*-</literal> &mdash; нет. Благодаря этому ограничению, <productname>&productname;</productname> может разбирать корректные SQL-запросы без пробелов между компонентами.</para>
     </listitem>
    </itemizedlist></para>

   <para>Записывая нестандартные SQL-операторы, обычно нужно отделять имена соседних операторов пробелами для однозначности. Например, если вы определили левый унарный оператор с именем <literal>@</literal>, вы не можете написать <literal>X*@Y</literal>, а должны написать <literal>X* @Y</literal>, чтобы <productname>&productname;</productname> однозначно прочитал это как два оператора, а не один.</para>
  </sect2>

  <sect2 id="sql-syntax-special-chars">
   <title>Специальные знаки</title>

  <para>Некоторые не алфавитно-цифровые символы имеют специальное значение, но при этом не являются операторами. Подробнее их использование будет рассмотрено при описании соответствующего элемента синтаксиса. Здесь они упоминаются только для сведения и обобщения их предназначения. <itemizedlist>
    <listitem>
     <para>Знак доллара (<literal>$</literal>), предваряющий число, используется для представления позиционного параметра в теле определения функции или подготовленного оператора. В других контекстах знак доллара может быть частью идентификатора или строковой константы, заключённой в доллары.</para>
    </listitem>

    <listitem>
     <para>Круглые скобки (<literal>()</literal>) имеют обычное значение и применяются для группировки выражений и повышения приоритета операций. В некоторых случаях скобки &mdash; это необходимая часть синтаксиса определённых SQL-команд.</para>
    </listitem>

    <listitem>
     <para>Квадратные скобки (<literal>[]</literal>) применяются для выделения элементов массива. Подробнее массивы рассматриваются в <xref remap="6" linkend="arrays"/>.</para>
    </listitem>

    <listitem>
     <para>Запятые (<literal>,</literal>) используются в некоторых синтаксических конструкциях для разделения элементов списка.</para>
    </listitem>

    <listitem>
     <para>Точка с запятой (<literal>;</literal>) завершает команду SQL. Она не может находиться нигде внутри команды, за исключением строковых констант или идентификаторов в кавычках.</para>
    </listitem>

    <listitem>
     <para>Двоеточие (<literal>:</literal>) применяется для выборки <quote>срезов</quote> массивов (см. <xref remap="4" linkend="arrays"/>.) В некоторых диалектах SQL (например, в Embedded SQL) двоеточие может быть префиксом в имени переменной.</para>
    </listitem>

    <listitem>
     <para>Звёздочка (<literal>*</literal>) используется в некоторых контекстах как обозначение всех полей строки или составного значения. Она также имеет специальное значение, когда используется как аргумент некоторых агрегатных функций, а именно функций, которым не нужны явные параметры.</para>
    </listitem>

    <listitem>
     <para>Точка (<literal>.</literal>) используется в числовых константах, а также для отделения имён схемы, таблицы и столбца.</para>
    </listitem>
   </itemizedlist></para>
  </sect2>

  <sect2 id="sql-syntax-comments">
   <title>Комментарии</title>

   <indexterm zone="sql-syntax-comments"><primary>комментарий</primary> <secondary sortas="SQL">в SQL</secondary></indexterm>

   <para>Комментарий &mdash; это последовательность символов, которая начинается с двух минусов и продолжается до конца строки, например: <programlisting>-- Это стандартный комментарий SQL</programlisting></para>

   <para>Кроме этого, блочные комментарии можно записывать в стиле C: <programlisting>/* многострочный комментарий
 * с вложенностью: /* вложенный блок комментария */
 */</programlisting> где комментарий начинается с <literal>/*</literal> и продолжается до соответствующего вхождения <literal>*/</literal>. Блочные комментарии можно вкладывать друг в друга, как разрешено по стандарту SQL (но не разрешено в C), так что вы можете комментировать большие блоки кода, которые при этом уже могут содержать блоки комментариев.</para>

   <para>Комментарий удаляется из входного потока в начале синтаксического анализа и фактически заменяется пробелом.</para>
  </sect2>

  <sect2 id="sql-precedence">
   <title>Приоритеты операторов</title>

   <indexterm zone="sql-precedence"><primary>оператор</primary> <secondary>приоритеты</secondary></indexterm>

   <para>В <xref remap="6" linkend="sql-precedence-table"/> показаны приоритеты и очерёдность операторов, действующие в <productname>&productname;</productname>. Большинство операторов имеют одинаковый приоритет и вычисляются слева направо. Приоритет и очерёдность операторов жёстко фиксированы в синтаксическом анализаторе.</para>

   <para>Иногда вам потребуется добавлять скобки, когда вы комбинируете унарные и бинарные операторы. Например, выражение: <programlisting>SELECT 5 ! - 6;</programlisting> будет разобрано как: <programlisting>SELECT 5 ! (- 6);</programlisting> так как анализатор до последнего не знает, что оператор <token>!</token> определён как постфиксный, а не инфиксный (внутренний). Чтобы получить желаемый результат в этом случае, нужно написать: <programlisting>SELECT (5 !) - 6;</programlisting> Такова цена расширяемости.</para>

   <table id="sql-precedence-table">
    <title>Приоритет операторов (от большего к меньшему)</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Оператор/элемент</entry>
       <entry>Очерёдность</entry>
       <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
       <entry>слева-направо</entry>
       <entry>разделитель имён таблицы и столбца</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
       <entry>слева-направо</entry>
       <entry>приведение типов в стиле <productname>&productname;</productname></entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>слева-направо</entry>
       <entry>выбор элемента массива</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>справа-налево</entry>
       <entry>унарный плюс, унарный минус</entry>
      </row>

      <row>
       <entry><token>^</token></entry>
       <entry>слева-направо</entry>
       <entry>возведение в степень</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>слева-направо</entry>
       <entry>умножение, деление, остаток от деления</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>слева-направо</entry>
       <entry>сложение, вычитание</entry>
      </row>

      <row>
       <entry>(любой другой оператор)</entry>
       <entry>слева-направо</entry>
       <entry>все другие встроенные и пользовательские операторы</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token> <token>IN</token> <token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry/>
       <entry>проверка диапазона, проверка членства, сравнение строк</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token> <token>=</token> <token>&lt;=</token> <token>&gt;=</token> <token>&lt;&gt;</token>
</entry>
       <entry/>
       <entry>операторы сравнения</entry>
      </row>

      <row>
       <entry><token>IS</token> <token>ISNULL</token> <token>NOTNULL</token></entry>
       <entry/>
       <entry><literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS NULL</literal>, <literal>IS DISTINCT FROM</literal> и т. д.</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
       <entry>справа-налево</entry>
       <entry>логическое отрицание</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
       <entry>слева-направо</entry>
       <entry>логическая конъюнкция</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
       <entry>слева-направо</entry>
       <entry>логическая дизъюнкция</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Заметьте, что правила приоритета операторов также применяются к операторам, определённым пользователем с теми же именами, что и вышеперечисленные встроенные операторы. Например, если вы определите оператор <quote>+</quote> для некоторого нестандартного типа данных, он будет иметь тот же приоритет, что и встроенный оператор <quote>+</quote>, независимо от того, что он у вас делает.</para>

   <para>Когда в конструкции <literal>OPERATOR</literal> используется имя оператора со схемой, например так: <programlisting>SELECT 3 OPERATOR(pg_catalog.+) 4;</programlisting> тогда <literal>OPERATOR</literal> имеет приоритет по умолчанию, соответствующий в <xref remap="6" linkend="sql-precedence-table"/> строке <quote>любой другой оператор</quote>. Это не зависит от того, какие именно операторы находятся в конструкции <literal>OPERATOR()</literal>.</para>

   <note>
    <para>В <productname>PostgreSQL</productname> до версии 9.5 действовали немного другие правила приоритета операторов. В частности, операторы <token>&lt;=</token>, <token>&gt;=</token> и <token>&lt;&gt;</token> обрабатывались по общему правилу; проверки <literal>IS</literal> имели более высокий приоритет; а <literal>NOT BETWEEN</literal> и связанные конструкции работали несогласованно — в некоторых случаях приоритетнее оказывался оператор <literal>NOT</literal>, а не <literal>BETWEEN</literal>. Эти правила были изменены для лучшего соответствия стандарту SQL и для уменьшения путаницы из-за несогласованной обработки логически равнозначных конструкций. В большинстве случаев эти изменения никак не проявятся, либо могут привести к ошибкам типа <quote>нет такого оператора</quote>, которые можно разрешить, добавив скобки. Однако, возможны особые случаи, когда запрос будет разобран без ошибки, но его поведение может измениться. Если вас беспокоит, не нарушают ли эти изменения незаметно работу вашего приложения, вы можете проверить это, включив конфигурационный параметр <xref linkend="guc-operator-precedence-warning"/> и пронаблюдав, не появятся ли предупреждения в журнале.</para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
  <title>Выражения значения</title>

  <indexterm zone="sql-expressions"><primary>выражение</primary> <secondary>синтаксис</secondary></indexterm>

  <indexterm zone="sql-expressions"><primary>выражение значения</primary></indexterm>

  <indexterm><primary>скаляр</primary> <see>выражение</see></indexterm>

  <para>Выражения значения применяются в самых разных контекстах, например в списке результатов команды <command>SELECT</command>, в значениях столбцов в <command>INSERT</command> или <command>UPDATE</command> или в условиях поиска во многих командах. Результат такого выражения иногда называют <firstterm>скаляром</firstterm>, чтобы отличить его от результата табличного выражения (который представляет собой таблицу). А сами выражения значения часто называют <firstterm>скалярными</firstterm> (или просто <firstterm>выражениями</firstterm>). Синтаксис таких выражений позволяет вычислять значения из примитивных частей, используя арифметические, логические и другие операции.</para>

  <para>Выражениями значения являются: <itemizedlist>
    <listitem>
     <para>Константа или непосредственное значение</para>
    </listitem>

    <listitem>
     <para>Ссылка на столбец</para>
    </listitem>

    <listitem>
     <para>Ссылка на позиционный параметр в теле определения функции или подготовленного оператора</para>
    </listitem>

    <listitem>
     <para>Выражение с индексом</para>
    </listitem>

    <listitem>
     <para>Выражение выбора поля</para>
    </listitem>

    <listitem>
     <para>Применение оператора</para>
    </listitem>

    <listitem>
     <para>Вызов функции</para>
    </listitem>

    <listitem>
     <para>Агрегатное выражение</para>
    </listitem>

    <listitem>
     <para>Вызов оконной функции</para>
    </listitem>

    <listitem>
     <para>Приведение типов</para>
    </listitem>

    <listitem>
     <para>Применение правил сортировки</para>
    </listitem>

    <listitem>
     <para>Скалярный подзапрос</para>
    </listitem>

    <listitem>
     <para>Конструктор массива</para>
    </listitem>

    <listitem>
     <para>Конструктор табличной строки</para>
    </listitem>

    <listitem>
     <para>Кроме того, выражением значения являются скобки (предназначенные для группировки подвыражений и переопределения приоритета <indexterm><primary>скобки</primary></indexterm>)</para>
    </listitem>
   </itemizedlist></para>

  <para>В дополнение к этому списку есть ещё несколько конструкций, которые можно классифицировать как выражения, хотя они не соответствуют общим синтаксическим правилам. Они обычно имеют вид функции или оператора и будут рассмотрены в соответствующем разделе <xref remap="2" linkend="functions"/>. Пример такой конструкции &mdash; предложение <literal>IS NULL</literal>.</para>

  <para>Мы уже обсудили константы в <xref remap="6" linkend="sql-syntax-constants"/>. В следующих разделах рассматриваются остальные варианты.</para>

  <sect2 id="sql-expressions-column-refs">
   <title>Ссылки на столбцы</title>

   <indexterm><primary>ссылка на столбец</primary></indexterm>

   <para>Ссылку на столбец можно записать в форме: <synopsis>
<replaceable>отношение</replaceable>.<replaceable>имя_столбца</replaceable>
</synopsis></para>

   <para>Здесь <replaceable>отношение</replaceable> &mdash; имя таблицы (возможно, полное, с именем схемы) или её псевдоним, определённый в предложении <literal>FROM</literal>. Это имя и разделяющую точку можно опустить, если имя столбца уникально среди всех таблиц, задействованных в текущем запросе. (См. также <xref remap="4" linkend="queries"/>.)</para>
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
   <title>Позиционные параметры</title>

   <indexterm><primary>параметр</primary> <secondary>синтаксис</secondary></indexterm>

   <indexterm><primary>$</primary></indexterm>

   <para>Ссылка на позиционный параметр применяется для обращения к значению, переданному в SQL-оператор извне. Параметры используются в определениях SQL-функций и подготовленных операторов. Некоторые клиентские библиотеки также поддерживают передачу значений данных отдельно от самой SQL-команды, и в этом случае параметры позволяют ссылаться на такие значения. Ссылка на параметр записывается в следующей форме: <synopsis>
$<replaceable>число</replaceable>
</synopsis></para>

   <para>Например, рассмотрим следующее определение функции <function>dept</function>: <programlisting>CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;</programlisting> Здесь <literal>$1</literal> всегда будет ссылаться на значение первого аргумента функции.</para>
  </sect2>

  <sect2 id="sql-expressions-subscripts">
   <title>Индексы элементов</title>

   <indexterm><primary>индекс элемента</primary></indexterm>

   <para>Если в выражении вы имеете дело с массивом, то можно извлечь определённый его элемент, написав: <synopsis>
<replaceable>выражение</replaceable>[<replaceable>индекс</replaceable>]
</synopsis> или несколько соседних элементов (<quote>срез массива</quote>): <synopsis>
<replaceable>выражение</replaceable>[<replaceable>нижний_индекс</replaceable>:<replaceable>верхний_индекс</replaceable>]
</synopsis> (Здесь квадратные скобки <literal>[ ]</literal> должны быть в явном виде.) Каждый <replaceable>индекс</replaceable> сам по себе является выражением, результатом которого должно быть целое число.</para>

   <para>В общем случае <replaceable>выражение</replaceable> массива должно заключаться в круглые скобки, но их можно опустить, когда выражение с индексом &mdash; это просто ссылка на столбец или позиционный параметр. Кроме того, можно соединить несколько индексов, если исходный массив многомерный. Например: <programlisting>моя_таблица.столбец_массив[4]
моя_таблица.столбец_массив_2d[17][34]
$1[10:42]
(функция_массив(a,b))[42]</programlisting> В последней строке круглые скобки необходимы. Подробнее массивы рассматриваются в <xref remap="6" linkend="arrays"/>.</para>
  </sect2>

  <sect2 id="field-selection">
   <title>Выбор поля</title>

   <indexterm><primary>выбор поля</primary></indexterm>

   <para>Если результат выражения &mdash; значение составного типа (строка таблицы), тогда определённое поле этой строки можно извлечь, написав:<synopsis>
<replaceable>выражение</replaceable>.<replaceable>имя_поля</replaceable>
</synopsis></para>

   <para>В общем случае <replaceable>выражение</replaceable> такого типа должно заключаться в круглые скобки, но их можно опустить, когда это ссылка на таблицу или позиционный параметр. Например: <programlisting>моя_таблица.столбец
$1.столбец
(функция_кортеж(a,b)).стол3</programlisting> (Таким образом, полная ссылка на столбец &mdash; это просто частный случай выбора поля.) Важный особый случай здесь &mdash; извлечение поля из столбца составного типа: <programlisting>(составной_столбец).поле
(моя_таблица.составной_столбец).поле</programlisting> Здесь скобки нужны, чтобы показать, что <structfield>составной_столбец</structfield> &mdash; это имя столбца, а не таблицы, и что <structname>моя_таблица</structname> &mdash; имя таблицы, а не схемы.</para>

   <para>Вы можете запросить все поля составного значения, написав <literal>.*</literal>: <programlisting>(составной_столбец).*</programlisting> Эта запись действует по-разному в зависимости от контекста; подробнее об этом говорится в <xref remap="6" linkend="rowtypes-usage"/>.</para>
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
   <title>Применение оператора</title>

   <indexterm><primary>оператор</primary> <secondary>вызов</secondary></indexterm>

   <para>Существуют три возможных синтаксиса применения операторов: <simplelist>
     <member><replaceable>выражение</replaceable> <replaceable>оператор</replaceable> <replaceable>выражение</replaceable> (бинарный инфиксный оператор)</member>
     <member><replaceable>оператор</replaceable> <replaceable>выражение</replaceable> (унарный префиксный оператор)</member>
     <member><replaceable>выражение</replaceable> <replaceable>оператор</replaceable> (унарный постфиксный оператор)</member>
    </simplelist>где <replaceable>оператор</replaceable> соответствует синтаксическим правилам, описанным в <xref remap="6" linkend="sql-syntax-operators"/>, либо это одно из ключевых слов <token>AND</token>, <token>OR</token> и <token>NOT</token>, либо полное имя оператора в форме: <synopsis>
<literal>OPERATOR(</literal><replaceable>схема</replaceable><literal>.</literal><replaceable>имя_оператора</replaceable><literal>)</literal>
</synopsis> Существование конкретных операторов и их тип (унарный или бинарный) зависит от того, как и какие операторы определены системой и пользователем. Встроенные операторы описаны в <xref remap="6" linkend="functions"/>.</para>
  </sect2>

  <sect2 id="sql-expressions-function-calls">
   <title>Вызовы функций</title>

   <indexterm><primary>функция</primary> <secondary>вызов</secondary></indexterm>

   <para>Вызов функции записывается просто как имя функции (возможно, дополненное именем схемы) и список аргументов в скобках: <synopsis>
<replaceable>имя_функции</replaceable> (<optional><replaceable>выражение</replaceable> <optional>, <replaceable>выражение</replaceable> ... </optional></optional>)
</synopsis></para>

   <para>Например, так вычисляется квадратный корень из 2: <programlisting>sqrt(2)</programlisting></para>

   <para>Список встроенных функций приведён в <xref remap="6" linkend="functions"/>. Пользователь также может определить и другие функции.</para>

   <para>Аргументам могут быть присвоены необязательные имена. Подробнее об этом см. <xref remap="4" linkend="sql-syntax-calling-funcs"/>.</para>

   <note>
    <para>Функцию, принимающую один аргумент составного типа, можно также вызывать, используя синтаксис выбора поля, и наоборот, выбор поля можно записать в функциональном стиле. То есть записи <literal>col(table)</literal> и <literal>table.col</literal> равносильны и взаимозаменяемы. Это поведение не оговорено стандартом SQL, но реализовано в <productname>&productname;</productname>, так как это позволяет использовать функции для эмуляции <quote>вычисляемых полей</quote>. Подробнее это описано в <xref remap="6" linkend="rowtypes-usage"/>.</para>
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
   <title>Агрегатные выражения</title>

   <indexterm zone="syntax-aggregates"><primary>агрегатная функция</primary> <secondary>вызов</secondary></indexterm>

   <indexterm zone="syntax-aggregates"><primary>сортирующая агрегатная функция</primary></indexterm>

   <indexterm zone="syntax-aggregates"><primary>WITHIN GROUP</primary></indexterm>

   <indexterm zone="syntax-aggregates"><primary>FILTER</primary></indexterm>

   <para><firstterm>Агрегатное выражение</firstterm> представляет собой применение агрегатной функции к строкам, выбранным запросом. Агрегатная функция сводит множество входных значений к одному выходному, как например, сумма или среднее. Агрегатное выражение может записываться следующим образом: <synopsis>
<replaceable>агрегатная_функция</replaceable> (<replaceable>выражение</replaceable> [ , ... ] [ <replaceable>предложение_order_by</replaceable> ] ) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ]
<replaceable>агрегатная_функция</replaceable> (ALL <replaceable>выражение</replaceable> [ , ... ] [ <replaceable>предложение_order_by</replaceable> ] ) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ]
<replaceable>агрегатная_функция</replaceable> (DISTINCT <replaceable>выражение</replaceable> [ , ... ] [ <replaceable>предложение_order_by</replaceable> ] ) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ]
<replaceable>агрегатная_функция</replaceable> ( * ) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ]
<replaceable>агрегатная_функция</replaceable> ( [ <replaceable>выражение</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>предложение_order_by</replaceable> ) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ]
</synopsis> Здесь <replaceable>агрегатная_функция</replaceable> &mdash; имя ранее определённой агрегатной функции (возможно, дополненное именем схемы), <replaceable>выражение</replaceable> &mdash; любое выражение значения, не содержащее в себе агрегатного выражения или вызова оконной функции. Необязательные предложения <replaceable>предложение_order_by</replaceable> и <replaceable>условие_фильтра</replaceable> описываются ниже.</para>

   <para>В первой форме агрегатного выражения агрегатная функция вызывается для каждой строки. Вторая форма эквивалентна первой, так как указание <literal>ALL</literal> подразумевается по умолчанию. В третьей форме агрегатная функция вызывается для всех различных значений выражения (или набора различных значений, для нескольких выражений), выделенных во входных данных. В четвёртой форме агрегатная функция вызывается для каждой строки, так как никакого конкретного значения не указано (обычно это имеет смысл только для функции <function>count(*)</function>). В последней форме используются <firstterm>сортирующие</firstterm> агрегатные функции, которые будут описаны ниже.</para>

   <para>Большинство агрегатных функций игнорируют значения NULL, так что строки, для которых выражения выдают одно или несколько значений NULL, отбрасываются. Это можно считать истинным для всех встроенных операторов, если явно не говорится об обратном.</para>

   <para>Например, <literal>count(*)</literal> подсчитает общее количество строк, а <literal>count(f1)</literal> только количество строк, в которых <literal>f1</literal> не NULL (так как <function>count</function> игнорирует NULL), а <literal>count(distinct f1)</literal> подсчитает число различных и отличных от NULL значений столбца <literal>f1</literal>.</para>

   <para>Обычно строки данных передаются агрегатной функции в неопределённом порядке и во многих случаях это не имеет значения, например функция <function>min</function> выдаёт один и тот же результат независимо от порядка поступающих данных. Однако некоторые агрегатные функции (такие как <function>array_agg</function> и <function>string_agg</function>) выдают результаты, зависящие от порядка данных. Для таких агрегатных функций можно добавить <replaceable>предложение_order_by</replaceable> и задать нужный порядок. Это <replaceable>предложение_order_by</replaceable> имеет тот же синтаксис, что и предложение <literal>ORDER BY</literal> на уровне запроса, как описано в <xref remap="6" linkend="queries-order"/>, за исключением того, что его выражения должны быть просто выражениями, а не именами результирующих столбцов или числами. Например: <programlisting>SELECT array_agg(a ORDER BY b DESC) FROM table;</programlisting></para>

   <para>Заметьте, что при использовании агрегатных функций с несколькими аргументами, предложение <literal>ORDER BY</literal> идёт после всех аргументов. Например, надо писать так: <programlisting>SELECT string_agg(a, ',' ORDER BY a) FROM table;</programlisting> а не так: <programlisting>SELECT string_agg(a ORDER BY a, ',') FROM table;  -- неправильно</programlisting> Последний вариант синтаксически допустим, но он представляет собой вызов агрегатной функции одного аргумента с двумя ключами <literal>ORDER BY</literal> (при этом второй не имеет смысла, так как это константа).</para>

   <para>Если <replaceable>предложение_order_by</replaceable> дополнено указанием <literal>DISTINCT</literal>, тогда все выражения <literal>ORDER BY</literal> должны соответствовать обычным аргументам агрегатной функции; то есть вы не можете сортировать строки по выражению, не включённому в список <literal>DISTINCT</literal>.</para>

   <note>
    <para>Возможность указывать и <literal>DISTINCT</literal>, и <literal>ORDER BY</literal> в агрегатной функции &mdash; это расширение <productname>&productname;</productname>.</para>
   </note>

   <para>При добавлении <literal>ORDER BY</literal> в обычный список аргументов агрегатной функции, описанном до этого, выполняется сортировка строк для <quote>обычной</quote> агрегатной функции, для которой сортировка необязательна. Но есть подмножество агрегатных функций, <firstterm>сортирующие агрегатные функции</firstterm>, для которых <replaceable>предложение_order</replaceable> является <emphasis>обязательным</emphasis>, обычно потому, что вычисление этой функции имеет смысл только при определённой сортировке входных строк. Типичными примерами сортирующих агрегатных функций являются вычисления ранга и процентиля. Для сортирующей агрегатной функции <replaceable>предложение_order_by</replaceable> записывается внутри <literal>WITHIN GROUP (...)</literal>, что иллюстрирует последний пример, приведённый выше. Выражения в <replaceable>предложении_order_by</replaceable> вычисляются однократно для каждой входной строки как аргументы обычной агрегатной функции, сортируются в соответствии с требованием <replaceable>предложения_order_by</replaceable> и поступают в агрегатную функции как входящие аргументы. (Если же <replaceable>предложение_order_by</replaceable> находится не в <literal>WITHIN GROUP</literal>, оно не передаётся как аргумент(ы) агрегатной функции.) Выражения-аргументы, предшествующие <literal>WITHIN GROUP</literal>, (если они есть), называются <firstterm>непосредственными аргументами</firstterm>, а выражения, указанные в <replaceable>предложении_order_by</replaceable> &mdash; <firstterm>агрегируемыми аргументами</firstterm>. В отличие от аргументов обычной агрегатной функции, непосредственные аргументы вычисляются однократно для каждого вызова функции, а не для каждой строки. Это значит, что они могут содержать переменные, только если эти переменные сгруппированы в <literal>GROUP BY</literal>; это суть то же ограничение, что действовало бы, будь эти непосредственные аргументы вне агрегатного выражения. Непосредственные аргументы обычно используются, например, для указания значения процентиля, которое имеет смысл, только если это конкретное число для всего расчёта агрегатной функции. Список непосредственных аргументов может быть пуст; в этом случае запишите просто <literal>()</literal>, но не <literal>(*)</literal>. (На самом деле <productname>&productname;</productname> примет обе записи, но только первая соответствует стандарту SQL.)</para>

   <para><indexterm><primary>медиана</primary> <seealso>процентиль</seealso></indexterm> Пример вызова сортирующей агрегатной функции: <programlisting>SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-----------------
           50489</programlisting> она получает 50-ый процентиль, или медиану, значения столбца <structfield>income</structfield> из таблицы <structname>households</structname>. В данном случае, <literal>0.5</literal> — это непосредственный аргумент; если бы дробь процентиля менялась от строки к строке, это не имело бы смысла.</para>

   <para>Если добавлено предложение <literal>FILTER</literal>, агрегатной функции подаются только те входные строки, для которых <replaceable>условие_фильтра</replaceable> вычисляется как истинное; другие строки отбрасываются. Например: <programlisting>SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)</programlisting></para>

   <para>Предопределённые агрегатные функции описаны в <xref remap="6" linkend="functions-aggregate"/>. Пользователь также может определить другие агрегатные функции.</para>

   <para>Агрегатное выражение может фигурировать только в списке результатов или в предложении <literal>HAVING</literal> команды <command>SELECT</command>. Во всех остальных предложениях, например <literal>WHERE</literal>, они запрещены, так как эти предложения логически вычисляются до того, как формируются результаты агрегатных функций.</para>

   <para>Когда агрегатное выражение используется в подзапросе (см. <xref remap="4" linkend="sql-syntax-scalar-subqueries"/> и <xref remap="4" linkend="functions-subquery"/>), оно обычно вычисляется для всех строк подзапроса. Но если в аргументах (или в <replaceable>условии_filter</replaceable>) агрегатной функции есть только переменные внешнего уровня, агрегатная функция относится к ближайшему внешнему уровню и вычисляется для всех строк соответствующего запроса. Такое агрегатное выражение в целом является внешней ссылкой для своего подзапроса и на каждом вычислении считается константой. При этом допустимое положение агрегатной функции ограничивается списком результатов и предложением <literal>HAVING</literal> на том уровне запросов, где она находится.</para>
  </sect2>

  <sect2 id="syntax-window-functions">
   <title>Вызовы оконных функций</title>

   <indexterm zone="syntax-window-functions"><primary>оконная функция</primary> <secondary>вызов</secondary></indexterm>

   <indexterm zone="syntax-window-functions"><primary>предложение OVER</primary></indexterm>

   <para><firstterm>Вызов оконной функции</firstterm> представляет собой применение функции, подобной агрегатной, к некоторому набору строк, выбранному запросом. В отличие от обычных агрегатных функций, оконные функции не связаны с группировкой выбранных строк в одну &mdash; каждая строка остаётся отдельной в результате запроса. Однако оконная функция может просканировать все строки, вошедшие в группу текущей строки согласно указанию (списку <literal>PARTITION BY</literal>) при вызове оконной функции. Вызов оконной функции может иметь следующие формы: <synopsis>
<replaceable>имя_функции</replaceable> (<optional><replaceable>выражение</replaceable> <optional>, <replaceable>выражение</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ] OVER <replaceable>имя_окна</replaceable>
<replaceable>имя_функции</replaceable> (<optional><replaceable>выражение</replaceable> <optional>, <replaceable>выражение</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ] OVER ( <replaceable class="parameter">определение_окна</replaceable> )
<replaceable>имя_функции</replaceable> ( * ) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ] OVER <replaceable>имя_окна</replaceable>
<replaceable>имя_функции</replaceable> ( * ) [ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ] OVER ( <replaceable class="parameter">определение_окна</replaceable> )
</synopsis> Здесь <replaceable class="parameter">определение_окна</replaceable> записывается в виде: <synopsis>
[ <replaceable class="parameter">имя_существующего_окна</replaceable> ]
[ PARTITION BY <replaceable class="parameter">выражение</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">выражение</replaceable> [ ASC | DESC | USING <replaceable class="parameter">оператор</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">определение_рамки</replaceable> ]
</synopsis> и необязательное <replaceable class="parameter">определение_рамки</replaceable> может иметь вид: <synopsis>
{ RANGE | ROWS } <replaceable>начало_рамки</replaceable>
{ RANGE | ROWS } BETWEEN <replaceable>начало_рамки</replaceable> AND <replaceable>конец_рамки</replaceable>
</synopsis> Здесь <replaceable>начало_рамки</replaceable> и <replaceable>конец_рамки</replaceable> задаются одним из следующих способов: <synopsis>
UNBOUNDED PRECEDING
<replaceable>значение</replaceable> PRECEDING
CURRENT ROW
<replaceable>значение</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis></para>

   <para>Здесь <replaceable>выражение</replaceable> &mdash; это любое выражение значения, не содержащее вызовов оконных функций.</para>

   <para><replaceable>имя_окна</replaceable> &mdash; ссылка на именованное окно, определённое предложением <literal>WINDOW</literal> в данном запросе. Также возможно написать в скобках полное <replaceable>определение_окна</replaceable>, используя тот же синтаксис определения именованного окна в предложении <literal>WINDOW</literal>; подробнее это описано в справке по <xref linkend="sql-select"/>. Стоит отметить, что запись <literal>OVER имя_окна</literal> не полностью равнозначна <literal>OVER (имя_окна)</literal>; последний вариант подразумевает копирование и изменение определения окна и не будет допустимым, если определение этого окна включает определение рамки.</para>

   <para>Указание <literal>PARTITION BY</literal> группирует строки запроса в <firstterm>разделы</firstterm>, которые затем обрабатываются оконной функцией независимо друг от друга. <literal>PARTITION BY</literal> работает подобно предложению <literal>GROUP BY</literal> на уровне запроса, за исключением того, что его аргументы всегда просто выражения, а не имена выходных столбцов или числа. Без <literal>PARTITION BY</literal> все строки, выдаваемые запросом, рассматриваются как один раздел. Указание <literal>ORDER BY</literal> определяет порядок, в котором оконная функция обрабатывает строки раздела. Оно так же подобно предложению <literal>ORDER BY</literal> на уровне запроса и так же не принимает имена выходных столбцов или числа. Без <literal>ORDER BY</literal> строки обрабатываются в неопределённом порядке.</para>

   <para><replaceable class="parameter">определение_рамки</replaceable> задаёт набор строк, образующих <firstterm>рамку окна</firstterm>, которая представляет собой подмножество строк текущего раздела и используется для оконных функций, работающих с рамкой, а не со всем разделом. Рамку можно указать в режимах <literal>RANGE</literal> или <literal>ROWS</literal>; в любом случае она начинается с положения <replaceable>начало_рамки</replaceable> и заканчивается положением <replaceable>конец_рамки</replaceable>. Если <replaceable>конец_рамки</replaceable> опущен, подразумевается <literal>CURRENT ROW</literal> (текущая строка).</para>

   <para>Если <replaceable>начало_рамки</replaceable> задано как <literal>UNBOUNDED PRECEDING</literal>, рамка начинается с первой строки раздела, а если <replaceable>конец_рамки</replaceable> определён как <literal>UNBOUNDED FOLLOWING</literal>, рамка заканчивается последней строкой раздела.</para>

   <para>В режиме <literal>RANGE</literal> <replaceable>начало_рамки</replaceable>, заданное как <literal>CURRENT ROW</literal>, определяет в качестве начала первую <firstterm>родственную</firstterm> строку (строку, которую <literal>ORDER BY</literal> считает равной текущей), тогда как <replaceable>конец_рамки</replaceable>, заданный как <literal>CURRENT ROW</literal>, определяет концом рамки последнюю родственную (для <literal>ORDER BY</literal>) строку. В режиме <literal>ROWS</literal> вариант <literal>CURRENT ROW</literal> просто обозначает текущую строку.</para>

   <para>Варианты <replaceable>значение</replaceable> <literal>PRECEDING</literal> и <replaceable>значение</replaceable> <literal>FOLLOWING</literal> допускаются только в режиме <literal>ROWS</literal>. Они указывают, что рамка начинается или заканчивается со сдвигом на заданное число строк перед или после заданной строки. Здесь <replaceable>значение</replaceable> должно быть целочисленным выражением, не содержащим переменные, агрегатные или оконные функции, и может быть нулевым, что будет означать выбор текущей строки.</para>

   <para>По умолчанию рамка определяется как <literal>RANGE UNBOUNDED PRECEDING</literal>, что равносильно расширенному определению <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</literal>. С указанием <literal>ORDER BY</literal> это означает, что рамка будет включать все строки от начала раздела до последней строки, родственной текущей (для <literal>ORDER BY</literal>). Без <literal>ORDER BY</literal> в рамку включаются все строки раздела, так как все они считаются родственными текущей.</para>

   <para>Действуют также ограничения: <replaceable>начало_рамки</replaceable> не может определяться как <literal>UNBOUNDED FOLLOWING</literal>, а <replaceable>конец_рамки</replaceable> &mdash; <literal>UNBOUNDED PRECEDING</literal>, и <replaceable>конец_рамки</replaceable> не может определяться раньше, чем <replaceable>начало_рамки</replaceable> &mdash; например, запись <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>значение</replaceable> PRECEDING</literal> недопустима.</para>

   <para>Если добавлено предложение <literal>FILTER</literal>, оконной функции подаются только те входные строки, для которых <replaceable>условие_фильтра</replaceable> вычисляется как истинное; другие строки отбрасываются. Предложение <literal>FILTER</literal> допускается только для агрегирующих оконных функций.</para>

   <para>Встроенные оконные функции описаны в <xref remap="6" linkend="functions-window-table"/>, но этот набор можно расширить, создавая собственные функции. Кроме того, в качестве оконных функций можно использовать любые встроенные или пользовательские обычные агрегатные функции (сортирующие агрегатные функции использовать в качестве оконных нельзя).</para>

   <para>Запись со звёздочкой (<literal>*</literal>) применяется при вызове агрегатных функций в качестве оконных, например <literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>. Звёздочка (<literal>*</literal>) обычно не применяется для не агрегатных оконных функций. Агрегатные оконные функции, в отличие от обычных агрегатных функций, не допускают использования <literal>DISTINCT</literal> и <literal>ORDER BY</literal> в списке аргументов.</para>

   <para>Вызовы оконных функций разрешены в запросах только в списке <literal>SELECT</literal> и в предложении <literal>ORDER BY</literal>.</para>

   <para>Дополнительно об оконных функциях можно узнать в <xref remap="6" linkend="tutorial-window"/>, <xref remap="6" linkend="functions-window"/> и <xref remap="6" linkend="queries-window"/>.</para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
   <title>Приведения типов</title>

   <indexterm><primary>тип данных</primary> <secondary>приведение типа</secondary></indexterm>

   <indexterm><primary>приведение типа</primary></indexterm>

   <indexterm><primary>::</primary></indexterm>

   <para>Приведение типа определяет преобразование данных из одного типа в другой. <productname>&productname;</productname> воспринимает две равносильные записи приведения типов: <synopsis>
CAST ( <replaceable>выражение</replaceable> AS <replaceable>тип</replaceable> )
<replaceable>выражение</replaceable>::<replaceable>тип</replaceable>
</synopsis> Запись с <literal>CAST</literal> соответствует стандарту SQL, тогда как вариант с <literal>::</literal> &mdash; историческое наследие <productname>&productname;</productname>.</para>

   <para>Когда приведению подвергается значение выражения известного типа, происходит преобразование типа во время выполнения. Это приведение будет успешным, только если определён подходящий оператор преобразования типов. Обратите внимание на небольшое отличие от приведения констант, описанного в <xref remap="6" linkend="sql-syntax-constants-generic"/>. Приведение строки в чистом виде представляет собой начальное присваивание строковой константы и оно будет успешным для любого типа (конечно, если строка содержит значение, приемлемое для данного типа данных).</para>

   <para>Неявное приведение типа можно опустить, если возможно однозначно определить, какой тип должно иметь выражение (например, когда оно присваивается столбцу таблицы); в таких случаях система автоматически преобразует тип. Однако автоматическое преобразование выполняется только для приведений с пометкой <quote>допускается неявное применение</quote> в системных каталогах. Все остальные приведения должны записываться явно. Это ограничение позволяет избежать сюрпризов с неявным преобразованием.</para>

   <para>Также можно записать приведение типа как вызов функции: <synopsis>
<replaceable>имя_типа</replaceable> ( <replaceable>выражение</replaceable> )
</synopsis> Однако это будет работать только для типов, имена которых являются также допустимыми именами функций. Например, <literal>double precision</literal> так использовать нельзя, а <literal>float8</literal> (альтернативное название того же типа) &mdash; можно. Кроме того, имена типов <literal>interval</literal>, <literal>time</literal> и <literal>timestamp</literal> из-за синтаксического конфликта можно использовать в такой записи только в кавычках. Таким образом, запись приведения типа в виде вызова функции провоцирует несоответствия и, возможно, лучше будет её не применять.</para>

   <note>
    <para>Приведение типа, представленное в виде вызова функции, на самом деле соответствует внутреннему механизму. Даже при использовании двух стандартных типов записи внутри происходит вызов зарегистрированной функции, выполняющей преобразование. По соглашению именем такой функции преобразования является имя выходного типа, и таким образом запись <quote>в виде вызова функции</quote> есть не что иное, как прямой вызов нижележащей функции преобразования. При создании переносимого приложения на это поведение, конечно, не следует рассчитывать. Подробнее это описано в справке <xref linkend="sql-createcast"/>.</para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
   <title>Применение правил сортировки</title>

   <indexterm><primary>COLLATE</primary></indexterm>

   <para>Предложение <literal>COLLATE</literal> переопределяет правило сортировки выражения. Оно добавляется после выражения: <synopsis>
<replaceable>выражение</replaceable> COLLATE <replaceable>правило_сортировки</replaceable>
</synopsis> где <replaceable>правило_сортировки</replaceable> &mdash; идентификатор правила, возможно дополненный именем схемы. Предложение <literal>COLLATE</literal> связывает выражение сильнее, чем операторы, так что при необходимости следует использовать скобки.</para>

   <para>Если правило сортировки не определено явно, система либо выбирает его по столбцам, которые используются в выражении, либо, если таких столбцов нет, переключается на установленное для базы данных правило сортировки по умолчанию.</para>

   <para>Предложение <literal>COLLATE</literal> имеет два распространённых применения: переопределение порядка сортировки в предложении <literal>ORDER BY</literal>, например: <programlisting>SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";</programlisting> и переопределение правил сортировки при вызове функций или операторов, возвращающих языкозависимые результаты, например: <programlisting>SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";</programlisting> Заметьте, что в последнем случае предложение <literal>COLLATE</literal> добавлено к аргументу оператора, на действие которого мы хотим повлиять. При этом не имеет значения, к какому именно аргументу оператора или функции добавляется <literal>COLLATE</literal>, так как правило сортировки, применяемое к оператору или функции, выбирается при рассмотрении всех аргументов, а явное предложение <literal>COLLATE</literal> переопределяет правила сортировки для всех других аргументов. (Однако добавление разных предложений <literal>COLLATE</literal> к нескольким аргументам будет ошибкой. Подробнее об этом см. <xref remap="4" linkend="collation"/>.) Таким образом, эта команда выдаст тот же результат: <programlisting>SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';</programlisting> Но это будет ошибкой: <programlisting>SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";</programlisting> здесь правило сортировки нельзя применить к результату оператора <literal>&gt;</literal>, который имеет несравниваемый тип данных <type>boolean</type>.</para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
   <title>Скалярные подзапросы</title>

   <indexterm><primary>подзапрос</primary></indexterm>

   <para>Скалярный подзапрос &mdash; это обычный запрос <command>SELECT</command> в скобках, который возвращает ровно одну строку и один столбец. (Написание запросов освещается в <xref remap="6" linkend="queries"/>.) После выполнения запроса <command>SELECT</command> его единственный результат используется в окружающем его выражении. В качестве скалярного подзапроса нельзя использовать запросы, возвращающие более одной строки или столбца. (Но если в результате выполнения подзапрос не вернёт строк, скалярный результат считается равным NULL.) В подзапросе можно ссылаться на переменные из окружающего запроса; в процессе одного вычисления подзапроса они будут считаться константами. Другие выражения с подзапросами описаны в <xref remap="6" linkend="functions-subquery"/>.</para>

   <para>Например, следующий запрос находит самый населённый город в каждом штате: <programlisting>SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;</programlisting></para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
   <title>Конструкторы массивов</title>

   <indexterm><primary>массив</primary> <secondary>конструктор</secondary></indexterm>

   <indexterm><primary>ARRAY</primary></indexterm>

   <para>Конструктор массива &mdash; это выражение, которое создаёт массив, определяя значения его элементов. Конструктор простого массива состоит из ключевого слова <literal>ARRAY</literal>, открывающей квадратной скобки <literal>[</literal>, списка выражений (разделённых запятыми), задающих значения элементов массива, и закрывающей квадратной скобки <literal>]</literal>. Например: <programlisting>SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</programlisting> По умолчанию типом элементов массива считается общий тип для всех выражений, определённый по правилам, действующим и для конструкций <literal>UNION</literal> и <literal>CASE</literal> (см. <xref remap="4" linkend="typeconv-union-case"/>). Вы можете переопределить его явно, приведя конструктор массива к требуемому типу, например: <programlisting>SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)</programlisting> Это равносильно тому, что привести к нужному типу каждое выражение по отдельности. Подробнее приведение типов описано в <xref remap="6" linkend="sql-syntax-type-casts"/>.</para>

   <para>Многомерные массивы можно образовывать, вкладывая конструкторы массивов. При этом во внутренних конструкторах слово <literal>ARRAY</literal> можно опускать. Например, результат работы этих конструкторов одинаков: <programlisting>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</programlisting> Многомерные массивы должны быть прямоугольными, и поэтому внутренние конструкторы одного уровня должны создавать вложенные массивы одинаковой размерности. Любое приведение типа, применённое к внешнему конструктору <literal>ARRAY</literal>, автоматически распространяется на все внутренние.</para>

  <para>Элементы многомерного массива можно создавать не только вложенными конструкторами <literal>ARRAY</literal>, но и другими способами, позволяющими получить массивы нужного типа. Например: <programlisting>CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)</programlisting></para>

  <para>Вы можете создать и пустой массив, но так как массив не может быть не типизированным, вы должны явно привести пустой массив к нужному типу. Например: <programlisting>SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)</programlisting></para>

  <para>Также возможно создать массив из результатов подзапроса. В этом случае конструктор массива записывается так же с ключевым словом <literal>ARRAY</literal>, за которым в круглых скобках следует подзапрос. Например: <programlisting>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)</programlisting> Такой подзапрос должен возвращать один столбец. Если этот столбец имеет тип, отличный от массива, результирующий одномерный массив будет включать элементы для каждой строки-результата подзапроса и типом элемента будет тип столбца результата. Если же тип столбца — массив, будет создан массив того же типа, но большей размерности; в любом случае во всех строках подзапроса должны выдаваться массивы одинаковой размерности, чтобы можно было получить прямоугольный результат.</para>

  <para>Индексы массива, созданного конструктором <literal>ARRAY</literal>, всегда начинаются с одного. Подробнее о массивах вы узнаете в <xref remap="6" linkend="arrays"/>.</para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
   <title>Конструкторы табличных строк</title>

   <indexterm><primary>составной тип</primary> <secondary>конструктор</secondary></indexterm>

   <indexterm><primary>тип табличной строки</primary> <secondary>конструктор</secondary></indexterm>

   <indexterm><primary>ROW</primary></indexterm>

   <para>Конструктор табличной строки &mdash; это выражение, создающее строку или кортеж (или составное значение) из значений его аргументов-полей. Конструктор строки состоит из ключевого слова <literal>ROW</literal>, открывающей круглой скобки, нуля или нескольких выражений (разделённых запятыми), определяющих значения полей, и закрывающей скобки. Например: <programlisting>SELECT ROW(1,2.5,'this is a test');</programlisting> Если в списке более одного выражения, ключевое слово <literal>ROW</literal> можно опустить.</para>

   <para>Конструктор строки поддерживает запись <replaceable>составное_значение</replaceable><literal>.*</literal>, при этом данное значение будет развёрнуто в список элементов, так же, как в записи <literal>.*</literal> на верхнем уровне списка <command>SELECT</command> (см. <xref remap="4" linkend="rowtypes-usage"/>). Например, если таблица <literal>t</literal> содержит столбцы <literal>f1</literal> и <literal>f2</literal>, эти записи равнозначны: <programlisting>SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;</programlisting></para>

   <note>
    <para>До версии <productname>PostgreSQL</productname> 8.2 запись <literal>.*</literal> не разворачивалась в конструкторах строк, так что выражение <literal>ROW(t.*, 42)</literal> создавало составное значение из двух полей, в котором первое поле так же было составным. Новое поведение обычно более полезно. Если вам нужно получить прежнее поведение, чтобы одно значение строки было вложено в другое, напишите внутреннее значение без <literal>.*</literal>, например: <literal>ROW(t, 42)</literal>.</para>
   </note>

   <para>По умолчанию значение, созданное выражением <literal>ROW</literal>, имеет тип анонимной записи. Если необходимо, его можно привести к именованному составному типу &mdash; либо к типу строки таблицы, либо составному типу, созданному оператором <command>CREATE TYPE AS</command>. Явное приведение может потребоваться для достижения однозначности. Например: <programlisting>CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Приведение не требуется, так как существует только одна getf1()
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Теперь приведение необходимо для однозначного выбора функции:
SELECT getf1(ROW(1,2.5,'this is a test'));
ОШИБКА:  функция getf1(record) не уникальна

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)</programlisting></para>

  <para>Используя конструктор строк (кортежей), можно создавать составное значение для сохранения в столбце составного типа или для передачи функции, принимающей составной параметр. Также вы можете сравнить два составных значения или проверить их с помощью <literal>IS NULL</literal> или <literal>IS NOT NULL</literal>, например: <programlisting>SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

  -- выбрать все строки, содержащие только NULL
SELECT ROW(table.*) IS NULL FROM table;</programlisting> Подробнее см. <xref remap="4" linkend="functions-comparisons"/>. Конструкторы строк также могут использоваться в сочетании с подзапросами, как описано в <xref remap="6" linkend="functions-subquery"/>.</para>

  </sect2>

  <sect2 id="syntax-express-eval">
   <title>Правила вычисления выражений</title>

   <indexterm><primary>выражение</primary> <secondary>порядок вычисления</secondary></indexterm>

   <para>Порядок вычисления подвыражений не определён. В частности, аргументы оператора или функции не обязательно вычисляются слева направо или в любом другом фиксированном порядке.</para>

   <para>Более того, если результат выражения можно получить, вычисляя только некоторые его части, тогда другие подвыражения не будут вычисляться вовсе. Например, если написать: <programlisting>SELECT true OR somefunc();</programlisting> тогда функция <literal>somefunc()</literal> не будет вызываться (возможно). То же самое справедливо для записи: <programlisting>SELECT somefunc() OR true;</programlisting> Заметьте, что это отличается от <quote>оптимизации</quote> вычисления логических операторов слева направо, реализованной в некоторых языках программирования.</para>

   <para>Как следствие, в сложных выражениях не стоит использовать функции с побочными эффектами. Особенно опасно рассчитывать на порядок вычисления или побочные эффекты в предложениях <literal>WHERE</literal> и <literal>HAVING</literal>, так как эти предложения тщательно оптимизируются при построении плана выполнения. Логические выражения (сочетания <literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal>) в этих предложениях могут быть видоизменены любым способом, допустимым законами Булевой алгебры.</para>

   <para>Когда порядок вычисления важен, его можно зафиксировать с помощью конструкции <literal>CASE</literal> (см. <xref remap="4" linkend="functions-conditional"/>). Например, такой способ избежать деления на ноль в предложении <literal>WHERE</literal> ненадёжен: <programlisting>SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;</programlisting> Безопасный вариант: <programlisting>SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</programlisting> Применяемая так конструкция <literal>CASE</literal> защищает выражение от оптимизации, поэтому использовать её нужно только при необходимости. (В данном случае было бы лучше решить проблему, переписав условие как <literal>y &gt; 1.5*x</literal>.)</para>

   <para>Однако, <literal>CASE</literal> не всегда спасает в подобных случаях. Показанный выше приём плох тем, что не предотвращает раннее вычисление константных подвыражений. Как описано в <xref remap="6" linkend="xfunc-volatility"/>, функции и операторы, помеченные как <literal>IMMUTABLE</literal>, могут вычисляться при планировании, а не выполнении запроса. Поэтому в примере <programlisting>SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;</programlisting>, скорее всего, произойдёт деление на ноль из-за того, что планировщик попытается упростить константное подвыражение, даже если во всех строках в таблице <literal>x &gt; 0</literal>, а значит во время выполнения ветвь <literal>ELSE</literal> никогда не будет выполняться.</para>

   <para>Хотя этот конкретный пример может показаться надуманным, похожие ситуации, в которых неявно появляются константы, могут возникать и в запросах внутри функций, так как значения аргументов функции и локальных переменных при планировании могут быть заменены константами. Поэтому например, в функциях <application>PL/pgSQL</application> гораздо безопаснее для защиты от рискованных вычислений использовать конструкцию <literal>IF</literal>-<literal>THEN</literal>-<literal>ELSE</literal>, чем выражение <literal>CASE</literal>.</para>

   <para>Ещё один подобный недостаток этого подхода в том, что <literal>CASE</literal> не может предотвратить вычисление заключённого в нём агрегатного выражения, так как агрегатные выражения вычисляются перед всеми остальными в списке <literal>SELECT</literal> или предложении <literal>HAVING</literal>. Например, в следующем запросе может возникнуть ошибка деления на ноль, несмотря на то, что он вроде бы защищён от неё: <programlisting>SELECT CASE WHEN min(employees) &gt; 0
            THEN avg(expenses / employees)
       END
    FROM departments;</programlisting> Агрегатные функции <function>min()</function> и <function>avg()</function> вычисляются независимо по всем входным строкам, так что если в какой-то строке поле <structfield>employees</structfield> окажется равным нулю, деление на ноль произойдёт раньше, чем станет возможным проверить результат функции <function>min()</function>. Поэтому, чтобы проблемные входные строки изначально не попали в агрегатную функцию, следует воспользоваться предложениями <literal>WHERE</literal> или <literal>FILTER</literal>.</para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
  <title>Вызов функций</title>

   <indexterm zone="sql-syntax-calling-funcs"><primary>запись</primary> <secondary>функций</secondary></indexterm>

   <para><productname>&productname;</productname> позволяет вызывать функции с именованными параметрами, используя запись с <firstterm>позиционной</firstterm> или <firstterm>именной</firstterm> передачей аргументов. Именная передача особенно полезна для функций со множеством параметров, так как она делает связь параметров и аргументов более явной и надёжной. В позиционной записи значения аргументов функции указываются в том же порядке, в каком они описаны в определении функции. При именной передаче аргументы сопоставляются с параметрами функции по именам и указывать их можно в любом порядке.</para>

   <para>При записи любым способом параметры, для которых в определении функции заданы значения по умолчанию, можно вовсе не указывать. Но это особенно полезно при именной передаче, так как опустить можно любой набор параметров, тогда как при позиционной параметры можно опускать только последовательно, справа налево.</para>

   <para><productname>&productname;</productname> также поддерживает <firstterm>смешанную</firstterm> передачу, когда параметры передаются и по именам, и по позиции. В этом случае позиционные параметры должны идти перед параметрами, передаваемыми по именам.</para>

   <para>Мы рассмотрим все три варианта записи на примере следующей функции: <programlisting>CREATE FUNCTION concat_lower_or_upper(a text, b text,
  uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;</programlisting> Функция <function>concat_lower_or_upper</function> имеет два обязательных параметра: <literal>a</literal> и <literal>b</literal>. Кроме того, есть один необязательный параметр <literal>uppercase</literal>, который по умолчанию имеет значение <literal>false</literal>. Аргументы <literal>a</literal> и <literal>b</literal> будут сложены вместе и переведены в верхний или нижний регистр, в зависимости от параметра <literal>uppercase</literal>. Остальные тонкости реализации функции сейчас не важны (подробнее о них рассказано в <xref remap="6" linkend="extend"/>).</para>

   <sect2 id="sql-syntax-calling-funcs-positional">
    <title>Позиционная передача</title>

    <indexterm><primary>функция</primary> <secondary>позиционная запись</secondary></indexterm>

    <para>Позиционная передача &mdash; это традиционный механизм передачи аргументов функции в <productname>&productname;</productname>. Пример такой записи: <screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen> Все аргументы указаны в заданном порядке. Результат возвращён в верхнем регистре, так как параметр <literal>uppercase</literal> имеет значение <literal>true</literal>. Ещё один пример: <screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen> Здесь параметр <literal>uppercase</literal> опущен, и поэтому он принимает значение по умолчанию (<literal>false</literal>), и результат переводится в нижний регистр. В позиционной записи любые аргументы с определённым значением по умолчанию можно опускать справа налево.</para>
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
    <title>Именная передача</title>

    <indexterm><primary>функция</primary> <secondary>именная передача</secondary></indexterm>

    <para>При именной передаче для аргумента добавляется имя, которое отделяется от выражения значения знаками <literal>=&gt;</literal>. Например: <screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen> Здесь аргумент <literal>uppercase</literal> был так же опущен, так что он неявно получил значение <literal>false</literal>. Преимуществом такой записи является возможность записывать аргументы в любом порядке, например: <screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World', uppercase =&gt; true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen></para>

    <para>Для обратной совместимости поддерживается и старый синтаксис с ":=": <screen>
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen></para>
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
   <title>Смешанная передача</title>

   <indexterm><primary>функция</primary> <secondary>смешанная запись</secondary></indexterm>

   <para>При смешанной передаче параметры передаются и по именам, и по позиции. Однако, как уже было сказано, именованные аргументы не могут стоять перед позиционными. Например: <screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen> В данном запросе аргументы <literal>a</literal> и <literal>b</literal> передаются по позиции, а <literal>uppercase</literal> &mdash; по имени. Единственное обоснование такого вызова здесь &mdash; он стал чуть более читаемым. Однако для более сложных функций с множеством аргументов, часть из которых имеют значения по умолчанию, именная или смешанная передача позволяют записать вызов эффективнее и уменьшить вероятность ошибок.</para>

   <note>
    <para>Именная и смешанная передача в настоящий момент не может использоваться при вызове агрегатной функции (но они допускаются, если агрегатная функция используется в качестве оконной).</para>
   </note>
  </sect2>
 </sect1>

</chapter>
