<!-- doc/src/xml/protocol.xml -->

<chapter id="protocol">
 <title>Клиент-серверный протокол</title>

 <indexterm zone="protocol"><primary>протокол</primary> <secondary>клиент-серверный</secondary></indexterm>

 <para>Клиенты и серверы <productname>&productname;</productname> взаимодействуют друг с другом, используя специальный протокол, основанный на сообщениях. Этот протокол поддерживается для соединений по <acronym>TCP/IP</acronym> и через доменные сокеты Unix. Для серверов, поддерживающих этот протокол, в IANA зарезервирован номер TCP-порта 5432, но на практике можно задействовать любой порт, не требующий особых привилегий.</para>

 <para>В этой документации описана версия 3.0 этого протокола, реализованная в <productname>PostgreSQL</productname> версии 7.4 и новее. За описанием предыдущих версий протокола обратитесь к документации более ранних выпусков <productname>PostgreSQL</productname>. Один сервер способен поддерживать несколько версий протокола. Из стартового сообщения при установлении соединения сервер узнаёт, какую версию протокола пытается использовать клиент, и если сервер поддерживает запрошенную версию, он продолжает обмен по этому протоколу.</para>

  <para>Чтобы эффективно обслуживать множество клиентов, сервер запускает отдельный <quote>обслуживающий</quote> процесс для каждого клиента. В текущей реализации новый дочерний процесс запускается немедленно после обнаружения входящего подключения. Однако это происходит прозрачно для протокола. С точки зрения протокола, термины <quote>обслуживающий процесс</quote>, <quote>процесс заднего плана</quote> и <quote>сервер</quote> взаимозаменяемы, как и <quote>приложение переднего плана</quote> и <quote>клиент</quote>.</para>

 <sect1 id="protocol-overview">
  <title>Обзор</title>

  <para>В протоколе выделены отдельные фазы для запуска и обычных операций. На стадии запуска клиент устанавливает подключение к серверу и должен удовлетворить сервер, подтвердив свою подлинность. (Для этого может потребоваться одно или несколько сообщений, в зависимости от применяемого метода проверки подлинности.) Если всё проходит успешно, сервер сообщает клиенту о текущем состоянии, а затем переходит к обычной работе. Не считая начального стартового сообщения, в этой фазе протокола ведущую роль играет сервер.</para>

  <para>В ходе обычной работы клиент передаёт запросы и другие команды серверу, а сервер возвращает результаты запросов и другие ответы. В некоторых случаях (например, с <command>NOTIFY</command>) сервер передаёт клиенту сообщения по своей инициативе, но по большей части эта фаза сеанса управляется запросами клиента.</para>

  <para>Завершение сеанса обычно происходит по желанию клиента, но в некоторых случаях и сервер может принудительно завершить сеанс. В любом случае, когда сервер закрывает соединение, он предварительно откатывает любую открытую (незавершённую) транзакцию.</para>

  <para>В процессе обычной работы команды SQL могут выполняться по одному из двух внутренних протоколов. По протоколу <quote>простых запросов</quote> клиент посылает просто текстовую строку запроса, которую сервер сразу же разбирает и выполняет. С протоколом <quote>расширенных запросов</quote> обработка запросов разделяется на несколько этапов: разбор, привязывание значений параметров и исполнение. Это даёт дополнительную гибкость и может увеличить быстродействие ценой большей сложности.</para>

  <para>В обычном режиме также поддерживаются дополнительные внутренние протоколы для специальных операций, например <command>COPY</command>.</para>

 <sect2 id="protocol-message-concepts">
  <title>Обзор обмена сообщениями</title>

  <para>Всё взаимодействие представляет собой поток сообщений. Первый байт сообщения определяет тип сообщения, а следующие четыре байта задают длину остального сообщения (эта длина включает размер самого поля длины, но не байт с типом сообщения). Остальное содержимое сообщения определяется его типом. По историческим причинам в самом первом сообщении, передаваемом клиентом, (стартовом сообщении) первый байт с типом сообщения отсутствует.</para>

  <para>Чтобы не потерять синхронизацию в потоке сообщений, и серверы, и клиенты обычно считывают всё сообщение в буфер (его размер определяется счётчиком байт), прежде чем обрабатывать его содержимое. Это позволяет без труда продолжить работу, если возникает ошибка при разборе сообщения. В исключительных случаях (например, при нехватке памяти для помещения сообщения в буфер), счётчик байт помогает получателю определить, сколько поступающих байт нужно пропустить, прежде чем продолжать получать сообщения.</para>

  <para>С другой стороны, и клиенты, и серверы, ни при каких условиях не должны передавать неполные сообщения. Чтобы этого не допустить, обычно всё сообщение сначала размещается в буфере, и только потом передаётся. Если в процессе отправки или получения сообщения происходит сбой передачи, единственным разумным вариантом продолжения будет прерывание соединения, так как вероятность восстановления синхронизации по границам сообщений в этой ситуации минимальна.</para>
 </sect2>

  <sect2 id="protocol-query-concepts">
   <title>Обзор расширенных запросов</title>

   <para>В протоколе расширенных запросов исполнение команд SQL разделяется на несколько этапов. Состояние между этапами представляется объектами двух типов: <firstterm>подготовленные операторы</firstterm> и <firstterm>порталы</firstterm>. Подготовленный оператор представляет собой результат разбора и семантического анализа текстовой строки запроса. Подготовленный оператор сам по себе не готов для исполнения, так как он может не иметь конкретных значений для <firstterm>параметров</firstterm>. Портал представляет собой готовый к исполнению или уже частично выполненный оператор, в котором заданы все недостающие значения параметров. (Для операторов <command>SELECT</command> портал равнозначен открытому курсору, но мы выбрали другой термин, так как курсоры неприменимы к операторам, отличным от <command>SELECT</command>.)</para>

   <para>Общий цикл выполнения состоит из этапа <firstterm>разбора</firstterm>, на котором из текстовой строки запроса создаётся подготовленный оператор; этапа <firstterm>привязки</firstterm>, на котором из подготовленного оператора и значений для необходимых параметров создаётся портал; и этапа <firstterm>выполнения</firstterm>, на котором исполняется запрос портала. В случае запроса, возвращающего строки (<command>SELECT</command>, <command>SHOW</command> и т. д.), можно указать, чтобы за один шаг выполнения возвращалось только ограниченное число строк, так что для завершения операции понадобятся несколько шагов выполнения.</para>

   <para>Сервер может контролировать одновременно несколько подготовленных операторов и порталов (но учтите, что они существуют только в рамках сеанса и никогда не разделяются между сеансами). Обращаться к подготовленным операторам и порталам можно по именам, которые назначаются им при создании. Кроме того, существуют и <quote>безымянные</quote> подготовленные операторы и порталы. Хотя они практически не отличаются от именованных объектов, операции с ними оптимизированы для разового выполнения запроса с последующим освобождением объекта, тогда как операции с именованными объектами оптимизируются в расчёте на многоразовое использование.</para>
  </sect2>

  <sect2 id="protocol-format-codes">
   <title>Форматы и коды форматов</title>

   <para>Данные определённого типа могут передаваться в одном из нескольких различных <firstterm>форматов</firstterm>. С версии 7.4 <productname>PostgreSQL</productname> поддерживаются только текстовый (<quote>text</quote>) и двоичный (<quote>binary</quote>) форматы, но в протоколе предусмотрены возможности для расширения в будущем. Ожидаемый формат для любого значения задаётся <firstterm>кодом формата</firstterm>. Клиенты могут указывать код формата для каждого передаваемого значения параметра и для каждого столбца результата запроса. Текстовый формат имеет код ноль, двоичный — код один, а другие коды оставлены для определения в будущем.</para>

   <para>Текстовым представлением значений будут строки, которые выдаются и принимаются функциями ввода/вывода определённого типа данных. В передаваемом представлении завершающий нулевой символ отсутствует, клиент должен добавить его сам, если хочет обрабатывать такое представление в виде строки C. (Собственно, данные в текстовом формате не могут содержать нулевые символы.)</para>

   <para>В двоичном представлении целых чисел применяется сетевой порядок байт (наиболее значащий байт первый). Какое именно двоичное представление имеют другие типы данных, можно узнать в документации или исходном коде. Но учтите, что двоичное представление сложных типов данных может меняться от версии к версии сервера; с точки зрения портируемости обычно лучше текстовый формат.</para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
  <title>Поток сообщений</title>

  <para>В этом разделе описывается поток сообщений и семантика каждого типа сообщений. (Подробнее точное представление каждого сообщения описывается в <xref remap="6" linkend="protocol-message-formats"/>.) В зависимости от состояния соединения выделяются несколько различных подразделов протокола: запуск, запрос, вызов функции, копирование (<command>COPY</command>) и завершение. Есть также специальные средства для асинхронных операций (в частности, для уведомлений и отмены команд), которые могут выполняться в любой момент после этапа запуска.</para>

  <sect2>
   <title>Запуск</title>

   <para>Чтобы начать сеанс, клиент открывает подключение к серверу и передаёт стартовое сообщение. В этом сообщении содержатся имена пользователя и базы данных, к которой пользователь хочет подключиться; в нём также определяется, какая именно версия протокола будет использоваться. (Стартовое сообщение также может содержать дополнительные значения для параметров времени выполнения.) Проанализировав эту информацию и содержимое своих файлов конфигурации (в частности, <filename>pg_hba.conf</filename>), сервер определяет, можно ли предварительно разрешить это подключение, и какая дополнительная проверка подлинности требуется.</para>

   <para>Затем сервер отправляет соответствующее сообщение с запросом аутентификации, на которое клиент должен ответить сообщением, подтверждающим его подлинность (например, по паролю). Для всех методов аутентификации, за исключением GSSAPI, SSPI и SASL, может быть максимум один запрос и один ответ. Для некоторых методов ответ клиента вообще не требуется, так что запрос аутентификации также не передаётся. Методы GSSAPI, SSPI и SASL для прохождения проверки подлинности могут потребовать выполнить серию обменов пакетами.</para>

   <para>Цикл аутентификации заканчивает сервер, либо запрещая соединение (ErrorResponse), либо принимая его (отправляя AuthenticationOk).</para>

   <para>Сервер может передавать в этой фазе следующие сообщения: <variablelist>
     <varlistentry>
      <term>ErrorResponse (Ошибочный ответ)</term>
      <listitem>
       <para>Попытка соединения была отвергнута. Сразу после этого сервер закрывает соединение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk (Аутентификация пройдена)</term>
      <listitem>
       <para>Обмен сообщениями для проверки подлинности завершён успешно.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV5 (Аутентификация Kerberos V5)</term>
      <listitem>
       <para>Клиент должен теперь принять участие в диалоге аутентификации по протоколу Kerberos V5 (здесь его детали не описывается, так как они относятся к спецификации Kerberos) с сервером. Если этот диалог завершается успешно, сервер отвечает AuthenticationOk, иначе — ErrorResponse. Этот вариант аутентификации больше не поддерживается.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationCleartextPassword (Аутентификация с открытым паролем)</term>
      <listitem>
       <para>Клиент должен передать в ответ сообщение PasswordMessage, содержащее пароль в открытом виде. Если пароль правильный, сервер отвечает ему AuthenticationOk, иначе — ErrorResponse.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationMD5Password (Аутентификация с паролем MD5)</term>
      <listitem>
       <para>Клиент должен передать в ответ сообщение PasswordMessage с результатом преобразования пароля (и имени пользователя) в хеш MD5 с последующим хешированием с четырёхбайтовым случайным значением соли, переданным в сообщении AuthenticationMD5Password. Если пароль правильный, сервер отвечает AuthenticationOk, иначе — ErrorResponse. Содержимое сообщения PasswordMessage можно вычислить в SQL как <literal>concat('md5', md5(concat(md5(concat(password, username)), random-salt)))</literal>. (Учтите, что функция <function>md5()</function> возвращает результат в виде шестнадцатеричной строки.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSCMCredential (Аутентификация по учётным данным SCM)</term>
      <listitem>
       <para>Этот ответ возможен только для локальных подключений через доменные сокеты Unix на платформах, поддерживающих сообщения с учётными данными SCM. Клиент должен выдать сообщение с учётными данными SCM и дополнительно отправить один байт данных. (Содержимое этого байта не представляет интереса; его нужно передавать, только чтобы сервер дожидался сообщения с учётными данными.) Если сервер принимает учётные данные, он отвечает AuthenticationOk, иначе — ErrorResponse. (Этот тип сообщений выдают только серверы версии до 9.1. В конце концов он может быть исключён из спецификации протокола.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS (Аутентификация GSS)</term>
      <listitem>
       <para>Клиент должен начать согласование GSSAPI. В ответ на это сообщение клиент отправляет PasswordMessage с первой частью потока данных GSSAPI. Если потребуются дополнительные сообщения, сервер передаст в ответ AuthenticationGSSContinue.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI (Аутентификация SSPI)</term>
      <listitem>
       <para>Клиент должен начать согласование SSPI. В ответ на это сообщение клиент отправляет PasswordMessage с первой частью потока данных SSPI. Если потребуются дополнительные сообщения, сервер передаст в ответ AuthenticationGSSContinue.</para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationGSSContinue (Продолжение аутентификации GSS)</term>
      <listitem>
       <para>Это сообщение содержит данные ответа на предыдущий шаг согласования GSSAPI или SSPI (AuthenticationGSS, AuthenticationSSPI или предыдущего AuthenticationGSSContinue). Если в структуре GSSAPI или SSPI в этом сообщении указывается, что для завершения аутентификации требуются дополнительные данные, клиент должен передать их в очередном сообщении PasswordMessage. Если этим сообщением завершается проверка подлинности GSSAPI или SSPI, сервер затем передаёт AuthenticationOk, сообщая об успешной проверке подлинности, либо ErrorResponse, сообщая об ошибке.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASL</term>
      <listitem>
       <para>После этого клиент должен начать согласование SASL, используя механизм SASL, указанный в сообщении. То есть он должен послать сообщение PasswordMessage с первым блоком потока данных SASL. Если от клиента потребуются дополнительные данные, сервер ответит сообщением AuthenticationSASLContinue.</para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationSASLContinue</term>
      <listitem>
       <para>Это сообщение содержит данные ответа после предыдущего этапа согласования SASL (AuthenticationSASL, либо предыдущего AuthenticationSASLContinue). Если содержимое SASL в этом сообщение указывает на то, что для завершения аутентификации необходимы дополнительные данные, клиент должен передать эти данные в виде ещё одного сообщения PasswordMessage. Если проверка подлинности SASL завершается этим сообщением, сервер посылает AuthenticationOk, сообщая об успешной аутентификации, либо ErrorResponse, сообщая об ошибке.</para>
      </listitem>
     </varlistentry>

    </variablelist></para>

   <para>Если клиент не поддерживает метод проверки подлинности, запрошенный сервером, он должен немедленно закрыть соединение.</para>

   <para>Получив сообщение AuthenticationOk, клиент должен ждать дальнейших сообщений от сервера. В этой фазе запускается обслуживающий процесс, а клиент представляет собой просто заинтересованного наблюдателя. Ошибка запуска может быть неудачной (и клиент получит ErrorResponse), но в обычной ситуации обслуживающий процесс передаёт несколько сообщений ParameterStatus, BackendKeyData и, наконец, ReadyForQuery.</para>

   <para>В ходе этой фазы обслуживающий процесс попытается применить все параметры времени выполнения, полученные в стартовом сообщении. Если это удастся, эти значения становятся сеансовыми значениями по умолчанию. При ошибке он передаёт ErrorResponse и завершается.</para>

   <para>Обслуживающий процесс может передавать в этой фазе следующие сообщения: <variablelist>
     <varlistentry>
      <term>BackendKeyData (Данные ключа сервера)</term>
      <listitem>
       <para>В этом сообщении передаётся секретный ключ, который клиент должен сохранить, чтобы впоследствии иметь возможность выполнять запросы. Клиент не должен отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ParameterStatus (Состояние параметров)</term>
      <listitem>
       <para>Это сообщение говорит клиенту о текущих (начальных) значениях параметров обслуживающего процесса, например, <xref linkend="guc-client-encoding"/> или <xref linkend="guc-datestyle"/>. Клиент может проигнорировать это сообщение или сохранить значения для дальнейшего использования; за дополнительными подробностями обратитесь к <xref remap="3" linkend="protocol-async"/>. Клиент не должен отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery (Готов к запросам)</term>
      <listitem>
       <para>Запуск завершён. Теперь клиент может выполнять команды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse (Ошибочный ответ)</term>
      <listitem>
       <para>Запуск не удался. Соединение закрывается после передачи этого сообщения.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse (Ответ с замечанием)</term>
      <listitem>
       <para>Выдаётся предупреждающее сообщение. Клиент должен вывести это сообщение, но продолжать ожидать сообщения ReadyForQuery или ErrorResponse.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>

   <para>Сообщение ReadyForQuery в данной фазе ничем не отличается от сообщений, который передаёт сервер после каждого цикла команд. В зависимости от условий реализации клиента, можно воспринимать сообщение ReadyForQuery как начинающее цикл команд, либо как завершающее фазу запуска и каждый последующий цикл команд.</para>
  </sect2>

  <sect2>
   <title>Простой запрос</title>

   <para>Цикл простого запроса начинает клиент, передавая серверу сообщение Query. Это сообщение включает команду (или команды) SQL, выраженную в виде текстовой строки. В ответ сервер передаёт одно или несколько сообщений, в зависимости от строки запроса, и завершает цикл сообщением ReadyForQuery. ReadyForQuery говорит клиенту, что он может безопасно передавать новую команду. (На самом деле клиент может передать следующую команду, не дожидаясь ReadyForQuery, но тогда он сам должен разобраться в ситуации, когда первая команда завершается ошибкой, а последующая выполняется успешно.)</para>

   <para>Сервер может передавать в этой фазе следующие ответные сообщения: <variablelist>
     <varlistentry>
      <term>CommandComplete (Команда завершена)</term>
      <listitem>
       <para>Команда SQL выполнена нормально.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyInResponse (Ответ входящего копирования)</term>
      <listitem>
       <para>Сервер готов копировать данные, получаемые от клиента, в таблицу; см. <xref remap="4" linkend="protocol-copy"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyOutResponse (Ответ исходящего копирования)</term>
      <listitem>
       <para>Сервер готов копировать данные из таблицы клиенту; см. <xref remap="4" linkend="protocol-copy"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>RowDescription (Описание строк)</term>
      <listitem>
       <para>Показывает, что в ответ на запрос <command>SELECT</command>, <command>FETCH</command> и т. п. будут возвращены строки. В содержимом этого сообщения описывается структура столбцов этих строк. За ним для каждой строки, возвращаемой клиенту, следует сообщение DataRow.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DataRow (Строка данных)</term>
      <listitem>
       <para>Одна строка из набора, возвращаемого запросом <command>SELECT</command>, <command>FETCH</command> и т. п.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EmptyQueryResponse (Ответ на пустой запрос)</term>
      <listitem>
       <para>Была принята пустая строка запроса.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse (Ошибочный ответ)</term>
      <listitem>
       <para>Произошла ошибка.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery (Готов к запросам)</term>
      <listitem>
       <para>Обработка строки запроса завершена. Чтобы отметить это, отправляется отдельное сообщение, так как строка запроса может содержать несколько команд SQL. (Сообщение CommandComplete говорит о завершении обработки одной команды SQL, а не всей строки.) ReadyForQuery передаётся всегда, и при успешном завершении обработки, и при ошибке.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse (Ответ с замечанием)</term>
      <listitem>
       <para>Выдаётся предупреждение, связанное с запросом. Эти замечания дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать команду.</para>
      </listitem>
     </varlistentry>

    </variablelist></para>

   <para>Ответ на запрос <command>SELECT</command> (или другие запросы, возвращающие наборы строк, такие как <command>EXPLAIN</command> и <command>SHOW</command>) обычно состоит из RowDescription, нуля или нескольких сообщений DataRow, и завершающего CommandComplete. Для команды <command>COPY</command> с вводом или выводом данных через клиента, применяется специальный протокол, описанный в <xref remap="6" linkend="protocol-copy"/>. Со всеми другими типами запросами обычно выдаётся только сообщение CommandComplete.</para>

   <para>Так как строка запроса может содержать несколько запросов (разделённых точкой с запятой), до завершения обработки всей строки сервер может передать несколько серий таких ответов. Когда сервер завершает обработку всей строки и готов принять следующую строку запроса, он выдаёт сообщение ReadyForQuery.</para>

   <para>Если получена полностью пустая строка запроса (не содержащая ничего, кроме пробельных символов), ответом будет EmptyQueryResponse с последующим ReadyForQuery.</para>

   <para>В случае ошибки выдаётся ErrorResponse с последующим ReadyForQuery. Сообщение ErrorResponse прерывает дальнейшую обработку строки запроса (даже если в ней остались другие запросы). Заметьте, что оно может быть выдано и в середине последовательности сообщений, выдаваемых в ответ на отдельный запрос.</para>

   <para>В режиме простых запросов получаемые значения всегда передаются в текстовом формате, за исключением результатов команды <command>FETCH</command> для курсора, объявленного с атрибутом <literal>BINARY</literal>. С такой командой значения передаются в двоичном формате. Какой именно формат используется, определяют коды формата, передаваемые в сообщении RowDescription.</para>

   <para>Клиент должен быть готов принять сообщения ErrorResponse и NoticeResponse, ожидая любой другой тип сообщений. Также обратитесь к <xref remap="3" linkend="protocol-async"/> за информацией о сообщениях, которые сервер может выдавать в ответ на внешние события.</para>

   <para>Код клиента рекомендуется реализовывать в виде машины состояний, которая в любой момент будет принимать сообщения всех типов, имеющих смысл на данном этапе, но не программировать жёстко обработку точной последовательности сообщений.</para>
  </sect2>

  <sect2 id="protocol-flow-ext-query">
   <title>Расширенный запрос</title>

   <para>Протокол расширенных запросов разбивает вышеописанный протокол простых запросов на несколько шагов. Результаты подготовительных шагов можно неоднократно использовать повторно для улучшения эффективности. Кроме того, он открывает дополнительные возможности, в частности, возможность передавать значения данных в отдельных параметрах вместо того, чтобы внедрять их непосредственно в строку запроса.</para>

   <para>В расширенном протоколе клиент сначала передаёт сообщение Parse с текстовой строкой запроса и, возможно, некоторыми сведениями о типах параметров и именем целевого объекта подготовленного оператора (если имя пустое, создаётся безымянный подготовленный оператор). Ответом на это сообщение будет ParseComplete или ErrorResponse. Типы параметров указываются по OID; при отсутствии явного указания анализатор запроса пытается определить типы данных так же, как он делал бы для нетипизированных строковых констант.</para>

   <note>
    <para>Тип данных параметра можно оставить неопределённым, задав для него значение ноль, либо сделав массив с OID типов параметров короче, чем набор символов параметров (<literal>$</literal><replaceable>n</replaceable>), используемых в строке запроса. Другой особый случай — передача типа параметра как <type>void</type> (то есть передача OID псевдотипа <type>void</type>). Это предусмотрено для того, чтобы символы параметров можно было использовать для параметров функций, на самом деле представляющих собой параметры OUT. Обычно параметр <type>void</type> нельзя использовать ни в каком контексте, но если такой параметр фигурирует в списке параметров функции, он фактически игнорируется. Например, вызову функции <literal>foo($1,$2,$3,$4)</literal> может соответствовать функция с аргументами IN и двумя OUT, если аргументы <literal>$3</literal> и <literal>$4</literal> объявлены как имеющие тип <type>void</type>.</para>
   </note>

   <note>
    <para>Строка запроса, содержащаяся в сообщении Parse, не может содержать больше одного оператора SQL; иначе выдаётся синтаксическая ошибка. Это ограничение отсутствует в протоколе простых запросов, но присутствует в расширенном протоколе, так как добавление поддержки подготовленных операторов или порталов, содержащих несколько команд, неоправданно усложнило бы протокол.</para>
   </note>

   <para>В случае успешного создания именованный подготовленный оператор продолжает существовать до завершения текущего сеанса, если только он не будет уничтожен явно. Безымянный подготовленный оператор сохраняется только до следующей команды Parse, в которой целевым является безымянный оператор. (Заметьте, что сообщение простого запроса также уничтожает безымянный оператор.) Именованные операторы должны явно закрываться, прежде чем их можно будет переопределить другим сообщением Parse, но для безымянных операторов это не требуется. Именованные подготовленные операторы также можно создавать и вызывать на уровне команд SQL, используя команды <command>PREPARE</command> и <command>EXECUTE</command>.</para>

   <para>Когда подготовленный оператор существует, его можно подготовить к выполнению сообщением Bind. В сообщении Bind задаётся имя исходного подготовленного оператора (пустая строка подразумевает безымянный подготовленный оператор), имя целевого портала (пустая строка подразумевает безымянный портал) и значения для любых шаблонов параметров, представленных в подготовленном операторе. Набор передаваемых значений должен соответствовать набору параметров, требующихся для подготовленного оператора. (Если вы объявили параметры <type>void</type> в сообщении Parse, передайте для них значения NULL в сообщении Bind.) Bind также принимает указание формата для данных, возвращаемых в результате запроса; формат можно указать для всех данных, либо для отдельных столбцов. Ответом на это сообщение будет BindComplete или ErrorResponse.</para>

   <note>
    <para>Выбор между текстовым и двоичным форматом вывода определяется кодами формата, передаваемыми в Bind, вне зависимости от команды SQL. При использовании протокола расширенных запросов атрибут <literal>BINARY</literal> в объявлении курсоров не имеет значения.</para>
   </note>

   <para>Планирование запроса обычно имеет место при обработке сообщения Bind. Если подготовленный оператор не имеет параметров, либо он выполняется многократно, сервер может сохранить созданный план и использовать его повторно при последующих сообщениях Bind для того же подготовленного оператора. Однако он будет делать это, только если решит, что можно получить универсальный план, который не будет значительно неэффективнее планов, зависящих от конкретных значений параметров. С точки зрения протокола это происходит незаметно.</para>

   <para>В случае успешного создания объект именованного портала продолжает существование до конца текущей транзакции, если только он не будет уничтожен явно. Безымянный портал уничтожается в конце транзакции или при выполнении следующей команды Bind, в которой в качестве целевого выбирается безымянный портал. (Заметьте, что сообщение простого запроса также уничтожает безымянный портал.) Именованные порталы должны явно закрываться, прежде чем их можно будет явно переопределить другим сообщением Bind, но это не требуется для безымянных порталов. Именованные порталы также можно создавать и вызывать на уровне команд SQL, используя команды <command>DECLARE CURSOR</command> и <command>FETCH</command>.</para>

   <para>Когда портал существует, его можно запустить на выполнение сообщением Execute. В сообщении Execute указывается имя портала (пустая строка подразумевает безымянный портал) и максимальное число результирующих строк (ноль означает <quote>выбрать все строки</quote>). Число результирующих строк имеет значение только для порталов, которые содержат команды, возвращающие наборы строк; в других случаях команда всегда выполняется до завершения и число строк игнорируется. В ответ на Execute могут быть получены те же сообщения, что описаны выше для запросов, выполняемых через протокол простых запросов, за исключением того, что после Execute не выдаются сообщения ReadyForQuery и RowDescription.</para>

   <para>Если операция Execute оканчивается до завершения выполнения портала (из-за достижения ненулевого ограничения на число строк), сервер отправляет сообщение PortalSuspended; появление этого сообщения говорит клиенту о том, что для завершения операции с данным порталом нужно выдать ещё одно сообщение Execute. Сообщение CommandComplete, говорящее о завершении исходной команды SQL, не передаётся до завершения выполнения портала. Таким образом, фаза Execute всегда заканчивается при появлении одного из сообщений: CommandComplete, EmptyQueryResponse (если портал был создан из пустой строки запроса), ErrorResponse или PortalSuspended.</para>

   <para>В конце каждой серии сообщений расширенных запросов клиент должен выдать сообщение Sync. Получив это сообщение без параметров, сервер закрывает текущую транзакцию, если команды выполняются не внутри блока транзакции <command>BEGIN</command>/<command>COMMIT</command> (под <quote>закрытием</quote> понимается фиксация при отсутствии ошибок или откат в противном случае). Затем он выдаёт ответ ReadyForQuery. Целью сообщения Sync является обозначение точки синхронизации для восстановления в случае ошибок. Если при обработке сообщений расширенных запросов происходит ошибка, сервер выдаёт ErrorResponse, затем считывает и пропускает сообщения до Sync, после чего выдаёт ReadyForQuery и возвращается к обычной обработке сообщений. (Но заметьте, что он не будет пропускать следующие сообщения, если ошибка происходит <emphasis>в процессе</emphasis> обработки Sync &mdash; это гарантирует, что для каждого Sync будет передаваться в точности одно сообщение ReadyForQuery.)</para>

   <note>
    <para>Сообщение Sync не приводит к закрытию блока транзакции, открытого командой <command>BEGIN</command>. Выявить эту ситуацию можно, используя информацию о состоянии транзакции, содержащуюся в сообщении ReadyForQuery.</para>
   </note>

   <para>В дополнение к этим фундаментальным и обязательным операциям, протокол расширенных запросов позволяет выполнить и несколько дополнительных операций.</para>

   <para>В сообщении Describe (в вариации для портала) задаётся имя существующего портала (пустая строка обозначает безымянный портал). В ответ передаётся сообщение RowDescription, описывающее строки, которые будут возвращены при выполнении портала; либо сообщение NoData, если портал не содержит запроса, возвращающего строки; либо ErrorResponse, если такого портала нет.</para>

   <para>В сообщении Describe (в вариации для оператора) задаётся имя существующего подготовленного оператора (пустая строка обозначает безымянный подготовленный оператор). В ответ передаётся сообщение ParameterDescription, описывающее параметры, требующиеся для оператора, за которым следует сообщение RowDescription, описывающее строки, которые будут возвращены, когда оператор будет собственно выполнен (или сообщение NoData, если оператор не возвратит строки). ErrorResponse выдаётся, если такой подготовленный оператор отсутствует. Заметьте, что так как команда Bind не выполнялась, сервер ещё не знает, в каком формате будут возвращаться столбцы; в этом случае поля кодов формата в сообщении RowDescription будут содержать нули.</para>

   <tip>
    <para>В большинстве случаев клиент должен выдать ту или иную вариацию Describe, прежде чем выдавать Execute, чтобы понять, как интерпретировать результаты, которые он получит.</para>
   </tip>

   <para>Сообщение Close закрывает существующий подготовленный оператор или портал и освобождает связанные ресурсы. При попытке выполнить Close для имени несуществующего портала или оператора ошибки не будет. Ответ на это сообщение обычно CloseComplete, но может быть и ErrorResponse, если при освобождении ресурсов возникают проблемы. Заметьте, что при закрытии подготовленного оператора неявно закрываются все открытые порталы, которые были получены из этого оператора.</para>

   <para>Сообщение Flush не приводит к генерации каких-либо данных, а указывает серверу передать все данные, находящиеся в очереди в его буферах вывода. Сообщение Flush клиент должен отправлять после любой команды расширенных запросов, кроме Sync, если он желает проанализировать результаты этой команды, прежде чем выдавать следующие команды. Без Flush сообщения, возвращаемые сервером, будут объединяться вместе в минимальное количество пакетов с целью уменьшения сетевого трафика.</para>

   <note>
    <para>Простое сообщение Query примерно равнозначно последовательности сообщений Parse, Bind, Describe (для портала), Execute, Close, Sync, с использованием объектов подготовленного оператора и портала без имён и без параметров. Одно отличие состоит в том, что такое сообщение может содержать в строке запроса несколько операторов SQL, для каждого из которых по очереди автоматически выполняется последовательность Bind/Describe/Execute. Другое отличие состоит в том, что в ответ на него не приходят сообщения ParseComplete, BindComplete, CloseComplete или NoData.</para>
   </note>
  </sect2>

  <sect2>
   <title>Вызов функций</title>

   <para>Подраздел протокола &laquo;Вызов функций&raquo; позволяет клиенту запросить непосредственный вызов любой функции, существующей в системном каталоге <structname>pg_proc</structname>. При этом клиент должен иметь право на выполнение этой функции.</para>

   <note>
    <para>Этот подраздел протокола считается устаревшим и в новом коде использовать его не следует. Примерно тот же результат можно получить, подготовив оператор с командой <literal>SELECT function($1, ...)</literal>. При таком подходе цикл вызова функции заменяется последовательностью Bind/Execute.</para>
   </note>

   <para>Цикл вызова функции начинает клиент, передавая серверу сообщение FunctionCall. Сервер возвращает одно или несколько сообщений ответа, в зависимости от результата вызова функции, и завершающее сообщение ReadyForQuery. ReadyForQuery говорит клиенту, что он может свободно передавать новый запрос или вызов функции.</para>

   <para>Сервер может передавать в этой фазе следующие ответные сообщения: <variablelist>
     <varlistentry>
      <term>ErrorResponse (Ошибочный ответ)</term>
      <listitem>
       <para>Произошла ошибка.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>FunctionCallResponse (Ответ на вызов функции)</term>
      <listitem>
       <para>Вызов функции завершён и в этом сообщении передаётся её результат. (Заметьте, что протокол вызова функций позволяет выдать только один скалярный результат, но не кортеж или набор результатов.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery (Готов к запросам)</term>
      <listitem>
       <para>Обработка вызова функции завершена. В ответ всегда передаётся ReadyForQuery, независимо от того, была ли функция выполнена успешно или с ошибкой.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse (Ответ с замечанием)</term>
      <listitem>
       <para>Выдаётся предупреждение, связанное с вызовом функции. Эти замечания дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать вызов.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>

  <sect2 id="protocol-copy">
   <title>Операции COPY</title>

   <para>Команда <command>COPY</command> позволяет обеспечить скоростную передачу данных на сервер или с сервера. Операции входящего и исходящего копирования переключают соединение в отдельные режимы протокола, которые завершаются только в конце операции.</para>

   <para>Режим входящего копирования (передача данных на сервер) включается, когда клиент выполняет SQL-оператор <command>COPY FROM STDIN</command>. Переходя в этот режим, сервер передаёт клиенту сообщение CopyInResponse. После этого клиент должен передать ноль или более сообщений CopyData, образующих поток входных данных. (При этом границы сообщений не обязательно должны совпадать с границами строк данных, хотя часто имеет смысл выровнять их.) Клиент может завершить режим входящего копирования, передав либо сообщение CopyDone (говорящее об успешном завершении), либо CopyFail (которое приведёт к завершению SQL-оператора <command>COPY</command> с ошибкой). При этом сервер вернётся в обычный режим обработки, в котором он находился до выполнения команды <command>COPY</command> (это может быть протокол простых или расширенных запросов). Затем он отправит сообщение CommandComplete (в случае успешного завершения) или ErrorResponse (в противном случае).</para>

   <para>В случае возникновения ошибки в режиме входящего копирования (включая получение сообщения CopyFail), сервер выдаёт сообщение ErrorResponse. Если команда <command>COPY</command> была получена в сообщении расширенного запроса, сервер не будет обрабатывать последующие сообщения клиента, пока не получит сообщение Sync, после которого он выдаст ReadyForQuery и вернётся в обычный режим работы. Если команда <command>COPY</command> была получена в сообщении простого запроса, остальная часть сообщения игнорируется и сразу выдаётся ReadyForQuery. В любом случае все последующие сообщения CopyData, CopyDone или CopyFail, поступающие от клиента, будут просто игнорироваться.</para>

   <para>В режиме входящего копирования сервер игнорирует поступающие сообщения Flush и Sync. При поступлении сообщений любого другого типа, не связанного с копированием, возникает ошибка, приводящая к прерыванию режима входящего копирования, как описано выше. (Исключение для сообщений Flush и Sync сделано для удобства клиентских библиотек, которые всегда передают Flush или Sync после сообщения Execute, не проверяя, не запускается ли в нём команда <command>COPY FROM STDIN</command>.)</para>

   <para>Режим исходящего копирования (передача данных с сервера) включается, когда клиент выполняет SQL-оператор <command>COPY TO STDOUT</command>. Переходя в этот режим, сервер передаёт клиенту сообщение CopyOutResponse, за ним ноль или более сообщений CopyData (всегда одно сообщение для каждой строки) и в завершение CopyDone. Затем сервер возвращается в обычный режим обработки, в котором он находился до выполнения команды <command>COPY</command>, и передаёт CommandComplete. Клиент не может прервать передачу (кроме как закрыв соединение или выдав запрос Cancel), но он может игнорировать ненужные ему сообщения CopyData и CopyDone.</para>

   <para>В случае обнаружения ошибки в режиме исходящего копирования, сервер выдаёт сообщение ErrorResponse и возвращается к обычной обработке. Клиент должен воспринимать поступление ErrorResponse как завершение режима исходящего копирования.</para>

   <para>Между сообщениями CopyData могут поступать сообщения NoticeResponse и ParameterStatus; клиенты должны обрабатывать их и быть готовы принимать и другие типы асинхронных сообщений (см. <xref remap="4" linkend="protocol-async"/>). В остальном, сообщения любых типов, кроме CopyData и CopyDone, могут восприниматься как завершающие режим исходящего копирования.</para>

   <para>Есть ещё один режим копирования, называемый двусторонним копированием и обеспечивающий высокоскоростную передачу данных на <emphasis>и</emphasis> с сервера. Двустороннее копирование запускается, когда клиент в режиме walsender выполняет оператор <command>START_REPLICATION</command>. В ответ сервер передаёт клиенту сообщение CopyBothResponse. Затем и сервер, и клиент могут передавать друг другу сообщения CopyData, пока кто-то из них не завершит передачу сообщением CopyDone. Когда сообщение CopyDone передаёт клиент, соединение переходит из режима двустороннего в режим исходящего копирования и клиент больше не может передавать сообщения CopyData. Аналогично, когда сообщение CopyDone передаёт сервер, соединение переходит в режим входящего копирования и сервер больше не может передавать сообщения CopyData. Когда сообщения CopyDone переданы обеими сторонами, режим копирования завершается и сервер возвращается в режим обработки команд. В случае обнаружения ошибки на стороне сервера в режиме двустороннего копирования, сервер выдаёт сообщение ErrorResponse, пропускает следующие сообщения клиента, пока не будет получено сообщение Sync, а затем выдаёт ReadyForQuery и возвращается к обычной обработке. Клиент должен воспринимать получение ErrorResponse как завершение двустороннего копирования; в этом случае сообщение CopyDone посылаться не должно. За дополнительной информацией о подразделе протокола, управляющем двусторонним копированием, обратитесь к <xref remap="3" linkend="protocol-replication"/>.</para>

   <para>Сообщения CopyInResponse, CopyOutResponse и CopyBothResponse содержат поля, из которых клиент может узнать количество столбцов в строке и код формата для каждого столбца. (В текущей реализации для всех столбцов в заданной операции <command>COPY</command> устанавливается один формат, но в конструкции сообщения это не заложено.)</para>

  </sect2>

  <sect2 id="protocol-async">
   <title>Асинхронные операции</title>

   <para>Возможны ситуации, в которых сервер будет отправлять клиенту сообщения, не предполагаемые потоком команд в текущем режиме. Клиенты должны быть готовы принять эти сообщения в любой момент, даже не в процессе выполнения запроса. Как минимум, следует проверять такие сообщения, прежде чем начинать читать ответ на запрос.</para>

   <para>Сообщения NoticeResponse могут выдаваться вследствие внешней активности; например, если администратор инициирует <quote>быстрое</quote> отключение баз данных, сервер отправит NoticeResponse, сигнализирующее об этом факте, прежде чем закрывать соединение. Соответственно, клиенты должны быть готовы всегда принять и вывести сообщения NoticeResponse, даже когда соединение фактически простаивает.</para>

   <para>Сообщения ParameterStatus будут выдаваться всякий раз, когда меняется действующее значение одного из параметров, об изменении которых, по мнению сервера, должен знать клиент. Чаще всего это происходит в ответ на SQL-команду <command>SET</command>, выполняемую клиентом и в таком случае это сообщение по сути синхронно &mdash; но состояние параметров может меняться и когда администратор изменяет файл конфигурации, а затем посылает серверу сигнал <systemitem>SIGHUP</systemitem>. Также, если действие команды <command>SET</command> отменяется, клиенту передаётся сообщение ParameterStatus, в котором отражается текущее значение параметра.</para>

   <para>В настоящее время есть жёстко зафиксированный набор параметров, при изменении которых выдаётся ParameterStatus: <varname>server_version</varname>, <varname>server_encoding</varname>, <varname>client_encoding</varname>, <varname>application_name</varname>, <varname>is_superuser</varname>, <varname>session_authorization</varname>, <varname>DateStyle</varname>, <varname>IntervalStyle</varname>, <varname>TimeZone</varname>, <varname>integer_datetimes</varname> и <varname>standard_conforming_strings</varname>. (<varname>server_encoding</varname>, <varname>TimeZone</varname> и <varname>integer_datetimes</varname> не отслеживались до версии 8.0; <varname>standard_conforming_strings</varname> не отслеживался до 8.1; <varname>IntervalStyle</varname> — до версии 8.4; <varname>application_name</varname> — до версии 9.0.) Заметьте, что <varname>server_version</varname>, <varname>server_encoding</varname> и <varname>integer_datetimes</varname> — это псевдопараметры, которые не могут меняться после запуска сервера. Этот набор может быть изменён в будущем или даже будет настраиваемым. Соответственно, клиент может просто игнорировать сообщения ParameterStatus для параметров, которые ему неизвестны или не представляют интереса.</para>

   <para>Если клиент выполняет команду <command>LISTEN</command>, сервер будет передавать ему сообщения NotificationResponse (не путайте с NoticeResponse!), когда для канала с тем же именем затем будет выполняться команда <command>NOTIFY</command>.</para>

   <note>
    <para>В настоящее время, сообщение NotificationResponse может быть передано только вне транзакции, так что оно не может оказаться в середине серии ответов на команду, хотя может поступить сразу после ReadyForQuery. Однако полагаться на это при проектировании логики клиента неразумно. Лучше разработать код так, чтобы NotificationResponse могло быть принято в любой фазе протокола.</para>
   </note>
  </sect2>

  <sect2>
   <title>Отмена выполняющихся запросов</title>

   <para>В процессе обработки запроса клиент может запросить отмену этого запроса. Запрос отмены не передаётся серверу непосредственно через открытое соединение из соображений эффективности: мы не хотим, чтобы сервер постоянно проверял поступающие от клиента сообщения в процессе выполнения запроса. Запросы отмены должны быть относительно редкими, поэтому мы выбрали для них не самый простой путь во избежание негативного влияния на обычный режим работы.</para>

   <para>Чтобы запросить отмену запроса, клиент должен установить новое подключение к серверу и отправить ему сообщение CancelRequest, вместо StartupMessage, обычно передаваемого при установлении нового подключения. Сервер обработает полученную команду и закроет это подключение. По соображениям безопасности сервер не отвечает непосредственно на сообщение с запросом отмены.</para>

   <para>Сообщение CancelRequest обрабатывается, только если оно содержит те же ключевые данные (PID и секретный ключ), что были переданы клиенту при запуске. Если PID и секретный ключ в запросе соответствуют данным выполняющегося в данный момент обслуживающего процесса, обработка текущего запроса в нём прерывается. (В существующей реализации это осуществляется путём передачи специального сигнала данному обслуживающему процессу.)</para>

   <para>Сигнал отмены может подействовать, а может и не подействовать (например, если он поступит после того, как сервер завершит обработку запроса). Если отмена действительно происходит, текущая команда прерывается досрочно с сообщением об ошибке.</para>

   <para>Вследствие такой организации, объясняемой соображениями безопасности и эффективности, клиент не может непосредственно определить, был ли запрос отмены успешен. Он должен продолжать ожидать ответа сервера на исходный запрос. Запрос отмены просто увеличивает вероятность того, что текущий запрос завершится быстрее, как и вероятность того, что он будет завершён не успешно, а с ошибкой.</para>

   <para>Так как запрос отмены передаётся серверу через новое подключение к серверу, а не через обычный канал связи клиент-сервер, такие запросы могут выдавать любые процессы, а не только клиентский процесс, запрос которого требуется отменить. Это может дать дополнительную гибкость при построении многопроцессных приложений. Это также представляет собой угрозу безопасности, так как попытаться отменить запросы могут и неавторизованные пользователи. Для ликвидации этой угрозы в запросах отмены требуется передавать динамически генерируемый секретный ключ.</para>
  </sect2>

  <sect2>
   <title>Завершение</title>

   <para>Обычная процедура мягкого завершения заключается в том, что клиент отправляет сообщение Terminate и немедленно закрывает соединение. Получая это сообщение, обслуживающий процесс закрывает соединение и завершается.</para>

   <para>В редких случаях (например, при отключении базы данных по команде администратора) обслуживающий процесс может отключиться, даже если клиент не запрашивает этого. В таких случаях, перед тем, как закрыть соединение, этот процесс пытается передать сообщение с ошибкой или уведомлением, в котором будет указана причина отключения.</para>

   <para>Другие сценарии завершения возникают с различными вариантами отказа, например, при критическом сбое с дампом памяти на одной или другой стороне, при потере канала соединения, потере синхронизации по границам сообщений и т. д. Если клиент или сервер обнаруживает, что соединение было неожиданно закрыто, он должен очистить ресурсы и завершиться. Клиент при этом может запустить новый обслуживающий процесс, переподключившись к серверу, если он сам хочет продолжать работу. Закрывать соединение также рекомендуется при получении сообщений нераспознанного типа, так как это может быть признаком потери синхронизации по границам сообщений.</para>

   <para>При штатном или нештатном завершении сеанса любая открытая транзакция откатывается, а не фиксируется. Однако следует заметить, что при отключении клиента в процессе обработки запроса, отличного от <command>SELECT</command>, обслуживающий процесс вероятнее всего завершит запрос, прежде чем заметит отключение. Если запрос выполняется не в блоке транзакции (вне последовательности <command>BEGIN</command> ... <command>COMMIT</command>), его результаты могут быть зафиксированы до того, как будет обнаружено отключение.</para>
  </sect2>

  <sect2>
   <title>Защита сеанса с <acronym>SSL</acronym></title>

   <para>Если <productname>&productname;</productname> был собран с поддержкой <acronym>SSL</acronym>, взаимодействие клиента с сервером может быть зашифровано с применением <acronym>SSL</acronym>. Это обеспечивает защиту на уровне канала в среде, где злоумышленники могут перехватить трафик сеанса. За дополнительными сведениями о шифровании трафика сеансов <productname>&productname;</productname> с использованием <acronym>SSL</acronym>, обратитесь к <xref remap="3" linkend="ssl-tcp"/>.</para>

   <para>Чтобы начать сеанс с <acronym>SSL</acronym>-шифрованием, клиент передаёт серверу вместо StartupMessage сообщение SSLRequest. В ответ сервер передаёт один байт, содержащий символ <literal>S</literal> или <literal>N</literal>, показывающий, что он желает, либо не желает включать <acronym>SSL</acronym>, соответственно. Если клиент не удовлетворён ответом, он должен закрыть соединение на этом этапе. Чтобы продолжить установление соединения после получения <literal>S</literal>, он выполняет начальное согласование <acronym>SSL</acronym> с сервером (не описывается здесь, так как относится к протоколу <acronym>SSL</acronym>). Если эта процедура выполняется успешно, он продолжает соединение, передавая обычное сообщение StartupMessage. При этом StartupMessage и все последующие данные будут защищены <acronym>SSL</acronym>-шифрованием. Чтобы продолжить после получения <literal>N</literal>, клиент может передать обычное сообщение StartupMessage и дальше взаимодействовать с сервером без шифрования.</para>

   <para>Клиент также должен быть готов обработать сообщение ErrorMessage, полученное от сервера в ответ на SSLRequest. Такая ситуация возможна, только если сервер имеет версию, которая ещё не поддерживала <acronym>SSL</acronym> в <productname>&productname;</productname>. (Такие серверы сейчас антикварная редкость, и скорее всего их уже не встретить в природе.) В этом случае соединение должно быть закрыто, но клиент может решить открыть новое соединение, не запрашивая <acronym>SSL</acronym>-шифрование.</para>

   <para>Начальный запрос SSLRequest может также передаваться при установлении соединения, открываемого для передачи сообщения CancelRequest.</para>

   <para>Так как в самом протоколе не предусмотрено принудительное включение <acronym>SSL</acronym>-шифрования сервером, администратор может настроить сервер так, чтобы в качестве дополнительного условия при проверке подлинности клиента он не принимал незашифрованные сеансы.</para>
  </sect2>
 </sect1>

<sect1 id="protocol-replication">
<title>Протокол потоковой репликации</title>

<para>Чтобы инициировать потоковую репликацию, клиент передаёт в стартовом сообщении параметр <literal>replication</literal>. Логическое значение <literal>true</literal> этого параметра указывает обслуживающему процессу перейти в режим передачи WAL (walsender), в котором вместо SQL-операторов клиент может выдавать только ограниченный набор команд репликации. В режиме walsender можно использовать только протокол простых запросов. Команды репликации будут записываться в журнал сообщений сервера, если включён режим <xref linkend="guc-log-replication-commands"/>. Если этот параметр имеет значение <literal>database</literal>, процесс walsender должен подключиться к базе данных, указанной в параметре <literal>dbname</literal>, что позволит использовать это подключение для логической репликации с указанной базой данных.</para>
<para>Для тестирования команд репликации вы можете установить соединение для репликации, запустив <application>psql</application> или другую программу на базе <literal>libpq</literal> со строкой подключения, включающей параметр <literal>replication</literal>, например так: <programlisting>psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"</programlisting> Однако часто полезнее использовать <xref linkend="app-pgreceivexlog"/> (для физической репликации) или <xref linkend="app-pgrecvlogical"/> (для логической).</para>

<para>В режиме walsender принимаются следующие команды: <variablelist>
  <varlistentry>
    <term><literal>IDENTIFY_SYSTEM</literal>
     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>
    </term>
    <listitem>
     <para>Запрашивает идентификационные данные сервера. Сервер возвращает набор результатов с одной строкой, содержащей четыре поля:</para>

     <para>
      <variablelist>
      <varlistentry>
      <term><literal>systemid</literal> (<type>text</type>)</term>
      <listitem>
      <para>Уникальный идентификатор системы, идентифицирующий кластер. По нему можно определить, что базовая резервная копия, из которой инициализировался резервный сервер, получена из того же кластера.</para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term><literal>timeline</literal> (<type>int4</type>)</term>
      <listitem>
      <para>Идентификатор текущей линии времени. Также полезен для того, чтобы убедиться, что резервный сервер согласован с главным.</para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term><literal>xlogpos</literal> (<type>text</type>)</term>
      <listitem>
      <para>Текущее положение сохранённых данных в xlog. Позволяет узнать, с какой позиции в журнале транзакций может начаться потоковая передача.</para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term><literal>dbname</literal> (<type>text</type>)</term>
      <listitem>
      <para>Подключённая база данных или NULL.</para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>TIMELINE_HISTORY</literal> <replaceable class="parameter">tli</replaceable>
     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
    </term>
    <listitem>
     <para>Запрашивает с сервера файл истории для линии времени <replaceable class="parameter">лин_врем</replaceable>. Сервер возвращает набор результатов с одной строкой, содержащей два поля:</para>

     <para>
      <variablelist>
      <varlistentry>
      <term><literal>filename</literal> (<type>text</type>)</term>
      <listitem>
      <para>Имя файла с историей линии времени, например <filename>00000002.history</filename>.</para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term><literal>content</literal> (<type>bytea</type>)</term>
      <listitem>
      <para>Содержимое файла с историей линией времени.</para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class="parameter">имя_слота</replaceable> { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class="parameter">модуль_вывода</replaceable> } <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm></term>
    <listitem>
     <para>Создаёт слот физической или логической репликации. Слоты репликации описаны подробно в <xref remap="6" linkend="streaming-replication-slots"/>.</para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">имя_слота</replaceable></term>
       <listitem>
         <para>Имя создаваемого слота. Заданное имя должно быть допустимым для слота репликации (см. <xref remap="4" linkend="streaming-replication-slots-manipulation"/>).</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="parameter">модуль_вывода</replaceable></term>
       <listitem>
         <para>Имя модуля вывода, применяемого для логического декодирования (см. <xref remap="4" linkend="logicaldecoding-output-plugin"/>).</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>RESERVE_WAL</literal></term>
       <listitem>
        <para>Указывает, что этот слот физической репликации резервирует <acronym>WAL</acronym> немедленно. Без этого указания <acronym>WAL</acronym> резервируется только при подключении клиента потоковой репликации.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">имя_слота</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">лин_врем</replaceable> ] <indexterm><primary>START_REPLICATION</primary></indexterm></term>
    <listitem>
     <para>Указывает серверу начать потоковую передачу WAL, начиная с позиции <replaceable class="parameter">XXX/XXX</replaceable> в WAL. Если указывается параметр <literal>TIMELINE</literal>, передача начинается на линии времени <replaceable class="parameter">лин_врем</replaceable>, иначе выбирается текущая линия времени сервера. Сервер может вернуть в ответ ошибку, например, если запрошенный сегмент WAL уже потерян. Если проблем не возникает, сервер возвращает сообщение CopyBothResponse, а затем начинает передавать поток WAL клиенту.</para>

     <para>Если в параметрах передаётся <replaceable class="parameter">имя_слота</replaceable>, сервер будет отражать состояние репликации в этом слоте и отслеживать, какие сегменты, а если включён режим <varname>hot_standby_feedback</varname>, то и в каких транзакциях, всё ещё нужны этому резервному серверу.</para>

     <para>Если клиент запрашивает не последнюю, но существующую в истории сервера линию времени, сервер будет передавать весь WAL на этой линии времени, начиная с запрошенной стартовой точки до момента, когда сервер переключился на другую линию времени. Если клиент запрашивает передачу с начальной позицией точно в конце старой линии времени, сервер немедленно отвечает CommandComplete, не переходя в режим COPY.</para>

     <para>После передачи всех записей WAL на линии времени, не являющейся текущей, сервер завершает потоковую передачу, выходя из режима копирования. Когда клиент подтверждает завершение передачи, также выходя из режима копирования, сервер возвращает набор результатов в одной строке с двумя столбцами, сообщая таким образом о следующей линии времени в истории сервера. В первом столбце передаётся идентификатор следующей линии времени (типа <type>int8</type>), а во втором — позиция в WAL, в которой произошло переключение (типа <type>text</type>). Обычно в этой же позиции завершается передача потока WAL, но возможны исключения, когда сервер может передавать записи WAL из старой линии времени, которые он сам ещё не воспроизвёл до переключения. Наконец сервер передаёт сообщение CommandComplete, после чего он готов принять следующую команду.</para>

     <para>Данные WAL передаются в серии сообщений CopyData. (Это позволяет перемежать их с другой информацией; в частности, сервер может передать сообщение ErrorResponse, если он столкнулся с проблемами, уже начав передачу потока.) Полезная нагрузка каждого сообщения CopyData от сервера к клиенту содержит данные в одном из следующих форматов:</para>

     <para>
      <variablelist>
      <varlistentry>
      <term>XLogData (B) — данные журнала транзакций</term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>Byte1('w')</term>
      <listitem>
      <para>Указывает, что в этом сообщении передаются данные WAL.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Начальная точка данных WAL в этом сообщении.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Текущее положение конца WAL на сервере.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Показания системных часов сервера в момент передачи, в микросекундах с полуночи 2000-01-01.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Byte<replaceable>n</replaceable></term>
      <listitem>
      <para>Фрагмент потока данных WAL.</para>
      <para>Одна запись WAL никогда не разделяется на два сообщения XLogData. Когда запись WAL пересекает границу страницы WAL, и таким образом от неё уже оказывается отделена продолжающая запись, её можно разделить на сообщения по границе страницы. Другими словами, первая основная запись WAL и продолжающие её записи могут быть переданы в различных сообщениях XLogData.</para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Primary keepalive message (B) — Сообщение об активности ведущего</term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>Byte1('k')</term>
      <listitem>
      <para>Указывает, что это сообщение об активности отправителя.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Текущее положение конца WAL на сервере.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Показания системных часов сервера в момент передачи, в микросекундах с полуночи 2000-01-01.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Byte1</term>
      <listitem>
      <para>Значение 1 означает, что клиент должен ответить на это сообщение как можно скорее, во избежание отключения по тайм-ауту. Со значением 0 это не требуется.</para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>Принимающий процесс может передавать ответы отправителю в любое время, используя один из следующих форматов данных (также в полезной нагрузке сообщения CopyData):</para>

     <para>
      <variablelist>
      <varlistentry>
      <term>Standby status update (F) — Обновление состояния резервного сервера</term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>Byte1('r')</term>
      <listitem>
      <para>Указывает, что это сообщение передаёт обновлённое состояние получателя.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Положение следующего за последним байтом WAL, полученным и записанным на диск на резервном сервере.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Положение следующего за последним байтом WAL, сохранённым на диске на резервном сервере.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Положение следующего за последним байтом WAL, применённым на резервном сервере.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Показания системных часов клиента в момент передачи, в микросекундах с полуночи 2000-01-01.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Byte1</term>
      <listitem>
      <para>Если содержит 1, клиент запрашивает от сервера немедленный ответ на это сообщение. Так клиент может запросить отклик сервера и проверить, продолжает ли функционировать соединение.</para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>Hot Standby feedback message (F) — Сообщение обратной связи горячего резерва</term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>Byte1('h')</term>
      <listitem>
      <para>Указывает, что это сообщение обратной связи горячего резерва.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int64</term>
      <listitem>
      <para>Показания системных часов клиента в момент передачи, в микросекундах с полуночи 2000-01-01.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int32</term>
      <listitem>
      <para>Текущее значение xmin данного резервного сервера. Может быть нулевым; это означает, что резервный сервер уведомляет о том, что сообщения обратной связи горячего резерва больше не будут передаваться через это подключение. Последующие ненулевые значения могут восстановить работу механизма обратной связи.</para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>Int32</term>
      <listitem>
      <para>Текущая эпоха резервного сервера.</para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class="parameter">имя_слота</replaceable> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</replaceable> [ ( <replaceable>имя_параметра</replaceable> [ <replaceable>значение_параметра</replaceable> ] [, ...] ) ]</term>
    <listitem>
     <para>Указывает серверу начать потоковую передачу WAL для логической репликации, начиная с позиции <replaceable class="parameter">XXX/XXX</replaceable> в WAL. Сервер может вернуть в ответ ошибку, например, если запрошенный сегмент WAL уже потерян. Если проблем не возникает, сервер возвращает сообщение CopyBothResponse, а затем начинает передавать поток WAL клиенту.</para>

     <para>Данные, передаваемые внутри сообщений CopyBothResponse, имеют тот же формат, что описан для команды <literal>START_REPLICATION ... PHYSICAL</literal>.</para>

     <para>Обработку выводимых данных для передачи выполняет модуль вывода, связанный с выбранным слотом.</para>

     <variablelist>
      <varlistentry>
       <term><literal>SLOT</literal> <replaceable class="parameter">имя_слота</replaceable></term>
       <listitem>
         <para>Имя слота, из которого передаются изменения. Это имя является обязательным, оно должно соответствовать существующему логическому слоту репликации, созданному командой <literal>CREATE_REPLICATION_SLOT</literal> в режиме <literal>LOGICAL</literal>.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">XXX/XXX</replaceable></term>
       <listitem>
        <para>Позиция в WAL, с которой должна начаться передача.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">имя_параметра</replaceable></term>
       <listitem>
        <para>Имя параметра, передаваемого модулю логического декодирования для выбранного слота.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">значение_параметра</replaceable></term>
       <listitem>
        <para>Необязательное значение, в форме строковой константы, связываемое с указанным параметром.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>DROP_REPLICATION_SLOT</literal> <replaceable class="parameter">имя_слота</replaceable>
     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>Удаляет слот репликации, что приводит к освобождению всех зарезервированных для него ресурсов на стороне сервера. Если слот в настоящий момент используется активным соединением, команда завершается ошибкой.</para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">имя_слота</replaceable></term>
       <listitem>
         <para>Имя слота, подлежащего удалению.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'метка'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>скорость</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] <indexterm><primary>BASE_BACKUP</primary></indexterm></term>
    <listitem>
     <para>Указывает серверу начать потоковую передачу базовой копии. Система автоматически переходит в режим резервного копирования до начала передачи, и выходит из него после завершения копирования. Эта команда принимает следующие параметры: <variablelist>
       <varlistentry>
        <term><literal>LABEL</literal> <replaceable>'метка'</replaceable></term>
        <listitem>
         <para>Устанавливает метку для резервной копии. Если метка не задана, по умолчанию устанавливается метка <literal>base backup</literal>. Для метки действуют те же правила применения кавычек, что и для стандартных строк SQL при включённым режиме <xref linkend="guc-standard-conforming-strings"/>.</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>PROGRESS</literal></term>
        <listitem>
         <para>Запрашивает информацию, необходимую для отслеживания прогресса операции. Сервер передаёт в ответ приблизительный размер в заголовке каждого табличного пространства, исходя из которого можно понять, насколько продвинулась передача потока. Для вычисления этого размера анализируются размеры всех файлов ещё до начала передачи, и это может негативно повлиять на производительность — в частности, может увеличиться задержка до передачи первых данных. Так как файлы базы данных могут меняться во время резервного копирования, оценка размера не будет точной; размер базы может увеличиться или уменьшиться за время от вычисления этой оценки до передачи актуальных файлов.</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>FAST</literal></term>
        <listitem>
         <para>Запрашивает быструю контрольную точку.</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAL</literal></term>
        <listitem>
         <para>Включает в резервную копию необходимые сегменты WAL. При этом в подкаталог <filename>pg_xlog</filename> архива базового каталога будут включены все файлы с начала до конца копирования.</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOWAIT</literal></term>
        <listitem>
         <para>По умолчанию при копировании ожидается завершение архивации последнего требуемого сегмента WAL либо выдаётся предупреждение, если архивация журнала не включена. Указание <literal>NOWAIT</literal> отключает и ожидание, и предупреждение, так что обеспечение наличия требуемого журнала становится задачей клиента.</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>MAX_RATE</literal> <replaceable>скорость</replaceable></term>
        <listitem>
         <para>Ограничивает (сдерживает) максимальный объём данных, передаваемый от сервера клиенту за единицу времени. Единица измерения этого параметра — килобайты в секунду. Если задаётся этот параметр, его значение должно быть равно нулю, либо должно находиться в диапазоне от 32 (килобайт/сек) до 1 Гбайта/сек (включая границы). Если передаётся ноль, либо параметр не задаётся, скорость передачи не ограничивается.</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>TABLESPACE_MAP</literal></term>
        <listitem>
         <para>Включает информацию о символических ссылках, представленных в каталоге <filename>pg_tblspc</filename>, в файл <filename>tablespace_map</filename>. Файл карты табличных пространств содержит имена всех ссылок, содержащихся в каталоге <filename>pg_tblspc/</filename>, и полный путь для каждой ссылки.</para>
        </listitem>
       </varlistentry>
      </variablelist></para>
     <para>Когда запускается копирование, сервер сначала передаёт два обычных набора результатов, за которыми следуют один или более результатов CopyResponse.</para>
     <para>В первом обычном наборе результатов передаётся начальная позиция резервной копии, в одной строке с двумя столбцами. В первом столбце содержится стартовая позиция в формате XLogRecPtr, а во втором идентификатор соответствующей линии времени.</para>
     <para>Во втором обычном наборе результатов передаётся по одной строке для каждого табличного пространства. Эта строка содержит следующие поля: <variablelist>
       <varlistentry>
        <term><literal>spcoid</literal> (<type>oid</type>)</term>
        <listitem>
         <para>OID табличного пространства либо NULL, если это базовый каталог.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>spclocation</literal> (<type>text</type>)</term>
        <listitem>
         <para>Полный путь к каталогу табличного пространства либо NULL, если это базовый каталог.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>size</literal> (<type>int8</type>)</term>
        <listitem>
         <para>Приблизительный размер табличного пространства, если была запрошена информация о прогрессе операции; в противном случае NULL.</para>
        </listitem>
       </varlistentry>
      </variablelist></para>
     <para>За вторым обычным набором результатов следует одна или несколько серий результатов CopyResponse, одна для основного каталога данных и по одной для каждого табличного пространства, отличного от <literal>pg_default</literal> и <literal>pg_global</literal>. Данные в CopyResponse представляют собой выгруженное в формате tar (<quote>формате обмена ustar</quote>, описанном в стандарте POSIX 1003.1-2008) содержимое табличных пространств, за исключением того, что два замыкающих блока нулей, описанных в стандарте, не передаются. После завершения передачи данных tar передаётся заключительный обычный набор результатов, в котором сообщается конечная позиция копии в WAL, в том же формате, что и стартовая позиция.</para>

     <para>Архив tar каталога данных и всех табличных пространств будет содержать все файлы в этих каталогах, будь то файлы <productname>&productname;</productname> или посторонние файлы, добавленные в эти каталоги. Исключение составляют только следующие файлы: <itemizedlist spacing="compact" mark="bullet">
       <listitem>
        <para>
         <filename>postmaster.pid</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>postmaster.opts</filename>
        </para>
       </listitem>
       <listitem>
        <para>различные временные файлы, создаваемые в процессе работы сервером &productname;</para>
       </listitem>
       <listitem>
        <para><filename>pg_xlog</filename>, включая подкаталоги. Если в резервную копию включаются файлы WAL, в архив входит преобразованная версия <filename>pg_xlog</filename>, в которой будут находиться только файлы, необходимые для восстановления копии, но не всё остальное содержимое этого каталога.</para>
       </listitem>
       <listitem>
        <para><filename>pg_replslot</filename> копируется в виде пустого каталога.</para>
       </listitem>
       <listitem>
        <para>файлы, отличные от обычных файлов и каталогов, например, символические ссылки и файлы специальных устройств, пропускаются. (Символические ссылки в <filename>pg_tblspc</filename> сохраняются.)</para>
       </listitem>
      </itemizedlist> Если файловая система сервера поддерживает это, в архив включается информация о владельце, группе и режиме файла.</para>
    </listitem>
  </varlistentry>
</variablelist></para>

</sect1>

<sect1 id="protocol-message-types">
<title>Типы данных в сообщениях</title>

<para>В этом разделе описываются базовые типы данных, применяемые в сообщениях. <variablelist>

<varlistentry>
<term>Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)</term>
<listitem>
<para>Целое число из <replaceable>n</replaceable> бит с сетевым порядком байт (наиболее значащий байт первый). Если указано <replaceable>i</replaceable>, это поле будет содержать именно указанное значение, в противном случае значение переменное. Например: Int16, Int32(42).</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]</term>
<listitem>
<para>Массив из <replaceable>k</replaceable> <replaceable>n</replaceable>-битовых целых, каждое записывается с сетевым порядком байт. Длина массива <replaceable>k</replaceable> всегда определяется по предыдущему полю сообщения, например Int16[M].</para>
</listitem>
</varlistentry>

<varlistentry>
<term>String(<replaceable>s</replaceable>)</term>
<listitem>
<para>Строка, оканчивающаяся нулём (строка в стиле C). На длину строк ограничение не накладывается. Если указывается <replaceable>s</replaceable>, это поле будет содержать именно указанное значение, в противном случае значение переменное. Например: String, String("user").</para>

<note>
<para><emphasis>Нет никакого предопределённого ограничения</emphasis> длины строки, которую может возвратить сервер. Поэтому при реализации клиента лучше использовать расширяемый буфер, чтобы он мог принять строку любого размера, умещающуюся в памяти. Если такой возможности нет, прочитайте строку целиком и отбросьте последние символы, не помещающиеся в ваш буфер фиксированного размера.</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term>Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)</term>
<listitem>
<para>В точности <replaceable>n</replaceable> байт. Если размер поля <replaceable>n</replaceable> задаётся не константой, он всегда определяется по предыдущему полю сообщения. Если указывается <replaceable>c</replaceable>, оно задаёт точное значение. Например: Byte2, Byte1('\n').</para>
</listitem>
</varlistentry>

</variablelist></para>
</sect1>

<sect1 id="protocol-message-formats">
<title>Форматы сообщений</title>

<para>В этом разделе подробно описывается формат каждого сообщения. Все сообщения помечены символами, обозначающими, какая сторона может их передавать: сервер (F), клиент (B) или обе стороны (F &amp; B). Заметьте, что хотя каждое сообщение включает счётчик байт в начале, формат сообщения разработан так, чтобы конец сообщения можно было найти, не обращаясь к счётчику байт. Это помогает проверять корректность сообщений. (Исключением является сообщение CopyData, так как оно образует часть потока данных; содержимое любого отдельного сообщения CopyData нельзя интерпретировать само по себе.)</para>

<variablelist>


<varlistentry>
<term>AuthenticationOk (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(0)</term>
<listitem>
<para>Показывает, что проверка подлинности прошла успешно.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>AuthenticationKerberosV5 (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(2)</term>
<listitem>
<para>Указывает, что требуется проверка подлинности по протоколу Kerberos V5.</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>AuthenticationCleartextPassword (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(3)</term>
<listitem>
<para>Указывает, что требуется пароль, передаваемый открытым текстом.</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>AuthenticationMD5Password (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(12)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(5)</term>
<listitem>
<para>Указывает, что требуется пароль, преобразованный в хеш MD5.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte4</term>
<listitem>
<para>Значение соли, с которым должен хешироваться пароль.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>AuthenticationSCMCredential (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(6)</term>
<listitem>
<para>Указывает, что требуется сообщение с учётными данными SCM.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>AuthenticationGSS (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(7)</term>
<listitem>
<para>Указывает, что требуется проверка подлинности на базе GSSAPI.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>AuthenticationSSPI (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(9)</term>
<listitem>
<para>Указывает, что требуется проверка подлинности на базе SSPI.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>
<varlistentry>
<term>AuthenticationGSSContinue (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Указывает, что это сообщение содержит данные GSSAPI или SSPI.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte<replaceable>n</replaceable></term>
<listitem>
<para>Данные аутентификации для GSSAPI или SSPI.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>

<varlistentry>
<term>AuthenticationSASL (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(10)</term>
<listitem>
<para>Указывает, что началась аутентификация SASL.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя механизма аутентификации SASL.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>

<varlistentry>
<term>AuthenticationSASLContinue (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('R')</term>
<listitem>
<para>Указывает, что это сообщение представляет запрос аутентификации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(11)</term>
<listitem>
<para>Указывает, что это сообщение содержит данные SASL.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte<replaceable>n</replaceable></term>
<listitem>
<para>Данные SASL, специфичные для применяемого механизма SASL.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>

<varlistentry>
<term>BackendKeyData (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('K')</term>
<listitem>
<para>Указывает, что это сообщение содержит ключевые данные для отмены запросов. Клиент должен сохранить эти данные, если ему нужна возможность впоследствии выдавать сообщения CancelRequest.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(12)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>PID обслуживающего процесса.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Секретный ключ обслуживающего процесса.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>Bind (F)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('B')</term>
<listitem>
<para>Указывает, что это сообщение представляет команду Bind.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя целевого портала (пустая строка выбирает безымянный портал).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя исходного подготовленного оператора (пустая строка выбирает безымянный подготовленный оператор).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество кодов форматов следующих параметров (обозначается ниже символом <replaceable>C</replaceable>). Может быть нулевым, что показывает, что параметры отсутствуют или все параметры передаются в формате по умолчанию (текстовом); либо равняться одному, в этом случае указанный один код формата применяется ко всем параметрам; либо может равняться действительному количеству параметров.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16[<replaceable>C</replaceable>]</term>
<listitem>
<para>Коды форматов параметров. В настоящее время допускаются коды ноль (текстовый формат) и один (двоичный).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество следующих значений параметров (может быть нулевым). Оно должно совпадать с количеством параметров, требующихся для запроса.</para>
</listitem>
</varlistentry>
</variablelist> Затем для каждого параметра идёт следующая пара полей: <variablelist>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина значения параметра, в байтах (само поле длины не считается). Может быть нулевой. В качестве особого значения, -1 представляет значение NULL. В случае с NULL никакие байты значений далее не следуют.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte<replaceable>n</replaceable></term>
<listitem>
<para>Значение параметра в формате, определённом соответствующим кодом формата. Переменная <replaceable>n</replaceable> задаёт длину значения.</para>
</listitem>
</varlistentry>
</variablelist> За последним параметром идут следующие поля: <variablelist>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество кодов формата для следующих столбцов результата (обозначается ниже символом <replaceable>R</replaceable>). Может быть нулевым, что показывает, что столбцы результата отсутствуют или для всех столбцов должен использоваться формат по умолчанию (текстовый), либо равняться одному, в этом случае указанный один код формата применяется ко всем столбцам (если они есть), либо может равняться действительному количеству столбцов результата запроса.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16[<replaceable>R</replaceable>]</term>
<listitem>
<para>Коды форматов столбцов результата. В настоящее время допускаются коды ноль (текстовый формат) и один (двоичный).</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>BindComplete (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('2')</term>
<listitem>
<para>Указывает, что это сообщение, сигнализирующее о завершении Bind.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CancelRequest (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Int32(16)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(80877102)</term>
<listitem>
<para>Код запроса отмены. Это специально выбранное значение содержит <literal>1234</literal> в старших 16 битах и <literal>5678</literal> в младших 16 битах. (Во избежание неоднозначности этот код не должен совпадать с номером версии протокола.)</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>PID целевого обслуживающего процесса.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Секретный ключ целевого обслуживающего процесса.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>Close (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('C')</term>
<listitem>
<para>Указывает, что это сообщение представляет команду Close.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte1</term>
<listitem>
<para>'<literal>S</literal>' для закрытия подготовленного оператора, '<literal>P</literal>' для закрытия портала.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя подготовленного оператора или портала, который должен быть закрыт (пустая строка выбирает безымянный подготовленный оператор или портал).</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CloseComplete (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('3')</term>
<listitem>
<para>Указывает, что это сообщение, сигнализирующее о завершении Close.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CommandComplete (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('C')</term>
<listitem>
<para>Указывает, что это сообщение об успешном завершении команды.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
       <para>Тег команды. Обычно это одно слово, обозначающее завершённую команду SQL.</para>

       <para>Для команды <command>INSERT</command> в качестве тега передаётся <literal>INSERT <replaceable>oid</replaceable> <replaceable>строк</replaceable></literal>, где <replaceable>строк</replaceable> — количество вставленных строк. В поле <replaceable>oid</replaceable> передаётся идентификатор объекта вставленной строки, если число <replaceable>строк</replaceable> равно 1 и в целевой таблице содержатся OID; в противном случае вместо <replaceable>oid</replaceable> передаётся 0.</para>

       <para>Для команды <command>DELETE</command> в качестве тега передаётся <literal>DELETE <replaceable>строк</replaceable></literal>, где <replaceable>строк</replaceable> — количество удалённых строк.</para>

       <para>Для команды <command>UPDATE</command> в качестве тега передаётся <literal>UPDATE <replaceable>строк</replaceable></literal>, где <replaceable>строк</replaceable> — количество изменённых строк.</para>

       <para>Для команды <command>SELECT</command> или <command>CREATE TABLE AS</command> в качестве тега передаётся <literal>SELECT <replaceable>строк</replaceable></literal>, где <replaceable>строк</replaceable> — число полученных строк.</para>

       <para>Для команды <command>MOVE</command> в качестве тега передаётся <literal>MOVE <replaceable>строк</replaceable></literal>, где <replaceable>строк</replaceable> — количество строк, на которое изменилась позиция курсора.</para>

       <para>Для команды <command>FETCH</command> в качестве тега передаётся <literal>FETCH <replaceable>строк</replaceable></literal>, где <replaceable>строк</replaceable> — количество строк, полученное через курсор.</para>

       <para>Для команды <command>COPY</command> в качестве тега передаётся <literal>COPY <replaceable>строк</replaceable></literal>, где <replaceable>строк</replaceable> — количество скопированных строк. (Заметьте: число строк выводится, начиная только с <productname>PostgreSQL</productname> 8.2.)</para>

</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CopyData (F &amp; B)</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>Byte1('d')</term>
<listitem>
<para>Указывает, что в этом сообщении передаются данные <command>COPY</command>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte<replaceable>n</replaceable></term>
<listitem>
<para>Данные, образующие часть информационного потока <command>COPY</command>. Сообщения от сервера всегда соответствуют отдельным строкам данных, но сообщения, передаваемые клиентами, могут разделять поток произвольным образом.</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CopyDone (F &amp; B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('c')</term>
<listitem>
<para>Указывает, что это сообщение, сигнализирующее о завершении <command>COPY</command>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CopyFail (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('f')</term>
<listitem>
<para>Указывает, что это сообщение, сигнализирующее об ошибке операции <command>COPY</command>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Сообщение об ошибке, описывающее причину сбоя операции.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CopyInResponse (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('G')</term>
<listitem>
<para>Указывает, что это сообщение является ответом на запуск входящего копирования. Получив его, клиент начинает передавать данные на вход операции копирования (если клиент не готов к этому, он передаёт сообщение CopyFail).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int8</term>
<listitem>
<para>Значение 0 указывает, что для всей операции <command>COPY</command> применяется текстовый формат (строки разделяются символами новой строки, столбцы разделяются символами-разделителями и т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный формат (подобный формату DataRow). За дополнительными сведениями обратитесь к <xref remap="3" linkend="sql-copy"/>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество столбцов в копируемых данных (ниже обозначается символом <replaceable>N</replaceable>).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16[<replaceable>N</replaceable>]</term>
<listitem>
<para>Коды формата для каждого столбца. В настоящее время допускаются коды ноль (текстовый формат) и один (двоичный). Если общий формат копирования — текстовый, все эти коды должны быть нулевыми.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CopyOutResponse (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('H')</term>
<listitem>
<para>Указывает, что это сообщение является ответом на запуск исходящего копирования. За этим сообщением следуют данные, исходящие со стороны сервера.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int8</term>
<listitem>
<para>Значение 0 указывает, что для всей операции <command>COPY</command> применяется текстовый формат (строки разделяются символами новой строки, столбцы разделяются символами-разделителями и т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный формат (подобный формату DataRow). За дополнительными сведениями обратитесь к <xref remap="3" linkend="sql-copy"/>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество столбцов в копируемых данных (ниже обозначается символом <replaceable>N</replaceable>).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16[<replaceable>N</replaceable>]</term>
<listitem>
<para>Коды формата для каждого столбца. В настоящее время допускаются коды ноль (текстовый формат) и один (двоичный). Если общий формат копирования — текстовый, все эти коды должны быть нулевыми.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>CopyBothResponse (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('W')</term>
<listitem>
<para>Указывает, что это сообщение является ответом на запуск двустороннего копирования. Это сообщение используется только для потоковой репликации.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int8</term>
<listitem>
<para>Значение 0 указывает, что для всей операции <command>COPY</command> применяется текстовый формат (строки разделяются символами новой строки, столбцы разделяются символами-разделителями и т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный формат (подобный формату DataRow). За дополнительными сведениями обратитесь к <xref remap="3" linkend="sql-copy"/>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество столбцов в копируемых данных (ниже обозначается символом <replaceable>N</replaceable>).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16[<replaceable>N</replaceable>]</term>
<listitem>
<para>Коды формата для каждого столбца. В настоящее время допускаются коды ноль (текстовый формат) и один (двоичный). Если общий формат копирования — текстовый, все эти коды должны быть нулевыми.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>DataRow (B)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('D')</term>
<listitem>
<para>Указывает, что в этом сообщении передаётся строка данных.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество последующих значений столбцов (может быть нулевым).</para>
</listitem>
</varlistentry>
</variablelist> Затем для каждого столбца идёт следующая пара полей: <variablelist>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина значения столбца, в байтах (само поле длины не считается). Может быть нулевой. В качестве особого значения, -1 представляет значение NULL. В случае с NULL никакие байты значений далее не следуют.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte<replaceable>n</replaceable></term>
<listitem>
<para>Значение столбца в формате, определённом соответствующим кодом формата. Переменная <replaceable>n</replaceable> задаёт длину значения.</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>Describe (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('D')</term>
<listitem>
<para>Указывает, что это сообщение представляет команду Describe.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte1</term>
<listitem>
<para>'<literal>S</literal>' для получения описания подготовленного оператора, '<literal>P</literal>' — портала.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя подготовленного оператора или портала, описание которого запрашивается (пустая строка выбирает безымянный подготовленный оператор или портал).</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>EmptyQueryResponse (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('I')</term>
<listitem>
<para>Указывает, что это сообщение является ответом на пустую строку запроса. (Это сообщение заменяет CommandComplete.)</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>ErrorResponse (B)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('E')</term>
<listitem>
<para>Указывает, что это сообщение ошибки.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist> Тело сообщения состоит из одного или нескольких определённых полей, за которыми в качестве завершающего следует нулевой байт. Поля могут идти в любом порядке. Для каждого поля передаётся: <variablelist>
<varlistentry>
<term>Byte1</term>
<listitem>
<para>Код, задающий тип поля; ноль обозначает конец сообщения, после которого ничего нет. Типы полей, определённые в настоящее время, перечислены в <xref remap="6" linkend="protocol-error-fields"/>. Так как в будущем могут появиться другие типы полей, клиенты должны просто игнорировать поля нераспознанного типа.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Значение поля.</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>Execute (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('E')</term>
<listitem>
<para>Указывает, что это сообщение представляет команду Execute.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя портала, подлежащего выполнению (пустая строка выбирает безымянный портал).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Максимальное число строк, которое должно быть возвращено, если портал содержит запрос, возвращающий строки (в противном случае игнорируется). Ноль означает <quote>без ограничения</quote>.</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>Flush (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('H')</term>
<listitem>
<para>Указывает, что это сообщение представляет команду Flush.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>FunctionCall (F)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('F')</term>
<listitem>
<para>Указывает, что это сообщение представляет вызов функции.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Задаёт идентификатор объекта вызываемой функции.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество кодов форматов следующих аргументов (обозначается ниже символом <replaceable>C</replaceable>). Может быть нулевым, что показывает, что аргументы отсутствуют или все аргументы передаются в формате по умолчанию (текстовом); либо равняться одному, в этом случае указанный один код формата применяется ко всем аргументами, либо может равняться действительному количеству аргументов.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16[<replaceable>C</replaceable>]</term>
<listitem>
<para>Коды форматов аргументов. В настоящее время допускаются коды ноль (текстовый формат) и один (двоичный).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Задаёт число аргументов, передаваемых функции.</para>
</listitem>
</varlistentry>
</variablelist> Затем для каждого аргумента идёт следующая пара полей: <variablelist>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина значения аргумента, в байтах (само поле длины не считается). Может быть нулевой. В качестве особого значения, -1 представляет значение NULL. В случае с NULL никакие байты значений далее не следуют.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte<replaceable>n</replaceable></term>
<listitem>
<para>Значение аргумента, в формате, определённом соответствующим кодом формата. Переменная <replaceable>n</replaceable> задаёт длину значения.</para>
</listitem>
</varlistentry>
</variablelist> За последним аргументом идут следующие поля: <variablelist>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Код формата результата функции. В настоящее время допускается код ноль (текстовый формат) и один (двоичный).</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>FunctionCallResponse (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('V')</term>
<listitem>
<para>Указывает, что в этом сообщении передаётся результат вызова функции.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина значения результата функции, в байтах (само поле длины не считается). Может быть нулевой. В качестве особого значения, -1 представляет значение NULL. В случае с NULL никакие байты значения далее не следуют.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte<replaceable>n</replaceable></term>
<listitem>
<para>Значение результата функции в формате, определённом соответствующим кодом формата. Переменная <replaceable>n</replaceable> задаёт длину значения.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>NoData (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('n')</term>
<listitem>
<para>Указывает, что это сообщение сигнализирует об отсутствии данных.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>NoticeResponse (B)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('N')</term>
<listitem>
<para>Указывает, что это сообщение представляет замечание.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist> Тело сообщения состоит из одного или нескольких определённых полей, за которыми в качестве завершающего следует нулевой байт. Поля могут идти в любом порядке. Для каждого поля передаётся: <variablelist>
<varlistentry>
<term>Byte1</term>
<listitem>
<para>Код, задающий тип поля; ноль обозначает конец сообщения, после которого ничего нет. Типы полей, определённые в настоящее время, перечислены в <xref remap="6" linkend="protocol-error-fields"/>. Так как в будущем могут появиться другие типы полей, клиенты должны просто игнорировать поля нераспознанного типа.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Значение поля.</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>NotificationResponse (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('A')</term>
<listitem>
<para>Указывает, что это сообщение представляет уведомление.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>PID обслуживающего процесса, отправляющего уведомление.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя канала, для которого было выдано уведомление.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Строка <quote>сообщения</quote>, сопровождающего уведомление.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>ParameterDescription (B)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('t')</term>
<listitem>
<para>Указывает, что это сообщение представляет описание параметра.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество параметров для оператора (может быть нулевым).</para>
</listitem>
</varlistentry>
</variablelist> Затем для каждого параметра передаётся: <variablelist>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Задаёт идентификатор объекта типа данных параметра.</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>ParameterStatus (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('S')</term>
<listitem>
<para>Указывает, что в этом сообщении передаётся состояние параметра времени выполнения.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя параметра времени выполнения, состояние которого передаётся.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Текущее значение параметра.</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>Parse (F)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('P')</term>
<listitem>
<para>Указывает, что это сообщение представляет команду Parse.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя целевого подготовленного оператора (пустая строка выбирает безымянный подготовленный оператор).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Строка запроса, которая должна быть разобрана.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Количество типов параметров (может быть нулевым). Заметьте, что это значение представляет не число параметров, которые могут фигурировать в строке запроса, а число параметров, для которых клиент хочет предопределить типы.</para>
</listitem>
</varlistentry>
</variablelist> Затем для каждого параметра передаётся: <variablelist>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Задаёт идентификатор объекта типа данных параметра. Указание нулевого значения равносильно отсутствию указания типа.</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>ParseComplete (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('1')</term>
<listitem>
<para>Указывает, что это сообщение, сигнализирующее о завершении Parse.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>PasswordMessage (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('p')</term>
<listitem>
<para>Указывает, что это сообщение, в котором передаётся пароль. Заметьте, что оно также применяется для передачи сообщений обмена GSSAPI, SSPI и SASL (это на самом деле ошибка проектирования, так как в этом случае сообщение может содержать произвольные двоичные данные, а не текстовую строку, оканчивающуюся нулём).</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Пароль (зашифрованный, если требуется).</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>PortalSuspended (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('s')</term>
<listitem>
<para>Указывает, что это сообщение сигнализирует о приостановке портала. Заметьте, что оно выдаётся только при достижении ограничения числа строк, заданного в сообщении Execute.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>Query (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('Q')</term>
<listitem>
<para>Указывает, что это сообщение представляет простой запрос.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Собственно строка запроса.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>ReadyForQuery (B)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('Z')</term>
<listitem>
<para>Определяет тип сообщения. Сообщение ReadyForQuery передаётся, когда сервер готов к новому циклу запросов.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(5)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Byte1</term>
<listitem>
<para>Индикатор текущего состояния транзакции на сервере. Возможные значения: '<literal>I</literal>', транзакция неактивна (вне блока транзакции), '<literal>T</literal>' в блоке транзакции, либо '<literal>E</literal>' в блоке прерванной транзакции (запросы не будут обрабатываться до завершения блока).</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>RowDescription (B)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Byte1('T')</term>
<listitem>
<para>Указывает, что это сообщение представляет описание строки.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Задаёт количество полей в строке (может быть нулевым).</para>
</listitem>
</varlistentry>
</variablelist> Затем для каждого поля передаётся: <variablelist>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя поля.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Если поле связано со столбцом определённой таблицы, идентификатор объекта этой таблицы; в противном случае — ноль.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Если поле связано со столбцом определённой таблицы, номер атрибута для этого столбца; в противном случае — ноль.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Идентификатор объекта типа данных поля.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Размер типа данных (см. <varname>pg_type.typlen</varname>). Заметьте, что отрицательные значения показывают, что тип имеет переменную длину.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Модификатор типа (см. <varname>pg_attribute.atttypmod</varname>). Смысл этого модификатора зависит от типа.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int16</term>
<listitem>
<para>Код формата, используемого для поля. В настоящее время допускаются коды ноль (текстовый формат) и один (двоичный). В сообщении RowDescription, возвращаемом вариацией Describe для оператора, код формата ещё не известен и всегда будет нулевым.</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>SSLRequest (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Int32(8)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(80877103)</term>
<listitem>
<para>Код запроса <acronym>SSL</acronym>. Это специально выбранное значение содержит <literal>1234</literal> в старших 16 битах и <literal>5679</literal> в младших 16 битах. (Во избежание неоднозначности этот код не должен совпадать с номером версии протокола.)</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>StartupMessage (F)</term>
<listitem>
<para><variablelist>
<varlistentry>
<term>Int32</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(196608)</term>
<listitem>
<para>Номер версии протокола. В старших 16 битах задаётся старший номер версии (3 для протокола, описываемого здесь). В младших 16 битах задаётся младший номер версии (0 для протокола, описываемого здесь).</para>
</listitem>
</varlistentry>
</variablelist> За номером версии протокола следует одна или несколько пар из имени параметра и строки значения. За последней парой имя/значение должен следовать нулевой байт. Передаваться параметры могут в любом порядке. Обязательным является только параметр <literal>user</literal>, остальные могут отсутствовать. Каждый параметр задаётся так: <variablelist>
<varlistentry>
<term>String</term>
<listitem>
<para>Имя параметра. В настоящее время принимаются имена: <variablelist>
<varlistentry>
<term>
                <literal>user</literal>
</term>
<listitem>
<para>Имя пользователя баз данных, с которым выполняется подключение. Является обязательным, значения по умолчанию нет.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>database</literal>
</term>
<listitem>
<para>База данных, к которой выполняется подключение. По умолчанию подставляется имя пользователя.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>options</literal>
</term>
<listitem>
<para>Аргументы командной строки для обслуживающего процесса. (Этот способ считается устаревшим; теперь следует устанавливать отдельные параметры времени выполнения.) Пробелы в этой строке воспринимаются как разделяющие аргументы, если перед ними нет обратной косой черты (<literal>\</literal>); чтобы представить обратную косую черту буквально, продублируйте её (<literal>\\</literal>).</para>
</listitem>
</varlistentry>
</variablelist> В дополнение к этим параметрам можно установить любые параметры времени выполнения, значение которых может быть задано во время запуска обслуживающего процесса. Заданные значения будут применены при запуске обслуживающего процесса (после разбора аргументов командной строки, если они были переданы). Эти значения станут значениями по умолчанию в новом сеансе.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>String</term>
<listitem>
<para>Значение параметра.</para>
</listitem>
</varlistentry>
</variablelist></para>
</listitem>
</varlistentry>


<varlistentry>
<term>Sync (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('S')</term>
<listitem>
<para>Указывает, что это сообщение представляет команду Sync.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>Terminate (F)</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>Byte1('X')</term>
<listitem>
<para>Указывает, что это сообщение завершает сеанс.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Int32(4)</term>
<listitem>
<para>Длина содержимого сообщения в байтах, включая само поле длины.</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


</variablelist>

</sect1>


<sect1 id="protocol-error-fields">
<title>Поля сообщений с ошибками и замечаниями</title>

<para>В этом разделе описываются поля, которые могут содержаться в сообщениях ErrorResponse и NoticeResponse. Для каждого типа поля определён свой идентификационный маркер. Заметьте, что в сообщении может содержаться поле любого из этих типов, но не больше одного раза.</para>

<variablelist>

<varlistentry>
<term>
<literal>S</literal>
</term>
<listitem>
<para>Важность: поле содержит <literal>ERROR</literal>, <literal>FATAL</literal> или <literal>PANIC</literal> (в сообщении об ошибке), либо <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, <literal>INFO</literal> или <literal>LOG</literal> (в сообщении с замечанием), либо переведённые значения (ОШИБКА, ВАЖНО, ПАНИКА, ПРЕДУПРЕЖДЕНИЕ, ЗАМЕЧАНИЕ, ОТЛАДКА, ИНФОРМАЦИЯ, СООБЩЕНИЕ, соответственно). Это поле присутствует всегда.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>V</literal>
</term>
<listitem>
<para>Важность: поле содержит <literal>ERROR</literal>, <literal>FATAL</literal> или <literal>PANIC</literal> (в сообщении об ошибке) либо <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, <literal>INFO</literal> или <literal>LOG</literal> (в сообщении с замечанием). Это поле подобно <literal>S</literal>, но его содержимое никогда не переводится. Присутствует только в сообщениях, выдаваемых <productname>&productname;</productname> версии 9.6 и новее.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>C</literal>
</term>
<listitem>
<para>Код: код SQLSTATE выданной ошибки (см. <xref remap="4" linkend="errcodes-appendix"/>). Не переводится на другие языки, присутствует всегда.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>M</literal>
</term>
<listitem>
<para>Сообщение: основное сообщение об ошибке, предназначенное для человека. Должно быть точным, но кратким (обычно в одну строку). Присутствует всегда.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>D</literal>
</term>
<listitem>
<para>Необязательное дополнительное сообщение об ошибке, передающее более детальную информацию о проблеме. Может занимать несколько строк.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>H</literal>
</term>
<listitem>
<para>Подсказка: необязательное предложение решения проблемы. Оно должно отличаться от подробного описания тем, что предлагает совет (не обязательно подходящий во всех случаях), а не сухие факты. Может располагаться в нескольких строках.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>P</literal>
</term>
<listitem>
<para>Позиция: значение поля представляет целочисленное число в ASCII, указывающее на положение ошибки в исходной строке запроса. Первый символ находится в позиции 1, при этом позиции отсчитываются по символам, а не по байтам.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>p</literal>
</term>
<listitem>
<para>Внутренняя позиция: она определяется так же, как поле <literal>P</literal>, но отражает положение ошибки во внутренне сгенерированной команде, а не в строке, переданной клиентом. Вместе с этим полем всегда присутствует поле <literal>q</literal>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>q</literal>
</term>
<listitem>
<para>Внутренний запрос: текст внутренне сгенерированной команды, в которой произошла ошибка. Это может быть, например, SQL-запрос, выполняемый функцией на PL/pgSQL.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>W</literal>
</term>
<listitem>
<para>Где: указывает на контекст, в котором произошла ошибка. В настоящее время включает трассировку стека вызовов текущей функции на процедурном языке и внутренне сгенерированных запросов. Записи трассировки разделяются по строкам, вначале последняя.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>s</literal>
</term>
<listitem>
<para>Имя схемы: если ошибка связана с некоторым объектом базы данных, это поле содержит имя схемы, к которой относится объект (если такая есть).</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>t</literal>
</term>
<listitem>
<para>Имя таблицы: если ошибка связана с некоторой таблицей, это поле содержит имя таблицы. (Узнать имя схемы таблицы можно из соответствующего отдельного поля.)</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>c</literal>
</term>
<listitem>
<para>Имя столбца: если ошибка связана с некоторым столбцом таблицы, это поле содержит имя столбца. (Идентифицировать таблицу можно, обратившись к полям, содержащим имя таблицы и схемы.)</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>d</literal>
</term>
<listitem>
<para>Имя типа данных: если ошибка связана с некоторым типом данных, это поле содержит имя типа. (Узнать имя схемы типа можно из соответствующего поля.)</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>n</literal>
</term>
<listitem>
<para>Имя ограничения: если ошибка связана с некоторым ограничением, это поле содержит имя ограничения. Чтобы узнать, к какой таблице или домену она относится, обратитесь к полям, описанным выше. (В данном контексте индексы считаются ограничениями, даже если они были созданы не с синтаксисом ограничений.)</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>F</literal>
</term>
<listitem>
<para>Файл: имя файла с исходным кодом, в котором была обнаружена ошибка.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>L</literal>
</term>
<listitem>
<para>Строка: номер строки в исходном коде, в которой была обнаружена ошибка.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>R</literal>
</term>
<listitem>
<para>Программа: имя программы в исходном коде, в которой была обнаружена ошибка.</para>
</listitem>
</varlistentry>

</variablelist>

<note>
 <para>Поля, содержащие имена схемы, таблицы, столбца, типа данных и ограничения, выдаются только для ограниченного числа типов ошибок; см. <xref remap="4" linkend="errcodes-appendix"/>. Клиенты не должны рассчитывать на то, что присутствие одного из полей обязательно влечёт присутствие другого поля. Системные источники ошибок устанавливают связь между ними, но пользовательские функции могут использовать эти поля по-другому. Подобным образом, клиенты не должны полагаться на то, что эти поля ссылаются на актуальные объекты в текущей базе данных.</para>
</note>

<para>Клиент отвечает за форматирование отображаемой информации в соответствии с его нуждами; в частности, он должен разбивать длинные строки, как требуется. Символы новой строки, встречающиеся в полях сообщения об ошибке, должны обрабатываться, как разрывы абзацев, а не строк.</para>

</sect1>

<sect1 id="protocol-changes">
<title>Сводка изменений по сравнению с протоколом версии 2.0</title>

<para>В этом разделе представлен краткий список изменений к сведению разработчиков, желающих модернизировать существующие клиентские библиотеки до протокола 3.0.</para>

<para>В начальном стартовом пакете вместо фиксированного формата применяется гибкий формат списка строк. Заметьте, что теперь сеансовые значения по умолчанию для параметров времени выполнения можно задать непосредственно в стартовом пакете. (Вообще, это можно было делать и раньше, используя поле <literal>options</literal>, но из-за ограниченного размера <literal>options</literal> и невозможности задавать значения с пробелами, это вариант был не очень безопасным.)</para>

<para>Во всех сообщениях непосредственно за байтом типа сообщения следует счётчик длины (за исключением стартовых пакетов, в которых нет байта типа). Также заметьте, что байт типа теперь есть в сообщении PasswordMessage.</para>

<para>Сообщения ErrorResponse и NoticeResponse ('<literal>E</literal>' и '<literal>N</literal>') могут содержать несколько полей, из которых клиентский код может собрать сообщение об ошибке желаемого уровня детализации. Заметьте, что текст отдельных полей обычно не завершается новой строкой, тогда как в старом протоколе одиночная строка всегда завершалась так.</para>

<para>Сообщение ReadyForQuery ('<literal>Z</literal>') включает индикатор статуса транзакции.</para>

<para>Различие между типами данных BinaryRow и DataRow ушло; один тип сообщений DataRow позволяет возвращать данные во всех форматах. Заметьте, что формат DataRow был изменён для упрощения его разбора. Также изменилось представление двоичных значений: оно больше не привязано к внутреннему представлению сервера.</para>

<para>В протоколе появился новый подраздел <quote>расширенный запрос</quote>, в котором добавлены типы сообщений для команд Parse, Bind, Execute, Describe, Close, Flush и Sync, а также типы серверных сообщений ParseComplete, BindComplete, PortalSuspended, ParameterDescription, NoData и CloseComplete. Существующие клиенты могут не подстраиваться под этот раздел протокола, но если они задействует его, это позволит улучшить производительность или функциональность.</para>

<para>Данные <command>COPY</command> теперь внедряются в сообщения CopyData и CopyDone. Есть чётко определённый способ восстановить работу в случае ошибок в процессе <command>COPY</command>. Специальная последняя строка <quote><literal>\.</literal></quote> больше не нужна, она не передаётся при выполнении <command>COPY OUT</command>. (Она по-прежнему воспринимается как завершающая последовательность в потоке <command>COPY IN</command>, но это считается устаревшим способом завершения, и в конце концов он будет исключён.) Поддерживается <command>COPY</command> в двоичном режиме. Сообщения CopyInResponse и CopyOutResponse включают поля, определяющие число столбцов и формат каждого столбца.</para>

<para>Изменилась структура сообщений FunctionCall и FunctionCallResponse. Сообщение FunctionCall теперь позволяет передавать функциям аргументы NULL. Ещё в нём могут передаваться параметры и получаться результаты в текстовом или двоичном формате. Не осталось повода считать сообщение FunctionCall потенциально небезопасным, так как оно не даёт прямого доступа к внутренней презентации данных на сервере.</para>

<para>Сервер отправляет сообщения ParameterStatus ('<literal>S</literal>') при попытке подключения для всех параметров, которые он считает интересными для клиентской библиотеки. Как следствие, при любом изменении активного значения одного из этих параметров также выдаётся сообщение ParameterStatus.</para>

<para>Сообщение RowDescription ('<literal>T</literal>') содержит поля с OID таблицы и номером столбца для каждого столбца описываемой строки. В нём также передаётся код формата для каждого столбца.</para>

<para>Сервер более не выдаёт сообщение CursorResponse ('<literal>P</literal>').</para>

<para>В сообщении NotificationResponse ('<literal>A</literal>') добавилось ещё одно строковое поле, в котором может передаваться строка <quote>сообщения</quote> от отправителя события <command>NOTIFY</command>.</para>

<para>Раньше сообщение EmptyQueryResponse ('<literal>I</literal>') включало пустой строковый параметр; теперь он ликвидирован.</para>

</sect1>

</chapter>
