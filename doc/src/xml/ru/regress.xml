<!-- doc/src/xml/regress.xml -->

 <chapter id="regress">
  <title>Регрессионные тесты</title>

  <indexterm zone="regress"><primary>Регрессионное тестирование</primary></indexterm>

  <indexterm zone="regress"><primary>тест</primary></indexterm>

  <para>Регрессионные тесты представляют собой полный набор проверок реализации SQL в <productname>&productname;</productname>. Они тестируют как стандартные SQL-операции, так и расширенные возможности <productname>&productname;</productname></para>

  <sect1 id="regress-run">
   <title>Выполнение тестов</title>

  <para>Регрессионное тестирование можно выполнять как на уже установленном и работающем сервере, так и используя временную инсталляцию внутри дерева сборки. Более того, существуют <quote>параллельный</quote> и <quote>последовательный </quote> режимы тестирования. Последовательный метод выполняет каждый сценарий теста отдельно, тогда как параллельный метод запускает несколько процессов на сервере с тем, чтобы выполнить определённый набор тестов параллельно. Параллельное тестирование позволяет с уверенностью утверждать, что межпроцессное взаимодействие и блокировки работают корректно.</para>

  <sect2>
   <title>Запуск тестов на временной инсталляции</title>

  <para>Чтобы запустить параллельное регрессионное тестирование после сборки, но до инсталляции, наберите: <screen>
make check
</screen> в каталоге верхнего уровня. (Или, как вариант, вы можете перейти в <filename>src/test/regress</filename> и выполнить команду там.) По завершении процесса вы должны увидеть нечто вроде: <screen>
<computeroutput>
=======================
 All 115 tests passed.
=======================
</computeroutput>
</screen> или список тестов, не пройденных успешно. Прочитайте <xref linkend="regress-evaluation"/>, прежде чем делать вывод о серьёзности выявленных <quote>проблем</quote>.</para>

   <para>Поскольку данный метод тестирования выполняется на временном сервере, он не будет работать, если вы выполняете сборку под пользователем root, сервер просто не запустится из под root. Рекомендуется не делать сборку под пользователем root, если только вы не собираетесь проводить тестирование после завершения инсталляции.</para>

   <para>Если вы сконфигурировали <productname>&productname;</productname> для инсталляции в месте, где уже установлена предыдущая версия <productname>&productname;</productname>, и вы выполняете <literal>make check</literal> до инсталляции новой версии, вы можете столкнуться с тем, что тестирование завершится со сбоем, поскольку новая программа будет пытаться использовать уже установленные общие библиотеки. (Типичные симптомы - жалобы на неопределённые символы.) Если вы хотите провести тестирование до перезаписи старой инсталляции, вам необходимо проводить построение с <literal>configure --disable-rpath</literal>. Однако этот вариант не рекомендуется для окончательной инсталляции.</para>

   <para>Параллельное регрессионное тестирование запускает довольно много процессов под вашим именем пользователя. В настоящее время возможный максимум параллельной обработки составляет двадцать параллельных тестовых сценариев, а это означает сорок процессов: это и серверный процесс, и <application>psql</application> процесс для каждого тестового сценария. Поэтому если ваша система устанавливает ограничения на количество процессов для каждого пользователя, имеет смысл уточнить, что ваш лимит составляет не меньше пятидесяти процессов, или около того. В противном случае вы столкнетесь с кажущимися случайными сбоями в параллельном тестировании. Если же вы не имеете права увеличить свой лимит процессов, вы можете снизить степень параллелизма установкой параметра <literal>MAX_CONNECTIONS</literal>. Например: <screen>
make MAX_CONNECTIONS=10 check
</screen> выполняет не больше десяти тестов параллельно.</para>
  </sect2>

  <sect2>
   <title>Запуск тестов для существующей инсталляции</title>

  <para>Чтобы запустить тестирование после инсталляции, инициализируйте кластер баз данных и запустите сервер, как показано в <xref remap="6" linkend="runtime"/>, потом введите: <screen>
make installcheck
</screen>, или для параллельного тестирования: <screen>
make installcheck-parallel
</screen>. Тестовые сценарии будут соединяться с сервером на локальном компьютере с номером порта по умолчанию, если иное не задано переменными среды <envar>PGHOST</envar> и <envar>PGPORT</envar>. Тестирование будет проведено в базе данных <literal>regression</literal>; любая существующая база с таким именем будет удалена.</para>

  <para>Также тесты будут создавать случайные объекты общие для кластера, такие как роли и пользователи. Имена этих объектов будут начинаться с <literal>regress_</literal>. Опасайтесь использования режима <literal>installcheck</literal> там, где пользователи или табличные пространства могут иметь такие имена.</para>
  </sect2>

  <sect2>
   <title>Дополнительные пакеты тестов</title>

  <para>Команды <literal>make check</literal> и <literal>make installcheck</literal> запускают только <quote>основные</quote> регрессионные тесты, которые проверяют встроенную функциональность сервера <productname>&productname;</productname>. Исходный дистрибутив также содержит дополнительные возможности тестирования, большая часть которых имеет дело с дополнительной функциональностью, такой, как, например, дополнительные процедурные языки.</para>

  <para>Чтобы запустить пакет тестов (включая основные) применительно к модулям, выбранным для построения, наберите одну из этих команд в каталоге верхнего уровня дерева сборки: <screen>
make check-world
make installcheck-world
</screen> Эти команды запускают тестирование используя временный сервер или уже установленный сервер, в соответствии с данным выше описанием для команд <literal>make check</literal> и <literal>make installcheck</literal>. Остальные детали соответствуют ранее изложенным объяснениям для каждого метода. Необходимо иметь в виду, что команда <literal>make check-world</literal> выстраивает отдельное дерево временной инсталляции для каждого тестируемого модуля, а это требует гораздо больше времени и дискового пространства, нежели команда <literal>make installcheck-world</literal>.</para>

  <para>В качестве альтернативного пути можно запустить индивидуальный набор тестов, набрав <literal>make check</literal> или <literal>make installcheck</literal> в подходящем подкаталоге дерева сборки. Имейте в виду, что <literal>make installcheck</literal> предполагает, что вы уже установили соответствующие модули, а не только основной сервер.</para>

  <para>Дополнительные тесты, которые можно активизировать таким способом:</para>

  <itemizedlist>
   <listitem>
    <para>Регрессионные тесты для дополнительных процедурных языков (отличных от <application>PL/pgSQL</application>, который тестируется в рамках основного тестирования). Эти тесты расположены в каталоге <filename>src/pl</filename>.</para>
   </listitem>
   <listitem>
    <para>Регрессионные тесты для модулей <filename>contrib</filename>, расположенные в каталоге <filename>contrib</filename>. Не для всех модулей из <filename> contrib</filename> существуют тесты.</para>
   </listitem>
   <listitem>
    <para>Регрессионные тесты для библиотеки ECPG, расположенные в <filename>src/interfaces/ecpg/test</filename>.</para>
   </listitem>
   <listitem>
    <para>Тесты, для проверки работы одновременного доступа параллельными сессиями, расположенные в <filename>src/test/isolation</filename>.</para>
   </listitem>
   <listitem>
    <para>Тесты клиентских программ из <filename>src/bin</filename>. См. также <xref remap="4" linkend="regress-tap"/>.</para>
   </listitem>
  </itemizedlist>

  <para>При использовании режима <literal>installcheck</literal> эти тесты удалят все существующие базы данных с именами <literal>pl_regression</literal>, <literal>contrib_regression</literal>, <literal>isolation_regression</literal>, <literal>ecpg1_regression</literal>, <literal>ecpg2_regression</literal>, а также <literal>regression</literal>.</para>
  </sect2>

  <sect2>
   <title>Локаль и кодировка</title>

   <para>По умолчанию, тесты, работающие на временной инсталляции, используют локаль, определённую в текущей среде и кодировку базы данных, заданную при выполнении <command>initdb</command>. Для тестирования различных локалей может оказаться полезным установить подходящие переменные среды, например: <screen>
make check LANG=C
make check LC_COLLATE=en_US.utf8 LC_CTYPE=ru_RU.utf8
</screen> Поддержка переменной <envar>LC_ALL</envar> в этом случае не реализована; все остальные переменные среды, относящиеся к локали, работают.</para>

   <para>При тестировании на существующей инсталляции, локаль определяется имеющимся кластером базы данных и не может быть изменена для выполнения теста.</para>

   <para>Вы можете задать кодировку базы данных в переменной <envar>ENCODING</envar>, например: <screen>
make check LANG=C ENCODING=EUC_JP
</screen> Установка кодировки базы данных таким образом имеет смысл только для локали C; в противном случае кодировка определяется автоматически из локали, и установка кодировки, не соответствующей локали, приведёт к ошибке.</para>

   <para>Кодировка базы данных может быть установлена как для тестирования на временной, так и на существующей инсталляции, хотя в последнем случае она должна быть совместимой с локалью этой инсталляции.</para>
  </sect2>

  <sect2>
   <title>Специальные тесты</title>

   <para>Пакет основных регрессионных тестов содержит несколько тестовых файлов, которые не запускаются по умолчанию, поскольку они могут зависеть от платформы или выполняться слишком долго. Вы можете запустить те или иные дополнительные тесты, задав переменную <envar>EXTRA_TESTS</envar>. Например, запустить тест <literal>numeric_big</literal>: <screen>
make check EXTRA_TESTS=numeric_big
</screen> Запустить тест сортировки: <screen>
make check EXTRA_TESTS=collate.linux.utf8 LANG=en_US.utf8
</screen> Тест <literal>collate.linux.utf8</literal> работает только на платформе Linux/glibc и выполняется только для баз данных с кодировкой UTF-8.</para>
  </sect2>

  <sect2>
   <title>Тестирование сервера горячего резерва</title>

  <para>Исходный дистрибутив также содержит регрессионные тесты для статического поведения сервера горячего резерва. Для выполнения тестов требуется работающий ведущий сервер и работающий резервный, принимающий новые записи WAL от ведущего (с использованием либо трансляции файлов журналов, либо потоковой репликации). Эти серверы не создаются автоматически, также как и настройка репликации здесь не описана. Пожалуйста, сверьтесь с соответствующими разделами документации.</para>

  <para>Для запуска тестов сервера горячего резерва необходимо создать базу данных <literal>regression</literal> на ведущем сервере: <screen>
psql -h primary -c "CREATE DATABASE regression"
</screen> Затем, на ведущем сервере в базе данных regression запустите предварительный скрипт <filename>src/test/regress/sql/hs_primary_setup.sql</filename> Например: <screen>
psql -h primary -f src/test/regress/sql/hs_primary_setup.sql regression
</screen> Убедитесь, что эти изменения распространились на резервный сервер.</para>

  <para>Теперь, для выполнения теста, настройте, чтобы подключение по умолчанию выполнялось к резервному серверу (например, задав переменные среды <envar>PGHOST</envar> и <envar>PGPORT</envar>). И, наконец, запустите <literal>make standbycheck</literal> в каталоге регрессионных тестов: <screen>
cd src/test/regress
make standbycheck
</screen></para>

  <para>Чтобы протестировать работу резервного сервера в некоторых экстремальных условиях, эти условия можно получить на главном, воспользовавшись скриптом <filename>src/test/regress/sql/hs_primary_extremes.sql</filename>.</para>
  </sect2>
  </sect1>

  <sect1 id="regress-evaluation">
   <title>Оценка результатов тестирования</title>

   <para>Некоторые правильно установленные и полностью функциональные <productname>&productname;</productname> инсталляции могут <quote>давать сбой</quote> при прохождении некоторых регрессионных тестов из-за особенностей, присущих той или иной платформе, таких как различное представление чисел с плавающей запятой и формулировкой сообщений. В настоящее время результаты тестов оцениваются простым <command>diff</command> сравнением с выводом, сделанным в эталонной системе, поэтому результаты чувствительны к небольшим отличиям между системами. Когда тест завершается со <quote>сбоем</quote>, всегда исследуйте разницу между ожидаемым и полученным результатом; возможно, вы обнаружите, что разница не столь уж существенна. Тем не менее, мы стремимся поддерживать эталонные файлы на всех поддерживаемых платформах, чтобы можно было ожидать прохождения всех тестов.</para>

   <para>Актуальные итоговые результаты регрессионного тестирования хранятся в каталоге <filename>src/test/regress/results</filename>. Тестовый скрипт использует команду <command>diff</command>, чтобы сравнить каждый итоговый файл с ожидаемыми результатами, которые хранятся в каталоге <filename>src/test/regress/expected</filename>. Все различия сохраняются в <filename>src/test/regress/regression.diffs</filename> для последующей проверки. (Если проводился тест не из основного пакета, то его результаты появятся в соответствующем подкаталоге, а не в <filename>src/test/regress</filename>.)</para>

   <para>Если вам не нравится используемая по умолчанию команда <command>diff</command>, установите переменную среды <envar>PG_REGRESS_DIFF_OPTS</envar>, например <literal>PG_REGRESS_DIFF_OPTS='-u'</literal>. (Или, если хотите, запустите <command>diff</command> самостоятельно.)</para>

   <para>Если по какой-то причине какая-то конкретная платформа генерирует <quote>сбой</quote> для отдельного теста, но изучение его результата убеждает вас, что результат правильный, вы можете добавить новый файл сравнения, чтобы замаскировать отчёт об ошибке для последующего прохождения теста. За подробностями обратитесь к <xref remap="3" linkend="regress-variant"/>.</para>

   <sect2>
    <title>Различия в сообщениях об ошибке</title>

    <para>Некоторые регрессионные тесты подставляют заведомо неверные входные значения. Сообщения об ошибке могут выдаваться как <productname>&productname;</productname>, так и самой операционной системой. В последнем случае, форма сообщений может отличаться в зависимости от платформы, но отражают они одну и ту же информацию. Вот эта разница в сообщениях и приводит к <quote>сбоям</quote> регрессионного теста, которые можно устранить при проверке.</para>
   </sect2>

   <sect2>
    <title>Разница локалей</title>

    <para>Если вы проводите тестирование на сервере, который был установлен с локалью, имеющей порядок сопоставления, отличный от С, вы можете столкнуться с различиями в порядке сортировки и, как следствие, с последующими сбоями. Пакет регрессионных тестов решает эту проблему путём наличия альтернативных файлов результата, которые способны справиться с большим количеством локалей.</para>

    <para>Если вы используете метод тестирования на временной инсталляции, то чтобы запустить тестирование на другой локали, используйте подходящую переменную среды, относящуюся к локали, в командной строке <command>make</command>, например: <programlisting>make check LANG=de_DE.utf8</programlisting> (Драйвер регрессионного теста обнуляет <envar>LC_ALL</envar>, поэтому выбор локали посредством данной переменной не работает.) Чтобы не использовать локаль, либо обнулите все переменные среды, относящиеся к локали, либо установите их в <literal>C</literal>) или используйте следующую специальную команду: <programlisting>make check NO_LOCALE=1</programlisting> Когда тест проходит на существующей инсталляции, установки локали определяются этой инсталляцией. Чтобы это изменить, инициализируйте кластер базы данных с иной локалью, передав соответствующие параметры <command>initdb</command>.</para>

    <para>В целом, рекомендуется по возможности проводить регрессионные тесты при таких установках локали, которые будут использованы в работе, тогда в результате тестирования будут проверены актуальные участки кода, относящиеся к локали и кодировке. В зависимости от окружения операционной системы, вы можете столкнуться со сбоями, но вы хотя бы будете знать, какого поведения локали можно ожидать при работе с реальными приложениями.</para>
   </sect2>

   <sect2>
    <title>Разница в дате и времени</title>

    <para>Большая часть результатов проверки даты и времени зависит от часового пояса окружения. Эталонные файлы созданы для пояса <literal>PST8PDT</literal> (Беркли, Калифорния), поэтому если проводить тесты не с этим часовым поясом, проявятся мнимые ошибки. Драйвер регрессионного теста задаёт переменную среды <envar>PGTZ</envar> как <literal>PST8PDT</literal>, что позволяет получить корректный результат.</para>
   </sect2>

   <sect2>
    <title>Разница в числах с плавающей запятой</title>

    <para>Некоторые тесты применяют 64-битное вычисление чисел с плавающей запятой (<type>double precision</type>) из столбцов таблицы. Наблюдаются различия в результатах при использовании математических функций для столбцов <type>double precision</type>. Тесты <literal>float8</literal> и <literal>geometry</literal> особенно чувствительны к небольшим различиям между платформами и даже режимами оптимизации компилятора. Чтобы понять реальную значимость этих различий, нужно сравнить их глазами, поскольку обычно они располагаются с десятого разряда справа от десятичной точки.</para>

    <para>Некоторые системы показывают минус ноль как <literal>-0</literal>, тогда как другие показывают просто <literal>0</literal>.</para>

    <para>Некоторые системы сигнализируют об ошибках в <function>pow()</function> и <function>exp()</function> не так, как ожидает текущий код <productname>&productname;</productname>.</para>
   </sect2>

   <sect2>
    <title>Разница в сортировке строк</title>

    <para>Иногда наблюдаются различия в том, что одни и те же строки выводятся в ином порядке, нежели в контрольном файле. В большинстве случаев это не является, строго говоря, ошибкой. Основная часть скриптов регрессионных тестов не столь педантична, чтобы использовать <literal>ORDER BY</literal> для каждого <literal>SELECT</literal>, и поэтому в результате порядок строк не гарантирован согласно спецификации SQL. На практике мы видим, как одинаковые запросы, выполняемые для одних и тех же данных на одном и том же программном обеспечении, выдают результаты в одинаковом порядке для всех платформ, в связи с чем отсутствие <literal>ORDER BY</literal> не является проблемой. Однако некоторые запросы выявляют межплатформенные различия в сортировке. Когда тестирование идет на уже установленном сервере, различия в сортировке могут быть следствием того, что локаль установлена в отличное от С значение, или некоторые параметры заданы не по умолчанию, такие как <varname>work_mem</varname> или стоимостные параметры планировщика.</para>

    <para>Поэтому, если вы видите различия в сортировке строк, не стоит волноваться, если только запрос не использует <literal>ORDER BY</literal>. Тем не менее, сообщайте нам о таких случаях, чтобы мы могли добавить <literal>ORDER BY</literal> в конкретный запрос, чтобы исключить возможность ошибки в будущих релизах.</para>

    <para>Вы можете задать вопрос, почему мы явно не добавили <literal>ORDER BY</literal> во все запросы регрессионных тестов, чтобы избавиться от таких ошибок раз и навсегда. Причина в том, что это снизит полезность регрессионных тестов, поскольку они будут иметь тенденцию к проверке планов запросов использующих сортировку, за счёт исключения запросов без сортировки.</para>
   </sect2>

   <sect2>
    <title>Недостаточная глубина стека</title>

    <para>Если <literal>ошибки </literal> теста приводят к поломке сервера при выполнении команды <literal>select infinite_recurse()</literal>, это означает, что предел платформы для размера стека меньше, чем показывает параметр <xref linkend="guc-max-stack-depth"/>. Проблема может быть решена запуском сервера с большим размером стека (рекомендованное значение <varname>max_stack_depth</varname> по умолчанию - 4 Мб). Если вы не можете этого сделать, в качестве альтернативы уменьшите значение <varname>max_stack_depth</varname>.</para>

    <para>На платформах, поддерживающих функцию <function>getrlimit()</function>, сервер должен автоматически выбирать значение переменной <varname>max_stack_depth</varname>; поэтому, если вы не переписывали это значение вручную, сбой такого типа — просто дефект, который нужно зарегистрировать.</para>
   </sect2>

   <sect2>
    <title>Тест <quote>случайных значений</quote></title>

    <para>Тестовый скрипт <literal>random</literal> подразумевает получение случайных значений. В очень редких случаях это приводит к сбоям в регрессионном тестировании. Выполнение <programlisting>diff results/random.out expected/random.out</programlisting> должно выводить одну или несколько строк различий. Нет причин для беспокойства, до тех пор пока сбои в этом тесте не повторяются постоянно.</para>
   </sect2>

   <sect2>
    <title>Параметры конфигурации</title>

    <para>Когда тестирование проходит на существующей инсталляции, некоторые нестандартные значения параметров могут привести к сбоям в тесте. Например, изменение таких параметров конфигурации, как <varname>enable_seqscan</varname> или <varname>enable_indexscan</varname> могут привести к такому изменению системы, которое сможет воздействовать на результаты тестов, использующих <command>EXPLAIN</command>.</para>
   </sect2>
  </sect1>

<!-- We might want to move the following section into the developer's guide. -->
  <sect1 id="regress-variant">
   <title>Вариативные сравнительные файлы</title>

   <para>Поскольку некоторые тесты по сути выдают результаты, зависящие от окружения, мы предлагаем несколько вариантов <quote>ожидаемых</quote> файлов результата. Каждый регрессионный тест может иметь несколько сравнительных файлов, показывающих возможные результаты на разных платформах. Существует два независимых механизма для определения, какой именно сравнительный файл будет выбран для каждого теста.</para>

   <para>Первый механизм позволяет выбирать сравнительный файл для конкретной платформы. Есть файл сопоставления <filename>src/test/regress/resultmap</filename>, в котором определяется, какой сравнительный файл выбирать для каждой платформы. Чтобы устранить ложные <quote>сбои</quote> тестирования для конкретной платформы, для начала вы должны выбрать или создать вариант сравнительного файла, а потом добавить строку в файл <filename>resultmap</filename>.</para>

   <para>Каждая строка в файле сопоставления выглядит как <synopsis>
testname:output:platformpattern=comparisonfilename
</synopsis> Имя теста (<literal>testname</literal>) здесь - просто название конкретного модуля регрессионного теста. Значение <literal>output</literal> показывает, вывод какого файла проверять. Для стандартного регрессионного теста это всегда <literal>out</literal>. Значение соответствует расширению выходного файла. <literal>platformpattern</literal> представляет собой шаблон в стиле Unix-утилиты <command>expr</command> (т. е. регулярное выражение с неявным <literal>^</literal> якорем в начале). Этот шаблон сравнивается с именем платформы, которое выводится из <command>config.guess</command>. <literal>comparisonfilename</literal> это имя сравнительного файла, который будет использован.</para>

   <para>Например: некоторые системы интерпретируют очень маленькие числа с плавающей запятой как ноль, а не как ошибку потери значимости. Это приводит к разночтениям в регрессионных тестах для <filename>float8</filename>. Поэтому мы предлагаем вариант сравнительного файла <filename>float8-small-is-zero.out</filename>, который включает в себя результат, ожидаемый для таких систем. Чтобы замаскировать сообщение о ложном <quote>сбое</quote> на платформе <systemitem>OpenBSD</systemitem>, файл <filename>resultmap</filename> включает в себя: <programlisting>float8:out:i.86-.*-openbsd=float8-small-is-zero.out</programlisting> который сработает на любой машине, где выходное значение <command>config.guess</command> соответствует <literal>i.86-.*-openbsd</literal>. Другие строки в <filename>resultmap</filename> выбирают вариант сравнительного файла для других платформ, если это целесообразно.</para>

   <para>Второй механизм выбора более автоматический: он просто выбирает <quote>подходящую пару</quote> из нескольких предлагаемых сравнительных файлов. Драйвер скрипта регрессионного теста рассматривает стандартный сравнительный файл для теста, <literal><replaceable>testname</replaceable>.out</literal>, вариативный файл <literal><replaceable>testname</replaceable>_<replaceable>digit</replaceable>.out</literal> (где <replaceable>digit</replaceable> любое одиночное число от <literal>0</literal> до <literal>9</literal>). Если какой-нибудь из этих файлов полностью совпадает, тест считается пройденным. В противном случае, для отчёта об ошибке выбирается файл с наименьшим различием. (Если <filename>resultmap</filename> включает вводные для конкретного теста, то в этом случае <replaceable>testname</replaceable> подменное имя, взятое из файла <filename>resultmap</filename>.)</para>

   <para>Например, для теста <literal>char</literal> сравнительный файл <filename>char.out</filename> содержит результаты, ожидаемые для локалей <literal>C</literal> и <literal>POSIX</literal>, тогда как файл <filename>char_1.out</filename> содержит результаты, характерные для многих других локалей.</para>

   <para>Механизм "лучшей пары" был разработан, чтобы справляться с результатами, зависящими от локали, но он может применяться в любой ситуации, когда сложно предсказать результаты, исходя только из названия платформы. Ограниченность этого метода проявляется лишь в том, что драйвер теста не может сказать, какой вариант правилен для данного окружения; просто выбирается вариант, который кажется наиболее подходящим. Поэтому безопаснее всего использовать этот метод только для вариативных результатов, которые вы хотели бы видеть одинаково надёжными для любого контекста.</para>

  </sect1>

  <sect1 id="regress-tap">
   <title>Тесты TAP</title>

   <para>Тесты клиентских программ внутри <filename>src/bin</filename> используют инструменты Perl TAP и запускаются командой <command>prove</command>. Вы можете передать аргументы командной строки команде <command>prove</command>, установив для <command>make</command> переменную <varname>PROVE_FLAGS</varname>, например: <programlisting>make -C src/bin check PROVE_FLAGS='--reverse'</programlisting> Умолчанием в данном случае является <literal>--verbose</literal>. За дополнительными сведениями обратитесь к странице руководства по <command>prove</command>.</para>

   <para>Тесты, написанные на Perl, требуют модуля Perl <literal>IPC::Run</literal>. Этот модуль доступен из CPAN или операционной системы.</para>
  </sect1>

  <sect1 id="regress-coverage">
   <title>Проверка покрытия теста</title>

   <para>Исходный код &productname; может быть скомпилирован с инструментарием для теста покрытия, так что можно проверить, какие части кода покрывает регрессионное тестирование, или любое другое тестирование, запускаемое относительно кода. В настоящее время эта возможность поддерживается в сочетании с компиляцией с GCC и требует наличия <command>gcov</command> и <command>lcov</command> программ.</para>

   <para>Типичный рабочий процесс выглядит так: <screen>
./configure --enable-coverage ... OTHER OPTIONS ...
make
make check # или другой комплект тестов
make coverage-html
</screen> Затем откройте в своём HTML-браузере страницу <filename>coverage/index.html</filename>. Команды <command>make</command> работают и в подкаталогах.</para>

   <para>Чтобы обнулить подсчёт выполнений между тестами, запустите: <screen>
make coverage-clean
</screen></para>
  </sect1>

</chapter>
