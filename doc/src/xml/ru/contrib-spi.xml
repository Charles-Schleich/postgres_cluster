<!-- doc/src/xml/contrib-spi.xml -->

<sect1 id="contrib-spi" xreflabel="spi">
 <title>spi</title>

 <indexterm zone="contrib-spi"><primary>SPI</primary> <secondary>примеры</secondary></indexterm>

 <para>Модуль <application>spi</application> предоставляет несколько рабочих примеров использования SPI и триггеров. Хотя эти функцию имеют некоторую ценность сами по себе, они ещё более полезны как заготовки, которые можно приспособить под собственные нужды. Эти функции достаточно общие, чтобы работать с любой таблицей, но вы должны явно указать имена таблицы и полей (как описано ниже) при создании триггера.</para>

 <para>Каждая группа функций, описанная ниже, представлена в виде отдельно устанавливаемого расширения.</para>

 <sect2>
  <title>refint &mdash; функции для реализации ссылочной целостности</title>

  <para>Функции <function>check_primary_key()</function> и <function>check_foreign_key()</function> применяются для проверки ограничений внешних ключей. (Эта функциональность уже давно вытеснена встроенным механизмом внешних ключей, но этот модуль всё ещё полезен в качестве примера.)</para>

  <para>Функция <function>check_primary_key()</function> проверяет ссылающуюся таблицу. Чтобы воспользоваться ей, создайте триггер <literal>BEFORE INSERT OR UPDATE</literal> с этой функцией для таблицы, ссылающейся на другую. Укажите в аргументах триггера: имена столбцов ссылающейся таблицы, образующих внешний ключ, имя целевой таблицы и имена столбцов в ней, образующих первичный/уникальный ключ. Чтобы контролировать несколько внешних ключей, создайте триггер для каждой такой ссылки.</para>

  <para>Функция <function>check_foreign_key()</function> проверяет целевую таблицу. Чтобы использовать её, создайте триггер <literal>BEFORE DELETE OR UPDATE</literal> с этой функцией для таблицы, на которую ссылаются другие. Укажите в аргументах триггера: число ссылающихся таблиц, для которых функция должна выполнить проверки, действие в случае обнаружения ссылающегося ключа (<literal>cascade</literal> &mdash; удалить ссылающуюся строку, <literal>restrict</literal> &mdash; прервать транзакцию, <literal>setnull</literal> &mdash; установить в ссылающихся полях значения NULL), имена столбцов целевой таблицы, образующих первичный/уникальный ключ, а затем имена таблиц и столбцов (в количестве, задаваемом первым аргументом). Заметьте, что поля первичных/уникальных столбцов должны иметь пометку NOT NULL и по ним должен быть создан уникальный индекс.</para>

  <para>Примеры приведены в <filename>refint.example</filename>.</para>
 </sect2>

 <sect2>
  <title>timetravel &mdash; функции для реализации перемещений во времени</title>

  <para>В далёком прошлом в <productname>&productname;</productname> была встроенная возможность перемещений во времени, для которой фиксировалось время добавления и удаления каждого кортежа. Эти функции позволяют её имитировать. Чтобы использовать их, вы должны добавить в таблицу два столбца типа <type>abstime</type>, в которых будет храниться дата/время, когда кортеж был вставлен (start_date) и когда изменён/удалён (stop_date): <programlisting>CREATE TABLE mytab (
        ...             ...
        start_date      abstime,
        stop_date       abstime
        ...             ...
);</programlisting> Эти столбцы могут называться как угодно, но в данном описании они называются start_date и stop_date.</para>

  <para>Когда вставляется новая строка, в start_date обычно устанавливается текущее время, а в stop_date — <literal>infinity</literal> (бесконечность). Триггер автоматически подставит эти значения, если добавляемая строка содержит NULL в этих столбцах. Обычно не-NULL в этих столбцах может оказаться только при загрузке в базу выгруженных данных.</para>

  <para>Кортежи, в которых поле stop_date равно <literal>infinity</literal>, считаются <quote>актуальными сейчас</quote> и могут быть изменены. Кортежи с определённой датой stop_date больше не могут быть изменены &mdash; триггер будет препятствовать этому. (Если вам нужно сделать это, вы можете отключить машину времени как показано ниже.)</para>

  <para>Если кортеж является изменяемым, при модификации в нём меняется только stop_date (на текущее время), но в таблицу вставляется новый кортеж с модифицированными данными. В поле start_date в этом новом кортеже записывается текущее время, а в stop_date записывается <literal>infinity</literal>.</para>

  <para>При удалении кортеж на самом деле не удаляется; в нём только записывается текущее время в stop_date.</para>

  <para>Чтобы запросить кортежи <quote>актуальные сейчас</quote>, добавьте <literal>stop_date = 'infinity'</literal> в условие WHERE вашего запроса. (Возможно, вы захотите завернуть это условие в представление.) Аналогичным образом вы можете запрашивать кортежи, которые были актуальны в любой момент в прошлом, задав подходящие условия для start_date и stop_date.</para>

  <para>Функция <function>timetravel()</function> реализует код универсального триггера, поддерживающего это поведение. Чтобы использовать её, создайте триггер <literal>BEFORE INSERT OR UPDATE OR DELETE</literal> с этой функцией для каждой таблицы, перемещающейся во времени. Передайте триггеру два аргумента: фактические имена столбцов start_date и stop_date. Вы также можете дополнительно передать от одного до трёх аргументов, задающих имена столбцов типа <type>text</type>. Данный триггер сохранит имя текущего пользователя в первый из этих столбцов при INSERT, во второй — при UPDATE, и в третий — при DELETE.</para>

  <para>Функция <function>set_timetravel()</function> позволяет включить или отключить машину времени для таблицы. Вызов <literal>set_timetravel('mytab', 1)</literal> включает машину времени для таблицы <literal>mytab</literal>, а <literal>set_timetravel('mytab', 0)</literal> — отключает её для таблицы <literal>mytab</literal>. В обоих случаях возвращается прежнее состояние. Когда машина времени выключена, вы можете свободно модифицировать столбцы start_date и stop_date. Заметьте, что состояние активности машины является локальным для текущего сеанса базы данных &mdash; в новых сеансах машина времени всегда включена для всех таблиц.</para>

  <para>Функция <function>get_timetravel()</function> возвращает состояние перемещения во времени для таблицы, не меняя его.</para>

  <para>Пример приведён в <filename>timetravel.example</filename>.</para>
 </sect2>

 <sect2>
  <title>autoinc &mdash; функции для автоувеличения полей</title>

  <para>Функция <function>autoinc()</function> реализует код триггера, сохраняющего следующее значение последовательности в целочисленном поле. Это в некоторой степени пересекается со встроенной функциональностью столбца <quote>serial</quote>, но есть и отличия: <function>autoinc()</function> препятствует попыткам вставить другое значение поля при добавлении строк и может увеличивать значение поля при изменениях.</para>

  <para>Чтобы использовать её, создайте триггер <literal>BEFORE INSERT</literal> (или <literal>BEFORE INSERT OR UPDATE</literal>) с этой функцией. Передайте триггеру два аргумента: имя целочисленного столбца, который будет меняться, и имя объекта последовательности, который будет поставлять значения. (Вообще вы можете задать любое число пар таких имён, если хотите поддерживать несколько автоувеличивающихся столбцов.)</para>

  <para>Пример приведён в <filename>autoinc.example</filename>.</para>

 </sect2>

 <sect2>
  <title>insert_username &mdash; функции для отслеживания пользователя, вносящего изменения</title>

  <para>Функция <function>insert_username()</function> реализует код триггера, сохраняющего имя текущего пользователя в текстовом поле. Это может быть полезно для отслеживания пользователя, изменившего конкретную строку таблицы последним.</para>

  <para>Чтобы использовать её, создайте триггер <literal>BEFORE INSERT</literal> и/или <literal>UPDATE</literal> с этой функцией. Передайте триггеру один аргумент: имя целевого текстового столбца.</para>

  <para>Пример приведён в <filename>insert_username.example</filename>.</para>

 </sect2>

 <sect2>
  <title>moddatetime &mdash; функции для отслеживания времени последнего изменения</title>

  <para>Функция <function>moddatetime()</function> реализует код триггера, сохраняющего текущее время в поле типа <type>timestamp</type>. Это может быть полезно для отслеживания времени последней модификации конкретной строки таблицы.</para>

  <para>Чтобы использовать её, создайте триггер <literal>BEFORE UPDATE</literal> с этой функцией. Передайте триггеру один аргумент: имя целевого столбца. Столбец должен иметь тип <type>timestamp</type> или <type>timestamp with time zone</type>.</para>

  <para>Пример приведён в <filename>moddatetime.example</filename>.</para>

 </sect2>

</sect1>
