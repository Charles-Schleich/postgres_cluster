<!-- doc/src/xml/backup.xml -->

<chapter id="backup">
 <title>Резервное копирование и восстановление</title>

 <indexterm zone="backup"><primary>резервная копия</primary></indexterm>

 <para>Как и всё, что содержит важные данные, базы данных <productname>&productname;</productname> следует регулярно сохранять в резервной копии. Хотя эта процедура по существу проста, важно чётко понимать лежащие в её основе приёмы и положения.</para>

 <para>Существует три фундаментально разных подхода к резервному копированию данных в <productname>&productname;</productname>: <itemizedlist>
   <listitem><para>Выгрузка в <acronym>SQL</acronym></para></listitem>
   <listitem><para>Копирование на уровне файлов</para></listitem>
   <listitem><para>Непрерывное архивирование</para></listitem>
  </itemizedlist> Каждый из них имеет свои сильные и слабые стороны; все они обсуждаются в следующих разделах.</para>

 <sect1 id="backup-dump">
  <title>Выгрузка в <acronym>SQL</acronym></title>

  <para>Идея, стоящая за этим методом, заключается в генерации текстового файла с командами SQL, которые при выполнении на сервере пересоздадут базу данных в том же самом состоянии, в котором она была на момент выгрузки. <productname>&productname;</productname> предоставляет для этой цели вспомогательную программу <xref linkend="app-pgdump"/>. Простейшее применение этой программы выглядит так: <synopsis>
pg_dump <replaceable class="parameter">имя_базы</replaceable> &gt; <replaceable class="parameter">выходной_файл</replaceable>
</synopsis> Как видите, <application>pg_dump</application> записывает результаты своей работы в устройство стандартного вывода. Далее будет рассмотрено, чем это может быть полезно. В то время как вышеупомянутая команда создаёт текстовый файл, <application>pg_dump</application> может создать файлы и в других форматах, которые допускают параллельную обработку и более гибкое управление восстановлением объектов.</para>

  <para>Программа <application>pg_dump</application> является для <productname>&productname;</productname> обычным клиентским приложением (хотя и весьма умным). Это означает, что вы можете выполнять процедуру резервного копирования с любого удалённого компьютера, если имеете доступ к нужной базе данных. Но помните, что <application>pg_dump</application> не использует для своей работы какие-то специальные привилегии. В частности, ей обычно требуется доступ на чтение всех таблиц, которые вы хотите выгрузить, так что для копирования всей базы данных практически всегда её нужно запускать с правами суперпользователя СУБД. (Если у вас нет достаточных прав для резервного копирования всей базы данных, вы, тем не менее, можете сделать резервную копию той части базы, доступ к которой у вас есть, используя такие параметры, как <option>-n <replaceable>схема</replaceable></option> или <option>-t <replaceable>таблица</replaceable></option>.)</para>

  <para>Указать, к какому серверу должна подключаться программа <application>pg_dump</application>, можно с помощью аргументов командной строки <option>-h <replaceable>сервер</replaceable></option> и <option>-p <replaceable>порт</replaceable></option>. По умолчанию в качестве сервера выбирается localhost или значение, указанное в переменной окружения <envar>PGHOST</envar>. Подобным образом, по умолчанию используется порт, заданный в переменной окружения <envar>PGPORT</envar>, а если она не задана, то порт, указанный по умолчанию при компиляции. (Для удобства при компиляции сервера обычно устанавливается то же значение по умолчанию.)</para>

  <para>Как и любое другое клиентское приложение <productname>&productname;</productname>, <application>pg_dump</application> по умолчанию будет подключаться к базе данных с именем пользователя, совпадающим с именем текущего пользователя операционной системы. Чтобы переопределить имя, либо добавьте параметр <option>-U</option>, либо установите переменную окружения <envar>PGUSER</envar>. Помните, что <application>pg_dump</application> подключается к серверу через обычные механизмы проверки подлинности клиента (которые описываются в <xref remap="6" linkend="client-authentication"/>).</para>

  <para>Важное преимущество <application>pg_dump</application> в сравнении с другими методами резервного копирования, описанными далее, состоит в том, что вывод <application>pg_dump</application> обычно можно загрузить в более новые версии <productname>&productname;</productname>, в то время как резервная копия на уровне файловой системы и непрерывное архивирование жёстко зависят от версии сервера. Также, только метод с применением <application>pg_dump</application> будет работать при переносе базы данных на другую машинную архитектуру, например, при переносе с 32-битной на 64-битную версию сервера.</para>

  <para>Дампы, создаваемые <application>pg_dump</application>, являются внутренне согласованными, то есть, дамп представляет собой снимок базы данных на момент начала запуска <application>pg_dump</application>. <application>pg_dump</application> не блокирует другие операции с базой данных во время своей работы. (Исключение составляют операции, которым нужна исключительная блокировка, как например, большинство форм команды <command>ALTER TABLE</command>.)</para>

  <sect2 id="backup-dump-restore">
   <title>Восстановление дампа</title>

   <para>Текстовые файлы, созданные <application>pg_dump</application> предназначаются для последующего чтения программой <application>psql</application>. Общий вид команды для восстановления дампа: <synopsis>
psql <replaceable class="parameter">имя_базы</replaceable> &lt; <replaceable class="parameter">входной_файл</replaceable>
</synopsis> где <replaceable class="parameter">входной_файл</replaceable> &mdash; это файл, содержащий вывод команды <application>pg_dump</application>. База данных, заданная параметром <replaceable class="parameter">имя_базы</replaceable>, не будет создана данной командой, так что вы должны создать её сами из базы <literal>template0</literal> перед запуском <application>psql</application> (например, с помощью команды <literal>createdb -T template0 <replaceable class="parameter">имя_базы</replaceable></literal>). Программа <application>psql</application> принимает параметры, указывающие сервер, к которому осуществляется подключение, и имя пользователя, подобно <application>pg_dump</application>. За дополнительными сведениями обратитесь к справке по <xref linkend="app-pgrestore"/>. Копии не текстовые восстанавливаются утилитой <xref linkend="app-pgrestore"/>.</para>

   <para>Перед восстановлением SQL-дампа все пользователи, которые владели объектами или имели права на объекты в выгруженной базе данных, должны уже существовать. Если их нет, при восстановлении будут ошибки пересоздания объектов с изначальными владельцами и/или правами. (Иногда это желаемый результат, но обычно нет).</para>

   <para>По умолчанию, если происходит ошибка SQL, программа <application>psql</application> продолжает выполнение. Если же запустить <application>psql</application> с установленной переменной <literal>ON_ERROR_STOP</literal>, это поведение поменяется и <application>psql</application> завершится с кодом 3 в случае возникновения ошибки SQL: <programlisting>psql --set ON_ERROR_STOP=on имя_базы &lt; входной_файл</programlisting> В любом случае, вы получите только частично восстановленную базу данных. В качестве альтернативы можно указать, что весь дамп должен быть восстановлен в одной транзакции, так что восстановление либо полностью выполнится, либо полностью отменится. Включить данный режим можно, передав <application>psql</application> аргумент <option>-1</option> или <option>--single-transaction</option>. Выбирая этот режим, учтите, что даже незначительная ошибка может привести к откату восстановления, которое могло продолжаться несколько часов. Однако, это всё же может быть предпочтительней, чем вручную вычищать сложную базу данных после частично восстановленного дампа.</para>

   <para>Благодаря способности <application>pg_dump</application> и <application>psql</application> писать и читать каналы ввода/вывода, можно скопировать базу данных непосредственно с одного сервера на другой, например: <programlisting>pg_dump -h <replaceable>host1</replaceable> <replaceable>имя_базы</replaceable> | psql -h <replaceable>host2</replaceable> <replaceable>имя_базы</replaceable></programlisting></para>

   <important>
    <para>Дампы, которые выдаёт <application>pg_dump</application>, содержат определения относительно <literal>template0</literal>. Это означает, что любые языки, процедуры и т. п., добавленные в базу через <literal>template1</literal>, <application>pg_dump</application> также выгрузит в дамп. Как следствие, если при восстановлении вы используете модифицированный <literal>template1</literal>, вы должны создать пустую базу данных из <literal>template0</literal>, как показано в примере выше.</para>
   </important>

   <para>После восстановления резервной копии имеет смысл запустить <xref linkend="sql-analyze"/> для каждой базы данных, чтобы оптимизатор запросов получил полезную статистику; за подробностями обратитесь к <xref remap="3" linkend="vacuum-for-statistics"/> и <xref remap="3" linkend="autovacuum"/>. Другие советы по эффективной загрузке больших объёмов данных в <productname>&productname;</productname> вы можете найти в <xref remap="6" linkend="populate"/>.</para>
  </sect2>

  <sect2 id="backup-dump-all">
   <title>Использование <application>pg_dumpall</application></title>

   <para>Программа <application>pg_dump</application> выгружает только одну базу данных в один момент времени и не включает в дамп информацию о ролях и табличных пространствах (так как это информация уровня кластера, а не самой базы данных). Для удобства создания дампа всего содержимого кластера баз данных предоставляется программа <xref linkend="app-pg-dumpall"/>, которая делает резервную копию всех баз данных кластера, а также сохраняет данные уровня кластера, такие как роли и определения табличных пространств. Простое использование этой команды: <synopsis>
pg_dumpall &gt; <replaceable>выходной_файл</replaceable>
</synopsis> Полученную копию можно восстановить с помощью <application>psql</application>: <synopsis>
psql -f <replaceable class="parameter">входной_файл</replaceable> postgres
</synopsis> (В принципе, здесь в качестве начальной базы данных можно указать имя любой существующей базы, но если вы загружаете копию в пустой кластер, обычно нужно использовать <literal>postgres</literal>). Восстанавливать дамп, который выдала <application>pg_dumpall</application>, всегда необходимо с правами суперпользователя, так как они требуются для восстановления информации о ролях и табличных пространствах. Если вы используете табличные пространства, убедитесь, что пути к табличным пространствам в дампе соответствуют новой среде.</para>

   <para><application>pg_dumpall</application> выдаёт команды, которые заново создают роли, табличные пространства и пустые базы данных, а затем вызывает для каждой базы <application>pg_dump</application>. Таким образом, хотя каждая база данных будет внутренне согласованной, состояние разных баз не будет синхронным.</para>

   <para>Только глобальные данные кластера можно выгрузить, передав <application>pg_dumpall</application> ключ <option>--globals-only</option>. Это необходимо, чтобы полностью скопировать кластер, когда <application>pg_dump</application> выполняется для отдельных баз данных.</para>
  </sect2>

  <sect2 id="backup-dump-large">
   <title>Управление большими базами данных</title>

   <para>Некоторые операционные системы накладывают ограничение на максимальный размер файла, что приводит к проблемам при создании больших файлов с помощью <application>pg_dump</application>. К счастью, <application>pg_dump</application> может писать в стандартный вывод, так что вы можете использовать стандартные инструменты Unix для того, чтобы избежать потенциальных проблем. Вот несколько возможных методов:</para>

   <formalpara>
    <title>Используйте сжатые дампы.</title>
    <para>Вы можете использовать предпочитаемую программу сжатия, например <application>gzip</application>: <programlisting>pg_dump <replaceable class="parameter">имя_базы</replaceable> | gzip &gt; <replaceable class="parameter">имя_файла</replaceable>.gz</programlisting> Затем загрузить сжатый дамп можно командой: <programlisting>gunzip -c <replaceable class="parameter">имя_файла</replaceable>.gz | psql <replaceable class="parameter">имя_базы</replaceable></programlisting> или: <programlisting>cat <replaceable class="parameter">имя_файла</replaceable>.gz | gunzip | psql <replaceable class="parameter">имя_базы</replaceable></programlisting></para>
   </formalpara>

   <formalpara>
    <title>Используйте <command>split</command>.</title>
    <para>Команда <command>split</command> может разбивать выводимые данные на небольшие файлы, размер которых удовлетворяет ограничению нижележащей файловой системы. Например, чтобы получить части по 1 мегабайту: <programlisting>pg_dump <replaceable class="parameter">имя_базы</replaceable> | split -b 1m - <replaceable class="parameter">имя_файла</replaceable></programlisting> Восстановить их можно так: <programlisting>cat <replaceable class="parameter">имя_файла</replaceable>* | psql <replaceable class="parameter">имя_базы</replaceable></programlisting></para>
   </formalpara>

   <formalpara>
    <title>Используйте специальный формат дампа <application>pg_dump</application>.</title>
    <para>Если при сборке <productname>&productname;</productname> была подключена библиотека <application>zlib</application>, дамп в специальном формате будет записываться в файл в сжатом виде. В таком формате размер файла дампа будет близок к размеру, полученному с применением <command>gzip</command>, но он лучше тем, что позволяет восстанавливать таблицы выборочно. Следующая команда выгружает базу данных в специальном формате: <programlisting>pg_dump -Fc <replaceable class="parameter">имя_базы</replaceable> &gt; <replaceable class="parameter">имя_файла</replaceable></programlisting> Дамп в специальном формате не является скриптом для <application>psql</application> и должен восстанавливаться с помощью команды <application>pg_restore</application>, например: <programlisting>pg_restore -d <replaceable class="parameter">имя_базы</replaceable> <replaceable class="parameter">имя_файла</replaceable></programlisting> За подробностями обратитесь к справке по командам <xref linkend="app-pgdump"/> и <xref linkend="app-pgrestore"/>.</para>
   </formalpara>

   <para>Для очень больших баз данных может понадобиться сочетать <command>split</command> с одним из двух других методов.</para>

   <formalpara>
    <title>Используйте возможность параллельной выгрузки в <application>pg_dump</application>.</title>
    <para>Чтобы ускорить выгрузку большой БД, вы можете использовать режим параллельной выгрузки в <application>pg_dump</application>. При этом одновременно будут выгружаться несколько таблиц. Управлять числом параллельных заданий позволяет параметр <command>-j</command>. Параллельная выгрузка поддерживается только для формата архива в каталоге. <programlisting>pg_dump -j <replaceable class="parameter">число</replaceable> -F d -f <replaceable class="parameter">выходной_каталог</replaceable> <replaceable class="parameter">имя_базы</replaceable></programlisting> Вы также можете восстановить копию в параллельном режиме с помощью <command>pg_restore -j</command>. Это поддерживается для любого архива в формате каталога или специальном формате, даже если архив создавался не командой <command>pg_dump -j</command>.</para>
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="backup-file">
  <title>Резервное копирование на уровне файлов</title>

  <para>Альтернативной стратегией резервного копирования является непосредственное копирование файлов, в которых <productname>&productname;</productname> хранит содержимое базы данных; в <xref remap="6" linkend="creating-cluster"/> рассказывается, где находятся эти файлы. Вы можете использовать любой способ копирования файлов по желанию, например: <programlisting>tar -cf backup.tar /usr/local/pgsql/data</programlisting></para>

  <para>Однако, существуют два ограничения, которые делают этот метод непрактичным или как минимум менее предпочтительным по сравнению с <application>pg_dump</application>: <orderedlist>
    <listitem>
     <para>Чтобы полученная резервная копия была годной, сервер баз данных <emphasis>должен</emphasis> быть остановлен. Такие полумеры, как запрещение всех подключений к серверу, работать <emphasis>не</emphasis> будут (отчасти потому что <command>tar</command> и подобные средства не получают мгновенный снимок состояния файловой системы, но ещё и потому, что в сервере есть внутренние буферы). Узнать о том, как остановить сервер, можно в <xref remap="6" linkend="server-shutdown"/>. Необходимо отметить, что сервер нужно будет остановить и перед восстановлением данных.</para>
    </listitem>

    <listitem>
     <para>Если вы ознакомились с внутренней организацией базы данных в файловой системе, у вас может возникнуть соблазн скопировать или восстановить только отдельные таблицы или базы данных в соответствующих файлах или каталогах. Это <emphasis>не</emphasis> будет работать, потому что информацию, содержащуюся в этих файлах, нельзя использовать без файлов журналов транзакций, <filename>pg_clog/*</filename>, которые содержат состояние всех транзакций. Без этих данных файлы таблиц непригодны к использованию. Разумеется также невозможно восстановить только одну таблицу и соответствующие данные <filename>pg_clog</filename>, потому что в результате нерабочими станут все другие таблицы в кластере баз данных. Таким образом, копирование на уровне файловой системы будет работать, только если выполняется полное копирование и восстановление всего кластера баз данных.</para>
    </listitem>
   </orderedlist></para>

  <para>Ещё один подход к резервному копированию файловой системы заключается в создании <quote>целостного снимка</quote> каталога с данными, если это поддерживает файловая система (и вы склонны считать, что эта функциональность реализована корректно). Типичная процедура включает создание <quote>замороженного снимка</quote> тома, содержащего базу данных, затем копирование всего каталога с данными (а не его избранных частей, см. выше) из этого снимка на устройство резервного копирования, и наконец освобождение замороженного снимка. При этом сервер базы данных может не прекращать свою работу. Однако резервная копия, созданная таким способом, содержит файлы базы данных в таком состоянии, как если бы сервер баз данных не был остановлен штатным образом; таким образом, когда вы запустите сервер баз данных с сохранёнными данными, он будет считать, что до этого процесс сервера был прерван аварийно, и будет накатывать журнал WAL. Это не проблема, просто имейте это в виду (и обязательно включите файлы WAL в резервную копию). Чтобы сократить время восстановления, можно выполнить команду <command>CHECKPOINT</command> перед созданием снимка.</para>

  <para>Если ваша база данных размещена в нескольких файловых системах, получить в точности одновременно замороженные снимки всех томов может быть невозможно. Например, если файлы данных и журналы WAL находятся на разных дисках или табличные пространства расположены в разных файловых системах, резервное копирование со снимками может быть неприменимо, потому что снимки <emphasis>должны</emphasis> быть одновременными. В таких ситуациях очень внимательно изучите документацию по вашей файловой системе, прежде чем довериться технологии согласованных снимков.</para>

  <para>Если одновременные снимки невозможны, остаётся вариант с остановкой сервера баз данных на время, достаточное для получения всех замороженных снимков. Другое возможное решение — получить базовую копию путём непрерывного архивирования (см. <xref remap="4" linkend="backup-base-backup"/>), такие резервные копии не могут пострадать от изменений файловой системы в процессе резервного копирования. Для этого требуется включить непрерывное архивирование только на время резервного копирования; для восстановления применяется процедура восстановления из непрерывного архива (<xref linkend="backup-pitr-recovery"/>).</para>

  <para>Ещё один вариант — копировать содержимое файловой системы с помощью <application>rsync</application>. Для этого <application>rsync</application> запускается сначала во время работы сервера баз данных, а затем сервер останавливается на время, достаточное для запуска <command>rsync --checksum</command>. (Ключ <option>--checksum</option> необходим, потому что <command>rsync</command> различает время только с точностью до секунд.) Во второй раз <application>rsync</application> отработает быстрее, чем в первый, потому что скопировать надо будет относительно немного данных; и в итоге будет получен согласованный результат, так как сервер был остановлен. Данный метод позволяет получить копию на уровне файловой системы с минимальным временем простоя.</para>

  <para>Обратите внимание, что размер копии на уровне файлов обычно больше, чем дампа SQL. (Программе <application>pg_dump</application> не нужно, например, записывать содержимое индексов, достаточно команд для их пересоздания). Однако копирование на уровне файлов может выполняться быстрее.</para>
 </sect1>

 <sect1 id="continuous-archiving">
  <title>Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR)</title>

  <indexterm zone="backup"><primary>непрерывное архивирование</primary></indexterm>

  <indexterm zone="backup"><primary>восстановление на момент времени</primary></indexterm>

  <indexterm zone="backup"><primary>PITR</primary></indexterm>

  <para>Всё время в процессе работы <productname>&productname;</productname> ведёт <firstterm>журнал упреждающей записи</firstterm> (WAL), который расположен в подкаталоге <filename>pg_xlog/</filename> каталога с данными кластера баз данных. В этот журнал записываются все изменения, вносимые в файлы данных. Прежде всего, журнал существует для безопасного восстановления после краха сервера: если происходит крах, целостность СУБД может быть восстановлена в результате <quote>воспроизведения</quote> записей, зафиксированных после последней контрольной точки. Однако наличие журнала делает возможным использование третьей стратегии копирования баз данных: можно сочетать резервное копирование на уровне файловой системы с копированием файлов WAL. Если потребуется восстановить данные, мы можем восстановить копию файлов, а затем воспроизвести журнал из скопированных файлов WAL, и таким образом привести систему в нужное состояние. Такой подход более сложен для администрирования, чем любой из описанных выше, но он имеет значительные преимущества: <itemizedlist>
   <listitem>
    <para>В качестве начальной точки для восстановления необязательно иметь полностью согласованную копию на уровне файлов. Внутренняя несогласованность копии будет исправлена при воспроизведении журнала (практически то же самое происходит при восстановлении после краха). Таким образом, согласованный снимок файловой системы не требуется, вполне можно использовать <application>tar</application> или похожие средства архивации.</para>
   </listitem>
   <listitem>
    <para>Поскольку при воспроизведении можно обрабатывать неограниченную последовательность файлов WAL, непрерывную резервную копию можно получить, просто продолжая архивировать файлы WAL. Это особенно ценно для больших баз данных, полные резервные копии которых делать как минимум неудобно.</para>
   </listitem>
   <listitem>
    <para>Воспроизводить все записи WAL до самого конца нет необходимости. Воспроизведение можно остановить в любой точке и получить целостный снимок базы данных на этот момент времени. Таким образом, данная технология поддерживает <firstterm>восстановление на момент времени</firstterm>: можно восстановить состояние базы данных на любое время с момента создания резервной копии.</para>
   </listitem>
   <listitem>
    <para>Если непрерывно передавать последовательность файлов WAL другому серверу, получившему данные из базовой копии того же кластера, получается система <firstterm>тёплого резерва</firstterm>: в любой момент мы можем запустить второй сервер и он будет иметь практически текущую копию баз данных.</para>
   </listitem>
  </itemizedlist></para>

  <note>
   <para>Программы <application>pg_dump</application> и <application>pg_dumpall</application> не создают копии на уровне файловой системы и не могут применяться как часть решения по непрерывной архивации. Создаваемые ими копии являются логическими и не содержат информации, необходимой для воспроизведения WAL.</para>
  </note>

  <para>Как и обычное резервное копирование файловой системы, этот метод позволяет восстанавливать только весь кластер баз данных целиком, но не его части. Кроме того, для архивов требуется большое хранилище: базовая резервная копия может быть объёмной, а нагруженные системы будут генерировать многие мегабайты трафика WAL, который необходимо архивировать. Тем не менее, этот метод резервного копирования предпочитается во многих ситуациях, где необходима высокая надёжность.</para>

  <para>Для успешного восстановления с применением непрерывного архивирования (также называемого <quote>оперативным резервным копированием</quote> многими разработчиками СУБД), вам необходима непрерывная последовательность заархивированных файлов WAL, начинающаяся не позже, чем с момента начала копирования. Так что для начала вы должны настроить и протестировать процедуру архивирования файлов WAL <emphasis>до того</emphasis>, как получите первую базовую копию. Соответственно, сначала мы обсудим механику архивирования файлов WAL.</para>

  <sect2 id="backup-archiving-wal">
   <title>Настройка архивирования WAL</title>

   <para>В абстрактном смысле, запущенная СУБД <productname>&productname;</productname> производит неограниченно длинную последовательность записей WAL. СУБД физически делит эту последовательность на <firstterm>файлы-сегменты</firstterm> WAL, которые обычно имеют размер в 16 МиБ (хотя размер сегмента может быть изменён при сборке <productname>&productname;</productname>). Файлы-сегменты получают цифровые имена, которые отражают их позицию в абстрактной последовательности WAL. Когда архивирование WAL не применяется, система обычно создаёт только несколько файлов-сегментов и затем <quote>перерабатывает</quote> их, меняя номер в имени более не нужного файла-сегмента на больший. Предполагается, что файлы-сегменты, чьё содержимое предшествует последней контрольной точке, уже не представляют интереса и могут быть переработаны.</para>

   <para>При архивировании данных WAL необходимо считывать содержимое каждого файла-сегмента, как только он заполняется, и сохранять эти данные куда-то, прежде чем файл-сегмент будет переработан и использован повторно. В зависимости от применения и доступного аппаратного обеспечения, возможны разные способы <quote>сохранить данные куда-то</quote>: можно скопировать файлы-сегменты в смонтированный по NFS каталог на другую машину, записать их на ленту (убедившись, что у вас есть способ идентифицировать исходное имя каждого файла) или собрать их в пакет и записать на CD, либо какие-то совсем другие варианты. Чтобы у администратора баз данных была гибкость в этом плане, <productname>&productname;</productname> пытается не делать каких-либо предположений о том, как будет выполняться архивация. Вместо этого, <productname>&productname;</productname> позволяет администратору указать команду оболочки, которая будет запускаться для копирования завершённого файла-сегмента в нужное место. Эта команда может быть простой как <literal>cp</literal>, а может вызывать сложный скрипт оболочки &mdash; это решать вам.</para>

   <para>Чтобы включить архивирование WAL, установите в параметре конфигурации <xref linkend="guc-wal-level"/> уровень <literal>replica</literal> (или выше), в <xref linkend="guc-archive-mode"/> — значение <literal>on</literal>, и задайте желаемую команду оболочки в параметре <xref linkend="guc-archive-command"/>. На практике эти параметры всегда задаются в файле <filename>postgresql.conf</filename>. В <varname>archive_command</varname> символы <literal>%p</literal> заменяются полным путём к файлу, подлежащему архивации, а <literal>%f</literal> заменяются только именем файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога данных кластера). Если в команду нужно включить сам символ <literal>%</literal>, запишите <literal>%%</literal>. Простейшая команда, которая может быть полезна: <programlisting>archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows</programlisting> Она будет копировать архивируемые сегменты WAL в каталог /mnt/server/archivedir. (Команда дана как пример, а не как рекомендация, и может не работать на всех платформах.) После замены параметров <literal>%p</literal> и <literal>%f</literal> фактически запускаемая команда может выглядеть так: <programlisting>test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065</programlisting> Подобная команда будет генерироваться для каждого следующего архивируемого файла.</para>

   <para>Команда архивирования будет запущена от имени того же пользователя, от имени которого работает сервер <productname>&productname;</productname>. Поскольку архивируемые последовательности файлов WAL фактически содержат всё, что есть в вашей базе данных, вам нужно будет защитить архивируемые данные от посторонних глаз; например, сохраните архив в каталог, чтение которого запрещено для группы и остальных пользователей.</para>

   <para>Важно, чтобы команда архивирования возвращала нулевой код завершения, если и только если она завершилась успешно. Получив нулевой результат, <productname>&productname;</productname> будет полагать, что файл успешно заархивирован и удалит его или переработает. Однако, ненулевой код состояния скажет <productname>&productname;</productname>, что файл не заархивирован; попытки заархивировать его будут периодически повторяться, пока это не удастся.</para>

   <para>Команда архивирования обычно разрабатывается так, чтобы не допускать перезаписи любых существующих архивных файлов. Это важная мера безопасности, позволяющая сохранить целостность архива в случае ошибки администратора (например, если архивируемые данные двух разных серверов будут сохраняться в одном каталоге).</para>

   <para>Рекомендуется протестировать команду архивирования, чтобы убедиться, что она действительно не перезаписывает существующие файлы, и что она <emphasis>возвращает ненулевое состояние в этом случае</emphasis>. В показанной выше команде для Unix для этого добавлен отдельный шаг <command>test</command>. На некоторых платформах Unix у <command>cp</command> есть ключ <option>-i</option>, который позволяет сделать то же, но менее явно; но не проверив, какой код состояния при этом возвращается, полагаться на этот ключ не следует. (В частности, GNU <command>cp</command> возвратит нулевой код состояния, если используется ключ <option>-i</option> и целевой файл существует, а это <emphasis>не то</emphasis>, что нужно.)</para>

   <para>Разрабатывая схему архивирования, подумайте, что произойдёт, если команда архивирования начнёт постоянно выдавать ошибку, потому что требуется вмешательство оператора или для архивирования не хватает места. Например, это может произойти, если вы записываете архивы на ленточное устройство без механизма автозамены; когда лента заполняется полностью, больше ничего архивироваться не будет, пока вы не замените кассету. Вы должны убедиться, что любые возникающие ошибки или обращения к человеку (оператору), обрабатываются так, чтобы проблема решалась достаточно быстро. Пока она не разрешится, каталог <filename>pg_xlog/</filename> продолжит наполняться файлами-сегментами WAL. (Если файловая система, в которой находится каталог <filename>pg_xlog/</filename> заполнится до конца, <productname>&productname;</productname> завершит свою работу аварийно. Зафиксированные транзакции не потеряются, но база данных не будет работать, пока вы не освободите место.)</para>

   <para>Не важно, с какой скоростью работает команда архивирования, если только она не ниже средней скорости, с которой сервер генерирует записи WAL. Обычно работа продолжается, даже если процесс архивирования немного отстаёт. Если же архивирование отстаёт значительно, это приводит к увеличению объёма данных, которые могут быть потеряны в случае аварии. При этом каталог <filename>pg_xlog/</filename> будет содержать большое количество ещё не заархивированных файлов-сегментов, которые в конце концов могут занять всё доступное дисковое пространство. Поэтому рекомендуется контролировать процесс архивации и следить за тем, чтобы он выполнялся как задумано.</para>

   <para>При написании команды архивирования вы должны иметь в виду, что имена файлов для архивирования могут иметь длину до 64 символов и содержать любые комбинации из цифр, точек и букв ASCII. Сохранять исходный относительный путь (<literal>%p</literal>) необязательно, но необходимо сохранять имя файла (<literal>%f</literal>).</para>

   <para>Обратите внимание, что хотя архивирование WAL позволяет сохранить любые изменения данных, произведённые в базе данных <productname>&productname;</productname>, оно не затрагивает изменения, внесённые в конфигурационные файлы (такие как <filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> и <filename>pg_ident.conf</filename>), поскольку эти изменения выполняются вручную, а не через SQL. Поэтому имеет смысл разместить конфигурационные файлы там, где они будут заархивированы обычными процедурами копирования файлов. Как перемещать конфигурационные файлы, рассказывается в <xref remap="6" linkend="runtime-config-file-locations"/>.</para>

   <para>Команда архивирования вызывается, только когда сегмент WAL заполнен до конца. Таким образом, если сервер постоянно генерирует небольшой трафик WAL (или есть продолжительные периоды, когда это происходит), между завершением транзакций и их безопасным сохранением в архиве может образоваться большая задержка. Чтобы ограничить время жизни неархивированных данных, можно установить <xref linkend="guc-archive-timeout"/>, чтобы сервер переключался на новый файл сегмента WAL как минимум с заданной частотой. Заметьте, что неполные файлы, архивируемые досрочно из-за принудительного переключения по тайм-ауту, будут иметь тот же размер, что и заполненные файлы. Таким образом, устанавливать очень маленький <varname>archive_timeout</varname> &mdash; неразумно; это приведёт к неэффективному заполнению архива. Обычно подходящее значение <varname>archive_timeout</varname> — минута или около того.</para>

   <para>Также вы можете принудительно переключить сегмент WAL вручную с помощью <function>pg_switch_xlog</function>, если хотите, чтобы только что завершённая транзакция заархивировалась как можно скорее. Другие полезные функции, относящиеся к управлению WAL, перечисляются в <xref remap="6" linkend="functions-admin-backup-table"/>.</para>

   <para>Когда <varname>wal_level</varname> имеет значение <literal>minimal</literal>, некоторые команды SQL выполняются в обход журнала WAL, как описывается в <xref remap="6" linkend="populate-pitr"/>. Если архивирование или потоковая репликация были включены во время выполнения таких операторов, WAL не будет содержать информацию, необходимую для восстановления. (На восстановление после краха это не распространяется). Поэтому <varname>wal_level</varname> можно изменить только при запуске сервера. Однако, чтобы изменить команду <varname>archive_command</varname>, достаточно перезагрузить файл конфигурации. Если вы хотите на время остановить архивирование, это можно сделать, например, задав в качестве значения <varname>archive_command</varname> пустую строку (''). В результате файлы WAL будут накапливаться в каталоге <filename>pg_xlog/</filename>, пока не будет восстановлена действующая команда <varname>archive_command</varname>.</para>
  </sect2>

  <sect2 id="backup-base-backup">
   <title>Создание базовой резервной копии</title>

   <para>Проще всего получить базовую резервную копию, используя программу <xref linkend="app-pgbasebackup"/>. Эта программа сохраняет базовую копию в виде обычных файлов или в архиве tar. Если гибкости <xref linkend="app-pgbasebackup"/> не хватает, вы также можете получить базовую резервную копию, используя низкоуровневый API (см. <xref remap="4" linkend="backup-lowlevel-base-backup"/>).</para>

   <para>Продолжительность создания резервной копии обычно не имеет большого значения. Однако, если вы эксплуатируете сервер с отключённым режимом <varname>full_page_writes</varname>, вы можете заметить падение производительности в процессе резервного копирования, так как режим <varname>full_page_writes</varname> включается принудительно на время резервного копирования.</para>

   <para>Чтобы резервной копией можно было пользоваться, нужно сохранить все файлы сегментов WAL, сгенерированные во время и после копирования файлов. Для облегчения этой задачи, процесс создания базовой резервной копии записывает <firstterm>файл истории резервного копирования</firstterm>, который немедленно сохраняется в области архивации WAL. Данный файл получает имя по имени файла первого сегмента WAL, который потребуется для восстановления скопированных файлов. Например, если начальный файл WAL назывался <literal>0000000100001234000055CD</literal>, файл истории резервного копирования получит имя <literal>0000000100001234000055CD.007C9330.backup</literal>. (Вторая часть имени файла обозначает точную позицию внутри файла WAL и обычно может быть проигнорирована.) Как только вы заархивировали копии файлов данных и файлов сегментов WAL, полученных в процессе копирования (по сведениям в файле истории резервного копирования), все заархивированные сегменты WAL с именами, меньшими по номеру, становятся ненужными для восстановления файловой копии и могут быть удалены. Но всё же рассмотрите возможность хранения нескольких наборов резервных копий, чтобы быть абсолютно уверенными, что вы сможете восстановить ваши данные.</para>

   <para>Файл истории резервного копирования &mdash; это просто небольшой текстовый файл. В него записывается метка, которая была передана <xref linkend="app-pgbasebackup"/>, а также время и текущие сегменты WAL в момент начала и завершения резервной копии. Если вы связали с данной меткой соответствующий файл дампа, то заархивированного файла истории достаточно, чтобы найти файл дампа, нужный для восстановления.</para>

   <para>Поскольку необходимо хранить все заархивированные файлы WAL с момента последней базовой резервной копии, интервал базового резервного копирования обычно выбирается в зависимости от того, сколько места может быть выделено для архива файлов WAL. Также стоит отталкиваться от того, сколько вы готовы ожидать восстановления, если оно понадобится — системе придётся воспроизвести все эти сегменты WAL, а этот процесс может быть долгим, если с момента последней базовой копии прошло много времени.</para>
  </sect2>

  <sect2 id="backup-lowlevel-base-backup">
   <title>Создание базовой резервной копии через низкоуровневый API</title>
   <para>Процедура создания базовой резервной копии с использованием низкоуровневого API содержит чуть больше шагов, чем метод <xref linkend="app-pgbasebackup"/>, но всё же относительно проста. Очень важно, чтобы эти шаги выполнялись по порядку, и следующий шаг выполнялся, только если предыдущий успешен.</para>
   <para>Резервное копирование на низком уровне можно произвести в монопольном или немонопольном режиме. Рекомендуется применять немонопольный метод, а монопольный считается устаревшим и в конце концов будет ликвидирован.</para>
   <sect3 id="backup-lowlevel-base-backup-nonexclusive">
    <title>Немонопольное резервное копирование на низком уровне</title>
    <para>Немонопольное резервное копирование позволяет параллельно запускать другие процессы копирования (используя тот же API или <xref linkend="app-pgbasebackup"/>).</para>
    <para>
  <orderedlist>
   <listitem>
    <para>Убедитесь, что архивирование WAL включено и работает.</para>
   </listitem>
   <listitem>
    <para>Подключитесь к серверу (к любой базе данных) как пользователь с правами на выполнение pg_start_backup (суперпользователь или пользователь, которому дано право EXECUTE для этой функции) и выполните команду: <programlisting>SELECT pg_start_backup('label', false, false);</programlisting> где <literal>label</literal> &mdash; любая метка, по которой можно однозначно идентифицировать данную операцию резервного копирования. Соединение, через которое вызывается <function>pg_start_backup</function>, должно поддерживаться до окончания резервного копирования, иначе этот процесс будет автоматически прерван.</para>

    <para>По умолчанию <function>pg_start_backup</function> может выполняться длительное время. Это объясняется тем, что функция выполняет контрольную точку, а операции ввода/вывода, требуемые для этого, распределяются в интервале времени, по умолчанию равном половине интервала между контрольными точками (см. параметр <xref linkend="guc-checkpoint-completion-target"/>). Обычно это вполне приемлемо, так как при этом минимизируется влияние на выполнение других запросов. Если же вы хотите начать резервное копирование максимально быстро, передайте во втором параметре <literal>true</literal>. В этом случае контрольная точка будет выполнена немедленно без ограничения объёма ввода/вывода.</para>

    <para>Третий параметр, имеющий значение <literal>false</literal>, указывает <function>pg_start_backup</function> начать немонопольное базовое копирование.</para>
   </listitem>
   <listitem>
    <para>Скопируйте файлы, используя любое удобное средство резервного копирования, например, <application>tar</application> или <application>cpio</application> (не <application>pg_dump</application> или <application>pg_dumpall</application>). В процессе копирования останавливать работу базы данных не требуется, это ничего не даёт. В <xref remap="6" linkend="backup-lowlevel-base-backup-data"/> описано, что следует учитывать в процессе копирования.</para>
   </listitem>
   <listitem>
    <para>Через то же подключение, что и раньше, выполните команду: <programlisting>SELECT * FROM pg_stop_backup(false);</programlisting> Сервер выйдет из режима резервного копирования и автоматически переключится на следующий сегмент WAL. Это переключение выполняется для того, чтобы файл последнего сегмента WAL, записанного во время копирования, был готов к архивации.</para>
    <para>Функция <function>pg_stop_backup</function> возвратит одну строку с тремя значениями. Второе из них нужно записать в файл <filename>backup_label</filename> в корневой каталог резервной копии. Третье значение, если оно не пустое, должно быть записано в файл <filename>tablespace_map</filename>. Эти значения крайне важны для восстановления копии и должны записываться без изменений.</para>
   </listitem>
   <listitem>
    <para>После этого останется заархивировать файлы сегментов WAL, активных во время создания резервной копии, и процедура резервного копирования будет завершена. Функция <function>pg_stop_backup</function> в первом значении результата указывает, какой последний сегмент требуется для формирования полного набора файлов резервной копии. Если включён режим архивации (параметр <varname>archive_mode</varname>), функция <function>pg_stop_backup</function> не завершится, пока не будет заархивирован последний сегмент. В этом случае файлы будут заархивированы автоматически, поскольку также должна быть настроена команда <varname>archive_command</varname>. Чаще всего это происходит быстро, но мы советуем наблюдать за системой архивации и проверять, не возникают ли задержки. Если архивирование остановится из-за ошибок команды архивации, попытки архивации будут продолжаться до успешного завершения, и только тогда резервная копия будет завершена. Если вы хотите ограничить время выполнения <function>pg_stop_backup</function>, установите соответствующее значение в <varname>statement_timeout</varname>, но заметьте, что в случае прерывания <function>pg_stop_backup</function> по времени резервная копия может оказаться негодной.</para>
   </listitem>
  </orderedlist>
    </para>
   </sect3>
   <sect3 id="backup-lowlevel-base-backup-exclusive">
    <title>Монопольное резервное копирование на низком уровне</title>
    <para>Монопольное резервное копирование во многом похоже на немонопольное, но имеет несколько важных отличий. Этот вариант не позволяет запустить больше одного процесса копирования одновременно, а в случае сбоя в процессе копирования возможны некоторые осложнения на сервере. До &productname; 9.6 это был единственный возможный метод низкоуровневого копирования, но сейчас пользователям рекомендуется по возможности подкорректировать свои скрипты и перейти к использованию немонопольного варианта.</para>
    <para>
  <orderedlist>
   <listitem>
    <para>Убедитесь, что архивирование WAL включено и работает.</para>
   </listitem>
   <listitem>
    <para>Подключитесь к серверу (к любой базе данных) как пользователь с правами на выполнение pg_start_backup (суперпользователь или пользователь, которому дано право EXECUTE для этой функции) и выполните команду: <programlisting>SELECT pg_start_backup('label');</programlisting> где <literal>label</literal> &mdash; любая метка, по которой можно однозначно идентифицировать данную операцию резервного копирования. Функция <function>pg_start_backup</function> создаёт в каталоге кластера файл <firstterm>метки резервного копирования</firstterm>, называемый <filename>backup_label</filename>, в который помещается информация о резервной копии, включающая время начала и строку метки. Эта функция также создаёт в каталоге кластера файл <firstterm>карты табличных пространств</firstterm>, называемый <filename>tablespace_map</filename>, с информацией о символических ссылках табличных пространств в <filename>pg_tblspc/</filename>, если такие ссылки есть. Оба файла важны для целостности резервных копии и понадобятся при восстановлении.</para>

    <para>По умолчанию <function>pg_start_backup</function> может выполняться длительное время. Это объясняется тем, что функция выполняет контрольную точку, а операции ввода/вывода, требуемые для этого, распределяются в интервале времени, по умолчанию равном половине интервала между контрольными точками (см. параметр <xref linkend="guc-checkpoint-completion-target"/>). Обычно это вполне приемлемо, так как при этом минимизируется влияние на выполнение других запросов. Если же вы хотите начать резервное копирование максимально быстро, выполните: <programlisting>SELECT pg_start_backup('label', true);</programlisting> При этом контрольная точка будет выполнена как можно скорее.</para>
   </listitem>
   <listitem>
    <para>Скопируйте файлы, используя любое удобное средство резервного копирования, например, <application>tar</application> или <application>cpio</application> (не <application>pg_dump</application> или <application>pg_dumpall</application>). В процессе копирования останавливать работу базы данных не требуется, это ничего не даёт. В <xref remap="6" linkend="backup-lowlevel-base-backup-data"/> описано, что следует учитывать в процессе копирования.</para>
   </listitem>
   <listitem>
    <para>Снова подключитесь к базе данных как пользователь с правами на выполнение pg_stop_backup (суперпользователь или пользователь, которому дано право EXECUTE для этой функции) и выполните команду: <programlisting>SELECT pg_stop_backup();</programlisting> Сервер выйдет из режима резервного копирования и автоматически переключится на следующий сегмент WAL. Это переключение выполняется для того, чтобы файл последнего сегмента WAL, записанного во время копирования, был готов к архивации.</para>
   </listitem>
   <listitem>
    <para>После этого останется заархивировать файлы сегментов WAL, активных во время создания резервной копии, и процедура резервного копирования будет завершена. Функция <function>pg_stop_backup</function> возвращает указание на файл последнего сегмента, который требуется для формирования полного набора файлов резервной копии. Если включён режим архивации (параметр <varname>archive_mode</varname>), функция <function>pg_stop_backup</function> не завершится, пока не будет заархивирован последний сегмент. В этом случае файлы будут заархивированы автоматически, поскольку также должна быть настроена команда <varname>archive_command</varname>. Чаще всего это происходит быстро, но мы советуем наблюдать за системой архивации и проверять, не возникают ли задержки. Если архивирование остановится из-за ошибок команды архивации, попытки архивации будут продолжаться до успешного завершения, и только тогда резервная копия будет завершена. Если вы хотите ограничить время выполнения <function>pg_stop_backup</function>, установите соответствующее значение в <varname>statement_timeout</varname>, но заметьте, что в случае прерывания <function>pg_stop_backup</function> по времени резервная копия может оказаться негодной.</para>
   </listitem>
  </orderedlist>
    </para>
   </sect3>
   <sect3 id="backup-lowlevel-base-backup-data">
   <title>Копирование каталога данных</title>
   <para>Некоторые средства резервного копирования файлов выдают предупреждения или ошибки, если файлы, которые они пытаются скопировать, изменяются в процессе копирования. При получении базовой резервной копии активной базы данных это вполне нормально и не является ошибкой. Однако, вам нужно знать, как отличить ошибки такого рода от реальных ошибок. Например, некоторые версии <application>rsync</application> возвращают отдельный код выхода для ситуации <quote>исчезнувшие исходные файлы</quote>, и вы можете написать управляющий скрипт, который примет этот код как не ошибочный. Также некоторые версии GNU <application>tar</application> возвращают код выхода, неотличимый от кода фатальной ошибки, если файл был усечён, когда <application>tar</application> копировал его. К счастью, GNU <application>tar</application> версий 1.16 и более поздних завершается с кодом 1, если файл был изменён во время копирования, и 2 в случае других ошибок. С GNU <application>tar</application> версии 1.23 и более поздними, вы можете использовать следующие ключи <literal>--warning=no-file-changed --warning=no-file-removed</literal>, чтобы скрыть соответствующие предупреждения.</para>

   <para>Убедитесь, что ваша резервная копия включает все файлы из каталога кластера баз данных (например, <filename>/usr/local/pgsql/data</filename>). Если вы используете табличные пространства, которые находятся не внутри этого каталога, не забудьте включить и их в резервную копию (также важно, чтобы при создании резервной копии символьные ссылки сохранялись как ссылки, иначе табличные пространства будут повреждены при восстановлении).</para>

   <para>Однако следует исключить из резервной копии файлы в подкаталоге данных кластера <filename>pg_xlog/</filename>. Эту небольшую корректировку стоит внести для снижения риска ошибок при восстановлении. Это легко организовать, если <filename>pg_xlog/</filename> — символическая ссылка на каталог за пределами каталога данных (так часто делают из соображений производительности). Также имеет смысл исключить файлы <filename>postmaster.pid</filename> и <filename>postmaster.opts</filename>, содержащие информацию о работающем процессе <application>postmaster</application> (а не о том процессе <application>postmaster</application>, который будет восстанавливать эту копию). (Эти файлы могут ввести <application>pg_ctl</application> в заблуждение.)</para>

   <para>Часто также стоит исключать из резервной копии каталог <filename>pg_replslot/</filename> кластера, чтобы слоты репликации, существующие на главном сервере, не попадали в копию. В противном случае, при последующем восстановлении копии на резервном сервере может получиться так, что он будет неограниченно долго сохранять файлы WAL, а главный не будет очищаться, если он следит за горячим резервом, так как клиенты этих слотов репликации будут продолжать подключаться и изменять состояние слотов на главном, а не резервном сервере. Даже если резервная копия предназначена только для создания нового главного сервера, копирование слотов репликации вряд ли принесёт пользу, так как к моменту включения в работу этого нового сервера содержимое этих слотов станет абсолютно неактуальным.</para>

   <para>В файл метки резервной копии записывается строка метки, заданная при вызове <function>pg_start_backup</function>, время запуска функции <function>pg_start_backup</function> и имя начального файла WAL. Таким образом, в случае сомнений можно заглянуть внутрь архива резервной копии и точно определить, в каком сеансе резервного копирования он был создан. Файл карты табличных пространств содержит имена символических ссылок, как они существуют в каталоге <filename>pg_tblspc/</filename>, и полный путь каждой символической ссылки. Эти файлы не только к вашему сведению; их существование и содержание важны для правильного проведения процесса восстановления системы.</para>

   <para>Вы также можете создать резервную копию, когда сервер остановлен. В этом случае, вы, очевидно, не сможете вызвать <function>pg_start_backup</function> или <function>pg_stop_backup</function>, и следовательно, вам надо будет самостоятельно как-то идентифицировать резервные копии и понимать, какие файлы WAL должны быть заархивированы. Поэтому обычно всё-таки лучше следовать вышеописанной процедуре непрерывного архивирования.</para>
   </sect3>
  </sect2>

  <sect2 id="backup-pitr-recovery">
   <title>Восстановление непрерывной архивной копии</title>

   <para>Допустим, худшее случилось и вам необходимо восстановить базу данных из резервной копии. Порядок действий таков: <orderedlist>
   <listitem>
    <para>Остановите сервер баз данных, если он запущен.</para>
   </listitem>
   <listitem>
    <para>Если у вас есть место для этого, скопируйте весь текущий каталог кластера баз данных и все табличные пространства во временный каталог на случай, если они вам понадобятся. Учтите, что эта мера предосторожности требует, чтобы свободного места на диске было достаточно для размещения двух копий существующих данных. Если места недостаточно, необходимо сохранить как минимум содержимое подкаталога <filename>pg_xlog</filename> каталога кластера, так как он может содержать журналы, не попавшие в архив перед остановкой системы.</para>
   </listitem>
   <listitem>
    <para>Удалите все существующие файлы и подкаталоги из каталога кластера и из корневых каталогов используемых табличных пространств.</para>
   </listitem>
   <listitem>
    <para>Восстановите файлы базы данных из архивной копии файлов. Важно, чтобы у восстановленных файлов были правильные разрешения и правильный владелец (пользователь, запускающий сервер, а не <literal>root</literal>!). Если вы используете табличные пространства, убедитесь также, что символьные ссылки в <filename>pg_tblspc/</filename> восстановились корректно.</para>
   </listitem>
   <listitem>
    <para>Удалите все файлы из <filename>pg_xlog/</filename>; они восстановились из резервной копии файлов и поэтому, скорее всего, будут старее текущих. Если вы вовсе не архивировали <filename>pg_xlog/</filename>, создайте этот каталог с правильными правами доступа, но если это была символьная ссылка, восстановите её.</para>
   </listitem>
   <listitem>
    <para>Если на шаге 2 вы сохранили незаархивированные файлы с сегментами WAL, скопируйте их в <filename>pg_xlog/</filename>. (Лучше всего именно копировать, а не перемещать их, чтобы у вас остались неизменённые файлы на случай, если возникнет проблема и всё придётся начинать сначала.)</para>
   </listitem>
   <listitem>
    <para>Создайте командный файл восстановления <filename>recovery.conf</filename> в каталоге кластера баз данных (см. <xref remap="4" linkend="recovery-config"/>). Вы можете также временно изменить <filename>pg_hba.conf</filename>, чтобы обычные пользователи не могли подключаться, пока вы не будете уверены, что восстановление завершилось успешно.</para>
   </listitem>
   <listitem>
    <para>Запустите сервер. Сервер запустится в режиме восстановления и начнёт считывать необходимые ему архивные файлы WAL. Если восстановление будет прервано из-за внешней ошибки, сервер можно просто перезапустить и он продолжит восстановление. По завершении процесса восстановления сервер переименует файл <filename>recovery.conf</filename> в <filename>recovery.done</filename> (чтобы предотвратить повторный запуск режима восстановления), а затем перейдёт к обычной работе с базой данных.</para>
   </listitem>
   <listitem>
    <para>Просмотрите содержимое базы данных, чтобы убедиться, что вы вернули её к желаемому состоянию. Если это не так, вернитесь к шагу 1. Если всё хорошо, разрешите пользователям подключаться к серверу, восстановив обычный файл <filename>pg_hba.conf</filename>.</para>
   </listitem>
  </orderedlist></para>

   <para>Ключевой момент этой процедуры заключается в создании файла конфигурации восстановления, описывающего, как будет выполняться восстановление и до какой точки. В качестве прототипа вы можете использовать файл <filename>recovery.conf.sample</filename> (он обычно помещается в каталог <filename>share/</filename> после установки). Единственное, что совершенно необходимо указать в <filename>recovery.conf</filename> &mdash; это команду <varname>restore_command</varname>, которая говорит <productname>&productname;</productname>, как получать из архива файл-сегменты WAL. Как и <varname>archive_command</varname>, это командная строка для оболочки. Она может содержать символы <literal>%f</literal>, которые заменятся именем требующегося файла журнала, и <literal>%p</literal>, которые заменятся целевым путём для копирования этого файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога кластера данных.) Если вам нужно включить в команду сам символ <literal>%</literal>, напишите <literal>%%</literal>. Простейшая команда, которая может быть полезна, такая: <programlisting>restore_command = 'cp /mnt/server/archivedir/%f %p'</programlisting> Эта команда копирует заархивированные ранее сегменты WAL из каталога <filename>/mnt/server/archivedir</filename>. Разумеется, вы можете использовать что-то более сложное, возможно, даже скрипт оболочки, который укажет оператору установить соответствующую ленту.</para>

   <para>Важно, чтобы данная команда возвращала ненулевой код возврата в случае ошибки. Эта команда <emphasis>будет</emphasis> вызываться и с запросом файлов, отсутствующих в архиве; в этом случае она должна вернуть ненулевое значение и это считается штатной ситуацией. В исключительной ситуации, когда команда была прервана сигналом (кроме <systemitem>SIGTERM</systemitem>, который применяется в процессе остановки сервера базы данных) или произошла ошибка оболочки (например, команда не найдена), восстановление будет прервано и сервер не запустится.</para>

   <para>Не все запрашиваемые файлы будут сегментами WAL; следует также ожидать запросов файлов с суффиксом <literal>.backup</literal> или <literal>.history</literal>. Также учтите, что базовое имя пути <literal>%p</literal> будет отличаться от <literal>%f</literal>; не думайте, что они взаимозаменяемы.</para>

   <para>Сегменты WAL, которые не найдутся в архиве, система будет искать в <filename>pg_xlog/</filename>; благодаря этому можно использовать последние незаархивированные сегменты. Однако файлы в <filename>pg_xlog/</filename> будут менее предпочтительными, если такие сегменты окажутся в архиве.</para>

   <para>Обычно при восстановлении обрабатываются все доступные сегменты WAL и, таким образом, база данных восстанавливается до последнего момента времени (или максимально близкого к нему, в зависимости от наличия сегментов WAL). Таким образом, восстановление обычно завершается с сообщением <quote>файл не найден</quote>; точный текст сообщения об ошибке зависит от того, что делает <varname>restore_command</varname>. Вы также можете увидеть сообщение об ошибке в начале восстановления для файла с именем типа <filename>00000001.history</filename>. Это также нормально и обычно не говорит о какой-либо проблеме при восстановлении в простых ситуациях; подробнее об этом рассказывается в <xref remap="6" linkend="backup-timelines"/>.</para>

   <para>Если вы хотите восстановить базу на какой-то момент времени (скажем, до момента, когда неопытный администратор базы данных удалил основную таблицу транзакций), просто укажите требуемую <link linkend="recovery-target-settings">точку остановки</link> в <filename>recovery.conf</filename>. Вы можете задать точку останова, так называемую <quote>цель восстановления</quote>, по дате/времени, именованной точке восстановления или определённому идентификатору транзакции. На момент написания этой документации полезными могут быть только указания даты/времени или имени точки восстановления, пока нет никаких средств, позволяющих точно определить, какой идентификатор транзакции нужно выбрать.</para>

   <note>
     <para>Точка останова должна указывать на момент после окончания базового копирования, т. е. после времени завершения <function>pg_stop_backup</function>. Использовать базовую резервную копию для восстановления на момент времени, когда она ещё только создавалась, нельзя. (Чтобы восстановить данные на этот момент времени, придётся вернуться к предыдущей базовой резервной копии и накатывать изменения с этой позиции.)</para>
   </note>

   <para>Если при восстановлении обнаруживаются повреждённые данные WAL, восстановление прерывается в этом месте и сервер не запускается. В этом случае процесс восстановления можно перезапустить с начала, указав <quote>цель восстановления</quote> до точки повреждения, чтобы восстановление могло завершиться нормально. Если восстановление завершается ошибкой из-за внешней причины, например, из-за краха системы или недоступности архива WAL, его можно просто перезапустить, и оно продолжится с того места, где было прервано. Перезапуск восстановления реализован по тому же принципу, что и контрольные точки при обычной работе: сервер периодически сохраняет всё текущее состояние на диске и отражает это в файле <filename>pg_control</filename>, чтобы уже обработанные данные WAL не приходилось сканировать снова.</para>

  </sect2>

  <sect2 id="backup-timelines">
   <title>Линии времени</title>

  <indexterm zone="backup"><primary>линии времени</primary></indexterm>

   <para>Возможность восстановить базу данных на некий предыдущий момент времени создаёт некоторые сложности, сродни научно-фантастическим историям о путешествиях во времени и параллельных мирах. Например, предположим, что в начальной истории базы данных вы удалили важную таблицу в 17:15 во вторник, но осознали эту ошибку только в среду в полдень. Вы можете спокойно взять резервную копию, восстановить данные на 17:14 во вторник и запустить сервер. В <emphasis>этой</emphasis> истории мира базы данных вы никогда не удаляли вышеупомянутую таблицу. Но предположим, что позже вы заметили, что это была не такая уж хорошая идея и захотели вернуться к утру среды в первоначальной истории базы данных. Вы не сможете сделать это, если в процессе работы базы данных она успеет перезаписать какие-либо файлы-сегменты WAL, приводящие к моменту времени, к которому вы хотите вернуться теперь. Таким образом, для получения желаемого результата необходимо как-то отличать последовательности записей WAL, добавленные после восстановления на какой-то момент времени от тех, что существовали в начальной истории базы данных.</para>

   <para>Для решения этой проблемы в <productname>&productname;</productname> есть такое понятие, как <firstterm>линия времени</firstterm>. Всякий раз, когда завершается восстановление из архива, создаётся новая линия времени, позволяющая идентифицировать последовательность записей WAL, добавленных после этого восстановления. Номер линии времени включается в имя файлов-сегментов WAL, так что файлы новой линии времени не перезаписывают файлы WAL, сгенерированные предыдущими линиями времени. Фактически это позволяет архивировать много различных линий времени. Хотя это может показаться бесполезной возможностью, на самом деле она часто бывает спасительной. Представьте, что вы не определились, какую точку времени выбрать для восстановления, и таким образом должны проводить восстановление методом проб и ошибок, пока не найдёте лучший момент для ответвления от старой истории. Без линий времени этот процесс быстро стал бы очень запутанным. А благодаря линиям времени, вы можете вернуться к <emphasis>любому</emphasis> предыдущему состоянию, включая состояния в ветках линий времени, покинутых ранее.</para>

   <para>Каждый раз, когда образуется новая линия времени, <productname>&productname;</productname> создаёт файл <quote>истории линии времени</quote>, показывающий, от какой линии времени ответвилась данная и когда. Эти файлы истории нужны, чтобы система могла выбрать правильные файлы-сегменты WAL при восстановлении из архива, содержащего несколько линий времени. Таким образом, они помещаются в область архивов WAL так же, как и файлы сегментов WAL. Файлы истории представляют собой небольшие текстовые файлы, так что они не занимают много места и их вполне можно сохранять неограниченно долго (в отличие от файлов сегментов, имеющих большой размер). Если хотите, вы можете добавлять в файл истории комментарии, свои собственные заметки о том, как и почему была создана эта конкретная линия времени. Такие комментарии будут особенно ценны, если в результате экспериментов у вас образуется хитросплетение разных линий времени.</para>

   <para>По умолчанию при восстановлении восстанавливается та же линия времени, которая была текущей при создании базовой резервной копии. Если вы хотите восстановить состояние на какой-либо дочерней линии времени, (то есть, хотите вернуться к некоторому состоянию, которое тоже было получено в результате попытки восстановления), вам необходимо указать идентификатор целевой линии времени в <filename>recovery.conf</filename>. Восстановить состояние в линии времени, ответвившейся раньше, чем была сделана базовая резервная копия, нельзя.</para>
  </sect2>

  <sect2 id="backup-tips">
   <title>Советы и примеры</title>

   <para>Ниже мы дадим несколько советов по настройке непрерывного архивирования.</para>

    <sect3 id="backup-standalone">
     <title>Обособленные горячие резервные копии</title>

     <para>Средства резервного копирования <productname>&productname;</productname> можно применять для создания обособленных горячих копий. Эти копии нельзя использовать для восстановления на момент времени, но создаются и восстанавливаются они обычно гораздо быстрее, чем дампы <application>pg_dump</application>. (Они также намного больше, чем дампы <application>pg_dump</application>, так что в некоторых случаях выигрыш в скорости может быть потерян.)</para>

     <para>Как и базовые резервные копии, обособленную горячую копию проще всего получить, используя программу <xref linkend="app-pgbasebackup"/>. Если вы вызовете эту программу с параметром <literal>-X</literal>, в эту копию автоматически будет включён весь журнал транзакций, необходимый для её использования, так что никакие особые действия для восстановления не потребуются.</para>

     <para>Если нужна дополнительная гибкость в процессе копирования файлов, создавать обособленные горячие копии можно также на более низком уровне. Чтобы подготовиться к получению такой копии на низком уровне, установите в <varname>wal_level</varname> уровень <literal>replica</literal> (или выше), в <varname>archive_mode</varname> значение <literal>on</literal> и настройте команду <varname>archive_command</varname>, которая будет выполнять архивацию, только когда существует <emphasis>файл-переключатель</emphasis>. Например: <programlisting>archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'</programlisting> Данная команда выполнит архивацию, если будет существовать файл <filename>/var/lib/pgsql/backup_in_progress</filename>, а в противном случае просто вернёт нулевой код возврата (и тогда <productname>&productname;</productname> сможет переработать ненужный файл WAL).</para>

     <para>После такой подготовки резервную копию можно создать, например таким скриптом: <programlisting>touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/</programlisting> Сначала создаётся файл-переключатель <filename>/var/lib/pgsql/backup_in_progress</filename>, включающий архивирование заполненных файлов WAL. По окончании резервного копирования файл-переключатель удаляется. Затем заархивированные файлы WAL тоже добавляются в резервную копию, так что в одном архиве <application>tar</application> оказывается и базовая резервная копия, и все требуемые файлы WAL. Пожалуйста, не забудьте добавить в ваши скрипты резервного копирования обработку ошибок.</para>

    </sect3>

    <sect3 id="compressed-archive-logs">
     <title>Сжатие журналов в архиве</title>

     <para>Если размер архива имеет большое значение, можно воспользоваться <application>gzip</application> и сжимать архивные файлы: <programlisting>archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'</programlisting> При этом для восстановления придётся использовать <application>gunzip</application>: <programlisting>restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'</programlisting></para>
    </sect3>

    <sect3 id="backup-scripts">
     <title>Скрипты <varname>archive_command</varname></title>

     <para>Многие в качестве команды <varname>archive_command</varname> используют скрипты, так что запись в <filename>postgresql.conf</filename> оказывается очень простой: <programlisting>archive_command = 'local_backup_script.sh "%p" "%f"'</programlisting> Применять отдельный файла скрипта целесообразно всегда, когда вы хотите использовать в процедуре архивирования несколько команд. Это позволяет управлять сложностью этой процедуры в рамках одного скрипта, который можно написать на любом популярном языке скриптов, например на <application>bash</application> или <application>perl</application>.</para>

     <para>В частности, с помощью скриптов можно решить такие задачи: <itemizedlist>
       <listitem>
        <para>Копирование данных в безопасное внешнее хранилище</para>
       </listitem>
       <listitem>
        <para>Пакетная обработка файлов WAL, чтобы они передавались каждые три часа, а не по одному</para>
       </listitem>
       <listitem>
        <para>Взаимодействие с другими приложениями резервного копирования и восстановления</para>
       </listitem>
       <listitem>
        <para>Взаимодействие со средствами мониторинга, регистрация ошибок</para>
       </listitem>
      </itemizedlist></para>

     <tip>
      <para>Когда в <varname>archive_command</varname> используется скрипт, желательно включить <xref linkend="guc-logging-collector"/>. Тогда все сообщения, которые скрипт выведет в <systemitem>stderr</systemitem>, будут записываться в журнал сервера баз данных, что позволит легко диагностировать ошибки в сложных конфигурациях.</para>
     </tip>
    </sect3>
  </sect2>

  <sect2 id="continuous-archiving-caveats">
   <title>Ограничения</title>

   <para>На момент написания документации методика непрерывного архивирования имеет несколько ограничений. Они могут быть ликвидированы в будущих версиях: <itemizedlist>
   <listitem>
    <para>Операции с хеш-индексами в настоящее время не проходят через WAL, так что при воспроизведении WAL эти индексы не меняются. Это означает, что добавление данных будет игнорироваться индексом, изменяемые строки будут исчезать, а на удалённые строки сохранятся ссылки. Другими словами, если вы изменяете таблицу, для которой есть хеш-индекс, на резервном сервере вы будете получать некорректные результаты запросов. Поэтому по завершении восстановления рекомендуется вручную выполнить <xref linkend="sql-reindex"/> для каждого такого индекса.</para>
   </listitem>

   <listitem>
    <para>Если во время создания базовой резервной копии выполняется команда <xref linkend="sql-createdatabase"/>, а затем база-шаблон, задействованная в <command>CREATE DATABASE</command>, изменяется, пока продолжается копирование, возможно, что при восстановлении эти изменения распространятся также и на созданную базу данных. Конечно, это нежелательно. Во избежание подобных рисков, лучше всего не изменять никакие базы-шаблоны во время получения базовой резервной копии.</para>
   </listitem>

   <listitem>
    <para>Команды <xref linkend="sql-createtablespace"/> записываются в WAL с абсолютным путём и, таким образом, при воспроизведении WAL будут выполнены с тем же абсолютным путём. Это может быть нежелательно, если журнал воспроизводится на другой машине. Но опасность есть, даже если журнал воспроизводится на той же машине, но в другом каталоге данных: при воспроизведении будет так же перезаписано содержимое исходных табличных пространств. Чтобы избежать потенциальных проблем такого рода, лучше всего делать новую базовую резервную копию после создания или удаления табличных пространств.</para>
   </listitem>
  </itemizedlist></para>

   <para>Также следует заметить, что стандартный формат <acronym>WAL</acronym> не очень компактный, так как включает много снимков дисковых страниц. Эти снимки страниц предназначены для поддержки восстановления после сбоя, на случай, если понадобится исправить страницы, записанные на диск частично. В зависимости от аппаратного и программного обеспечения вашей системы, риск частичной записи может быть достаточно мал, так что его можно игнорировать, и в этом случае можно существенно уменьшить общий объём архивируемых журналов, выключив снимки страниц с помощью параметра <xref linkend="guc-full-page-writes"/>. (Прежде чем делать это, прочтите замечания и предупреждения в <xref remap="6" linkend="wal"/>.) Выключение снимков страниц не препятствует использованию журналов для восстановления PITR. Одним из направлений разработки в будущем является сжатие архивируемых данных WAL, путём удаления ненужных копий страниц даже при включённом режиме <varname>full_page_writes</varname>. Тем временем администраторы могут сократить количество снимков страниц, включаемых в WAL, увеличив параметры интервала контрольных точек в разумных пределах.</para>
  </sect2>
 </sect1>

</chapter>
