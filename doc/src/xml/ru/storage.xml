<!-- doc/src/xml/storage.xml -->

<chapter id="storage">

<title>Физическое хранение базы данных</title>

<para>В данной главе рассматривается формат физического хранения, используемый базами данных <productname>&productname;</productname>.</para>

<sect1 id="storage-file-layout">

<title>Размещение файлов базы данных</title>

<para>Этот раздел описывает формат хранения на уровне файлов и каталогов.</para>

<para>Файлы конфигурации и файлы данных, используемые кластером базы данных, традиционно хранятся вместе в каталоге данных кластера, который обычно называют <varname>PGDATA</varname> (по имени переменной среды, которую можно использовать для его определения). Обычно <varname>PGDATA</varname> находится в <filename>/var/lib/pgsql/data</filename>. На одной и той же машине может находиться множество кластеров, управляемых различными экземплярами сервера.</para>

<para>В каталоге <varname>PGDATA</varname> содержится несколько подкаталогов и управляющих файлов, как показано в <xref remap="6" linkend="pgdata-contents-table"/>. В дополнение к этим обязательным элементам конфигурационные файлы кластера <filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> и <filename>pg_ident.conf</filename> традиционно хранятся в <varname>PGDATA</varname>, хотя их можно разместить и в другом месте.</para>

<table tocentry="1" id="pgdata-contents-table">
<title>Содержание <varname>PGDATA</varname></title>
<tgroup cols="2">
<thead>
<row>
<entry>Элемент</entry>
<entry>Описание</entry>
</row>
</thead>

<tbody>

<row>
 <entry><filename>PG_VERSION</filename></entry>
 <entry>Файл, содержащий номер основной версии <productname>&productname;</productname></entry>
</row>

<row>
 <entry><filename>base</filename></entry>
 <entry>Подкаталог, содержащий подкаталоги для каждой базы данных</entry>
</row>

<row>
 <entry><filename>global</filename></entry>
 <entry>Подкаталог, содержащий общие таблицы кластера, такие как <structname>pg_database</structname></entry>
</row>

<row>
 <entry><filename>pg_commit_ts</filename></entry>
 <entry>Подкаталог, содержащий данные о времени фиксации транзакций</entry>
</row>

<row>
 <entry><filename>pg_clog</filename></entry>
 <entry>Подкаталог, содержащий данные о состоянии транзакции</entry>
</row>

<row>
 <entry><filename>pg_dynshmem</filename></entry>
 <entry>Подкаталог, содержащий файлы, используемые подсистемой динамически разделяемой памяти</entry>
</row>

<row>
 <entry><filename>pg_logical</filename></entry>
 <entry>Подкаталог, содержащий данные о состоянии для логического декодирования</entry>
</row>

<row>
 <entry><filename>pg_multixact</filename></entry>
 <entry>Подкаталог, содержащий данные о состоянии мультитранзакций (используемые для разделяемой блокировки строк)</entry>
</row>

<row>
 <entry><filename>pg_notify</filename></entry>
 <entry>Подкаталог, содержащий данные состояния прослушивания и нотификации (LISTEN/NOTIFY)</entry>
</row>

<row>
 <entry><filename>pg_replslot</filename></entry>
 <entry>Подкаталог, содержащий данные слота репликации</entry>
</row>

<row>
 <entry><filename>pg_serial</filename></entry>
 <entry>Подкаталог, содержащий информацию о выполненных сериализуемых транзакциях.</entry>
</row>

<row>
 <entry><filename>pg_snapshots</filename></entry>
 <entry>Подкаталог, содержащий экспортированные снимки (snapshots)</entry>
</row>

<row>
 <entry><filename>pg_stat</filename></entry>
 <entry>Подкаталог, содержащий постоянные файлы для подсистемы статистики.</entry>
</row>

<row>
 <entry><filename>pg_stat_tmp</filename></entry>
 <entry>Подкаталог, содержащий временные файлы для подсистемы статистики</entry>
</row>

<row>
 <entry><filename>pg_subtrans</filename></entry>
 <entry>Подкаталог, содержащий данные о состоянии подтранзакций</entry>
</row>

<row>
 <entry><filename>pg_tblspc</filename></entry>
 <entry>Подкаталог, содержащий символические ссылки на табличные пространства</entry>
</row>

<row>
 <entry><filename>pg_twophase</filename></entry>
 <entry>Подкаталог, содержащий файлы состояний для подготовленных транзакций</entry>
</row>

<row>
 <entry><filename>pg_xlog</filename></entry>
 <entry>Подкаталог, содержащий файлы WAL (журнал предзаписи)</entry>
</row>

<row>
 <entry><filename>postgresql.auto.conf</filename></entry>
 <entry>Файл, используемый для хранения параметров конфигурации, которые устанавливаются при помощи <command>ALTER SYSTEM</command></entry>
</row>

<row>
 <entry><filename>postmaster.opts</filename></entry>
 <entry>Файл, записывающий параметры командной строки, с которыми сервер был запущен в последний раз</entry>
</row>

<row>
 <entry><filename>postmaster.pid</filename></entry>
 <entry>Файл блокировки, записывающий идентификатор (ID) текущего управляющего процесса (PID), путь к каталогу данных кластера, временную метку запуска управляющего процесса, номер порта, путь к каталогу сокетов Unix (пустой для Windows), первый корректный адрес прослушивания (listen_address) (IP-адрес или <literal>*</literal>, либо пустое значение в случае отсутствия прослушивания по TCP), и ID сегмента разделяемой памяти (этот файл отсутствует после остановки сервера).</entry>
</row>

</tbody>
</tgroup>
</table>

<para>Для каждой базы данных в кластере существует подкаталог внутри <varname>PGDATA</varname><filename>/base</filename>, названный по OID базы данных в <structname>pg_database</structname>. Этот подкаталог по умолчанию является местом хранения файлов базы данных; в частности, там хранятся её системные каталоги.</para>

<para>Каждая таблица и индекс хранятся в отдельном файле. Для обычных отношений, эти файлы получают имя по номеру <firstterm>файлового узла</firstterm> таблицы или индекса, который содержится в <structname>pg_class</structname>.<structfield>relfilenode</structfield>. Но для временных отношений, имя файла имеет форму <literal>t<replaceable>BBB</replaceable>_<replaceable>FFF</replaceable></literal>, где <replaceable>BBB</replaceable> - идентификатор серверного процесса сервера, который создал данный файл, а <replaceable>FFF</replaceable> — номер файлового узла. В обоих случаях, помимо главного файла (также называемого основным слоем), у каждой таблицы и индекса есть <firstterm>карта свободного пространства</firstterm> (см. <xref remap="4" linkend="storage-fsm"/>), в которой хранится информация о свободном пространстве в данном отношении. Имя файла карты свободного пространства образуется из номера файлового узла с суффиксом <literal>_fsm</literal>. Также таблицы имеют <firstterm>карту видимости</firstterm>, хранящуюся в слое с суффиксом <literal>_vm</literal>, для отслеживания страниц, не содержащих мёртвых записей. Карта видимости подробнее описана в <xref remap="6" linkend="storage-vm"/>. Нежурналируемые таблицы и индексы имеют третий слой, так называемый слой инициализации, имя которого содержит суффикс <literal>_init</literal> (см. <xref remap="4" linkend="storage-init"/>).</para>

<caution>
<para>Заметьте, что хотя номер файла таблицы часто совпадает с её OID, так бывает <emphasis>не</emphasis> всегда; некоторые операции, например, <command>TRUNCATE</command>, <command>REINDEX</command>, <command>CLUSTER</command> и некоторые формы команды <command>ALTER TABLE</command> могут изменить номер файла, но при этом сохранят OID. Не следует рассчитывать, что номер файлового узла и OID таблицы совпадают. Кроме того, для некоторых системных каталогов, включая и <structname>pg_class</structname>, в <structname>pg_class</structname>.<structfield>relfilenode</structfield> содержится ноль. Фактический номер файлового узла для них хранится в низкоуровневой структуре данных, и его можно получить при помощи функции <function>pg_relation_filenode()</function>.</para>
</caution>

<para>Когда объём таблицы или индекса превышает 1 GB, они делятся на <firstterm>сегменты</firstterm> размером в один гигабайт. Файл первого сегмента называется по номеру файлового узла (filenode); последующие сегменты получают имена filenode.1, filenode.2 и т. д. При такой организации хранения не возникает проблем на платформах, имеющих ограничения по размеру файлов. (На самом деле, 1 GB является лишь стандартным размером сегмента. Размер сегмента можно изменить, используя параметр конфигурации <option>--with-segsize</option> при создании <productname>&productname;</productname>.) В принципе, карты свободного пространства и карты видимости также могут занимать нескольких сегментов, хотя на практике это маловероятно.</para>

<para>У таблицы, столбцы которой могут содержать данные большого объёма, будет иметься собственная таблица <firstterm>TOAST</firstterm>, предназначенная для отдельного хранения значений, которые слишком велики для хранения в строках самой таблицы. Основная таблица связывается с её таблицей <acronym>TOAST</acronym> (если таковая имеется) через <structname>pg_class</structname>.<structfield>reltoastrelid</structfield>. За подробной информацией обратитесь к <xref remap="3" linkend="storage-toast"/>.</para>

<para>Содержание таблиц и индексов рассматривается ниже (см. <xref remap="4" linkend="storage-page-layout"/>).</para>

<para>Табличное пространство делает сценарий более сложным. Каждое пользовательское табличное пространство имеет символическую ссылку внутри каталога <varname>PGDATA</varname><filename>/pg_tblspc</filename>, указывающую на физический каталог табличного пространства (т. е., положение, указанное в команде табличного пространства <command>CREATE TABLESPACE</command>). Эта символическая ссылка получает имя по OID табличного пространства. Внутри физического каталога табличного пространства имеется подкаталог, имя которого зависит от версии сервера <productname>&productname;</productname>, как например <literal>PG_9.0_201008051</literal>. (Этот подкаталог используется для того, чтобы последующие версии базы данных могли свободно использовать одно и то местоположение, заданное в <command>CREATE TABLESPACE</command>.) Внутри каталога конкретной версии находится подкаталог для каждой базы данных, которая имеет элементы в табличном пространстве, названный по OID базы данных. Таблицы и индексы хранятся внутри этого каталога, используя схему именования файловых узлов. Табличное пространство <literal>pg_default</literal> недоступно через <filename>pg_tblspc</filename>, но соответствует <varname>PGDATA</varname><filename>/base</filename>. Подобным же образом, табличное пространство <literal>pg_global</literal> недоступно через <filename>pg_tblspc</filename>, но соответствует <varname>PGDATA</varname><filename>/global</filename>.</para>

<para>Функция <function>pg_relation_filepath()</function> показывает полный путь (относительно <varname>PGDATA</varname>) для любого отношения. Часто это избавляет от необходимости запоминать многие из приведённых выше правил. Но следует помнить, что эта функция выдаёт лишь имя первого сегмента основного слоя отношения, т. е. возможно, понадобится добавить номер сегмента и/или <literal>_fsm</literal>, <literal>_vm</literal> или <literal>_init</literal>, чтобы найти все файлы, связанные с отношением.</para>

<para>Временные файлы (для таких операций, как сортировка объёма данных большего, чем может уместиться в памяти) создаются внутри <varname>PGDATA</varname><filename>/base/pgsql_tmp</filename> или внутри подкаталога <filename>pgsql_tmp</filename> каталога табличного пространства, если для них определено табличное пространство, отличное от <literal>pg_default</literal>. Имя временного файла имеет форму <filename>pgsql_tmp<replaceable>PPP</replaceable>.<replaceable>NNN</replaceable></filename>, где <replaceable>PPP</replaceable> — PID серверного процесса, а <replaceable>NNN</replaceable> служит для разделения различных временных файлов этого серверного процесса.</para>

</sect1>

<sect1 id="storage-toast">

<title>TOAST</title>

    <indexterm><primary>TOAST</primary></indexterm>
    <indexterm><primary>нарезанный хлеб</primary> <see>TOAST</see></indexterm>

<para>В данном разделе рассматривается <acronym>TOAST</acronym> (The Oversized-Attribute Storage Technique, Методика хранения сверхбольших атрибутов).</para>

<para><productname>&productname;</productname> использует фиксированный размер страницы (обычно 8 КБ), и не позволяет кортежам занимать несколько страниц. Поэтому непосредственно хранить очень большие значения полей невозможно. Для преодоления этого ограничения большие значения полей сжимаются и/или разбиваются на несколько физических строк. Это происходит незаметно для пользователя и на большую часть кода сервера влияет незначительно. Этот метод известен как <acronym>TOAST</acronym> (тост, или <quote>лучшее после изобретения нарезанного хлеба</quote>). Инфраструктура <acronym>TOAST</acronym> также применяется для оптимизации обработки больших значений данных в памяти.</para>

<para>Лишь определённые типы данных поддерживают <acronym>TOAST</acronym> &mdash; нет смысла производить дополнительные действия с типами данных, размер которых не может быть большим. Чтобы поддерживать <acronym>TOAST</acronym>, тип данных должен представлять значение переменной длины (<firstterm>varlena</firstterm>), в котором первое четырёхбайтовое слово любого хранящегося значения содержит общую длину значения в байтах (включая само это слово). Содержание оставшейся части значения <acronym>TOAST</acronym> не ограничивает. Специальные представления, в целом называемые <firstterm>значениями в формате <acronym>TOAST</acronym></firstterm>, работают, манипулируя этим начальным словом длины и интерпретируя его по-своему. Таким образом, функции уровня C, работающие с типом данных, поддерживающим <acronym>TOAST</acronym>, должны аккуратно обращаться со входными значениями, которые могут быть в формате <acronym>TOAST</acronym>: входные данные могут и не содержать четырёхбайтовое слово длины и содержимое после него, пока не будут <firstterm>распакованы</firstterm>. (Обычно в таких ситуациях нужно использовать макрос <function>PG_DETOAST_DATUM</function> прежде чем что-либо делать с входным значением, но в некоторых случаях возможны и более эффективные подходы. За подробностями обратитесь к <xref remap="3" linkend="xtypes-toast"/>.)</para>

<para><acronym>TOAST</acronym> занимает два бита слова длины varlena (старшие биты на машинах с порядком байт от старшего к младшему, или младшие биты — при другом порядке байт), таким образом, логический размер любого значения в формате <acronym>TOAST</acronym> ограничивается 1 Гигабайтом (2<superscript>30</superscript> - 1 байт). Когда оба бита равны нулю, значение является обычным, не в формате <acronym>TOAST</acronym>, и оставшиеся биты слова длины задают общий размер элемента данных (включая слово длины) в байтах. Когда установлен старший (или младший, в зависимости от архитектуры) бит, значение имеет однобайтовый заголовок вместо обычного четырёхбайтового, а оставшиеся биты этого байта задают общий размер элемента данных (включая байт длины) в байтах. Этот вариант позволяет экономно хранить значения короче 127 байт и при этом допускает расширение значения этого типа данных до 1 Гбайта при необходимости. Значения с однобайтовыми заголовками не выравниваются по какой-либо определённой границе, тогда как значения с четырёхбайтовыми заголовками выравниваются по границе минимум четырёх байт; это избавление от выравнивания даёт дополнительный выигрыш в объёме, очень ощутимый для коротких значений. В качестве особого случая, если все оставшиеся биты однобайтового заголовка равны нулю (что в принципе невозможно с учётом включения размера длины), значением является указатель на отдельно размещённые данные, с несколькими возможными вариантами, описанными ниже. Тип и размер такого <firstterm>указателя TOAST</firstterm> определяется кодом, хранящимся во втором байте значения. Наконец, когда старший (или младший, в зависимости от архитектуры) бит очищен, а соседний бит установлен, содержимое данных хранится в упакованном виде и должно быть распаковано перед использованием. В этом случае оставшиеся биты четырёхбайтового слова длины задают общий размер сжатых, а не исходных данных. Заметьте, что сжатие также возможно и для отделённых данных, но заголовок varlena не говорит, имеет ли оно место &mdash; это определяется содержимым, на которое указывает указатель <acronym>TOAST</acronym>.</para>

<para>Как уже было сказано, существуют разные варианты использования указателя <acronym>TOAST</acronym>. Самый старый и наиболее популярный вариант — когда он указывает на отделённые данные, размещённые в <firstterm>таблице <acronym>TOAST</acronym></firstterm>, которая отделена, но связана с таблицей, содержащей собственно указатель данных <acronym>TOAST</acronym>. Такой указатель на данные <firstterm>на диске</firstterm> создаётся кодом обработки <acronym>TOAST</acronym> (в <filename>access/heap/tuptoaster.c</filename>), когда кортеж, сохраняемый на диск, оказывается слишком большим. Дополнительные подробности описаны в <xref remap="6" linkend="storage-toast-ondisk"/>. Кроме того, указатель <acronym>TOAST</acronym> может указывать на отделённые данные, размещённые где-то в памяти. Такие данные обязательно недолговременные и никогда не оказываются на диске, но этот механизм очень полезен для исключения копирования и избыточной обработки данные большого размера. Дополнительные подробности описаны в <xref remap="6" linkend="storage-toast-inmemory"/>.</para>

<para>В качестве метода сжатия внутренних и отделённых данных применяется довольно простой и очень быстрый представитель семейства алгоритмов LZ. Подробнее см. <filename>src/common/pg_lzcompress.c</filename>.</para>

<sect2 id="storage-toast-ondisk">
 <title>Отдельное размещение TOAST на диске</title>

<para>Если какие-либо столбцы таблицы хранятся в формате <acronym>TOAST</acronym>, у таблицы будет связанная с ней таблица <acronym>TOAST</acronym>, OID которой хранится в значении <structname>pg_class</structname>.<structfield>reltoastrelid</structfield> для данной таблицы. Размещаемые на диске <acronym>TOAST</acronym>-значения содержатся в таблице <acronym>TOAST</acronym>, что подробнее описано ниже.</para>

<para>Отделённые значения делятся на порции (после сжатия, если оно применяется) размером не более <symbol>TOAST_MAX_CHUNK_SIZE</symbol> байт (по умолчанию это значение выбирается таким образом, чтобы на странице помещались четыре строки порций, то есть размер одной составляет порядка 2000 байт). Каждая порция хранится как отдельная строка в таблице <acronym>TOAST</acronym>, принадлежащей исходной таблице-владельцу. Каждая таблица <acronym>TOAST</acronym> имеет столбцы <structfield>chunk_id</structfield> (OID, идентифицирующий конкретное <acronym>TOAST</acronym>-значение), <structfield>chunk_seq</structfield> (последовательный номер для порции внутри значения) и <structfield>chunk_data</structfield> (фактические данные порции). Уникальный индекс по <structfield>chunk_id</structfield> и <structfield>chunk_seq</structfield> обеспечивает быструю выдачу значений. Таким образом, в указателе, представляющем отдельно размещаемое на диске значение <acronym>TOAST</acronym>, должно храниться OID таблицы <acronym>TOAST</acronym>, к которой нужно обращаться, и OID определённого значения (его <structfield>chunk_id</structfield>). Для удобства в данных указателя также хранится логический размер элемента данных (исходных данных без сжатия) и фактический размер хранимых данных (отличающийся, если было применено сжатие). Учитывая байты заголовка varlena, общий размер указателя на хранимое на диске значение <acronym>TOAST</acronym> составляет 18 байт, независимо от фактического размера собственно значения.</para>

<para>Код обработки <acronym>TOAST</acronym> срабатывает, только когда значение строки, которое должно храниться в таблице, по размеру больше, чем <symbol>TOAST_TUPLE_THRESHOLD</symbol> байт (обычно это 2 Кб). Код <acronym>TOAST</acronym> будет сжимать и/или выносить значения поля за пределы таблицы до тех пор, пока значение строки не станет меньше <symbol>TOAST_TUPLE_TARGET</symbol> байт (также обычно 2 Кб) или уменьшить объём станет невозможно. Во время операции UPDATE значения неизменённых полей обычно сохраняются как есть, поэтому модификация строки с отдельно хранимыми значениями не несёт издержек, связанных с <acronym>TOAST</acronym>, если все такие значения остаются без изменений.</para>

<para>Код обработки <acronym>TOAST</acronym> распознаёт четыре различные стратегии хранения столбцов, совместимых с <acronym>TOAST</acronym>, на диске: <itemizedlist>
    <listitem>
     <para><literal>PLAIN</literal> не допускает ни сжатие, ни отдельное хранение; кроме того, отключается использование однобайтовых заголовков для типов varlena. Это единственно возможная стратегия для столбцов типов данных, которые несовместимы с <acronym>TOAST</acronym>.</para>
    </listitem>
    <listitem>
     <para><literal>EXTENDED</literal> допускает как сжатие, так и отдельное хранение. Это стандартный вариант для большинства типов данных, совместимых с <acronym>TOAST</acronym>. Сначала происходит попытка выполнить сжатие, затем — сохранение вне таблицы, если строка всё ещё слишком велика.</para>
    </listitem>
    <listitem>
     <para><literal>EXTERNAL</literal> допускает отдельное хранение, но не сжатие. Использование <literal>EXTERNAL</literal> ускорит операции над частями строк в больших столбцах <type>text</type> и <type>bytea</type> (ценой увеличения объёма памяти для хранения), так как эти операции оптимизированы для извлечения только требуемых частей отделённого значения, когда оно не сжато.</para>
    </listitem>
    <listitem>
     <para><literal>MAIN</literal> допускает сжатие, но не отдельное хранение. (Фактически, отдельное хранение, тем не менее, будет выполнено для таких столбцов, но лишь как крайняя мера, когда нет другого способа уменьшить строку так, чтобы она помещалась на странице.)</para>
    </listitem>
   </itemizedlist> Каждый тип данных, совместимый с <acronym>TOAST</acronym>, определяет стандартную стратегию для столбцов этого типа данных, но стратегия для заданного столбца таблицы может быть изменена с помощью <command>ALTER TABLE SET STORAGE</command>.</para>

<para>Эта схема имеет ряд преимуществ по сравнению с более простым подходом, когда значения строк могут занимать несколько страниц. Если предположить, что обычно запросы характеризуются выполнением сравнения с относительно маленькими значениями ключа, большая часть работы будет выполняться с использованием главной записи строки. Большие значения атрибутов в формате <acronym>TOAST</acronym> будут просто передаваться (если будут выбраны) в тот момент, когда результирующий набор отправляется клиенту. Таким образом, главная таблица получается гораздо меньше, и в общий кеш буферов помещается больше её строк, чем их было бы без использования отдельного хранения. Наборы данных для сортировок также уменьшаются, а сортировки чаще будут выполняться исключительно в памяти. Небольшой тест показал, что таблица, содержащая типичные HTML-страницы и их URL после сжатия занимала примерно половину объёма исходных данных, включая таблицу <acronym>TOAST</acronym>, и что главная таблица содержала лишь около 10% всех данных (URL и некоторые маленькие HTML-страницы). Время обработки не отличалось от времени, необходимого для обработки таблицы без использования <acronym>TOAST</acronym>, в которой размер всех HTML-страниц был уменьшен до 7 Кб, чтобы они уместились в строках.</para>

</sect2>

<sect2 id="storage-toast-inmemory">
 <title>Отдельное размещение TOAST в памяти</title>

<para>Указатели <acronym>TOAST</acronym> могут указывать на данные, размещённые не на диске, а где-либо в памяти текущего серверного процесса. Очевидно, что такие указатель не могут быть долговременными, но они, тем не менее, полезны. В настоящее время поддерживаются два подварианта: <firstterm>косвенные</firstterm> указатели на данные и указатели на <firstterm>развёрнутые</firstterm> данные.</para>

<para>Косвенный указатель <acronym>TOAST</acronym> просто указывает на значение varlena, хранящееся где-то в памяти. Этот вариант изначально был реализован просто как подтверждение концепции, но в настоящее время он применяется при логическом декодировании, чтобы не приходилось создавать физические кортежи больше одного 1 ГБ (что может потребоваться при консолидации всех отделённых значений полей в одном кортеже). Данный вариант имеет ограниченное применение, так как создатель такого указателя должен полностью понимать, что целевые данные будут существовать, только пока существует указатель, и никакой инфраструктуры для сохранения их нет.</para>

<para>Указатели на развёрнутые данные <acronym>TOAST</acronym> полезны для сложных типов, представление которых на диске плохо приспособлено для вычислительных целей. Например, стандартное представление в виде varlena массива <productname>&productname;</productname> включает информацию о размерности, битовую карту элементов NULL (если они в нём содержатся), а затем значения всех элементов по порядку. Когда элемент сам по себе имеет переменную длину, единственный способ найти <replaceable>N</replaceable>-ный элемент — просканировать все предыдущие элементы. Это представление компактно, и поэтому подходит для хранения на диске, но для вычислительной обработки массива гораздо удобнее иметь <quote>развёрнутое</quote> или <quote>деконструированное</quote> представление, в котором можно определить начальные адреса всех элементов. Механизм указателей <acronym>TOAST</acronym> способствует решению этой задачи, допуская передачу по ссылке элемента Datum как указателя на стандартное значение varlena (представление на диске) или указателя <acronym>TOAST</acronym> на развёрнутое представление где-то в памяти. Детали развёрнутого представление определяются самим типом данных, хотя оно может иметь стандартный заголовок и удовлетворять другим требованиям API, описанным в <filename>src/include/utils/expandeddatum.h</filename>. Функции уровня C, работающие с этим типом, могут реализовать поддержку любого из этих представлений. Функции, не знающие о развёрнутом представлении, а просто применяющие <function>PG_DETOAST_DATUM</function> к своим входным данным, будут автоматически получать традиционное представление varlena; так что поддержка развёрнутого представления может вводиться постепенно, по одной функции.</para>

<para>Указатели <acronym>TOAST</acronym> на развёрнутые значения далее подразделяются на указатели <firstterm>для чтения/записи</firstterm> и указатели <firstterm>только для чтения</firstterm>. Представление, на которое они указывают, в любом случае одинаковое, но функции, получающей указатель для чтения/записи, разрешается модифицировать целевые данные прямо на месте, тогда как функция, получающая указатель только для чтения, не должна этого делать; если ей нужно получить изменённую версию значения, она должна сначала сделать копию. Это отличие и связанные с ним соглашения позволяют избежать излишнего копирования развёрнутых значений при выполнении запросов.</para>

<para>Для всех типов указателей <acronym>TOAST</acronym> на данные в памяти, код обработки <acronym>TOAST</acronym> гарантирует, что такие данные не окажутся случайно сохранены на диске. Указатели <acronym>TOAST</acronym> в памяти автоматически сворачиваются в обычные значения varlena перед сохранением &mdash; а затем могут преобразоваться в указатели <acronym>TOAST</acronym> на диске, если без этого не смогут уместиться в содержащем их кортеже.</para>

</sect2>

</sect1>

<sect1 id="storage-fsm">

<title>Карта свободного пространства</title>

<indexterm><primary>Карта свободного пространства</primary></indexterm>
<indexterm><primary>FSM</primary> <see>Карта свободного пространства</see></indexterm>

<para>Каждое табличное и индексное отношение, за исключением хеш-индексов, имеет карту свободного пространства (Free Space Map, FSM) для отслеживания доступного места. Она хранится рядом с данными главного отношения в отдельном слое, имя которого образуется номером файлового узла отношения с суффиксом <literal>_fsm</literal>. Например, если файловый узел отношения — 12345, FSM хранится в файле с именем <filename>12345_fsm</filename> в том же каталоге, что и основной файл отношения.</para>

<para>Карта свободного пространства представляет собой дерево страниц <acronym>FSM</acronym>. Страницы <acronym>FSM</acronym> нижнего уровня хранят информацию о свободном пространстве, доступном на каждой странице таблицы (или индекса), используя один байт для представления каждой такой страницы. Верхние уровни агрегируют информацию нижних уровней.</para>

<para>Внутри каждой страницы <acronym>FSM</acronym> имеется двоичное дерево, хранящееся в массиве, где один байт выделяется на каждый узел дерева. Каждый листовой узел представляет страницу таблицы или страницу <acronym>FSM</acronym> нижнего уровня. В каждом узле выше листовых хранится наибольшее из значений его узлов-потомков. Поэтому максимальное из значений листовых узлов хранится в корневом узле.</para>

<para>Более подробную информацию о структуре <acronym>FSM</acronym> и о том, как выполняется обновление и поиск, вы найдёте в <filename>src/backend/storage/freespace/README</filename>. Модуль <xref linkend="pgfreespacemap"/> может быть использован для просмотра информации, хранящейся в картах свободного пространства.</para>

</sect1>

<sect1 id="storage-vm">

<title>Карта видимости</title>

<indexterm><primary>Карта видимости</primary></indexterm>
<indexterm><primary>VM</primary> <see>Карта видимости</see></indexterm>

<para>Каждое отношение таблицы имеет карту видимости (Visibility Map, VM) для отслеживания страниц, содержащих только кортежи, которые видны всем активным транзакциям; в ней также отслеживается, какие страницы содержат только замороженные кортежи. Она хранится вместе с данными главного отношения в отдельном файле, имя которого образуется номером файлового узла отношения с суффиксом <literal>_vm</literal>. Например, если файловый узел отношения — 12345, VM хранится в файле <filename>12345_vm</filename>, в том же самом каталоге, что и основной файл отношения. Заметьте, что индексы не имеют VM.</para>

<para>Карта видимости хранит по два бита на страницу таблицы. Первый бит, если он установлен, показывает, что вся страница видна или, другими словами, не содержит кортежей, которые необходимо очистить. Эта информация может также использоваться при <link linkend="indexes-index-only-scans"><firstterm>сканировании только индекса</firstterm></link> для поиска ответов только в данных индекса. Установленный второй бит показывает, что все кортежи на этой странице заморожены.</para>

<para>Карта может отражать реальные данные с запаздыванием в том смысле, что мы уверены, что в случаях, когда установлен бит, известно, что условие верно, но если бит не установлен, оно может быть верным или неверным. Биты карты видимости устанавливаются только при очистке, а сбрасываются при любых операциях, изменяющих данные на странице.</para>

<para>Для изучения информации, хранящейся в карте видимости, можно воспользоваться модулем <xref linkend="pgvisibility"/>.</para>

</sect1>

<sect1 id="storage-init">

<title>Слой инициализации</title>

<indexterm><primary>Слой инициализации</primary></indexterm>

<para>Каждая нежурналируемая таблица, и каждый индекс такой таблицы имеет файл инициализации. Файл инициализации представляет собой пустую таблицу или индекс соответствующего типа. Когда нежурналируемая таблица должна быть заново очищена по причине сбоя, файл инициализации копируется поверх главного файла, а все прочие файлы удаляются (при необходимости они будут автоматически созданы заново).</para>

</sect1>

<sect1 id="storage-page-layout">

<title>Компоновка страницы базы данных</title>

<para>В данном разделе рассматривается формат страницы, используемый в таблицах и индексах <productname>&productname;</productname>.<footnote>
  <para>Фактически индексные методы доступа не нуждаются в этом формате страниц. Все существующие индексные методы в действительности используют этот основной формат, но данные, хранящиеся в индексных метастраницах обычно не следуют правилам компоновки.</para>
</footnote> Последовательности и таблицы <acronym>TOAST</acronym> форматируются как обычные таблицы.</para>

<para>В дальнейшем подразумевается, что <firstterm>байт</firstterm> содержит 8 бит. В дополнение, термин <firstterm>элемент</firstterm> относится к индивидуальному значению данных, которое хранится на странице. В таблице элемент — это строка; в индексе — элемент индекса.</para>

<para>Каждая таблица и индекс хранятся как массив <firstterm>страниц</firstterm> фиксированного размера (обычно 8 kB, хотя можно выбрать другой размер страницы при компиляции сервера). В таблице все страницы логически эквивалентны, поэтому конкретный элемент (строка) может храниться на любой странице. В индексах первая страница обычно резервируется как <firstterm>метастраница</firstterm>, хранящая контрольную информацию, а внутри индекса могут быть разные типы страниц, в зависимости от метода доступа индекса.</para>

<para><xref linkend="page-table"/> показывает общую компоновку страницы. Каждая страница имеет пять частей.</para>

<table tocentry="1" id="page-table">
<title>Общая компоновка страницы</title>
<titleabbrev>Компоновка страницы</titleabbrev>
<tgroup cols="2">
<thead>
<row>
<entry>Элемент</entry>
<entry>Описание</entry>
</row>
</thead>

<tbody>

<row>
 <entry>Данные заголовка страницы</entry>
 <entry>Длина — 24 байта. Содержит общую информацию о странице, включая указатели свободного пространства.</entry>
</row>

<row>
<entry>Данные идентификаторов элементов</entry>
<entry>Массив пар (смещение, длина), указывающих на фактические элементы. Для каждого элемента выделяется 4 байта.</entry>
</row>

<row>
<entry>Свободное пространство</entry>
<entry>Незанятое пространство. Новые указатели элементов размещаются с начала этой области, сами новые элементы — с конца.</entry>
</row>

<row>
<entry>Элементы</entry>
<entry>Сами элементы данных как таковые.</entry>
</row>

<row>
<entry>Специальное пространство</entry>
<entry>Специфические данные метода доступа. Для различных методов хранятся различные данные. Для обычных таблиц таких данных нет.</entry>
</row>

</tbody>
</tgroup>
</table>

 <para>Первые 40 байт каждой страницы образуют заголовок страницы (<structname>PageHeaderData</structname>). Его формат подробно описан в <xref remap="6" linkend="pageheaderdata-table"/>. В первом поле отслеживается самая последняя запись в WAL, связанная с этой страницей. Второе поле содержит контрольную сумму страницы, если включён режим <xref linkend="app-initdb-data-checksums"/>. Затем идёт двухбайтовое поле, содержащее биты флагов. За ним следуют три двухбайтовых целочисленных поля (<structfield>pd_lower</structfield>, <structfield>pd_upper</structfield> и <structfield>pd_special</structfield>). Они содержат смещения в байтах от начала страницы до начала незанятого пространства, до конца незанятого пространства и до начала специального пространства. Затем идут два 8-байтовых поля, содержащих эпоху, то есть смещение, для коротких (4-байтовых) идентификаторов транзакций на этой странице. В следующих 2 байтах заголовка страницы, в поле <structfield>pd_pagesize_version</structfield>, хранится размер страницы и индикатор версии. Начиная с <productname>PostgreSQL</productname> 8.3, используется версия 4; в <productname>PostgreSQL</productname> 8.1 и 8.2 использовалась версия 3; в <productname>PostgreSQL</productname> 8.0 — версия 2; в <productname>PostgreSQL</productname> 7.3 и 7.4 — версия 1; а в предыдущих выпусках — версия 0. (Основная структура страницы и формат заголовка почти во всех этих версиях одни и те же, но структура заголовка строк в куче изменялась.) Размер страницы присутствует, в основном, только для перекрёстной проверки; возможность использовать в одной инсталляции разные размеры страниц не поддерживается. Последнее поле подсказывает, насколько вероятна возможность получить выигрыш, произведя очистку страницы: оно отслеживает самый старый XMAX на странице, не подвергавшийся очистке.</para>

 <table tocentry="1" id="pageheaderdata-table">
 <title>Данные заголовка страницы (PageHeaderData)</title>
 <titleabbrev>Данные заголовка страницы</titleabbrev>
 <tgroup cols="4">
 <thead>
  <row>
   <entry>Поле</entry>
   <entry>Тип</entry>
   <entry>Длина</entry>
   <entry>Описание</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>pd_lsn</entry>
   <entry>PageXLogRecPtr</entry>
   <entry>8 байт</entry>
   <entry>LSN: Следующий байт после последнего байта записи xlog для последнего изменения на этой странице</entry>
  </row>
  <row>
   <entry>pd_checksum</entry>
   <entry>uint16</entry>
   <entry>2 байта</entry>
   <entry>Контрольная сумма страницы</entry>
  </row>
  <row>
   <entry>pd_flags</entry>
   <entry>uint16</entry>
   <entry>2 байта</entry>
   <entry>Биты признаков</entry>
  </row>
  <row>
   <entry>pd_lower</entry>
   <entry>LocationIndex</entry>
   <entry>2 байта</entry>
   <entry>Смещение до начала свободного пространства</entry>
  </row>
  <row>
   <entry>pd_upper</entry>
   <entry>LocationIndex</entry>
   <entry>2 байта</entry>
   <entry>Смещение до конца свободного пространства</entry>
  </row>
  <row>
   <entry>pd_special</entry>
   <entry>LocationIndex</entry>
   <entry>2 байта</entry>
   <entry>Смещение до начала специального пространства</entry>
  </row>
  <row>
   <entry>pd_pagesize_version</entry>
   <entry>uint16</entry>
   <entry>2 байта</entry>
   <entry>Информация о размере страницы и номере версии компоновки</entry>
  </row>
  <row>
   <entry>pd_xid_epoch</entry>
   <entry>TransactionId</entry>
   <entry>8 байт</entry>
   <entry>Эпоха для коротких 4-байтных идентификаторов на этой странице</entry>
  </row>
  <row>
   <entry>pd_multi_epoch</entry>
   <entry>TransactionId</entry>
   <entry>8 байт</entry>
   <entry>Эпоха для коротких 4-байтных мультитранзакций на этой странице</entry>
  </row>
  <row>
   <entry>pd_prune_xid</entry>
   <entry>ShortTransactionId</entry>
   <entry>4 байта</entry>
   <entry>Самый старый неочищенный идентификатор XMAX на странице или ноль при отсутствии такового</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>Всю подробную информацию можно найти в <filename>src/include/storage/bufpage.h</filename>.</para>

 <para>За заголовком страницы следуют идентификаторы элемента (<type>ItemIdData</type>), каждому из которых требуется 4 байта. Идентификатор элемента содержит байтовое смещение до начала элемента, его длину в байтах и несколько битов атрибутов, которые влияют на его интерпретацию. Новые идентификаторы элементов размещаются по мере необходимости от начала свободного пространства. Количество имеющихся идентификаторов элементов можно определить через значение <structfield>pd_lower</structfield>, которое увеличивается при добавлении нового идентификатора. Поскольку идентификатор элемента никогда не перемещается до тех пор, пока он не освобождается, его индекс можно использовать в течение длительного периода времени, чтобы ссылаться на элемент, даже когда сам элемент перемещается по странице для уплотнения свободного пространства. Фактически каждый указатель на элемент (<type>ItemPointer</type>, также известный как <type>CTID</type>), созданный <productname>&productname;</productname>, состоит из номера страницы и индекса идентификатора элемента.</para>

 <para>Сами элементы хранятся в пространстве, выделяемом в направлении от конца к началу незанятого пространства. Точная структура меняется в зависимости от того, каким будет содержание таблицы. Как таблицы, так и последовательности используют структуру под названием <type>HeapTupleHeaderData</type>, которая описывается ниже.</para>

 <para>Последний раздел является <quote>особым разделом</quote>, который может содержать всё, что необходимо методу доступа для хранения. Например, индексы-B-деревья хранят ссылки на страницы слева и справа, равно как и некоторые другие данные, соответствующие структуре индекса. Обычные таблицы не используют особый раздел вовсе (что указывается установкой значения <structfield>pd_special</structfield> равным размеру страницы).</para>

 <para>Все строки таблицы структурированы одним и тем же образом. Они включают заголовок фиксированного размера (занимающий 40 байтов на большинстве машин), за которым следует необязательная битовая карта пустых значений, необязательное поле идентификатора объекта и данные пользователя. Подробное описание заголовка представлено в <xref remap="6" linkend="heaptupleheaderdata-table"/>. Собственно пользовательские данные (столбцы строки) начинаются после смещения, заданного в <structfield>t_hoff</structfield>, которое должно всегда быть кратным величине MAXALIGN для платформы. Битовая карта пустых значений присутствует, только если в поле <structfield>t_infomask</structfield> установлен бит <firstterm>HEAP_HASNULL</firstterm>. В случае присутствия она располагается сразу за фиксированным заголовком и занимает столько байт, сколько необходимо для представления отдельного бита для каждого столбца данных (то есть, всего <structfield>t_natts</structfield> битов). В этом списке битов 1 соответствует значению, отличному от NULL, а 0 — NULL. Когда эта битовая карта отсутствует, считается, что все столбцы отличны от NULL. Идентификатор объекта присутствует, только если в <structfield>t_infomask</structfield> установлен бит <firstterm>HEAP_HASOID</firstterm>. Если он присутствует, он располагается сразу перед границей выравнивания <structfield>t_hoff</structfield>. Любое дополнительное выравнивание, необходимое, чтобы <structfield>t_hoff</structfield> было кратным MAXALIGN, будет располагаться между битовой картой пустых значений и идентификатором объекта. (Это в свою очередь гарантирует, что идентификатор объекта будет выровнен правильно.)</para>

 <table tocentry="1" id="heaptupleheaderdata-table">
 <title>Данные заголовка строки таблицы (HeapTupleHeaderData)</title>
 <titleabbrev>Данные заголовка строки таблицы</titleabbrev>
 <tgroup cols="4">
 <thead>
  <row>
   <entry>Поле</entry>
   <entry>Тип</entry>
   <entry>Длина</entry>
   <entry>Описание</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>t_xmin</entry>
   <entry>ShortTransactionId</entry>
   <entry>4 байта</entry>
   <entry>значение XID вставки</entry>
  </row>
  <row>
   <entry>t_xmax</entry>
   <entry>ShortTransactionId</entry>
   <entry>4 байта</entry>
   <entry>значение XID удаления</entry>
  </row>
  <row>
   <entry>t_cid</entry>
   <entry>CommandId</entry>
   <entry>4 байта</entry>
   <entry>значение CID для вставки и/или удаления (пересекается с t_xvac)</entry>
  </row>
  <row>
   <entry>t_xvac</entry>
   <entry>ShortTransactionId</entry>
   <entry>4 байта</entry>
   <entry>XID для операции VACUUM, которая перемещает версию строки</entry>
  </row>
  <row>
   <entry>t_ctid</entry>
   <entry>ItemPointerData</entry>
   <entry>6 байт</entry>
   <entry>текущее значение TID этой или более новой версии строки</entry>
  </row>
  <row>
   <entry>t_infomask2</entry>
   <entry>uint16</entry>
   <entry>2 байта</entry>
   <entry>количество атрибутов плюс различные биты флагов</entry>
  </row>
  <row>
   <entry>t_infomask</entry>
   <entry>uint16</entry>
   <entry>2 байта</entry>
   <entry>различные биты флагов</entry>
  </row>
  <row>
   <entry>t_hoff</entry>
   <entry>uint8</entry>
   <entry>1 байт</entry>
   <entry>отступ до пользовательских данных</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>Всю подробную информацию можно найти в <filename>src/include/access/htup_details.h</filename>.</para>

 <para>Интерпретация текущих данных может быть проведена с помощью информации, полученной из других таблиц, в основном из <structname>pg_attribute</structname>. Ключевые значения, необходимые для определения расположения полей <structfield>attlen</structfield> и <structfield>attalign</structfield>. Не существует способа непосредственного получения заданного атрибута кроме случая, когда имеются только поля фиксированной длины, и при этом нет пустых значений. Все эти особенности учитываются в функциях <firstterm>heap_getattr</firstterm>, <firstterm>fastgetattr</firstterm> и <firstterm>heap_getsysattr</firstterm>.</para>
 <para>Чтобы прочитать данные, необходимо просмотреть каждый атрибут по очереди. В первую очередь нужно проверить, является ли значение поля пустым согласно битовой карте пустых значений. Если это так, можно переходить к следующему полю. Затем следует убедиться, что выравнивание является верным. Если это поле фиксированной ширины, берутся просто все его байты. Если это поле переменной длины (attlen = -1), всё несколько сложнее. Все типы данных с переменной длиной имеют общую структуру заголовка <type>struct varlena</type>, которая включает общую длину сохранённого значения и некоторые биты флагов. В зависимости от установленных флагов, данные могут храниться либо локально, либо в таблице <acronym>TOAST</acronym>. Также, возможно сжатие данных (см. <xref remap="4" linkend="storage-toast"/>).</para>
</sect1>

</chapter>
