<!-- doc/src/xml/func.xml -->

 <chapter id="functions">
  <title>Функции и операторы</title>

  <indexterm zone="functions"><primary>функция</primary></indexterm>

  <indexterm zone="functions"><primary>оператор</primary></indexterm>

  <para><productname>&productname;</productname> предоставляет огромное количество функций и операторов для встроенных типов данных. Кроме того, пользователи могут определять свои функции операторы, как описано в <xref remap="6" linkend="server-programming"/>. Просмотреть все существующие функции и операторы можно в <application>psql</application> с помощью команд <command>\df</command> и <command>\do</command>, соответственно.</para>

  <para>Если для вас важна переносимость, учтите, что практически все функции и операторы, описанные в этой главе, за исключением простейших арифметических и операторов сравнения, а также явно отмеченных функций, не описаны в стандарте <acronym>SQL</acronym>. Тем не менее, частично эта расширенная функциональность присутствует и в других СУБД <acronym>SQL</acronym> и во многих случаях различные реализации одинаковых функций оказываются аналогичными и совместимыми. В этой главе не описываются абсолютно все функции; некоторые дополнительные функции рассматриваются в других разделах документации.</para>


  <sect1 id="functions-logical">
   <title>Логические операторы</title>

   <indexterm zone="functions-logical"><primary>оператор</primary> <secondary>логический</secondary></indexterm>

   <indexterm><primary>Булевы</primary> <secondary>операторы</secondary> <see>операторы, логические</see></indexterm>

   <para>Набор логических операторов включает обычные: <indexterm><primary>AND (оператор)</primary></indexterm> <indexterm><primary>OR (оператор)</primary></indexterm> <indexterm><primary>NOT (оператор)</primary></indexterm> <indexterm><primary>конъюнкция</primary></indexterm> <indexterm><primary>дизъюнкция</primary></indexterm> <indexterm><primary>отрицание</primary></indexterm> <simplelist>
     <member><literal>AND</literal></member>
     <member><literal>OR</literal></member>
     <member><literal>NOT</literal></member>
    </simplelist> В <acronym>SQL</acronym> работает логическая система с тремя состояниями: true (истина), false (ложь) и <literal>NULL</literal>, <quote>неопределённое</quote> состояние. Рассмотрите следующие таблицы истинности: <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable> <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable></para>

   <para>Операторы <literal>AND</literal> и <literal>OR</literal> коммутативны, то есть от перемены мест операндов результат не меняется. Однако значение может иметь порядок вычисления подвыражений. Подробнее это описано в <xref remap="6" linkend="syntax-express-eval"/>.</para>
  </sect1>

  <sect1 id="functions-comparison">
   <title>Функции и операторы сравнения</title>

   <indexterm zone="functions-comparison"><primary>сравнение</primary> <secondary>операторы</secondary></indexterm>

   <para>Набор операторов сравнения включает обычные операторы, перечисленные в <xref remap="6" linkend="functions-comparison-op-table"/>.</para>

   <table id="functions-comparison-op-table">
    <title>Операторы сравнения</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Оператор</entry>
       <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>&lt;</literal> </entry>
       <entry>меньше</entry>
      </row>

      <row>
       <entry> <literal>&gt;</literal> </entry>
       <entry>больше</entry>
      </row>

      <row>
       <entry> <literal>&lt;=</literal> </entry>
       <entry>меньше или равно</entry>
      </row>

      <row>
       <entry> <literal>&gt;=</literal> </entry>
       <entry>больше или равно</entry>
      </row>

      <row>
       <entry> <literal>=</literal> </entry>
       <entry>равно</entry>
      </row>

      <row>
       <entry><literal>&lt;&gt;</literal> или <literal>!=</literal></entry>
       <entry>не равно</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>Оператор <literal>!=</literal> преобразуется в <literal>&lt;&gt;</literal> на стадии разбора запроса. Как следствие, реализовать операторы <literal>!=</literal> и <literal>&lt;&gt;</literal> по-разному невозможно.</para>
   </note>

   <para>Операторы сравнения определены для всех типов данных, для которых они имеют смысл. Все операторы сравнения представляют собой бинарные операторы, возвращающие значения типа <type>boolean</type>; при этом выражения вида <literal>1 &lt; 2 &lt; 3</literal> недопустимы (так как не существует оператора <literal>&lt;</literal>, который бы сравнивал булево значение с <literal>3</literal>).</para>

   <para>Существует также несколько предикатов сравнения; они приведены в <xref remap="6" linkend="functions-comparison-pred-table"/>. Они работают подобно операторам, но имеют особый синтаксис, установленный стандартом SQL.</para>

   <table id="functions-comparison-pred-table">
    <title>Предикаты сравнения</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Предикат</entry>
       <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <replaceable>a</replaceable> <literal>BETWEEN</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
       <entry>между</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>NOT BETWEEN</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
       <entry>не между</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
       <entry>между, после сортировки сравниваемых значений</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
       <entry>не между, после сортировки сравниваемых значений</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>b</replaceable> </entry>
       <entry>не равно, при этом NULL воспринимается как обычное значение</entry>
      </row>

      <row>
       <entry><replaceable>a</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>b</replaceable></entry>
       <entry>равно, при этом NULL воспринимается как обычное значение</entry>
      </row>

      <row>
       <entry> <replaceable>выражение</replaceable> <literal>IS NULL</literal> </entry>
       <entry>эквивалентно NULL</entry>
      </row>

      <row>
       <entry> <replaceable>выражение</replaceable> <literal>IS NOT NULL</literal> </entry>
       <entry>не эквивалентно NULL</entry>
      </row>

      <row>
       <entry> <replaceable>выражение</replaceable> <literal>ISNULL</literal> </entry>
       <entry>эквивалентно NULL (нестандартный синтаксис)</entry>
      </row>

      <row>
       <entry> <replaceable>выражение</replaceable> <literal>NOTNULL</literal> </entry>
       <entry>не эквивалентно NULL (нестандартный синтаксис)</entry>
      </row>

      <row>
       <entry> <replaceable>логическое_выражение</replaceable> <literal>IS TRUE</literal> </entry>
       <entry>истина</entry>
      </row>

      <row>
       <entry> <replaceable>логическое_выражение</replaceable> <literal>IS NOT TRUE</literal> </entry>
       <entry>ложь или неопределённость</entry>
      </row>

      <row>
       <entry> <replaceable>логическое_выражение</replaceable> <literal>IS FALSE</literal> </entry>
       <entry>ложь</entry>
      </row>

      <row>
       <entry> <replaceable>логическое_выражение</replaceable> <literal>IS NOT FALSE</literal> </entry>
       <entry>истина или неопределённость</entry>
      </row>

      <row>
       <entry> <replaceable>логическое_выражение</replaceable> <literal>IS UNKNOWN</literal> </entry>
       <entry>неопределённость</entry>
      </row>

      <row>
       <entry> <replaceable>логическое_выражение</replaceable> <literal>IS NOT UNKNOWN</literal> </entry>
       <entry>истина или ложь</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><indexterm><primary>BETWEEN</primary></indexterm> Предикат <token>BETWEEN</token> упрощает проверки интервала: <synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis> равнозначно выражению <synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis> Заметьте, что <token>BETWEEN</token> считает, что границы интервала также включаются в интервал. <literal>NOT BETWEEN</literal> выполняет противоположное сравнение: <synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis> равнозначно выражению <synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis> <indexterm><primary>BETWEEN SYMMETRIC</primary></indexterm> Предикат <literal>BETWEEN SYMMETRIC</literal> аналогичен <literal>BETWEEN</literal>, за исключением того, что аргумент слева от <literal>AND</literal> не обязательно должен быть меньше или равен аргументу справа. Если это не так, аргументы автоматически меняются местами, так что всегда подразумевается непустой интервал.</para>

   <para><indexterm><primary>IS DISTINCT FROM</primary></indexterm> <indexterm><primary>IS NOT DISTINCT FROM</primary></indexterm> Обычные операторы сравнения выдают NULL (что означает <quote>неопределённость</quote>), а не true или false, когда любое из сравниваемых значений NULL. Например, <literal>7 = NULL</literal> выдаёт NULL, так же, как и <literal>7 &lt;&gt; NULL</literal>. Когда это поведение нежелательно, можно использовать предикаты <literal>IS <optional> NOT </optional> DISTINCT FROM</literal>: <synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis> Для значений не NULL условие <literal>IS DISTINCT FROM</literal> работает так же, как оператор <literal>&lt;&gt;</literal>. Однако, если оба сравниваемых значения NULL, результат будет false, и только если одно из значений NULL, возвращается true. Аналогично, условие <literal>IS NOT DISTINCT FROM</literal> равносильно <literal>=</literal> для значений не NULL, но возвращает true, если оба сравниваемых значения NULL и false в противном случае. Таким образом, эти предикаты по сути работают с NULL, как с обычным значением, а не с <quote>неопределённостью</quote>.</para>

   <para><indexterm><primary>IS NULL</primary></indexterm> <indexterm><primary>IS NOT NULL</primary></indexterm> <indexterm><primary>ISNULL</primary></indexterm> <indexterm><primary>NOTNULL</primary></indexterm> Для проверки, содержит ли значение NULL или нет, используются предикаты: <synopsis>
<replaceable>выражение</replaceable> IS NULL
<replaceable>выражение</replaceable> IS NOT NULL
</synopsis> или равнозначные (но нестандартные) предикаты: <synopsis>
<replaceable>выражение</replaceable> ISNULL
<replaceable>выражение</replaceable> NOTNULL
</synopsis> <indexterm><primary>NULL</primary> <secondary>сравнение</secondary></indexterm></para>

   <para>Заметьте, что проверка <literal><replaceable>выражение</replaceable> = NULL</literal> <emphasis>не</emphasis> будет работать, так как <literal>NULL</literal> считается не <quote>равным</quote> <literal>NULL</literal>. (Значение NULL представляет неопределённость, и равны ли две неопределённости, тоже не определено.)</para>

  <tip>
   <para>Некоторые приложения могут ожидать, что <literal><replaceable>выражение</replaceable> = NULL</literal> вернёт true, если результатом <replaceable>выражения</replaceable> является NULL. Такие приложения настоятельно рекомендуется исправить и привести в соответствие со стандартом SQL. Однако, в случаях, когда это невозможно, это поведение можно изменить с помощью параметра конфигурации <xref linkend="guc-transform-null-equals"/>. Когда этот параметр включён, <productname>&productname;</productname> преобразует условие <literal>x = NULL</literal> в <literal>x IS NULL</literal>.</para>
  </tip>

   <para>Если <replaceable>выражение</replaceable> возвращает табличную строку, тогда <literal>IS NULL</literal> будет истинным, когда само выражение — NULL или все поля строки — NULL, а <literal>IS NOT NULL</literal> будет истинным, когда само выражение не NULL, и все поля строки так же не NULL. Вследствие такого определения, <literal>IS NULL</literal> и <literal>IS NOT NULL</literal> не всегда будут возвращать взаимодополняющие результаты для таких выражений; в частности такие выражения со строками, одни поля которых NULL, а другие не NULL, будут ложными одновременно. В некоторых случаях имеет смысл написать <replaceable>строка</replaceable> <literal>IS DISTINCT FROM NULL</literal> или <replaceable>строка</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>, чтобы просто проверить, равно ли NULL всё значение строки, без каких-либо дополнительных проверок полей строки.</para>

   <para><indexterm><primary>IS TRUE</primary></indexterm> <indexterm><primary>IS NOT TRUE</primary></indexterm> <indexterm><primary>IS FALSE</primary></indexterm> <indexterm><primary>IS NOT FALSE</primary></indexterm> <indexterm><primary>IS UNKNOWN</primary></indexterm> <indexterm><primary>IS NOT UNKNOWN</primary></indexterm> Логические значения можно также проверить с помощью предикатов <synopsis>
<replaceable>логическое_выражение</replaceable> IS TRUE
<replaceable>логическое_выражение</replaceable> IS NOT TRUE
<replaceable>логическое_выражение</replaceable> IS FALSE
<replaceable>логическое_выражение</replaceable> IS NOT FALSE
<replaceable>логическое_выражение</replaceable> IS UNKNOWN
<replaceable>логическое_выражение</replaceable> IS NOT UNKNOWN
</synopsis> Они всегда возвращают true или false и никогда NULL, даже если какой-любо операнд — NULL. Они интерпретируют значение NULL как <quote>неопределённость</quote>. Заметьте, что <literal>IS UNKNOWN</literal> и <literal>IS NOT UNKNOWN</literal> по сути равнозначны <literal>IS NULL</literal> и <literal>IS NOT NULL</literal>, соответственно, за исключением того, что выражение может быть только булевого типа.</para>

<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    predicates
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

   <para>Также имеется несколько связанных со сравнениями функций; они перечислены в <xref remap="6" linkend="functions-comparison-func-table"/>.</para>

  <table id="functions-comparison-func-table">
    <title>Функции сравнения</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат примера</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm><primary>num_nonnulls</primary></indexterm>
         <literal>num_nonnulls(VARIADIC "any")</literal>
       </entry>
       <entry>возвращает число аргументов, отличных от NULL</entry>
       <entry><literal>num_nonnulls(1, NULL, 2)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm><primary>num_nulls</primary></indexterm>
         <literal>num_nulls(VARIADIC "any")</literal>
       </entry>
       <entry>возвращает число аргументов NULL</entry>
       <entry><literal>num_nulls(1, NULL, 2)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-math">
   <title>Математические функции и операторы</title>

   <para>Математические операторы определены для множества типов <productname>&productname;</productname>. Как работают эти операции с типами, для которых нет стандартных соглашений о математических действиях (например, с типами даты/времени), мы опишем в последующих разделах.</para>

   <para>В <xref remap="6" linkend="functions-math-op-table"/> перечислены все доступные математические операторы.</para>

   <table id="functions-math-op-table">
    <title>Математические операторы</title>

    <tgroup cols="4">
     <thead>
      <row>
       <entry>Оператор</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>+</literal> </entry>
       <entry>сложение</entry>
       <entry><literal>2 + 3</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>-</literal> </entry>
       <entry>вычитание</entry>
       <entry><literal>2 - 3</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry> <literal>*</literal> </entry>
       <entry>умножение</entry>
       <entry><literal>2 * 3</literal></entry>
       <entry><literal>6</literal></entry>
      </row>

      <row>
       <entry> <literal>/</literal> </entry>
       <entry>деление (при целочисленном делении остаток отбрасывается)</entry>
       <entry><literal>4 / 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry> <literal>%</literal> </entry>
       <entry>остаток от деления</entry>
       <entry><literal>5 % 4</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry> <literal>^</literal> </entry>
       <entry>возведение в степень (вычисляется слева направо)</entry>
       <entry><literal>2.0 ^ 3.0</literal></entry>
       <entry><literal>8</literal></entry>
      </row>

      <row>
       <entry> <literal>|/</literal> </entry>
       <entry>квадратный корень</entry>
       <entry><literal>|/ 25.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>||/</literal> </entry>
       <entry>кубический корень</entry>
       <entry><literal>||/ 27.0</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry> <literal>!</literal> </entry>
       <entry>факториал</entry>
       <entry><literal>5 !</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>!!</literal> </entry>
       <entry>факториал (префиксная форма)</entry>
       <entry><literal>!! 5</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>@</literal> </entry>
       <entry>модуль числа (абсолютное значение)</entry>
       <entry><literal>@ -5.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <entry>битовый AND</entry>
       <entry><literal>91 &amp; 15</literal></entry>
       <entry><literal>11</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <entry>битовый OR</entry>
       <entry><literal>32 | 3</literal></entry>
       <entry><literal>35</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <entry>битовый XOR</entry>
       <entry><literal>17 # 5</literal></entry>
       <entry><literal>20</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <entry>битовый NOT</entry>
       <entry><literal>~1</literal></entry>
       <entry><literal>-2</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <entry>битовый сдвиг влево</entry>
       <entry><literal>1 &lt;&lt; 4</literal></entry>
       <entry><literal>16</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <entry>битовый сдвиг вправо</entry>
       <entry><literal>8 &gt;&gt; 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>Битовые операторы работают только с целостными типами данных, тогда как другие и работают и с остальными числовыми типами. Битовые операции также работают с битовыми строками <type>bit</type> и <type>bit varying</type>, как показано в <xref remap="6" linkend="functions-bit-string-op-table"/>.</para>

  <para>В <xref remap="6" linkend="functions-math-func-table"/> перечислены все существующие математические функции. Сокращение <literal>dp</literal> в ней обозначает тип <type>double precision</type> (плавающее с двойной точностью). Многие из этих функций имеют несколько форм с разными типами аргументов. За исключением случаев, где это указано явно, любая форма функции возвращает результат того же типа, что и аргумент. Функции, работающие с данными <type>double precision</type>, в массе своей используют реализации из системных библиотек сервера, поэтому точность и поведение в граничных случаях может зависеть от системы сервера.</para>

   <table id="functions-math-func-table">
    <title>Математические функции</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>abs</primary></indexterm>
        <literal><function>abs(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>модуль числа (абсолютное значение)</entry>
       <entry><literal>abs(-17.4)</literal></entry>
       <entry><literal>17.4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>cbrt</primary></indexterm>
        <literal><function>cbrt(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>кубический корень</entry>
       <entry><literal>cbrt(27.0)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>ceil</primary></indexterm>
        <literal><function>ceil(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>ближайшее целое, большее или равное аргументу</entry>
       <entry><literal>ceil(-42.8)</literal></entry>
       <entry><literal>-42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>ceiling</primary></indexterm>
        <literal><function>ceiling(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>ближайшее целое, большее или равное аргументу (равнозначно <function>ceil</function>)</entry>
       <entry><literal>ceiling(-95.3)</literal></entry>
       <entry><literal>-95</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>degrees</primary></indexterm>
        <literal><function>degrees(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>преобразование радианов в градусы</entry>
       <entry><literal>degrees(0.5)</literal></entry>
       <entry><literal>28.6478897565&#8203;412</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>div</primary></indexterm>
        <literal><function>div(<parameter>y</parameter> <type>numeric</type>, <parameter>x</parameter> <type>numeric</type>)</function></literal>
       </entry>
       <entry><type>numeric</type></entry>
       <entry>целочисленный результат <parameter>y</parameter>/<parameter>x</parameter></entry>
       <entry><literal>div(9,4)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>exp</primary></indexterm>
        <literal><function>exp(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>экспонента</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.7182818284&#8203;5905</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>floor</primary></indexterm>
        <literal><function>floor(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>ближайшее целое, меньшее или равное аргументу</entry>
       <entry><literal>floor(-42.8)</literal></entry>
       <entry><literal>-43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>ln</primary></indexterm>
        <literal><function>ln(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>натуральный логарифм</entry>
       <entry><literal>ln(2.0)</literal></entry>
       <entry><literal>0.6931471805&#8203;59945</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>log</primary></indexterm>
        <literal><function>log(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>логарифм по основанию 10</entry>
       <entry><literal>log(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>log(<parameter>b</parameter> <type>numeric</type>, <parameter>x</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry>логарифм по основанию <parameter>b</parameter></entry>
       <entry><literal>log(2.0, 64.0)</literal></entry>
       <entry><literal>6.0000000000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>mod</primary></indexterm>
        <literal><function>mod(<parameter>y</parameter>, <parameter>x</parameter>)</function></literal>
       </entry>
       <entry>зависит от типов аргументов</entry>
       <entry>остаток от деления <parameter>y</parameter>/<parameter>x</parameter></entry>
       <entry><literal>mod(9,4)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pi</primary></indexterm>
        <literal><function>pi()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>константа <quote>&pi;</quote></entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.1415926535&#8203;8979</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>power</primary></indexterm>
        <literal><function>power(<parameter>a</parameter> <type>dp</type>, <parameter>b</parameter> <type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry><parameter>a</parameter> возводится в степень <parameter>b</parameter></entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>power(<parameter>a</parameter> <type>numeric</type>, <parameter>b</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry><parameter>a</parameter> возводится в степень <parameter>b</parameter></entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>radians</primary></indexterm>
        <literal><function>radians(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>преобразование градусов в радианы</entry>
       <entry><literal>radians(45.0)</literal></entry>
       <entry><literal>0.7853981633&#8203;97448</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>round</primary></indexterm>
        <literal><function>round(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>округление до ближайшего целого</entry>
       <entry><literal>round(42.4)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>round(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry>округление <parameter>v</parameter> до <parameter>s</parameter> десятичных знаков</entry>
       <entry><literal>round(42.4382, 2)</literal></entry>
       <entry><literal>42.44</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>scale</primary></indexterm>
        <literal><function>scale(<type>numeric</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>масштаб аргумента (число десятичных цифр в дробной части)</entry>
       <entry><literal>scale(8.41)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>sign</primary></indexterm>
        <literal><function>sign(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>знак аргумента (-1, 0, +1)</entry>
       <entry><literal>sign(-8.4)</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>sqrt</primary></indexterm>
        <literal><function>sqrt(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>квадратный корень</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.4142135623&#8203;731</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>trunc</primary></indexterm>
        <literal><function>trunc(<type>dp</type> или <type>numeric</type>)</function></literal>
       </entry>
       <entry>тип аргумента</entry>
       <entry>округление к нулю</entry>
       <entry><literal>trunc(42.8)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
       <entry>округление к 0 до <parameter>s</parameter> десятичных знаков</entry>
       <entry><literal>trunc(42.4382, 2)</literal></entry>
       <entry><literal>42.43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>width_bucket</primary></indexterm>
        <literal><function>width_bucket(<parameter>operand</parameter> <type>dp</type>, <parameter>b1</parameter> <type>dp</type>, <parameter>b2</parameter> <type>dp</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>возвращает номер группы, в которую попадёт <parameter>operand</parameter> в гистограмме с числом групп <parameter>count</parameter> равного размера, в диапазоне от <parameter>b1</parameter> до <parameter>b2</parameter>; возвращает <literal>0</literal> или <literal><parameter>count</parameter>+1</literal>, если операнд лежит вне диапазона</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>numeric</type>, <parameter>b1</parameter> <type>numeric</type>, <parameter>b2</parameter> <type>numeric</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>возвращает номер группы, в которую попадёт <parameter>operand</parameter> в гистограмме с числом групп <parameter>count</parameter> равного размера, в диапазоне от <parameter>b1</parameter> до <parameter>b2</parameter>; возвращает <literal>0</literal> или <literal><parameter>count</parameter>+1</literal>, если операнд лежит вне диапазона</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>возвращает номер группы, в которую попадёт <parameter>operand</parameter> (группы определяются нижними границами, передаваемыми в <parameter>thresholds</parameter>); возвращает 0, если операнд оказывается левее нижней границы; массив <parameter>thresholds</parameter> <emphasis>должен быть отсортирован</emphasis> по возрастанию, иначе будут получены неожиданные результаты</entry>
       <entry><literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal></entry>
       <entry><literal>2</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>В <xref remap="6" linkend="functions-math-random-table"/> перечислены все функции для генерации случайных чисел.</para>

   <table id="functions-math-random-table">
    <title>Случайные функции</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm><primary>random</primary></indexterm>
        <literal><function>random()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
       <entry>случайное число в диапазоне 0.0 &lt;= x &lt; 1.0</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>setseed</primary></indexterm>
        <literal><function>setseed(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>задаёт отправную точку для последующих вызовов <literal>random()</literal> (значение между -1.0 и 1.0, включая границы)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Характеристики значений, возвращаемых функцией <literal><function>random()</function></literal> зависят от системы. Для применения в криптографии они непригодны; альтернативы описаны в <xref remap="6" linkend="pgcrypto"/>.</para>

  <para>Наконец, в <xref remap="6" linkend="functions-math-trig-table"/> перечислены все имеющиеся тригонометрические функции. Все эти функции принимают аргументы и возвращают значения типа <type>double precision</type>. У каждой функции имеются две вариации — одна измеряет углы в радианах, а вторая в градусах.</para>

   <table id="functions-math-trig-table">
    <title>Тригонометрические функции</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Функции (в радианах)</entry>
       <entry>Функции (в градусах)</entry>
       <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>acos</primary></indexterm><literal><function>acos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>acosd</primary></indexterm><literal><function>acosd(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>арккосинус</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>asin</primary></indexterm>
        <literal><function>asin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>asind</primary></indexterm>
        <literal><function>asind(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>арксинус</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>atan</primary></indexterm>
        <literal><function>atan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>atand</primary></indexterm>
        <literal><function>atand(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>арктангенс</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>atan2</primary></indexterm>
        <literal><function>atan2(<replaceable>y</replaceable>, <replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>atan2d</primary></indexterm>
        <literal><function>atan2d(<replaceable>y</replaceable>, <replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>арктангенс <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>cos</primary></indexterm>
        <literal><function>cos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>cosd</primary></indexterm>
        <literal><function>cosd(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>косинус</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>cot</primary></indexterm>
        <literal><function>cot(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>cotd</primary></indexterm>
        <literal><function>cotd(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>котангенс</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>sin</primary></indexterm>
        <literal><function>sin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>sind</primary></indexterm>
        <literal><function>sind(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>синус</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>tan</primary></indexterm>
        <literal><function>tan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm><primary>tand</primary></indexterm>
        <literal><function>tand(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>тангенс</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>Также можно работать с углами в градусах, применяя вышеупомянутые функции преобразования единиц <literal><function>radians()</function></literal> и <literal><function>degrees()</function></literal>. Однако предпочтительнее использовать тригонометрические функции с градусами, так как это позволяет избежать ошибок округления в особых случаях, например, при вычислении <literal>sind(30)</literal>.</para>
  </note>

  </sect1>


  <sect1 id="functions-string">
   <title>Строковые функции и операторы</title>

   <para>В этом разделе описаны функции и операторы для работы с текстовыми строками. Под строками в данном контексте подразумеваются значения типов <type>character</type>, <type>character varying</type> и <type>text</type>. Если не отмечено обратное, все нижеперечисленные функции работают со всеми этими типами, хотя с типом <type>character</type> следует учитывать возможные эффекты автоматического дополнения строк пробелами. Некоторые из этих функций также поддерживают битовые строки.</para>

   <para>В <acronym>SQL</acronym> определены несколько строковых функций, в которых аргументы разделяются не запятыми, а ключевыми словами. Они перечислены в <xref remap="6" linkend="functions-string-sql"/>. <productname>&productname;</productname> также предоставляет варианты этих функций с синтаксисом, обычным для функций (см. <xref remap="4" linkend="functions-string-other"/>).</para>

   <note>
    <para>До версии 8.3 в <productname>PostgreSQL</productname> эти функции также прозрачно принимали значения некоторых не строковых типов, неявно приводя эти значения к типу <type>text</type>. Сейчас такие приведения исключены, так как они часто приводили к неожиданным результатам. Однако оператор конкатенации строк (<literal>||</literal>) по-прежнему принимает не только строковые данные, если хотя бы один аргумент имеет строковый тип, как показано в <xref remap="6" linkend="functions-string-sql"/>. Во всех остальных случаях для повторения предыдущего поведения потребуется добавить явное преобразование в <type>text</type>.</para>
   </note>

   <table id="functions-string-sql">
    <title>Строковые функции и операторы языка <acronym>SQL</acronym></title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>Конкатенация строк <indexterm><primary>символьная строка</primary> <secondary>конкатенация</secondary></indexterm></entry>
       <entry><literal>'Post' || 'greSQL'</literal></entry>
       <entry><literal>PostgreSQL</literal></entry>
      </row>

      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal> <parameter>не string</parameter></literal> или <literal><parameter>не string</parameter> <literal>||</literal> <parameter>string</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>Конкатенация строк с одним не строковым операндом</entry>
       <entry><literal>'Value: ' || 42</literal></entry>
       <entry><literal>Value: 42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>bit_length</primary></indexterm>
        <literal><function>bit_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Число бит в строке</entry>
       <entry><literal>bit_length('jose')</literal></entry>
       <entry><literal>32</literal></entry>
      </row>

      <row>
       <entry><indexterm><primary>char_length</primary></indexterm> <literal><function>char_length(<parameter>string</parameter>)</function></literal> или <literal><function>character_length(<parameter>string</parameter>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>Число символов в строке <indexterm><primary>строка символов</primary> <secondary>длина</secondary></indexterm> <indexterm><primary>длина</primary> <secondary sortas="символьная строка">строки символов</secondary> <see>строка символов, длина</see></indexterm></entry>
       <entry><literal>char_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>lower</primary></indexterm>
        <literal><function>lower(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Переводит символы строки в нижний регистр</entry>
       <entry><literal>lower('TOM')</literal></entry>
       <entry><literal>tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>octet_length</primary></indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Число байт в строке</entry>
       <entry><literal>octet_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>overlay</primary></indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Заменяет подстроку</entry>
       <entry><literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal></entry>
       <entry><literal>Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>position</primary></indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Положение указанной подстроки</entry>
       <entry><literal>position('om' in 'Thomas')</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>substring</primary></indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Извлекает подстроку</entry>
       <entry><literal>substring('Thomas' from 2 for 3)</literal></entry>
       <entry><literal>hom</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>шаблон</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>Извлекает подстроку, соответствующую регулярному выражению в стиле POSIX. Подробно шаблоны описаны в <xref remap="6" linkend="functions-matching"/>.</entry>
       <entry><literal>substring('Thomas' from '...$')</literal></entry>
       <entry><literal>mas</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>шаблон</replaceable> for <replaceable>спецсимвол</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>Извлекает подстроку, соответствующую регулярному выражению в стиле <acronym>SQL</acronym>. Подробно шаблоны описаны в <xref remap="6" linkend="functions-matching"/>.</entry>
       <entry><literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal></entry>
       <entry><literal>oma</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>trim</primary></indexterm>
        <literal><function>trim(<optional>leading | trailing | both</optional> <optional><parameter>characters</parameter></optional> from <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Удаляет наибольшую подстроку, содержащую только символы <parameter>characters</parameter> (по умолчанию пробелы), с начала (<literal>leading</literal>), с конца (<literal>trailing</literal>) или с обеих сторон (<literal>both</literal>, (по умолчанию)) строки <parameter>string</parameter></entry>
       <entry><literal>trim(both 'xyz' from 'yxTomxx')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>trim(<optional>leading | trailing | both</optional> <optional>from</optional> <parameter>string</parameter> <optional>, <parameter>characters</parameter></optional> )</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Нестандартный синтаксис <function>trim()</function></entry>
       <entry><literal>trim(both from 'yxTomxx', 'xyz')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>upper</primary></indexterm>
        <literal><function>upper(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Переводит символы строки в верхний регистр</entry>
       <entry><literal>upper('tom')</literal></entry>
       <entry><literal>TOM</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Кроме этого, в <productname>PostgreSQL</productname> есть и другие функции для работы со строками, перечисленные в <xref remap="6" linkend="functions-string-other"/>. Некоторые из них используются в качестве внутренней реализации стандартных строковых функций <acronym>SQL</acronym>, приведённых в <xref remap="6" linkend="functions-string-sql"/>.</para>

   <table id="functions-string-other">
    <title>Другие строковые функции</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>ascii</primary></indexterm>
        <literal><function>ascii(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Возвращает <acronym>ASCII</acronym>-код первого символа аргумента. Для <acronym>UTF8</acronym> возвращает код символа в Unicode. Для других многобайтных кодировок аргумент должен быть <acronym>ASCII</acronym>-символом.</entry>
       <entry><literal>ascii('x')</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>btrim</primary></indexterm>
        <literal><function>btrim(<parameter>string</parameter> <type>text</type> <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Удаляет наибольшую подстроку, состоящую только из символов <parameter>characters</parameter> (по умолчанию пробелов), с начала и с конца строки <parameter>string</parameter></entry>
       <entry><literal>btrim('xyxtrimyyx', 'xyz')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>chr</primary></indexterm>
        <literal><function>chr(<type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Возвращает символ с данным кодом. Для <acronym>UTF8</acronym> аргумент воспринимается как код символа Unicode, а для других кодировок он должен указывать на <acronym>ASCII</acronym>-символ. Код 0 (NULL) не допускается, так как байты с нулевым кодом в текстовых строках сохранить нельзя.</entry>
       <entry><literal>chr(65)</literal></entry>
       <entry><literal>A</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>concat</primary></indexterm>
        <literal><function>concat(<parameter>str</parameter> <type>"any"</type> [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Соединяет текстовые представления всех аргументов, игнорируя NULL.</entry>
       <entry><literal>concat('abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde222</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>concat_ws</primary></indexterm>
        <literal><function>concat_ws(<parameter>sep</parameter> <type>text</type>, <parameter>str</parameter> <type>"any"</type> [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Соединяет все аргументы, кроме первого, через разделитель, игнорируя аргументы NULL. Разделитель указывается в первом аргументе.</entry>
       <entry><literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde,2,22</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>convert</primary></indexterm>
        <literal><function>convert(<parameter>string</parameter> <type>bytea</type>, <parameter>src_encoding</parameter> <type>name</type>, <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Преобразует строку <parameter>string</parameter> из кодировки <parameter>src_encoding</parameter> в <parameter>dest_encoding</parameter>. Переданная строка должна быть допустимой для исходной кодировки. Преобразования могут быть определены с помощью <command>CREATE CONVERSION</command>. Все встроенные преобразования перечислены в <xref remap="6" linkend="conversion-names"/>.</entry>
       <entry><literal>convert('text_in_utf8'&#8203;, 'UTF8', 'LATIN1')</literal></entry>
       <entry>строка <literal>text_in_utf8</literal>, представленная в кодировке Latin-1 (ISO 8859-1)</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>convert_from</primary></indexterm>
        <literal><function>convert_from(<parameter>string</parameter> <type>bytea</type>, <parameter>src_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Преобразует строку <parameter>string</parameter> из кодировки <parameter>src_encoding</parameter> в кодировку базы данных. Переданная строка должна быть допустимой для исходной кодировки.</entry>
       <entry><literal>convert_from('text_in_utf8'&#8203;, 'UTF8')</literal></entry>
       <entry>строка <literal>text_in_utf8</literal>, представленная в кодировке текущей базы данных</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>convert_to</primary></indexterm>
        <literal><function>convert_to(<parameter>string</parameter> <type>text</type>, <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Преобразует строку в кодировку <parameter>dest_encoding</parameter>.</entry>
       <entry><literal>convert_to('некоторый текст', 'UTF8')</literal></entry>
       <entry><literal>некоторый текст</literal>, представленный в кодировке UTF8</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>decode</primary></indexterm>
        <literal><function>decode(<parameter>string</parameter> <type>text</type>, <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Получает двоичные данные из текстового представления в <parameter>string</parameter>. Значения параметра <parameter>format</parameter> те же, что и для функции <function>encode</function>.</entry>
       <entry><literal>decode('MTIzAAE=', 'base64')</literal></entry>
       <entry><literal>\x3132330001</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>encode</primary></indexterm>
        <literal><function>encode(<parameter>data</parameter> <type>bytea</type>, <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Переводит двоичные данные в текстовое представление в одном из форматов: <literal>base64</literal>, <literal>hex</literal>, <literal>escape</literal>. Формат <literal>escape</literal> преобразует нулевые байты и байты с 1 в старшем бите в восьмеричные последовательности <literal>\nnn</literal> и дублирует обратную косую черту.</entry>
       <entry><literal>encode(E'123&#8203;\\000&#8203;\\001', 'base64')</literal></entry>
       <entry><literal>MTIzAAE=</literal></entry>
      </row>

      <row>
       <entry id="format">
        <indexterm><primary>format</primary></indexterm>
        <literal><function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Форматирует аргумент в соответствии со строкой формата. Эта функция работает подобно <function>sprintf</function> в языке C. См. <xref remap="4" linkend="functions-string-format"/>.</entry>
       <entry><literal>format('Hello %s, %1$s', 'World')</literal></entry>
       <entry><literal>Hello World, World</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>initcap</primary></indexterm>
        <literal><function>initcap(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Переводит первую букву каждого слова в строке в верхний регистр, а остальные &mdash; в нижний. Словами считаются последовательности алфавитно-цифровых символов, разделённые любыми другими символами.</entry>
       <entry><literal>initcap('hi THOMAS')</literal></entry>
       <entry><literal>Hi Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>left</primary></indexterm>
        <literal><function>left(<parameter>str</parameter> <type>text</type>, <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Возвращает первые <replaceable>n</replaceable> символов в строке. Когда <replaceable>n</replaceable> меньше нуля, возвращаются все символы слева, кроме последних |<replaceable>n</replaceable>|.</entry>
       <entry><literal>left('abcde', 2)</literal></entry>
       <entry><literal>ab</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>length</primary></indexterm>
        <literal><function>length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Число символов в строке <parameter>string</parameter></entry>
       <entry><literal>length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>length(<parameter>string</parameter> <type>bytea</type>, <parameter>encoding</parameter> <type>name</type> )</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>Число символов, которые содержит строка <parameter>string</parameter> в заданной кодировке <parameter>encoding</parameter>. Переданная строка должна быть допустимой в этой кодировке.</entry>
       <entry><literal>length('jose', 'UTF8')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>lpad</primary></indexterm>
        <literal><function>lpad(<parameter>string</parameter> <type>text</type>, <parameter>length</parameter> <type>int</type> <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Дополняет строку <parameter>string</parameter> слева до длины <parameter>length</parameter> символами <parameter>fill</parameter> (по умолчанию пробелами). Если длина строки уже больше заданной, она обрезается справа.</entry>
       <entry><literal>lpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>xyxhi</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>ltrim</primary></indexterm>
        <literal><function>ltrim(<parameter>string</parameter> <type>text</type> <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Удаляет наибольшую подстроку, содержащую только символы <parameter>characters</parameter> (по умолчанию пробелы), с начала строки <parameter>string</parameter></entry>
       <entry><literal>ltrim('zzzytest', 'xyz')</literal></entry>
       <entry><literal>test</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>md5</primary></indexterm>
        <literal><function>md5(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Вычисляет MD5-хеш строки <parameter>string</parameter> и возвращает результат в 16-ричном виде</entry>
       <entry><literal>md5('abc')</literal></entry>
       <entry><literal>90015098&#8203;3cd24fb0 d6963f7d&#8203;28e17f72</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>parse_ident</primary></indexterm>
        <literal><function>parse_ident(<parameter>qualified_identifier</parameter> <type>text</type> [, <parameter>strictmode</parameter> <type>boolean</type> DEFAULT true ] )</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>Раскладывает полный идентификатор, задаваемый параметром <parameter>qualified_identifier</parameter>, на массив идентификаторов, удаляя кавычки, обрамляющие отдельные идентификаторы. По умолчанию лишние символы после последнего идентификатора вызывают ошибку, но если отключить строгий режим (передать во втором параметре <literal>false</literal>), такие символы игнорируются. (Это поведение полезно для разбора имён таких объектов, как функции.) Заметьте, что эта функция не усекает чрезмерно длинные идентификаторы. Если вы хотите получить усечённые имена, можно привести результат к <type>name[]</type>.</entry>
       <entry><literal>parse_ident('"SomeSchema".someTable')</literal></entry>
       <entry><literal>{SomeSchema,sometable}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_client_encoding</primary></indexterm>
        <literal><function>pg_client_encoding()</function></literal>
       </entry>
       <entry><type>name</type></entry>
       <entry>Возвращает имя текущей клиентской кодировки</entry>
       <entry><literal>pg_client_encoding()</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>quote_ident</primary></indexterm>
        <literal><function>quote_ident(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Переданная строка оформляется для использования в качестве идентификатора в <acronym>SQL</acronym> -операторе. При необходимости идентификатор заключается в кавычки (например, если он содержит символы, недопустимые в открытом виде, или буквы в разном регистре). Если переданная строка содержит кавычки, они дублируются. См. также <xref remap="4" linkend="plpgsql-quote-literal-example"/>.</entry>
       <entry><literal>quote_ident('Foo bar')</literal></entry>
       <entry><literal>"Foo bar"</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>quote_literal</primary></indexterm>
        <literal><function>quote_literal(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Переданная строка оформляется для использования в качестве текстовой строки в <acronym>SQL</acronym>-операторе. Включённые символы апостроф и обратная косая черта при этом дублируются. Заметьте, что <function>quote_literal</function> возвращает NULL, когда на вход ей передаётся строка NULL; если же нужно получить представление и такого аргумента, лучше использовать <function>quote_nullable</function>. См. также <xref remap="4" linkend="plpgsql-quote-literal-example"/>.</entry>
       <entry><literal>quote_literal(E'O\'Reilly')</literal></entry>
       <entry><literal>'O''Reilly'</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_literal(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>Переводит данное значение в текстовый вид и заключает в апострофы как текстовую строку. Символы апостроф и обратная косая черта при этом дублируются.</entry>
       <entry><literal>quote_literal(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>quote_nullable</primary></indexterm>
        <literal><function>quote_nullable(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Переданная строка оформляется для использования в качестве текстовой строки в <acronym>SQL</acronym>-операторе; при этом для аргумента NULL возвращается строка <literal>NULL</literal>. Символы апостроф и обратная косая черта дублируются должным образом. См. также <xref remap="4" linkend="plpgsql-quote-literal-example"/>.</entry>
       <entry><literal>quote_nullable(NULL)</literal></entry>
       <entry><literal>NULL</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_nullable(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>Переводит данное значение в текстовый вид и заключает в апострофы как текстовую строку, при этом для аргумента NULL возвращается строка <literal>NULL</literal>. Символы апостроф и обратная косая черта дублируются должным образом.</entry>
       <entry><literal>quote_nullable(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>regexp_matches</primary></indexterm>
        <literal><function>regexp_matches&#8203;(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text[]</type></entry>
       <entry>Возвращает все подходящие подстроки, полученные в результате применения регулярного выражения в стиле POSIX к <parameter>string</parameter>. Подробности описаны в <xref remap="6" linkend="functions-posix-regexp"/>.</entry>
       <entry><literal>regexp_matches&#8203;('foobar&#8203;bequebaz', '(bar)(beque)')</literal></entry>
       <entry><literal>{bar,beque}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>regexp_replace</primary></indexterm>
        <literal><function>regexp_replace&#8203;(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Заменяет подстроки, соответствующие заданному регулярному выражению в стиле POSIX. Подробности описаны в <xref remap="6" linkend="functions-posix-regexp"/>.</entry>
       <entry><literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal></entry>
       <entry><literal>ThM</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>regexp_split_to_array</primary></indexterm>
        <literal><function>regexp_split_to_array(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>Разделяет содержимое <parameter>string</parameter> на элементы, используя в качестве разделителя регулярное выражение POSIX. Подробности описаны в <xref remap="6" linkend="functions-posix-regexp"/>.</entry>
       <entry><literal>regexp_split_to_array('hello world', E'\\s+')</literal></entry>
       <entry><literal>{hello,world}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>regexp_split&#8203;_to_table</primary></indexterm>
        <literal><function>regexp_split_to_table(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>Разделяет содержимое <parameter>string</parameter> на элементы, используя в качестве разделителя регулярное выражение POSIX. Подробности описаны в <xref remap="6" linkend="functions-posix-regexp"/>.</entry>
       <entry><literal>regexp_split_to_table('hello world', E'\\s+')</literal></entry>
       <entry><literal>hello</literal> <para><literal>world</literal></para> (2 строки)</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>repeat</primary></indexterm>
        <literal><function>repeat(<parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Повторяет содержимое <parameter>string</parameter> указанное число (<parameter>number</parameter>) раз</entry>
       <entry><literal>repeat('Pg', 4)</literal></entry>
       <entry><literal>PgPgPgPg</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>replace</primary></indexterm>
        <literal><function>replace(<parameter>string</parameter> <type>text</type>, <parameter>from</parameter> <type>text</type>, <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Заменяет все вхождения в <parameter>string</parameter> подстроки <parameter>from</parameter> подстрокой <parameter>to</parameter></entry>
       <entry><literal>replace('abcdefabcdef', 'cd', 'XX')</literal></entry>
       <entry><literal>abXXefabXXef</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>reverse</primary></indexterm>
        <literal><function>reverse(<parameter>str</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Возвращает перевёрнутую строку</entry>
       <entry><literal>reverse('abcde')</literal></entry>
       <entry><literal>edcba</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>right</primary></indexterm>
        <literal><function>right(<parameter>str</parameter> <type>text</type>, <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Возвращает последние <replaceable>n</replaceable> символов в строке. Когда <replaceable>n</replaceable> меньше нуля, возвращаются все символы справа, кроме первых |<replaceable>n</replaceable>|.</entry>
       <entry><literal>right('abcde', 2)</literal></entry>
       <entry><literal>de</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>rpad</primary></indexterm>
        <literal><function>rpad(<parameter>string</parameter> <type>text</type>, <parameter>length</parameter> <type>int</type> <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Дополняет строку <parameter>string</parameter> справа до длины <parameter>length</parameter> символами <parameter>fill</parameter> (по умолчанию пробелами). Если длина строки уже больше заданной, она обрезается.</entry>
       <entry><literal>rpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>hixyx</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>rtrim</primary></indexterm>
        <literal><function>rtrim(<parameter>string</parameter> <type>text</type> <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Удаляет наибольшую подстроку, содержащую только символы <parameter>characters</parameter> (по умолчанию пробелы), с конца строки <parameter>string</parameter></entry>
       <entry><literal>rtrim('testxxzx', 'xyz')</literal></entry>
       <entry><literal>test</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>split_part</primary></indexterm>
        <literal><function>split_part(<parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type>, <parameter>field</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Разделяет строку <parameter>string</parameter> по символу <parameter>delimiter</parameter> и возвращает элемент по заданному номеру (считая с 1)</entry>
       <entry><literal>split_part('abc~@~def&#8203;~@~ghi', '~@~', 2)</literal></entry>
       <entry><literal>def</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>strpos</primary></indexterm>
        <literal><function>strpos(<parameter>string</parameter>, <parameter>substring</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Возвращает положение указанной подстроки (подобно <literal>position(<parameter>substring</parameter> in <parameter>string</parameter>)</literal>, но с другим порядком аргументов)</entry>
       <entry><literal>strpos('high', 'ig')</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>substr</primary></indexterm>
        <literal><function>substr(<parameter>string</parameter>, <parameter>from</parameter> <optional>, <parameter>count</parameter></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Извлекает подстроку (подобно <literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)</entry>
       <entry><literal>substr('alphabet', 3, 2)</literal></entry>
       <entry><literal>ph</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>to_ascii</primary></indexterm>
        <literal><function>to_ascii(<parameter>string</parameter> <type>text</type> <optional>, <parameter>encoding</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Преобразует <parameter>string</parameter> в <acronym>ASCII</acronym> из кодировки <parameter>encoding</parameter> (поддерживаются только <literal>LATIN1</literal>, <literal>LATIN2</literal>, <literal>LATIN9</literal> и <literal>WIN1250</literal>)</entry>
       <entry><literal>to_ascii('Karel')</literal></entry>
       <entry><literal>Karel</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>to_hex</primary></indexterm>
        <literal><function>to_hex(<parameter>number</parameter> <type>int</type> или <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Преобразует число <parameter>number</parameter> в 16-ричный вид</entry>
       <entry><literal>to_hex(2147483647)</literal></entry>
       <entry><literal>7fffffff</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>translate</primary></indexterm>
        <literal><function>translate(<parameter>string</parameter> <type>text</type>, <parameter>from</parameter> <type>text</type>, <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Заменяет символы в <parameter>string</parameter>, найденные в наборе <parameter>from</parameter>, на соответствующие символы в множестве <parameter>to</parameter>. Если строка <parameter>from</parameter> длиннее <parameter>to</parameter>, найденные в исходной строке лишние символы <parameter>from</parameter> удаляются.</entry>
       <entry><literal>translate('12345', '143', 'ax')</literal></entry>
       <entry><literal>a2x5</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>Функции <function>concat</function>, <function>concat_ws</function> и <function>format</function> принимают переменное число аргументов, так что им для объединения или форматирования можно передавать значения в виде массива, помеченного ключевым словом <literal>VARIADIC</literal> (см. <xref remap="4" linkend="xfunc-sql-variadic-functions"/>). Элементы такого массива обрабатываются, как если бы они были обычными аргументами функции. Если вместо массива в соответствующем аргументе передаётся NULL, функции <function>concat</function> и <function>concat_ws</function> возвращают NULL, а <function>format</function> воспринимает NULL как массив нулевого размера.</para>

   <para>См. также агрегатную функцию <function>string_agg</function> в <xref remap="6" linkend="functions-aggregate"/>.</para>

   <table id="conversion-names">
    <title>Встроенные преобразования</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Имя преобразования <footnote>
         <para>Имена преобразований следуют стандартной схеме именования. К официальному названию исходной кодировки, в котором все не алфавитно-цифровые символы заменяются подчёркиваниями, добавляется <literal>_to_</literal>, а за ним аналогично подготовленное имя целевой кодировки. Таким образом, имена кодировок могут не совпадать буквально с общепринятыми названиями.</para>
        </footnote></entry>
       <entry>Исходная кодировка</entry>
       <entry>Целевая кодировка</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>ascii_to_mic</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>ascii_to_utf8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_euc_tw</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_mic</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_utf8</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_mic</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_utf8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_mic</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_sjis</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_utf8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_mic</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_utf8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_big5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_mic</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_utf8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gb18030_to_utf8</literal></entry>
       <entry><literal>GB18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gbk_to_utf8</literal></entry>
       <entry><literal>GBK</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_10_to_utf8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_13_to_utf8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_14_to_utf8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_15_to_utf8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_16_to_utf8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_mic</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_utf8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_mic</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_utf8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_windows_1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_mic</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_utf8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_mic</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_utf8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_koi8_r</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_mic</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_utf8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_6_to_utf8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_7_to_utf8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_8_to_utf8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_9_to_utf8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>johab_to_utf8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_iso_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_mic</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_utf8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_u_to_utf8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_ascii</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_big5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_cn</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_jp</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_kr</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_tw</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_koi8_r</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_sjis</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_euc_jp</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_mic</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_utf8</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>tcvn_to_utf8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>uhc_to_utf8</literal></entry>
       <entry><literal>UHC</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_ascii</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_big5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_cn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jp</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_kr</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_tw</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gb18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GB18030</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gbk</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GBK</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_1</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_10</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_13</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_14</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_15</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_16</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_2</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_3</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_4</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_9</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_johab</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_r</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_u</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_sjis</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_tcvn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_uhc</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>UHC</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1253</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1253</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1254</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1254</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1255</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1255</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1257</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1257</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_866</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_874</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN874</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_iso_8859_2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_mic</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_utf8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_iso_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_koi8_r</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_mic</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_utf8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_windows_866</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1252_to_utf8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1256_to_utf8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_iso_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_koi8_r</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_mic</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_utf8</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_windows_1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>windows_874_to_utf8</literal></entry>
       <entry><literal>WIN874</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_utf8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_utf8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_shift_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_shift_jis_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_euc_jis_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <sect2 id="functions-string-format">
    <title><function>format</function></title>

    <indexterm><primary>format</primary></indexterm>

    <para>Функция <function>format</function> выдаёт текст, отформатированный в соответствии со строкой формата, подобно функции <function>sprintf</function> в C.</para>

    <para><synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis> <replaceable>formatstr</replaceable> &mdash; строка, определяющая, как будет форматироваться результат. Обычный текст в строке формата непосредственно копируется в результат, за исключением <firstterm>спецификаторов формата</firstterm>. Спецификаторы формата представляют собой местозаполнители, определяющие, как должны форматироваться и выводиться в результате аргументы функции. Каждый аргумент <replaceable>formatarg</replaceable> преобразуется в текст по правилам выводам своего типа данных, а затем форматируется и вставляется в результирующую строку согласно спецификаторам формата.</para>

    <para>Спецификаторы формата предваряются символом <literal>%</literal> и имеют форму <synopsis>
%[<replaceable>позиция</replaceable>][<replaceable>флаги</replaceable>][<replaceable>ширина</replaceable>]<replaceable>тип</replaceable>
</synopsis> Здесь: <variablelist>
      <varlistentry>
       <term><replaceable>позиция</replaceable> (необязателен)</term>
       <listitem>
        <para>Строка вида <literal><replaceable>n</replaceable>$</literal>, где <replaceable>n</replaceable> &mdash; индекс выводимого аргумента. Индекс, равный 1, выбирает первый аргумент после <replaceable>formatstr</replaceable>. Если <replaceable>позиция</replaceable> опускается, по умолчанию используется следующий аргумент по порядку.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>флаги</replaceable> (необязателен)</term>
       <listitem>
        <para>Дополнительные параметры, управляющие форматированием данного спецификатора. В настоящее время поддерживается только знак минус (<literal>-</literal>), который выравнивает результата спецификатора по левому краю. Он работает, только если также определена <replaceable>ширина</replaceable>.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>ширина</replaceable> (необязателен)</term>
       <listitem>
        <para>Задаёт <emphasis>минимальное</emphasis> число символов, которое будет занимать результат данного спецификатора. Выводимое значение выравнивается по правой или левой стороне (в зависимости от флага <literal>-</literal>) с дополнением необходимым числом пробелов. Если ширина слишком мала, она просто игнорируется, т. е. результат не усекается. Ширину можно обозначить положительным целым, звёздочкой (<literal>*</literal>), тогда ширина будет получена из следующего аргумента функции, или строкой вида <literal>*<replaceable>n</replaceable>$</literal>, тогда ширина будет задаваться в <replaceable>n</replaceable>-ом аргументе функции.</para>

        <para>Если ширина передаётся в аргументе функции, этот аргумент выбирается до аргумента, используемого для спецификатора. Если аргумент ширины отрицательный, результат выравнивается по левой стороне (как если бы был указан флаг <literal>-</literal>) в рамках поля длины <function>abs</function>(<replaceable>ширина</replaceable>).</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>тип</replaceable> (обязателен)</term>
       <listitem>
        <para>Тип спецификатора определяет преобразование соответствующего выводимого значения. Поддерживаются следующие типы: <itemizedlist>
          <listitem>
           <para><literal>s</literal> форматирует значение аргумента как простую строку. Значение NULL представляется пустой строкой.</para>
          </listitem>
          <listitem>
           <para><literal>I</literal> обрабатывает значение аргумента как SQL-идентификатор, при необходимости заключая его в кавычки. Значение NULL для такого преобразования считается ошибочным (так же, как и для <function>quote_ident</function>).</para>
          </listitem>
          <listitem>
           <para><literal>L</literal> заключает значение аргумента в апострофы, как строку SQL. Значение NULL выводится буквально, как <literal>NULL</literal>, без кавычек (так же, как и с <function>quote_nullable</function>).</para>
          </listitem>
         </itemizedlist></para>
       </listitem>
      </varlistentry>
     </variablelist></para>

    <para>В дополнение к спецификаторам, описанным выше, можно использовать спецпоследовательность <literal>%%</literal>, которая просто выведет символ <literal>%</literal>.</para>

    <para>Несколько пример простых преобразований формата: <screen>
SELECT format('Hello %s', 'World');
<lineannotation>Результат: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Результат: </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\Program Files');
<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO locations VALUES(E'C:\\Program Files')</computeroutput>
</screen></para>

    <para>Следующие примеры иллюстрируют использование поля <replaceable>ширина</replaceable> и флага <literal>-</literal>: <screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</computeroutput>
</screen></para>

    <para>Эти примеры показывают применение полей <replaceable>позиция</replaceable>: <screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Результат: </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Результат: </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</computeroutput>
</screen></para>

    <para>В отличие от стандартной функции C <function>sprintf</function>, функция <function>format</function> в <productname>&productname;</productname> позволяет комбинировать в одной строке спецификаторы с полями <replaceable>позиция</replaceable> и без них. Спецификатор формата без поля <replaceable>позиция</replaceable> всегда использует следующий аргумент после последнего выбранного. Кроме того, функция <function>format</function> не требует, чтобы в строке формата использовались все аргументы функции. Пример этого поведения: <screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Результат: </lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen></para>

    <para>Спецификаторы формата <literal>%I</literal> и <literal>%L</literal> особенно полезны для безопасного составления динамических операторов SQL. См. <xref remap="4" linkend="plpgsql-quote-literal-example"/>.</para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
   <title>Функции и операторы двоичных строк</title>

   <indexterm zone="functions-binarystring"><primary>двоичные данные</primary> <secondary>функции</secondary></indexterm>

   <para>В этом разделе описываются функции и операторы для работы с данными типа <type>bytea</type>.</para>

   <para>В <acronym>SQL</acronym> определены несколько строковых функций, в которых аргументы разделяются не запятыми, а ключевыми словами. Подробнее это описано в <xref remap="6" linkend="functions-binarystring-sql"/>. <productname>&productname;</productname> также предоставляет варианты этих функций с синтаксисом, обычным для функций (см. <xref remap="4" linkend="functions-binarystring-other"/>).</para>

   <note>
    <para>В примерах, приведённых на этой странице, подразумевается, что параметр сервера <link linkend="guc-bytea-output"><varname>bytea_output</varname></link> равен <literal>escape</literal> (выбран традиционный формат &productname;).</para>
   </note>

   <table id="functions-binarystring-sql">
    <title><acronym>SQL</acronym>-функции и операторы для работы с двоичными строками</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>bytea</type> </entry>
       <entry>Конкатенация строк <indexterm><primary>двоичные строки</primary> <secondary>конкатенация</secondary></indexterm></entry>
       <entry><literal>E'\\\\Post'::bytea || E'\\047gres&#8203;\\000'::bytea</literal></entry>
       <entry><literal>\\Post'gres&#8203;\000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>octet_length</primary></indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Число байт в двоичной строке</entry>
       <entry><literal>octet_length(E'jo\\000se'::bytea)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>overlay</primary></indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Заменяет подстроку</entry>
       <entry><literal>overlay(E'Th\\000&#8203;omas'::bytea placing E'\\002\\003'::bytea from 2 for 3)</literal></entry>
       <entry><literal>T\\002&#8203;\\003&#8203;mas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>position</primary></indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Положение указанной подстроки</entry>
      <entry><literal>position(E'\\000om'::bytea in E'Th\\000&#8203;omas'::bytea)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>substring</primary></indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Извлекает подстроку</entry>
       <entry><literal>substring(E'Th\\000&#8203;omas'::bytea from 2 for 3)</literal></entry>
       <entry><literal>h\000o</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>trim</primary></indexterm>
        <literal><function>trim(<optional>both</optional> <parameter>bytes</parameter> from <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Удаляет наибольшую строку, содержащую только байты, заданные в параметре <parameter>bytes</parameter>, с начала и с конца строки <parameter>string</parameter></entry>
       <entry><literal>trim(E'\\000\\001'::bytea from E'\\000Tom\\001'::bytea)</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>В <productname>PostgreSQL</productname> есть и другие функции для работы с двоичными строками, перечисленные в <xref remap="6" linkend="functions-binarystring-other"/>. Некоторые из них используются в качестве внутренней реализации стандартных функций <acronym>SQL</acronym>, приведённых в <xref remap="6" linkend="functions-binarystring-sql"/>.</para>

   <table id="functions-binarystring-other">
    <title>Другие функции для работы с двоичными строками</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>btrim</primary></indexterm>
        <literal><function>btrim(<parameter>string</parameter> <type>bytea</type>, <parameter>bytes</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Удаляет наибольшую строку, содержащую только байты, заданные в параметре <parameter>bytes</parameter>, с начала и с конца строки <parameter>string</parameter></entry>
      <entry><literal>btrim(E'\\000trim\\001'::bytea, E'\\000\\001'::bytea)</literal></entry>
      <entry><literal>trim</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm><primary>decode</primary></indexterm>
       <literal><function>decode(<parameter>string</parameter> <type>text</type>, <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>bytea</type></entry>
      <entry>Получает двоичные данные из текстового представления в <parameter>string</parameter>. Значения параметра <parameter>format</parameter> те же, что и для функции <function>encode</function>.</entry>
      <entry><literal>decode(E'123&#8203;\\000456', 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm><primary>encode</primary></indexterm>
       <literal><function>encode(<parameter>data</parameter> <type>bytea</type>, <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>Переводит двоичные данные в текстовое представление в одном из форматов: <literal>base64</literal>, <literal>hex</literal>, <literal>escape</literal>. Формат <literal>escape</literal> преобразует нулевые байты и байты с 1 в старшем бите в восьмеричные последовательности <literal>\nnn</literal> и дублирует обратную косую черту.</entry>
      <entry><literal>encode(E'123&#8203;\\000456'::bytea, 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm><primary>get_bit</primary></indexterm>
        <literal><function>get_bit(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Извлекает бит из строки</entry>
       <entry><literal>get_bit(E'Th\\000&#8203;omas'::bytea, 45)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>get_byte</primary></indexterm>
        <literal><function>get_byte(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Извлекает байт из строки</entry>
       <entry><literal>get_byte(E'Th\\000&#8203;omas'::bytea, 4)</literal></entry>
       <entry><literal>109</literal></entry>
      </row>

     <row>
      <entry>
       <indexterm><primary>length</primary></indexterm>
       <literal><function>length(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>int</type></entry>
      <entry>Длина двоичной строки <indexterm><primary>двоичная строка</primary> <secondary>длина</secondary></indexterm> <indexterm><primary>длина</primary> <secondary sortas="двоичная строка">двоичной строки</secondary> <see>двоичные строки, длина</see></indexterm></entry>
      <entry><literal>length(E'jo\\000se'::bytea)</literal></entry>
      <entry><literal>5</literal></entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>md5</primary></indexterm>
       <literal><function>md5(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>Вычисляет MD5-хеш строки <parameter>string</parameter> и возвращает результат в 16-ричном виде</entry>
      <entry><literal>md5(E'Th\\000&#8203;omas'::bytea)</literal></entry>
      <entry><literal>8ab2d3c9&#8203;689aaf18 b4958c33&#8203;4c82d8b1</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm><primary>set_bit</primary></indexterm>
        <literal><function>set_bit(<parameter>string</parameter>, <parameter>offset</parameter>, <parameter>newvalue</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Устанавливает значение бита в строке</entry>
       <entry><literal>set_bit(E'Th\\000&#8203;omas'::bytea, 45, 0)</literal></entry>
       <entry><literal>Th\000omAs</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>set_byte</primary></indexterm>
        <literal><function>set_byte(<parameter>string</parameter>, <parameter>offset</parameter>, <parameter>newvalue</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Устанавливает значение байта в строке</entry>
       <entry><literal>set_byte(E'Th\\000&#8203;omas'::bytea, 4, 64)</literal></entry>
       <entry><literal>Th\000o@as</literal></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

  <para>Для функций <function>get_byte</function> и <function>set_byte</function> байты нумеруется с 0. Функции <function>get_bit</function> и <function>set_bit</function> нумеруют биты справа налево; например, бит 0 будет меньшим значащим битом первого байта, а бит 15 &mdash; большим значащим битом второго байта.</para>

  <para>См. также агрегатную функцию <function>string_agg</function> в <xref remap="6" linkend="functions-aggregate"/> и функции для работы с большими объектами в <xref remap="6" linkend="lo-funcs"/>.</para>
 </sect1>


  <sect1 id="functions-bitstring">
   <title>Функции и операторы для работы с битовыми строками</title>

   <indexterm zone="functions-bitstring"><primary>битовые строки</primary> <secondary>функции</secondary></indexterm>

   <para>В этом разделе описываются функции и операторы, предназначенные для работы с битовыми строками, то есть с данными типов <type>bit</type> и <type>bit varying</type>. Помимо обычных операторов сравнения, с такими данными можно использовать операторы, перечисленные в <xref remap="6" linkend="functions-bit-string-op-table"/>. Заметьте, что операторы <literal>&amp;</literal>, <literal>|</literal> и <literal>#</literal> работают только с двоичными строками одинаковой длины. Операторы побитового сдвига сохраняют длины исходных строк, как показано в примерах.</para>

   <table id="functions-bit-string-op-table">
    <title>Операторы для работы с битовыми строками</title>

    <tgroup cols="4">
     <thead>
      <row>
       <entry>Оператор</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>||</literal> </entry>
       <entry>конкатенация</entry>
       <entry><literal>B'10001' || B'011'</literal></entry>
       <entry><literal>10001011</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <entry>битовый AND</entry>
       <entry><literal>B'10001' &amp; B'01101'</literal></entry>
       <entry><literal>00001</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <entry>битовый OR</entry>
       <entry><literal>B'10001' | B'01101'</literal></entry>
       <entry><literal>11101</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <entry>битовый XOR</entry>
       <entry><literal>B'10001' # B'01101'</literal></entry>
       <entry><literal>11100</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <entry>битовый NOT</entry>
       <entry><literal>~ B'10001'</literal></entry>
       <entry><literal>01110</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <entry>битовый сдвиг влево</entry>
       <entry><literal>B'10001' &lt;&lt; 3</literal></entry>
       <entry><literal>01000</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <entry>битовый сдвиг вправо</entry>
       <entry><literal>B'10001' &gt;&gt; 2</literal></entry>
       <entry><literal>00100</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Следующие функции языка <acronym>SQL</acronym> работают как с символьными, так и с битовыми строками: <literal><function>length</function></literal>, <literal><function>bit_length</function></literal>, <literal><function>octet_length</function></literal>, <literal><function>position</function></literal>, <literal><function>substring</function></literal>, <literal><function>overlay</function></literal>.</para>

   <para>С битовыми и двоичными строками работают функции <literal><function>get_bit</function></literal> и <literal><function>set_bit</function></literal>. При работе с битовыми строками эти функции нумеруют биты слева направо и самый левый бит считается нулевым.</para>

   <para>Кроме того, целые значения можно преобразовать в тип <type>bit</type> и обратно. Например: <programlisting>44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation></programlisting> Заметьте, что приведение к типу <quote>bit</quote> без длины будет означать приведение к <literal>bit(1)</literal>, и в результате будет получен только один менее значащий бит числа.</para>

    <note>
     <para>Приведение целого числа к типу <type>bit(n)</type> копирует правые <literal>n</literal> бит числа. Если же целое преобразуется в битовую строку большей длины, чем требуется для этого числа, она дополняется слева битами знака числа.</para>
    </note>

  </sect1>


 <sect1 id="functions-matching">
  <title>Поиск по шаблону</title>

  <indexterm zone="functions-matching"><primary>поиск по шаблону</primary></indexterm>

   <para><productname>&productname;</productname> предлагает три разных способа поиска текста по шаблону: традиционный оператор <function>LIKE</function> языка <acronym>SQL</acronym>, более современный <function>SIMILAR TO</function> (добавленный в SQL:1999) и регулярные выражения в стиле <acronym>POSIX</acronym>. Помимо простых операторов, отвечающих на вопрос <quote>соответствует ли строка этому шаблону?</quote>, в <productname>&productname;</productname> есть функции для извлечения или замены соответствующих подстрок и для разделения строки по заданному шаблону.</para>

   <tip>
    <para>Если этих встроенных возможностей оказывается недостаточно, вы можете написать собственные функции на языке Perl или Tcl.</para>
   </tip>

   <caution>
    <para>Хотя чаще всего поиск по регулярному выражению бывает очень быстрым, регулярные выражения бывают и настолько сложными, что их обработка может занять приличное время и объём памяти. Поэтому опасайтесь шаблонов регулярных выражений, поступающих из недоверенных источников. Если у вас нет другого выхода, рекомендуется ввести тайм-аут для операторов.</para>

    <para>Поиск с шаблонами <function>SIMILAR TO</function> несёт те же риски безопасности, так как конструкция <function>SIMILAR TO</function> предоставляет во многом те же возможности, что и регулярные выражения в стиле <acronym>POSIX</acronym>.</para>

    <para>Поиск с <function>LIKE</function> гораздо проще, чем два другие варианта, поэтому его безопаснее использовать с недоверенными источниками шаблонов поиска.</para>
   </caution>

  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

   <indexterm><primary>LIKE</primary></indexterm>

<synopsis><replaceable>строка</replaceable> LIKE <replaceable>шаблон</replaceable> <optional>ESCAPE <replaceable>спецсимвол</replaceable></optional>
<replaceable>строка</replaceable> NOT LIKE <replaceable>шаблон</replaceable> <optional>ESCAPE <replaceable>спецсимвол</replaceable></optional></synopsis>

    <para>Выражение <function>LIKE</function> возвращает true, если <replaceable>строка</replaceable> соответствует заданному <replaceable>шаблону</replaceable>. (Как можно было ожидать, выражение <function>NOT LIKE</function> возвращает false, когда <function>LIKE</function> возвращает true, и наоборот. Этому выражению равносильно выражение <literal>NOT (<replaceable>строка</replaceable> LIKE <replaceable>шаблон</replaceable>)</literal>.)</para>

    <para>Если <replaceable>шаблон</replaceable> не содержит знаков процента и подчёркиваний, тогда шаблон представляет в точности строку и <function>LIKE</function> работает как оператор сравнения. Подчёркивание (<literal>_</literal>) в <replaceable>шаблоне</replaceable> подменяет (вместо него подходит) любой символ; а знак процента (<literal>%</literal>) подменяет любую (в том числе и пустую) последовательность символов.</para>

   <para>Несколько примеров: <programlisting>'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation></programlisting></para>

   <para>При проверке по шаблону <function>LIKE</function> всегда рассматривается вся строка. Поэтому, если нужно найти последовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться знаками процента.</para>

   <para>Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответствующим символом в <replaceable>шаблоне</replaceable> нужно добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная косая черта, но с помощью предложения <literal>ESCAPE</literal> можно выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте его.</para>

   <note>
    <para>Если параметр <xref linkend="guc-standard-conforming-strings"/> выключен, каждый символ обратной косой черты, записываемый в текстовой константе, нужно дублировать. Подробнее это описано в <xref remap="6" linkend="sql-syntax-strings"/>.</para>
   </note>

   <para>Также можно отказаться от спецсимвола, написав <literal>ESCAPE ''</literal>. При этом механизм спецпоследовательностей фактически отключается и использовать знаки процента и подчёркивания буквально в шаблоне нельзя.</para>

   <para>Вместо <token>LIKE</token> можно использовать ключевое слово <token>ILIKE</token>, чтобы поиск был регистр-независимым с учётом текущей языковой среды. Этот оператор не описан в стандарте <acronym>SQL</acronym>; это расширение <productname>&productname;</productname>.</para>

   <para>Кроме того, в <productname>&productname;</productname> есть оператор <literal>~~</literal>, равнозначный <function>LIKE</function>, и <literal>~~*</literal>, соответствующий <function>ILIKE</function>. Есть также два оператора <literal>!~~</literal> и <literal>!~~*</literal>, представляющие <function>NOT LIKE</function> и <function>NOT ILIKE</function>, соответственно. Все эти операторы можно отнести к особенностям <productname>&productname;</productname>.</para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
   <title>Регулярные выражения <function>SIMILAR TO</function></title>

   <indexterm><primary>регулярное выражение</primary></indexterm>

   <indexterm><primary>SIMILAR TO</primary></indexterm>
   <indexterm><primary>substring</primary></indexterm>

<synopsis><replaceable>строка</replaceable> SIMILAR TO <replaceable>шаблон</replaceable> <optional>ESCAPE <replaceable>спецсимвол</replaceable></optional>
<replaceable>строка</replaceable> NOT SIMILAR TO <replaceable>шаблон</replaceable> <optional>ESCAPE <replaceable>спецсимвол</replaceable></optional></synopsis>

   <para>Оператор <function>SIMILAR TO</function> возвращает true или false в зависимости от того, соответствует ли данная строка шаблону или нет. Он работает подобно оператору <function>LIKE</function>, только его шаблоны соответствуют определению регулярных выражений в стандарте SQL. Регулярные выражения SQL представляют собой любопытный гибрид синтаксиса <function>LIKE</function> с синтаксисом обычных регулярных выражений.</para>

   <para>Как и <function>LIKE</function>, условие <function>SIMILAR TO</function> истинно, только если шаблон соответствует всей строке; это отличается от условий с регулярными выражениями, в которых шаблон может соответствовать любой части строки. Также подобно <function>LIKE</function>, <function>SIMILAR TO</function> воспринимает символы <literal>_</literal> и <literal>%</literal> как знаки подстановки, подменяющие любой один символ или любую подстроку, соответственно (в регулярных выражениях POSIX им аналогичны символы <literal>.</literal> и <literal>.*</literal>).</para>

   <para>Помимо средств описания шаблонов, позаимствованных от <function>LIKE</function>, <function>SIMILAR TO</function> поддерживает следующие метасимволы, унаследованные от регулярных выражений POSIX: <itemizedlist>
    <listitem>
     <para><literal>|</literal> означает выбор (одного из двух вариантов).</para>
    </listitem>
    <listitem>
     <para><literal>*</literal> означает повторение предыдущего элемента 0 и более раз.</para>
    </listitem>
    <listitem>
     <para><literal>+</literal> означает повторение предыдущего элемента 1 и более раз.</para>
    </listitem>
    <listitem>
     <para><literal>?</literal> означает вхождение предыдущего элемента 0 или 1 раз.</para>
    </listitem>
    <listitem>
     <para><literal>{</literal><replaceable>m</replaceable><literal>}</literal> означает повторяет предыдущего элемента ровно <replaceable>m</replaceable> раз.</para>
    </listitem>
    <listitem>
     <para><literal>{</literal><replaceable>m</replaceable><literal>,}</literal> означает повторение предыдущего элемента <replaceable>m</replaceable> или более раз.</para>
    </listitem>
    <listitem>
     <para><literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> означает повторение предыдущего элемента не менее чем <replaceable>m</replaceable> и не более чем <replaceable>n</replaceable> раз.</para>
    </listitem>
    <listitem>
     <para>Скобки <literal>()</literal> объединяют несколько элементов в одну логическую группу.</para>
    </listitem>
    <listitem>
     <para>Квадратные скобки <literal>[...]</literal> обозначают класс символов так же, как и в регулярных выражениях POSIX.</para>
    </listitem>
   </itemizedlist> Обратите внимание, точка (<literal>.</literal>) не является метасимволом для оператора <function>SIMILAR TO</function>.</para>

   <para>Как и с <function>LIKE</function>, обратная косая черта отменяет специальное значение любого из этих метасимволов, а предложение <literal>ESCAPE</literal> позволяет выбрать другой спецсимвол.</para>

   <para>Несколько примеров: <programlisting>'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation></programlisting></para>

   <para>Функция <function>substring</function> с тремя параметрами, <function>substring(<replaceable>строка</replaceable> from <replaceable>шаблон</replaceable> for <replaceable>спецсимвол</replaceable>)</function> извлекает подстроку, соответствующую шаблону регулярного выражения SQL. Как и с <literal>SIMILAR TO</literal>, указанному шаблону должна соответствовать вся строка, в противном случае функция не найдёт ничего и вернёт NULL. Для обозначения части шаблона, которая должна быть возвращена в случае успеха, шаблон должен содержать два спецсимвола и кавычки (<literal>"</literal>) после каждого. Эта функция возвращает часть шаблона между двумя такими маркерами.</para>

   <para>Несколько примеров с маркерами <literal>#"</literal>, выделяющими возвращаемую строку: <programlisting>substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation></programlisting></para>
  </sect2>

  <sect2 id="functions-posix-regexp">
   <title>Регулярные выражения <acronym>POSIX</acronym></title>

   <indexterm zone="functions-posix-regexp"><primary>регулярное выражение</primary> <seealso>поиск по шаблону</seealso></indexterm>
   <indexterm><primary>substring</primary></indexterm>
   <indexterm><primary>regexp_replace</primary></indexterm>
   <indexterm><primary>regexp_matches</primary></indexterm>
   <indexterm><primary>regexp_split&#8203;_to_table</primary></indexterm>
   <indexterm><primary>regexp_split_to_array</primary></indexterm>

   <para>В <xref remap="6" linkend="functions-posix-table"/> перечислены все существующие операторы для проверки строк регулярными выражениями POSIX.</para>

   <table id="functions-posix-table">
    <title>Операторы регулярных выражений</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Оператор</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
      </row>
     </thead>

      <tbody>
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>Проверяет соответствие регулярному выражению с учётом регистра</entry>
        <entry><literal>'thomas' ~ '.*thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>~*</literal> </entry>
        <entry>Проверяет соответствие регулярному выражению без учёта регистра</entry>
        <entry><literal>'thomas' ~* '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~</literal> </entry>
        <entry>Проверяет несоответствие регулярному выражению с учётом регистра</entry>
        <entry><literal>'thomas' !~ '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~*</literal> </entry>
        <entry>Проверяет несоответствие регулярному выражению без учёта регистра</entry>
        <entry><literal>'thomas' !~* '.*vadim.*'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>Регулярные выражения <acronym>POSIX</acronym> предоставляют более мощные средства поиска по шаблонам, чем операторы <function>LIKE</function> и <function>SIMILAR TO</function>. Во многих командах Unix, таких как <command>egrep</command>, <command>sed</command> и <command>awk</command> используется язык шаблонов, похожий на описанный здесь.</para>

    <para>Регулярное выражение &mdash; это последовательность символов, представляющая собой краткое определение набора строк (<firstterm>регулярное множество</firstterm>). Строка считается соответствующей регулярному выражению, если она является членом регулярного множества, описываемого регулярным выражением. Как и для <function>LIKE</function>, символы шаблона непосредственно соответствуют символам строки, за исключением специальных символов языка регулярных выражений. При этом спецсимволы регулярных выражений отличается от спецсимволов <function>LIKE</function>. В отличие от шаблонов <function>LIKE</function>, регулярное выражение может совпадать с любой частью строки, если только оно не привязано явно к началу и/или концу строки.</para>

    <para>Несколько примеров: <programlisting>'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation></programlisting></para>

    <para>Более подробно язык шаблонов в стиле <acronym>POSIX</acronym> описан ниже.</para>

    <para>Функция <function>substring</function> с двумя параметрами, <function>substring(<replaceable>строка</replaceable> from <replaceable>шаблон</replaceable>)</function>, извлекает подстроку, соответствующую шаблону регулярного выражения POSIX. Она возвращает фрагмент текста, подходящий шаблону, если таковой находится в строке, либо NULL в противном случае. Но если шаблон содержит скобки, она возвращает первое подвыражение, заключённое в скобки (то, которое начинается с самой первой открывающей скобки). Если вы хотите использовать скобки, но не в таком особом режиме, можно просто заключить в них всё выражение. Если же вам нужно включить скобки в шаблон до подвыражения, которое вы хотите извлечь, это можно сделать, используя группы без захвата, которые будут описаны ниже.</para>

   <para>Несколько примеров: <programlisting>substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation></programlisting></para>

    <para>Функция <function>regexp_replace</function> подставляет другой текст вместо подстрок, соответствующих шаблонам регулярных выражений POSIX. Она имеет синтаксис <function>regexp_replace</function>(<replaceable>исходная_строка</replaceable>, <replaceable>шаблон</replaceable>, <replaceable>замена</replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если <replaceable>исходная_строка</replaceable> не содержит фрагмента, подходящего под <replaceable>шаблон</replaceable>, она возвращается неизменной. Если же соответствие находится, возвращается <replaceable>исходная_строка</replaceable>, в которой вместо соответствующего фрагмента подставляется <replaceable>замена</replaceable>. Строка <replaceable>замена</replaceable> может содержать <literal>\</literal><replaceable>n</replaceable>, где <replaceable>n</replaceable> &mdash; число от 1 до 9, указывающее на исходный фрагмент, соответствующий <replaceable>n</replaceable>-ому подвыражению в скобках, и может содержать обозначение <literal>\&amp;</literal>, указывающее, что будет вставлен фрагмент, соответствующий всему шаблону. Если же в текст замены нужно включить обратную косую черту буквально, следует написать <literal>\\</literal>. В необязательном параметре <replaceable>флаги</replaceable> передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Флаг <literal>i</literal> включает поиск без учёта регистра, а флаг <literal>g</literal> указывает, что заменяться должны все подходящие подстроки, а не только первая из них. Допустимые флаги (кроме <literal>g</literal>) описаны в <xref remap="6" linkend="posix-embedded-options-table"/>.</para>

   <para>Несколько примеров: <programlisting>regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', E'X\\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation></programlisting></para>

    <para>Функция <function>regexp_matches</function> возвращает текстовый массив из всех подходящих подстрок, полученных в результате применения регулярного выражения POSIX. Она имеет синтаксис <function>regexp_matches</function>(<replaceable>строка</replaceable>, <replaceable>шаблон</replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Эта функция может вовсе не вернуть строк или вернуть одну или несколько строк (см. описание флага <literal>g</literal> ниже). Если <replaceable>шаблон</replaceable> не находится в строке, функция не возвращает строк. Если шаблон не содержит подвыражений в скобках, тогда для каждой строки возвращается массив с одним элементом, содержащим подстроку, соответствующую всему шаблону. Если же шаблон содержит подвыражения в скобках, функция возвращает массив элементов, в котором <replaceable>n</replaceable>-эй элемент соответствует <replaceable>n</replaceable>-ому подвыражению в скобках (не считая скобки <quote>без захвата</quote>; подробнее об этом ниже). В необязательном параметре <replaceable>флаги</replaceable> передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Флаг <literal>g</literal> указывает, что функция должна находить в строке не только первое, а все соответствия шаблону, и возвращать строку для каждого соответствия. Допустимые флаги (кроме <literal>g</literal>) описаны в <xref remap="6" linkend="posix-embedded-options-table"/>.</para>

   <para>Несколько примеров: <programlisting>SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');
 regexp_matches 
----------------
 {bar,beque}
(1 row)

SELECT regexp_matches(
 'foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches 
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)

SELECT regexp_matches('foobarbequebaz', 'barbeque');
 regexp_matches 
----------------
 {barbeque}
(1 row)</programlisting></para>

   <para>Добиться, чтобы функция <function>regexp_matches()</function> всегда возвращала одну строку, можно с помощью вложенного подзапроса; это особенно полезно в списке выборки <literal>SELECT</literal>, когда нужно получить все строки, в том числе и не соответствующие шаблону: <programlisting>SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;</programlisting></para>

    <para>Функция <function>regexp_split_to_table</function> разделяет строку, используя в качестве разделителя шаблон регулярного выражения POSIX. Она имеет синтаксис <function>regexp_split_to_table</function>(<replaceable>строка</replaceable>, <replaceable>шаблон</replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если <replaceable>шаблон</replaceable> не находится в переданной строке, возвращается вся <replaceable>строка</replaceable> целиком. Если находится минимум одно вхождение, для каждого такого вхождения возвращается текст от конца предыдущего вхождения (или начала строки) до начала вхождения. После последнего найденного вхождения возвращается фрагмент от его конца до конца строки. В необязательном параметре <replaceable>флаги</replaceable> передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Флаги, которые поддерживает <function>regexp_split_to_table</function>, описаны в <xref remap="6" linkend="posix-embedded-options-table"/>.</para>

    <para>Функция <function>regexp_split_to_array</function> ведёт себя подобно <function>regexp_split_to_table</function>, за исключением того, что <function>regexp_split_to_array</function> возвращает результат в массиве элементов типа <type>text</type>. Она имеет синтаксис <function>regexp_split_to_array</function>(<replaceable>строка</replaceable>, <replaceable>шаблон</replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Параметры у этой функции те же, что и у <function>regexp_split_to_table</function>.</para>

   <para>Несколько примеров: <programlisting>SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)</programlisting></para>

   <para>Как показывает последний пример, функции разделения по регулярным выражениям игнорируют вхождения нулевой длины, идущие в начале и в конце строки, а также непосредственно за предыдущим вхождением. Это поведение противоречит строгому определению поиска по регулярным выражениям, который реализует <function>regexp_matches</function>, но обычно более удобно на практике. Подобное поведение наблюдается и в других программных средах, например в Perl.</para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
    <title>Подробное описание регулярных выражений</title>

   <para>Регулярные выражения в <productname>&productname;</productname> реализованы с использованием программного пакета, который разработал Генри Спенсер (Henry Spencer). Практически всё следующее описание регулярных выражений дословно скопировано из его руководства.</para>

   <para>Регулярное выражение (Regular expression, <acronym>RE</acronym>), согласно определению в <acronym>POSIX</acronym> 1003.2, может иметь две формы: <firstterm>расширенное</firstterm> <acronym>RE</acronym> или <acronym>ERE</acronym> (грубо говоря, это выражения которые понимает <command>egrep</command>) и <firstterm>простое</firstterm> <acronym>RE</acronym> или <acronym>BRE</acronym> (грубо говоря, это выражения для <command>ed</command>). <productname>&productname;</productname> поддерживает обе формы, а кроме того реализует некоторые расширения, не предусмотренные стандартом POSIX, но широко используемые вследствие их доступности в некоторых языках программирования, например в Perl и Tcl. Регулярные выражения, использующие эти несовместимые с POSIX расширения, здесь называются <firstterm>усовершенствованными</firstterm> <acronym>RE</acronym> или <acronym>ARE</acronym>. ARE практически представляют собой надмножество ERE, тогда как BRE отличаются некоторой несовместимостью в записи (помимо того, что они гораздо более ограничены). Сначала мы опишем формы ARE и ERE, отметив особенности, присущие только ARE, а затем расскажем, чем от них отличаются BRE.</para>

   <note>
    <para><productname>&productname;</productname> изначально всегда предполагает, что регулярное выражение следует правилам ARE. Однако можно переключиться на более ограниченные правила ERE или BRE, добавив в шаблон RE <firstterm>встроенный параметр</firstterm>, как описано в <xref remap="6" linkend="posix-metasyntax"/>. Это может быть полезно для совместимости с приложениями, ожидающими от СУБД строгого следования правилам <acronym>POSIX</acronym> 1003.2.</para>
   </note>

   <para>Регулярное выражение определяется как одна или более <firstterm>ветвей</firstterm>, разделённых символами <literal>|</literal>. Оно считается соответствующим всему, что соответствует одной из этих ветвей.</para>

   <para>Ветвь &mdash; это ноль или несколько <firstterm>количественных атомов</firstterm> или <firstterm>ограничений</firstterm>, соединённых вместе. Соответствие ветви в целом образуется из соответствия первой части, за которым следует соответствие второй части и т. д.; пустой ветви соответствует пустая строка.</para>

   <para>Количественный атом &mdash; это <firstterm>атом</firstterm>, за которым может следовать <firstterm>определитель количества</firstterm>. Без этого определителя ему соответствует одно вхождение атома. С определителем количества ему может соответствовать некоторое число вхождений этого атома. Все возможные <firstterm>атомы</firstterm> перечислены в <xref remap="6" linkend="posix-atoms-table"/>. Варианты определителей количества и их значения перечислены в <xref remap="6" linkend="posix-quantifiers-table"/>.</para>

   <para><firstterm>Ограничению</firstterm> соответствует пустая строка, но это соответствие возможно только при выполнении определённых условий. Ограничения могут использоваться там же, где и атомы, за исключением того, что их нельзя дополнять определителями количества. Простые ограничения показаны в <xref remap="6" linkend="posix-constraints-table"/>; некоторые дополнительные ограничения описаны ниже.</para>


   <table id="posix-atoms-table">
    <title>Атомы регулярных выражений</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Атом</entry>
       <entry>Описание</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>(где <replaceable>re</replaceable> &mdash; любое регулярное выражение) описывает соответствие <replaceable>re</replaceable>, при этом данное соответствие захватывается для последующей обработки</entry>
       </row>

       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>подобно предыдущему, но соответствие не захватывается (т. е. это набор скобок <quote>без захвата</quote>) (применимо только к ARE)</entry>
       </row>

       <row>
       <entry> <literal>.</literal> </entry>
       <entry>соответствует любому символу</entry>
       </row>

       <row>
       <entry> <literal>[</literal><replaceable>символы</replaceable><literal>]</literal> </entry>
       <entry><firstterm>выражение в квадратных скобках</firstterm>, соответствует любому из <replaceable>символов</replaceable> (подробнее это описано в <xref remap="6" linkend="posix-bracket-expressions"/>)</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry>(где <replaceable>k</replaceable> &mdash; не алфавитно-цифровой символ) соответствует обычному символу буквально, т. е. <literal>\\</literal> соответствует обратной косой черте</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry>где <replaceable>c</replaceable> &mdash; алфавитно-цифровой символ (за которым могут следовать другие символы), это <firstterm>спецсимвол</firstterm>, см. <xref remap="4" linkend="posix-escape-sequences"/> (применим только к ARE; в ERE и BRE этому атому соответствует <replaceable>c</replaceable>)</entry>
       </row>

       <row>
       <entry> <literal>{</literal> </entry>
       <entry>когда за этим символом следует любой символ, кроме цифры, этот атом соответствует левой фигурной скобке (<literal>{</literal>), если же за ним следует цифра, это обозначает начало <replaceable>границы</replaceable> (см. ниже)</entry>
       </row>

       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry>(где <replaceable>x</replaceable> &mdash; один символ, не имеющий специального значения) соответствует этому символу</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Выражение RE не может заканчиваться обратной косой чертой (<literal>\</literal>).</para>

   <note>
    <para>Если параметр <xref linkend="guc-standard-conforming-strings"/> выключен, каждый символ обратной косой черты, записываемый в текстовой константе, нужно дублировать. Подробнее это описано в <xref remap="6" linkend="sql-syntax-strings"/>.</para>
   </note>

   <table id="posix-quantifiers-table">
    <title>Определители количества в регулярных выражениях</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Определитель</entry>
       <entry>Соответствует</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</literal> </entry>
       <entry>0 или более вхождений атома</entry>
       </row>

       <row>
       <entry> <literal>+</literal> </entry>
       <entry>1 или более вхождений атома</entry>
       </row>

       <row>
       <entry> <literal>?</literal> </entry>
       <entry>0 или 1 вхождение атома</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry>ровно <replaceable>m</replaceable> вхождений атома</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry><replaceable>m</replaceable> или более вхождений атома</entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry>от <replaceable>m</replaceable> до <replaceable>n</replaceable> (включая границы) вхождений атома; <replaceable>m</replaceable> не может быть больше <replaceable>n</replaceable></entry>
       </row>

       <row>
       <entry> <literal>*?</literal> </entry>
       <entry>не жадная версия <literal>*</literal></entry>
       </row>

       <row>
       <entry> <literal>+?</literal> </entry>
       <entry>не жадная версия <literal>+</literal></entry>
       </row>

       <row>
       <entry> <literal>??</literal> </entry>
       <entry>не жадная версия <literal>?</literal></entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry>не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>}</literal></entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry>не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,}</literal></entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry>не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>В формах с <literal>{</literal><replaceable>...</replaceable><literal>}</literal> числа <replaceable>m</replaceable> и <replaceable>n</replaceable> определяют так называемые <firstterm>границы</firstterm> количества. Эти числа должны быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 включительно.</para>

    <para><firstterm>Не жадные</firstterm> определители (допустимые только в ARE) описывают те же возможные соответствия, что и аналогичные им обычные (&laquo;<firstterm>жадные</firstterm>&raquo;), но предпочитают выбирать наименьшее, а не наибольшее количество вхождений. Подробнее это описано в <xref remap="6" linkend="posix-matching-rules"/>.</para>

   <note>
    <para>Определители количества не могут следовать один за другим, например запись <literal>**</literal> будет ошибочной. Кроме того, определители не могут стоять в начале выражения или подвыражения и идти сразу после <literal>^</literal> или <literal>|</literal>.</para>
   </note>

   <table id="posix-constraints-table">
    <title>Ограничения в регулярных выражениях</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Ограничение</entry>
       <entry>Описание</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</literal> </entry>
       <entry>соответствует началу строки</entry>
       </row>

       <row>
       <entry> <literal>$</literal> </entry>
       <entry>соответствует концу строки</entry>
       </row>

       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry><firstterm>позитивный просмотр вперёд</firstterm> находит соответствие там, где начинается подстрока, соответствующая <replaceable>re</replaceable> (только для ARE)</entry>
       </row>

       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry><firstterm>негативный просмотр вперёд</firstterm> находит соответствие там, где не начинается подстрока, соответствующая <replaceable>re</replaceable> (только для ARE)</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry><firstterm>позитивный просмотр назад</firstterm> находит соответствие там, где заканчивается подстрока, соответствующая <replaceable>re</replaceable> (только для ARE)</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry><firstterm>негативный просмотр назад</firstterm> находит соответствие там, где не заканчивается подстрока, соответствующая <replaceable>re</replaceable> (только для ARE)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Ограничения просмотра вперёд и назад не могут содержать <firstterm>ссылки назад</firstterm> (см. <xref remap="4" linkend="posix-escape-sequences"/>), и все скобки в них считаются &laquo;скобками без захвата&raquo;.</para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
    <title>Выражения в квадратных скобках</title>

   <para><firstterm>Выражение в квадратных скобках</firstterm> содержит список символов, заключённый в <literal>[]</literal>. Обычно ему соответствует любой символ из списка (об исключении написано ниже). Если список начинается с <literal>^</literal>, ему соответствует любой символ, который <emphasis>не</emphasis> перечисляется далее в этом списке. Если два символа в списке разделяются знаком <literal>-</literal>, это воспринимается как краткая запись полного интервала символов между двумя заданными (и включая их) в порядке сортировки; например выражению <literal>[0-9]</literal> в <acronym>ASCII</acronym> соответствует любая десятичная цифра. Два интервала не могут разделять одну границу, т. е. выражение <literal>a-c-e</literal> недопустимо. Интервалы зависят от порядка сортировки, который может меняться, поэтому в переносимых программах их лучше не использовать.</para>

   <para>Чтобы включить в список <literal>]</literal>, этот символ нужно написать первым (сразу за <literal>^</literal>, если он присутствует). Чтобы включить в список символ <literal>-</literal>, его нужно написать первым или последним, либо как вторую границу интервала. Указать <literal>-</literal> в качестве первой границы интервал можно, заключив его между <literal>[.</literal> и <literal>.]</literal>, чтобы он стал элементом сортировки (см. ниже). За исключением этих символов, некоторых комбинаций с <literal>[</literal> (см. следующие абзацы) и спецсимволов (в ARE), все остальные специальные символы в квадратных скобках теряют своё особое значение. В частности, символ <literal>\</literal> по правилам ERE или BRE воспринимается как обычный, хотя в ARE он экранирует символ, следующий за ним.</para>

   <para>Выражения в квадратных скобках могут содержать элемент сортировки (символ или последовательность символов или имя такой последовательности), определение которого заключается между <literal>[.</literal> и <literal>.]</literal>. Определяющая его последовательность воспринимается в выражении в скобках как один элемент. Это позволяет включать в такие выражения элементы, соответствующие последовательности нескольких символов. Например, с элементом сортировки <literal>ch</literal> в квадратных скобках регулярному выражению <literal>[[.ch.]]*c</literal> будут соответствовать первые пять символов строки <literal>chchcc</literal>.</para>

   <note>
    <para>В настоящее время <productname>&productname;</productname> не поддерживает элементы сортировки, состоящие из нескольких символов. Эта информация относится к возможному в будущем поведению.</para>
   </note>

   <para>В квадратных скобках могут содержаться элементы сортировки, заключённые между <literal>[=</literal> и <literal>=]</literal>, обозначающие <firstterm>классы эквивалентности</firstterm>, т. е. последовательности символов из всех элементов сортировки, эквивалентных указанному, включая его самого. (Если для этого символа нет эквивалентных, он обрабатывается, как заключённый между <literal>[.</literal> и <literal>.]</literal>.) Например, если <literal>е</literal> и <literal>ё</literal> &mdash; члены одного класса эквивалентности, выражения <literal>[[=е=]]</literal>, <literal>[[=ё=]]</literal> и <literal>[её]</literal> будут равнозначными. Класс эквивалентности нельзя указать в качестве границы интервала.</para>

   <para>В квадратных скобках может также содержаться имя класса символов, заключённое между <literal>[:</literal> и <literal>:]</literal>, и заменяющее список всех символов этого класса. Стандартные имена классов: <literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</literal>, <literal>cntrl</literal>, <literal>digit</literal>, <literal>graph</literal>, <literal>lower</literal>, <literal>print</literal>, <literal>punct</literal>, <literal>space</literal>, <literal>upper</literal> и <literal>xdigit</literal>. Весь этот набор классов определён в <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry> и он может меняться в зависимости от локали (языковой среды). Класс символов также нельзя использовать в качестве границы интервала.</para>

   <para>Есть два особых вида выражений в квадратных скобках: выражения <literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, представляющие собой ограничения, соответствующие пустым строкам в начале и конце слова. Слово в данном контексте определяется как последовательность словосоставляющих символов, перед или после которой нет словосоставляющих символов. Словосоставляющий символ &mdash; это символ класса <literal>alnum</literal> (определённого в <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>) или подчёркивание. Это расширение совместимо со стандартом <acronym>POSIX</acronym> 1003.2, но не описано в нём, и поэтому его следует использовать с осторожностью там, где важна совместимость с другими системами. Обычно лучше использовать ограничивающие спецсимволы, описанные ниже; они также не совсем стандартны, но набрать их легче.</para>
   </sect3>

   <sect3 id="posix-escape-sequences">
    <title>Спецсимволы регулярных выражений</title>

   <para><firstterm>Спецсимволы</firstterm> &mdash; это специальные команды, состоящие из <literal>\</literal> и последующего алфавитно-цифрового символа. Можно выделить следующие категории спецсимволов: обозначения символов, коды классов, ограничения и ссылки назад. Символ <literal>\</literal>, за которым идёт алфавитно-цифровой символ, не образующий допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет: вне квадратных скобок пара из <literal>\</literal> и последующего алфавитно-цифрового символа, воспринимается просто как данный символ, а в квадратных скобках и сам символ <literal>\</literal> воспринимается просто как обратная косая черта. (Последнее на самом деле нарушает совместимость между ERE и ARE.)</para>

   <para><firstterm>Спецобозначения символов</firstterm> введены для того, чтобы облегчить ввод в RE непечатаемых и других неудобных символов. Они приведены в <xref remap="6" linkend="posix-character-entry-escapes-table"/>.</para>

   <para><firstterm>Коды классов</firstterm> представляют собой краткий способ записи имён некоторых распространённых классов символов. Они перечислены в <xref remap="6" linkend="posix-class-shorthand-escapes-table"/>.</para>

   <para><firstterm>Спецсимволы ограничений</firstterm> обозначают ограничения, которым при совпадении определённых условий соответствует пустая строка. Они перечислены в <xref remap="6" linkend="posix-constraint-escapes-table"/>.</para>

   <para><firstterm>Ссылка назад</firstterm> (<literal>\</literal><replaceable>n</replaceable>) соответствует той же строке, какой соответствовало предыдущее подвыражение в скобках под номером <replaceable>n</replaceable> (см. <xref remap="4" linkend="posix-constraint-backref-table"/>). Например, <literal>([bc])\1</literal> соответствует <literal>bb</literal> или <literal>cc</literal>, но не <literal>bc</literal> или <literal>cb</literal>. Это подвыражение должно полностью предшествовать ссылке назад в RE. Нумеруются подвыражения в порядке следования их открывающих скобок. При этом скобки без захвата исключаются из рассмотрения.</para>

   <table id="posix-character-entry-escapes-table">
    <title>Спецобозначения символов в регулярных выражениях</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Спецсимвол</entry>
       <entry>Описание</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</literal> </entry>
       <entry>символ звонка, как в C</entry>
       </row>

       <row>
       <entry> <literal>\b</literal> </entry>
       <entry>символ &laquo;забой&raquo;, как в C</entry>
       </row>

       <row>
       <entry> <literal>\B</literal> </entry>
       <entry>синоним для обратной косой черты (<literal>\</literal>), сокращающий потребность в дублировании этого символа</entry>
       </row>

       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry>(где <replaceable>X</replaceable> &mdash; любой символ) символ, младшие 5 бит которого те же, что и у <replaceable>X</replaceable>, а остальные равны 0</entry>
       </row>

       <row>
       <entry> <literal>\e</literal> </entry>
       <entry>символ, определённый в последовательности сортировки с именем <literal>ESC</literal>, либо, если таковой не определён, символ с восьмеричным значением <literal>033</literal></entry>
       </row>

       <row>
       <entry> <literal>\f</literal> </entry>
       <entry>подача формы, как в C</entry>
       </row>

       <row>
       <entry> <literal>\n</literal> </entry>
       <entry>новая строка, как в C</entry>
       </row>

       <row>
       <entry> <literal>\r</literal> </entry>
       <entry>возврат каретки, как в C</entry>
       </row>

       <row>
       <entry> <literal>\t</literal> </entry>
       <entry>горизонтальная табуляция, как в C</entry>
       </row>

       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry>(где <replaceable>wxyz</replaceable> ровно четыре шестнадцатеричные цифры) символ с шестнадцатеричным кодом <literal>0x</literal><replaceable>wxyz</replaceable></entry>
       </row>

       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry>(где <replaceable>stuvwxyz</replaceable> ровно восемь шестнадцатеричных цифр) символ с шестнадцатеричным кодом <literal>0x</literal><replaceable>stuvwxyz</replaceable></entry>
       </row>

       <row>
       <entry> <literal>\v</literal> </entry>
       <entry>вертикальная табуляция, как в C</entry>
       </row>

       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry>(где <replaceable>hhh</replaceable> &mdash; несколько шестнадцатеричных цифр) символ с шестнадцатеричным кодом <literal>0x</literal><replaceable>hhh</replaceable> (символ всегда один вне зависимости от числа шестнадцатеричных цифр)</entry>
       </row>

       <row>
       <entry> <literal>\0</literal> </entry>
       <entry>символ с кодом <literal>0</literal> (нулевой байт)</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry>(где <replaceable>xy</replaceable> &mdash; ровно две восьмеричных цифры, не <firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</literal><replaceable>xy</replaceable></entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry>(где <replaceable>xyz</replaceable> &mdash; ровно три восьмеричных цифры, не <firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</literal><replaceable>xyz</replaceable></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Шестнадцатеричные цифры записываются символами <literal>0</literal>-<literal>9</literal> и <literal>a</literal>-<literal>f</literal> или <literal>A</literal>-<literal>F</literal>. Восьмеричные цифры &mdash; цифры от <literal>0</literal> до <literal>7</literal>.</para>

   <para>Спецпоследовательности с числовыми кодами, задающими значения вне диапазона ASCII (0-127), воспринимаются по-разному в зависимости от кодировки базы данных. Когда база данных имеет кодировку UTF-8, спецкод равнозначен позиции символа в Unicode, например, <literal>\u1234</literal> обозначает символ <literal>U+1234</literal>. Для других многобайтных кодировок спецпоследовательности обычно просто задают серию байт, определяющих символ. Если в кодировке базы данных отсутствует символ, заданный спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей соответствовать.</para>

   <para>Символы, переданные спецобозначением, всегда воспринимаются как обычные символы. Например, <literal>\135</literal> кодирует <literal>]</literal> в ASCII, но спецпоследовательность <literal>\135</literal> не будет закрывать выражение в квадратных скобках.</para>

   <table id="posix-class-shorthand-escapes-table">
    <title>Спецкоды классов в регулярных выражениях</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Спецсимвол</entry>
       <entry>Описание</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\w</literal> </entry>
       <entry><literal>[[:alnum:]_]</literal> (подчёркивание также включается)</entry>
       </row>

       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\W</literal> </entry>
       <entry><literal>[^[:alnum:]_]</literal> (подчёркивание также включается)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>В выражениях в квадратных скобках спецсимволы <literal>\d</literal>, <literal>\s</literal> и <literal>\w</literal> теряют свои внешние квадратные скобки, а <literal>\D</literal>, <literal>\S</literal> и <literal>\W</literal> &mdash; недопустимы. (Так что, например запись <literal>[a-c\d]</literal> равнозначна <literal>[a-c[:digit:]]</literal>. А запись <literal>[a-c\D]</literal>, которая была бы равнозначна <literal>[a-c^[:digit:]]</literal>, &mdash; недопустима.)</para>

   <table id="posix-constraint-escapes-table">
    <title>Спецсимволы ограничений в регулярных выражений</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Спецсимвол</entry>
       <entry>Описание</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</literal> </entry>
       <entry>соответствует только началу строки (чем это отличается от <literal>^</literal>, описано в <xref remap="6" linkend="posix-matching-rules"/>)</entry>
       </row>

       <row>
       <entry> <literal>\m</literal> </entry>
       <entry>соответствует только началу слова</entry>
       </row>

       <row>
       <entry> <literal>\M</literal> </entry>
       <entry>соответствует только концу слова</entry>
       </row>

       <row>
       <entry> <literal>\y</literal> </entry>
       <entry>соответствует только началу или концу слова</entry>
       </row>

       <row>
       <entry> <literal>\Y</literal> </entry>
       <entry>соответствует только положению не в начале и не в конце слова</entry>
       </row>

       <row>
       <entry> <literal>\Z</literal> </entry>
       <entry>соответствует только концу строки (чем это отличается от <literal>$</literal>, описано в <xref remap="6" linkend="posix-matching-rules"/>)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Определением слова здесь служит то же, что было приведено выше в описании <literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>. В квадратных скобках спецсимволы ограничений не допускаются.</para>

   <table id="posix-constraint-backref-table">
    <title>Ссылки назад в регулярных выражениях</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Спецсимвол</entry>
       <entry>Описание</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry>(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0) &mdash; ссылка назад на подвыражение под номером <replaceable>m</replaceable></entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry>(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0, а <replaceable>nn</replaceable> &mdash; ещё несколько цифр с десятичным значением <replaceable>mnn</replaceable>, не превышающим число закрытых до этого скобок с захватом) ссылка назад на подвыражение под номером <replaceable>mnn</replaceable></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>Регулярным выражениям присуща неоднозначность между восьмеричными кодами символов и ссылками назад, которая разрешается следующим образом (это упоминалось выше). Ведущий ноль всегда считается признаком восьмеричной последовательности. Единственная цифра, отличная от 0, за которой не следует ещё одна цифра, всегда воспринимается как ссылка назад. Последовательность из нескольких цифр, которая начинается не с 0, воспринимается как ссылка назад, если она идёт за подходящим подвыражением (т. е. число оказывается в диапазоне, допустимом для ссылки назад), в противном случае она воспринимается как восьмеричное число.</para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
    <title>Метасинтаксис регулярных выражений</title>

   <para>В дополнение к основному синтаксису, описанному выше, можно использовать также несколько особых форм и разнообразные синтаксические удобства.</para>

   <para>Регулярное выражение может начинаться с одного из двух специальных префиксов режима. Если RE начинается с <literal>***:</literal>, его продолжение рассматривается как ARE. (В <productname>&productname;</productname> это обычно не имеет значения, так как регулярные выражения воспринимаются как ARE по умолчанию; но это может быть полезно, когда параметр <replaceable>флаги</replaceable> функций regex включает режим ERE или BRE.) Если RE начинается с <literal>***=</literal>, его продолжение воспринимается как обычная текстовая строка, все его символы воспринимаются буквально.</para>

   <para>ARE может начинаться со <firstterm>встроенных параметров</firstterm>: последовательности <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal> (где <replaceable>xyz</replaceable> &mdash; один или несколько алфавитно-цифровых символов), определяющих параметры остального регулярного выражения. Эти параметры переопределяют любые ранее определённые параметры, в частности они могут переопределить режим чувствительности к регистру, подразумеваемый для оператора regex, или параметр <replaceable>флаги</replaceable> функции regex. Допустимые буквы параметров показаны в <xref remap="6" linkend="posix-embedded-options-table"/>. Заметьте, что те же буквы используются в параметре <replaceable>флаги</replaceable> функций regex.</para>

   <table id="posix-embedded-options-table">
    <title>Буквы встроенных параметров ARE</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Параметр</entry>
       <entry>Описание</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</literal> </entry>
       <entry>продолжение регулярного выражения &mdash; BRE</entry>
       </row>

       <row>
       <entry> <literal>c</literal> </entry>
       <entry>поиск соответствий с учётом регистра (переопределяет тип оператора)</entry>
       </row>

       <row>
       <entry> <literal>e</literal> </entry>
       <entry>продолжение RE &mdash; ERE</entry>
       </row>

       <row>
       <entry> <literal>i</literal> </entry>
       <entry>поиск соответствий без учёта регистра (см. <xref remap="4" linkend="posix-matching-rules"/>) (переопределяет тип оператора)</entry>
       </row>

       <row>
       <entry> <literal>m</literal> </entry>
       <entry>исторически сложившийся синоним <literal>n</literal></entry>
       </row>

       <row>
       <entry> <literal>n</literal> </entry>
       <entry>поиск соответствий с учётом перевода строк (см. <xref remap="4" linkend="posix-matching-rules"/>)</entry>
       </row>

       <row>
       <entry> <literal>p</literal> </entry>
       <entry>переводы строк учитываются частично (см. <xref remap="4" linkend="posix-matching-rules"/>)</entry>
       </row>

       <row>
       <entry> <literal>q</literal> </entry>
       <entry>продолжение регулярного выражения &mdash; обычная строка (<quote>в кавычках</quote>), содержимое которой воспринимается буквально</entry>
       </row>

       <row>
       <entry> <literal>s</literal> </entry>
       <entry>поиск соответствий без учёта перевода строк (по умолчанию)</entry>
       </row>

       <row>
       <entry> <literal>t</literal> </entry>
       <entry>компактный синтаксис (по умолчанию; см. ниже)</entry>
       </row>

       <row>
       <entry> <literal>w</literal> </entry>
       <entry>переводы строк учитываются частично, но в другом, <quote>странном</quote> режиме (см. <xref remap="4" linkend="posix-matching-rules"/>)</entry>
       </row>

       <row>
       <entry> <literal>x</literal> </entry>
       <entry>развёрнутый синтаксис (см. ниже)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Внедрённые параметры начинают действовать сразу после скобки <literal>)</literal>, завершающей их последовательность. Они могут находиться только в начале ARE (после указания <literal>***:</literal>, если оно присутствует).</para>

   <para>Помимо обычного (<firstterm>компактного</firstterm>) синтаксиса RE, в котором имеют значение все символы, поддерживается также <firstterm>развёрнутый</firstterm> синтаксис, включить который можно с помощью встроенного параметра <literal>x</literal>. В развёрнутом синтаксисе игнорируются пробельные символы, а также все символы от <literal>#</literal> до конца строки (или конца RE). Это позволяет разделять RE на строки и добавлять в него комментарии. Но есть три исключения: <itemizedlist>
     <listitem>
      <para>пробельный символ или <literal>#</literal>, за которым следует <literal>\</literal>, сохраняется</para>
     </listitem>
     <listitem>
      <para>пробельный символ или <literal>#</literal> внутри выражения в квадратных скобках сохраняется</para>
     </listitem>
     <listitem>
      <para>пробельные символы и комментарии не могут присутствовать в составных символах, например, в <literal>(?:</literal></para>
     </listitem>
    </itemizedlist> В данном контексте пробельными символами считаются пробел, табуляция, перевод строки и любой другой символ, относящийся к классу символов <replaceable>space</replaceable>.</para>

   <para>И наконец, в ARE последовательность <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal> (где <replaceable>ttt</replaceable> &mdash; любой текст, не содержащий <literal>)</literal>) вне квадратных скобок также считается комментарием и полностью игнорируется. При этом она так же не может находиться внутри составных символов, таких как <literal>(?:</literal>. Эти комментарии в большей степени историческое наследие, чем полезное средство; они считаются устаревшими, а вместо них рекомендуется использовать развёрнутый синтаксис.</para>

   <para><emphasis>Ни одно</emphasis> из этих расширений метасинтаксиса не будет работать, если выражение начинается с префикса <literal>***=</literal>, после которого строка воспринимается буквально, а не как RE.</para>
   </sect3>

   <sect3 id="posix-matching-rules">
    <title>Правила соответствия регулярным выражениям</title>

   <para>В случае, когда RE может соответствовать более чем одной подстроке в заданной строке, соответствующей RE считается подстрока, которая начинается в ней первой. Если к данной позиции подобных соответствующих подстрок оказывается несколько, из них выбирается либо самая длинная, либо самая короткая из возможных, в зависимости от того, какой режим выбран в RE: <firstterm>жадный</firstterm> или <firstterm>не жадный</firstterm>.</para>

   <para>Где жадный или не жадный характер RE определяется по следующим правилам: <itemizedlist>
     <listitem>
      <para>Большинство атомов и все ограничения не имеют признака жадности (так как они всё равно не могут соответствовать подстрокам разного состава).</para>
     </listitem>
     <listitem>
      <para>Скобки, окружающие RE, не влияют на его &laquo;жадность&raquo;.</para>
     </listitem>
     <listitem>
      <para>Атом с определителем фиксированного количества (<literal>{</literal><replaceable>m</replaceable><literal>}</literal> или <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>) имеет ту же характеристику жадности (или может не иметь её), как и сам атом.</para>
     </listitem>
     <listitem>
      <para>Атом с другими обычными определителями количества (включая <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>, где <replaceable>m</replaceable> равняется <replaceable>n</replaceable>) считается жадным (предпочитает соответствие максимальной длины).</para>
     </listitem>
     <listitem>
      <para>Атом с не жадным определителем количества (включая <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>, где <replaceable>m</replaceable> равно <replaceable>n</replaceable>) считается не жадным (предпочитает соответствие минимальной длины).</para>
     </listitem>
     <listitem>
      <para>Ветвь (RE без оператора <literal>|</literal> на верхнем уровне) имеет ту же характеристику жадности, что и первый количественный атом в нём, имеющий атрибут жадности.</para>
     </listitem>
     <listitem>
      <para>RE, образованное из двух или более ветвей, соединённых оператором <literal>|</literal>, всегда считается жадным.</para>
     </listitem>
    </itemizedlist></para>

   <para>Эти правила связывают характеристики жадности не только с отдельными количественными атомами, но и с ветвями и целыми RE, содержащими количественные атомы. Это означает, что при сопоставлении ветвь или целое RE может соответствовать максимально длинной или короткой подстроке <emphasis>в целом</emphasis>. Когда определена длина всего соответствия, часть его, соответствующая конкретному подвыражению, определяется с учётом характеристики жадности для этого подвыражения, при этом подвыражения, начинающиеся в RE раньше, имеют больший приоритет, чем следующие за ними.</para>

   <para>Это иллюстрирует следующий пример: <screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Результат: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Результат: </lineannotation><computeroutput>1</computeroutput>
</screen> В первом случае, RE в целом жадное, так как жадным является атом <literal>Y*</literal>. Соответствие ему начинается с буквы <literal>Y</literal> и оно включает подстроку максимальной длины с этого места, т. е. подстроку <literal>Y123</literal>. Результат выражения &mdash; её часть, соответствующая подвыражению в скобках, т. е. <literal>123</literal>. Во втором случае, RE в целом наследует не жадный характер от атома <literal>Y*?</literal>. Соответствие ему так же начинается с <literal>Y</literal>, но включает оно подстроку минимальной длины с этого места, т. е. <literal>Y1</literal>. И хотя подвыражение <literal>[0-9]{1,3}</literal> имеет жадный характер, оно не может повлиять на выбор длины соответствия в целом, поэтому ему остаётся только подстрока <literal>1</literal>.</para>

   <para>Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё соответствие будет максимально длинным или коротким в зависимости от характеристики всего RE. Характеристики, связанные с подвыражениями, влияют только на то, какую часть подстроки может <quote>поглотить</quote> одно подвыражение относительно другого.</para>

   <para>Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению или всему RE, можно использовать определители <literal>{1,1}</literal> и <literal>{1,1}?</literal>, соответственно. Это полезно, когда вам нужно, чтобы общая характеристика жадности RE отличалась от той, что вытекает из его элементов. Например, предположим, что вы пытаетесь выделить из строки, содержащей несколько цифр, эти цифры и части до и после них. Можно попытаться сделать это так: <screen>
SELECT regexp_matches('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Результат: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen> Но это не будет работать: первая группа <literal>.*</literal> — &laquo;жадная&raquo;, она <quote>съест</quote> всё, что сможет, оставляя для соответствия <literal>\d+</literal> только последнюю возможность, то есть последнюю цифру. Можно попытаться сделать запрос &laquo;нежадным&raquo;: <screen>
SELECT regexp_matches('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Результат: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen> И это не будет работать, так теперь весь RE в целом стал нежадным, и все соответствия завершаются как можно раньше. Но мы можем получить нужный результат, явно сделав жадным всё RE: <screen>
SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Результат: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen> Управление общей характеристикой &laquo;жадности&raquo; RE независимо от &laquo;жадности&raquo; его компонентов даёт большую гибкость в описании шаблонов переменной длины.</para>

   <para>При определении более длинного или более короткого соответствия длины соответствий определяются в символах, а не в элементах сортировки. Пустая строка считается длиннее, чем отсутствие соответствия. Например, выражению <literal>bb*</literal> соответствуют три символа в середине строки <literal>abbbc</literal>, выражению <literal>(week|wee)(night|knights)</literal> &mdash; все десять символов <literal>weeknights</literal>; когда выражение <literal>(.*).*</literal> сопоставляется со строкой <literal>abc</literal>, подвыражению в скобках соответствуют все три символа; а когда <literal>(a*)*</literal> сопоставляется со строкой <literal>bc</literal>, то и RE в целом, и подстроке в скобках соответствует пустая строка.</para>

   <para>Игнорирование регистра символов даёт практически тот же эффект, как если бы в алфавите исчезли различия прописных и строчных букв. Если буква, существующая и в верхнем, и в нижнем регистре, фигурирует вне квадратных скобок как обычный символ, она по сути преобразуется в выражение в квадратных скобках, содержащее оба варианта, например <literal>x</literal> становится <literal>[xX]</literal>. Если же она фигурирует в выражении в квадратных скобках, в это выражение добавляются все её варианты, например <literal>[x]</literal> становится <literal>[xX]</literal>, а <literal>[^x]</literal> &mdash; <literal>[^xX]</literal>.</para>

   <para>Когда включён режим учёта перевода строк, атом <literal>.</literal> и выражения в квадратных скобках с <literal>^</literal> никогда не будут соответствовать символам конца строки (так что соответствия никогда не будут пересекать границы строк, если в RE нет явных указаний на эти символы), а <literal>^</literal> и <literal>$</literal> будут соответствовать пустой подстроке не только в начале и конце всего текста, но и в начале и конце каждой отдельной его строки. Однако спецсимволы ARE <literal>\A</literal> и <literal>\Z</literal> по-прежнему будут соответствовать <emphasis>только</emphasis> началу и концу всего текста.</para>

   <para>В режиме, когда переводы строк учитываются частично, особый смысл перевод строк имеет для атома <literal>.</literal> и выражений в квадратных скобках, но не для <literal>^</literal> и <literal>$</literal>.</para>

   <para>В обратном частичном режиме, перевод строк имеет особый смысл для <literal>^</literal> и <literal>$</literal>, как и в режиме с учётом перевода строк, но не для <literal>.</literal> и выражений в квадратных скобках. Данный режим не очень полезен, но существует для симметрии.</para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
    <title>Пределы и совместимость</title>

   <para>В текущей реализации отсутствует какой-либо явно заданный предел длины RE. Однако, разрабатывая программы высокой степени переносимости, не следует применять RE длиннее 256 байт, так как другая POSIX-совместимая реализация может отказаться обрабатывать такие регулярные выражения.</para>

   <para>Единственная особенность ARE, действительно несовместимая с ERE стандарта POSIX проявляется в том, что в ARE знак <literal>\</literal> не теряет своё специальное значение в квадратных скобках. Все другие расширения ARE используют синтаксические возможности, которые не определены, не допустимы или не поддерживаются в ERE; синтаксис переключения режимов (<literal>***</literal>) также выходит за рамки синтаксиса POSIX как для BRE, так и для ERE.</para>

   <para>Многие расширения ARE заимствованы из языка Perl, но некоторые были изменены, оптимизированы, а несколько расширений Perl были исключены. В результате имеют место следующие несовместимости: атомы <literal>\b</literal> и <literal>\B</literal>, отсутствие специальной обработки завершающего перевода строки, добавление исключений в квадратных скобках в число случаев, когда учитывается перевод строк, особые условия для скобок и ссылок назад в ограничениях просмотра вперёд/назад и семантика <quote>наиболее длинное/короткое соответствие</quote> (вместо <quote>первое соответствие</quote>).</para>

   <para>Важно отметить две несовместимости синтаксиса ARE и регулярных выражений ERE, которые воспринимал <productname>PostgreSQL</productname> до версии 7.4: <itemizedlist>
     <listitem>
      <para>В ARE <literal>\</literal> с последующим алфавитно-цифровым символом представляет либо спецсимвол, либо ошибочную последовательность, тогда как в предыдущих версиях так можно было записывать алфавитно-цифровые символы. Это не должно быть большой проблемой, так как раньше не было причин использовать такие последовательности.</para>
     </listitem>
     <listitem>
      <para>В ARE знак <literal>\</literal> сохраняет своё специальное значение в <literal>[]</literal>, поэтому, чтобы передать <literal>\</literal> в квадратных скобках буквально, его нужно записать как <literal>\\</literal>.</para>
     </listitem>
    </itemizedlist></para>
   </sect3>

   <sect3 id="posix-basic-regexes">
    <title>Простые регулярные выражения</title>

   <para>BRE имеют ряд отличий от ERE. В BRE знаки <literal>|</literal>, <literal>+</literal> и <literal>?</literal> теряют специальное значение, а замены им нет. Границы количества окружаются символами <literal>\{</literal> и <literal>\}</literal>, тогда как <literal>{</literal> и <literal>}</literal> рассматриваются как обычные символы. Вложенные подвыражения помещаются между <literal>\(</literal> и <literal>\)</literal>, а <literal>(</literal> и <literal>)</literal> представляют обычные символы. Символ <literal>^</literal> воспринимается как обычный, если только он не находится в начале RE или подвыражения в скобках, <literal>$</literal> &mdash; тоже обычный символ, если он находится не в конце RE или в конце подвыражения в скобках, и <literal>*</literal> &mdash; обычный символ, когда он находится в начале RE или подвыражения в скобках (возможно, после начального <literal>^</literal>). И, наконец, в BRE работают ссылки назад с одной цифрой, <literal>\&lt;</literal> и <literal>\&gt;</literal> &mdash; синонимы для <literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, соответственно; никакие другие спецсимволы в BRE не поддерживаются.</para>
   </sect3>

<!-- end re_syntax.n man page -->

  </sect2>
 </sect1>


  <sect1 id="functions-formatting">
   <title>Функции форматирования данных</title>

   <indexterm><primary>форматирование</primary></indexterm>

   <para>Функции форматирования в <productname>&productname;</productname> предоставляют богатый набор инструментов для преобразования самых разных типов данных (дата/время, целое, числа с плавающей и фиксированной точкой) в форматированные строки и обратно. Все они перечислены в <xref remap="6" linkend="functions-formatting-table"/>. Все эти функции следует одному соглашению: в первом аргументе передаётся значение, которое нужно отформатировать, а во втором &mdash; шаблон, определяющий формат ввода или вывода.</para>

    <table id="functions-formatting-table">
     <title>Функции форматирования</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm><primary>to_char</primary></indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>преобразует время в текст</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>преобразует интервал в текст</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>преобразует целое в текст</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>, <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>преобразует плавающее одинарной/двойной точности в текст</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>преобразует числовое значение в текст</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>to_date</primary></indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>преобразует текст в дату</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>to_number</primary></indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
        <entry>преобразует текст в число</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>to_timestamp</primary></indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>преобразует строку во время</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>Также имеется функция <function>to_timestamp</function> с одним аргументом; см. <xref remap="4" linkend="functions-datetime-table"/>.</para>
   </note>

   <para>Шаблон вывода <function>to_char</function> может содержать ряд кодов, которые распознаются при форматировании и заменяются соответствующими данными. Любой текст, который не является кодом, копируется в результат в неизменном виде. Подобным образом, в строке шаблона ввода (для других функций) коды шаблона определяют, какие значения содержит передаваемая текстовая строка.</para>

  <para>Все коды форматирования даты и времени перечислены в <xref remap="6" linkend="functions-formatting-datetime-table"/>.</para>

    <table id="functions-formatting-datetime-table">
     <title>Коды форматирования даты/времени</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Код</entry>
        <entry>Описание</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
        <entry>час (01-12)</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>час (01-12)</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>час (00-23)</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <entry>минута (00-59)</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
        <entry>секунда (00-59)</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
        <entry>миллисекунда (000-999)</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
        <entry>микросекунда (000000-999999)</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
        <entry>число секунд с начала суток (0-86399)</entry>
       </row>
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>, <literal>PM</literal> или <literal>pm</literal></entry>
        <entry>обозначение времени до/после полудня (без точек)</entry>
       </row>
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>, <literal>P.M.</literal> или <literal>p.m.</literal></entry>
        <entry>обозначение времени до/после полудня (с точками)</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>год (4 или более цифр) с разделителем</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>год (4 или более цифр)</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>последние 3 цифры года</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
        <entry>последние 2 цифры года</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
        <entry>последняя цифра года</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>недельный год по ISO 8601 (4 или более цифр)</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>последние 3 цифры недельного года по ISO 8601</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
        <entry>последние 2 цифры недельного года по ISO 8601</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
        <entry>последняя цифра недельного года по ISO 8601</entry>
       </row>
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>, <literal>AD</literal> или <literal>ad</literal></entry>
        <entry>обозначение эры (без точек)</entry>
       </row>
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>, <literal>A.D.</literal> или <literal>a.d.</literal></entry>
        <entry>обозначение эры (с точками)</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>полное название месяца в верхнем регистре (дополненное пробелами до 9 символов)</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
        <entry>полное название месяца с большой буквы (дополненное пробелами до 9 символов)</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
        <entry>полное название месяца в нижнем регистре (дополненное пробелами до 9 символов)</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
        <entry>сокращённое название месяца в верхнем регистре (3 буквы в английском; в других языках длина может меняться)</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>сокращённое название месяца с большой буквы (3 буквы в английском; в других языках длина может меняться)</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
        <entry>сокращённое название месяца в нижнем регистре (3 буквы в английском; в других языках длина может меняться)</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
        <entry>номер месяца (01-12)</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>полное название дня недели в верхнем регистре (дополненное пробелами до 9 символов)</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
        <entry>полное название дня недели с большой буквы (дополненное пробелами до 9 символов)</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
        <entry>полное название дня недели в нижнем регистре (дополненное пробелами до 9 символов)</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
        <entry>сокращённое название дня недели в верхнем регистре (3 буквы в английском; в других языках может меняться)</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>сокращённое название дня недели с большой буквы (3 буквы в английском; в других языках длина может меняться)</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
        <entry>сокращённое название дня недели в нижнем регистре (3 буквы в английском; в других языках длина может меняться)</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>номер дня в году (001-366)</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>номер дня в году по ISO 8601 (001-371; 1 день &mdash; понедельник первой недели по ISO)</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
        <entry>день месяца (01-31)</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <entry>номер дня недели, считая с воскресенья (<literal>1</literal>) до субботы (<literal>7</literal>)</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
        <entry>номер дня недели по ISO 8601, считая с понедельника (<literal>1</literal>) до воскресенья (<literal>7</literal>)</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
        <entry>неделя месяца (1-5) (первая неделя начинается в первое число месяца)</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
        <entry>номер недели в году (1-53) (первая неделя начинается в первый день года)</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
        <entry>номер недели в году по ISO 8601 (01-53; первый четверг года относится к неделе 1)</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
        <entry>век (2 цифры) (двадцать первый век начался 2001-01-01)</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
        <entry>День по юлианскому календарю (номер дня с 24 ноября 4714 г. до н. э.)</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
        <entry>квартал (игнорируется функциями <function>to_date</function> и <function>to_timestamp</function>)</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
        <entry>номер месяца римскими цифрами в верхнем регистре (I-XII; I=январь)</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
        <entry>номер месяца римскими цифрами в нижнем регистре (i-xii; i=январь)</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>сокращённое название часового пояса в верхнем регистре (поддерживается только в <function>to_char</function>)</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
        <entry>сокращённое название часового пояса в нижнем регистре (поддерживается только в <function>to_char</function>)</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
        <entry>смещение часового пояса от UTC (поддерживается только в <function>to_char</function>)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>К любым кодам форматирования можно добавить модификаторы, изменяющие их поведение. Например, шаблон форматирования <literal>FMMonth</literal> включает код <literal>Month</literal> с модификатором <literal>FM</literal>. Модификаторы, предназначенные для форматирования даты/времени, перечислены в <xref remap="6" linkend="functions-formatting-datetimemod-table"/>.</para>

    <table id="functions-formatting-datetimemod-table">
     <title>Модификаторы кодов для форматирования даты/времени</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Модификатор</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>Приставка <literal>FM</literal></entry>
        <entry>режим заполнения (подавляет ведущие нули и дополнение пробелами)</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
        <entry>Окончание <literal>TH</literal></entry>
        <entry>окончание порядкового числительного в верхнем регистре</entry>
        <entry><literal>DDTH</literal>, например <literal>12TH</literal></entry>
       </row>
       <row>
        <entry>Окончание <literal>th</literal></entry>
        <entry>окончание порядкового числительного в нижнем регистре</entry>
        <entry><literal>DDth</literal>, например <literal>12th</literal></entry>
       </row>
       <row>
        <entry>Приставка <literal>FX</literal></entry>
        <entry>глобальный параметр фиксированного формата (см. замечания)</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
        <entry>Приставка <literal>TM</literal></entry>
        <entry>режим перевода (выводятся локализованные названия дней и месяцев, исходя из <xref linkend="guc-lc-time"/>)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
        <entry>Окончание <literal>SP</literal></entry>
        <entry>режим числа прописью (не реализован)</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Замечания по использованию форматов даты/времени: <itemizedlist>
     <listitem>
      <para><literal>FM</literal> подавляет дополняющие пробелы и нули справа, которые в противном случае будут добавлены, чтобы результат имел фиксированную ширину. В <productname>&productname;</productname> модификатор <literal>FM</literal> действует только на следующий код, тогда как в Oracle <literal>FM</literal> её действие распространяется на все последующие коды, пока не будет отключено последующим модификатором <literal>FM</literal>.</para>
     </listitem>

     <listitem>
      <para><literal>TM</literal> не затрагивает замыкающие пробелы. Функции <function>to_timestamp</function> и <function>to_date</function> игнорируют указание <literal>TM</literal>.</para>
     </listitem>

     <listitem>
      <para><function>to_timestamp</function> и <function>to_date</function> пропускают повторяющиеся пробелы во входной строке, если только не используется параметр <literal>FX</literal>. Например, <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> будет работать, но <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> вернёт ошибку, так как <function>to_timestamp</function> в данном случае ожидает только один разделяющий пробел. Приставка <literal>FX</literal> должна быть первой в шаблоне.</para>
     </listitem>

     <listitem>
      <para><function>to_timestamp</function> и <function>to_date</function> предназначены для обработки входных форматов, для которых недостаточно простого приведения. Эти функции интерпретируют вводимые данные с послаблениями, проверяя только грубые ошибки. Хотя они выдают корректные данные, результат может отличаться от ожидаемого. В частности, входные аргументы этих функций не ограничиваются обычными диапазонами, так что <literal>to_date('20096040','YYYYMMDD')</literal> выдаёт <literal>2014-01-17</literal>, а не ошибку. С приведением такого не происходит.</para>
     </listitem>

     <listitem>
      <para>Шаблоны для функций <function>to_char</function> могут содержать обычный текст; он будет выведен в неизменном виде. Чтобы вывести текст принудительно, например, если в нём оказываются поддерживаемые коды, его можно заключить в кавычки. Например, в строке <literal>'"Hello Year "YYYY'</literal>, код <literal>YYYY</literal> будет заменён номером года, а буква <literal>Y</literal> в слове <literal>Year</literal> останется неизменной. В функциях <function>to_date</function>, <function>to_number</function> и <function>to_timestamp</function> при обработке подстроки в кавычках просто пропускаются символы входной строки по числу символов в подстроке, например для <literal>"XX"</literal> будут пропущены два символа.</para>
     </listitem>

     <listitem>
      <para>Если вы хотите получить в результате кавычки, перед ними нужно добавить обратную косую черту, например так: <literal>'\"YYYY Month\"'</literal>.</para>
     </listitem>

     <listitem>
      <para>Если формат года определяется менее, чем 4 цифрами, например, как <literal>YYY</literal>, и в переданном значении года тоже меньше 4 цифр, год пересчитывается в максимально близкий к году 2020, т. е. <literal>95</literal> воспринимается как 1995.</para>
     </listitem>

     <listitem>
      <para>С преобразованием <literal>YYYY</literal> из строки в тип <type>timestamp</type> или <type>date</type> связано ограничение, когда обрабатываемый год записывается более чем 4 цифрами. После <literal>YYYY</literal> необходимо будет добавить не цифровой символ или соответствующий код, иначе год всегда будет восприниматься как 4 цифры. Например, в <literal>to_date('200001131', 'YYYYMMDD')</literal> (с годом 20000) год будет интерпретирован как состоящий из 4 цифр; чтобы исправить ситуацию, нужно добавить не цифровой разделитель после года, как в <literal>to_date('20000-1131', 'YYYY-MMDD')</literal>, или код как в <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.</para>
     </listitem>

     <listitem>
      <para>В преобразованиях из строки в тип <type>timestamp</type> или <type>date</type>, поле <literal>CC</literal> (век) игнорируется, если шаблон включает поля <literal>YYY</literal>, <literal>YYYY</literal> или <literal>Y,YYY</literal>. Когда <literal>CC</literal> используется с <literal>YY</literal> или <literal>Y</literal>, год вычисляется как год данного столетия. Если присутствует только код столетия, без года, подразумевается первый год этого века.</para>
     </listitem>

     <listitem>
      <para>Даты по недельному календарю ISO 8601 (отличающиеся от григорианских) можно передать функциям <function>to_timestamp</function> и <function>to_date</function> одним из двух способов: <itemizedlist>
        <listitem>
         <para>Год, номер недели и дня недели: например, <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal> возвращает дату <literal>2006-10-19</literal>. Если день недели опускается, он считается равным 1 (понедельнику).</para>
        </listitem>
        <listitem>
         <para>Год и день года: например, <literal>to_date('2006-291', 'IYYY-IDDD')</literal> также возвращает <literal>2006-10-19</literal>.</para>
        </listitem>
       </itemizedlist></para>
      <para>Попытка ввести дату из смеси полей григорианского и недельного календаря ISO 8601 бессмысленна, поэтому это будет считаться ошибкой. В контексте ISO 8601 понятия <quote>номер месяца</quote> и <quote>день месяца</quote> не существуют, а в григорианском календаре нет понятия номера недели по ISO.</para>
      <caution>
       <para>Тогда как <function>to_date</function> не примет смесь полей григорианского и недельного календаря ISO, <function>to_char</function> способна на это, так как форматы вроде <literal>YYYY-MM-DD (IYYY-IDDD)</literal> могут быть полезны. Но избегайте форматов типа <literal>IYYY-MM-DD</literal>; в противном случае с датами в начале года возможны сюрпризы. (За дополнительными сведениями обратитесь к <xref remap="3" linkend="functions-datetime-extract"/>.)</para>
      </caution>
     </listitem>

     <listitem>
      <para>При преобразовании из текстовой строки в <type>timestamp</type>, миллисекунды (<literal>MS</literal>) или микросекунды (<literal>US</literal>) воспринимаются как дробная часть числа секунд. Например, <literal>to_timestamp('12:3', 'SS:MS')</literal> &mdash; это не 3 миллисекунды, а 300, так как это значение воспринимается как 12 + 0.3 сек. Это значит, что для формата <literal>SS:MS</literal> вводимые значения <literal>12:3</literal>, <literal>12:30</literal> и <literal>12:300</literal> задают одно и то же число миллисекунд. Чтобы получить три миллисекунды, время нужно записать в виде <literal>12:003</literal>, тогда это будет воспринято как 12 + 0.003 = 12.003 сек.</para>

      <para>Ещё более сложный пример: <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal> будет преобразовано в 15 часов, 12 минут и 2 секунды + 20 миллисекунд + 1230 микросекунд = 2.021230 seconds.</para>
     </listitem>

     <listitem>
      <para>Нумерация дней недели в <function>to_char(..., 'ID')</function> соответствует функции <function>extract(isodow from ...)</function>, но нумерация <function>to_char(..., 'D')</function> не соответствует нумерации, принятой в <function>extract(dow from ...)</function>.</para>
     </listitem>

     <listitem>
      <para>Функция <function>to_char(interval)</function> обрабатывает форматы <literal>HH</literal> и <literal>HH12</literal> в рамках 12 часов, то есть 0 и 36 часов будут выводиться как <literal>12</literal>, тогда как <literal>HH24</literal> выводит значение полностью и для интервалов выводимое значение может превышать 23.</para>
     </listitem>

    </itemizedlist></para>

  <para>Коды форматирования числовых значений перечислены в <xref remap="6" linkend="functions-formatting-numeric-table"/>.</para>

    <table id="functions-formatting-numeric-table">
     <title>Коды форматирования чисел</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Код</entry>
        <entry>Описание</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
        <entry>позиция цифры (может отсутствовать, если цифра незначащая)</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
        <entry>позиция цифры (присутствует всегда, даже если цифра незначащая)</entry>
       </row>
       <row>
        <entry><literal>.</literal> (точка)</entry>
        <entry>десятичная точка</entry>
       </row>
       <row>
        <entry><literal>,</literal> (запятая)</entry>
        <entry>разделитель групп (тысяч)</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
        <entry>отрицательное значение в угловых скобках</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
        <entry>знак, добавляемый к числу (с учётом локали)</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
        <entry>символ денежной единицы (с учётом локали)</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <entry>разделитель целой и дробной части числа (с учётом локали)</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
        <entry>разделитель групп (с учётом локали)</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <entry>знак минус в заданной позиции (если число &lt; 0)</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
        <entry>знак плюс в заданной позиции (если число &gt; 0)</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
        <entry>знак плюс или минус в заданной позиции</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
        <entry>число римскими цифрами (в диапазоне от 1 до 3999)</entry>
       </row>
       <row>
        <entry><literal>TH</literal> или <literal>th</literal></entry>
        <entry>окончание порядкового числительного</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
        <entry>сдвиг на заданное количество цифр (см. замечания)</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>экспоненциальная запись числа</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Замечания по использованию форматов чисел: <itemizedlist>
     <listitem>
      <para><literal>0</literal> обозначает позицию цифры, которая будет выводиться всегда, даже если это незначащий ноль слева или справа. <literal>9</literal> также обозначает позицию цифры, но если это незначащий ноль слева, он заменяется пробелом, а если справа и задан режим заполнения, он удаляется. (Для функции <function>to_number()</function> эти два символа равнозначны.)</para>
     </listitem>

     <listitem>
      <para>Символы шаблона <literal>S</literal>, <literal>L</literal>, <literal>D</literal> и <literal>G</literal> представляют знак, символ денежной единицы, десятичную точку и разделитель тысяч, как их определяет текущая локаль (см. <xref remap="4" linkend="guc-lc-monetary"/> и <xref remap="4" linkend="guc-lc-numeric"/>). Символы точка и запятая представляют те же символы, обозначающие десятичную точку и разделитель тысяч, но не зависят от локали.</para>
     </listitem>

     <listitem>
      <para>Если в шаблоне <function>to_char()</function> отсутствует явное указание положения знака, для него резервируется одна позиция рядом с числом (слева от него). Если левее нескольких <literal>9</literal> помещён <literal>S</literal>, знак также будет приписан слева к числу.</para>
     </listitem>

     <listitem>
      <para>Знак числа, полученный кодами <literal>SG</literal>, <literal>PL</literal> или <literal>MI</literal>, не присоединяется к числу; например, <literal>to_char(-12, 'MI9999')</literal> выдаёт <literal>'-&nbsp;&nbsp;12'</literal>, тогда как <literal>to_char(-12, 'S9999')</literal> &mdash; <literal>'&nbsp;&nbsp;-12'</literal>. (В Oracle <literal>MI</literal> не может идти перед <literal>9</literal>, наоборот <literal>9</literal> нужно указать перед <literal>MI</literal>.)</para>
     </listitem>

     <listitem>
      <para><literal>TH</literal> не преобразует значения меньше 0 и не поддерживает дробные числа.</para>
     </listitem>

     <listitem>
      <para><literal>PL</literal>, <literal>SG</literal> и <literal>TH</literal> &mdash; расширения <productname>&productname;</productname>.</para>
     </listitem>

     <listitem>
      <para><literal>V</literal> c <function>to_char</function> умножает вводимое значение на <literal>10^<replaceable>n</replaceable></literal>, где <replaceable>n</replaceable> — число цифр, следующих за <literal>V</literal>. <literal>V</literal> с <function>to_number</function> подобным образом делит значение. Функции <function>to_char</function> и <function>to_number</function> не поддерживают <literal>V</literal> с дробными числами (например, <literal>99.9V99</literal> не допускается).</para>
     </listitem>

     <listitem>
      <para>Код <literal>EEEE</literal> (научная запись) не может сочетаться с любыми другими вариантами форматирования или модификаторами, за исключением цифр и десятичной точки, и должен располагаться в конце строки шаблона (например, <literal>9.99EEEE</literal> &mdash; допустимый шаблон).</para>
     </listitem>
    </itemizedlist></para>

   <para>Для изменения поведения кодов к ним могут быть применены определённые модификаторы. Например, <literal>FM99.99</literal> обрабатывается как код <literal>99.99</literal> с модификатором <literal>FM</literal>. Все модификаторы для форматирования чисел перечислены в <xref remap="6" linkend="functions-formatting-numericmod-table"/>.</para>

    <table id="functions-formatting-numericmod-table">
     <title>Модификаторы шаблонов для форматирования чисел</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Модификатор</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>Приставка <literal>FM</literal></entry>
        <entry>режим заполнения (подавляет завершающие нули и дополнение пробелами)</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
       <row>
        <entry>Окончание <literal>TH</literal></entry>
        <entry>окончание порядкового числительного в верхнем регистре</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
        <entry>Окончание <literal>th</literal></entry>
        <entry>окончание порядкового числительного в нижнем регистре</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>В <xref remap="6" linkend="functions-formatting-examples-table"/> приведены некоторые примеры использования функции <function>to_char</function>.</para>

    <table id="functions-formatting-examples-table">
     <title>Примеры <function>to_char</function></title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Выражение</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
   <title>Операторы и функции даты/времени</title>

  <para>Все существующие функции для обработки даты/времени перечислены в <xref remap="6" linkend="functions-datetime-table"/>, а подробнее они описаны в следующих подразделах. Поведение основных арифметических операторов (<literal>+</literal>, <literal>*</literal> и т. д.) описано в <xref remap="6" linkend="operators-datetime-table"/>. Функции форматирования этих типов данных были перечислены в <xref remap="6" linkend="functions-formatting"/>. Общую информацию об этих типах вы получили (или можете получить) в <xref remap="6" linkend="datatype-datetime"/>.</para>

  <para>Все описанные ниже функции и операторы принимают две разновидности типов <type>time</type> или <type>timestamp</type>: с часовым поясом (<type>time with time zone</type> и <type>timestamp with time zone</type>) и без него (<type>time without time zone</type> и <type>timestamp without time zone</type>). Для краткости здесь они рассматриваются вместе. Кроме того, операторы <literal>+</literal> и <literal>*</literal> обладают переместительным свойством (например, date + integer = integer + date); здесь будет приведён только один вариант для каждой пары.</para>

    <table id="operators-datetime-table">
     <title>Операторы даты/времени</title>

     <tgroup cols="3">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
        <entry><literal>integer '3'</literal> (дня)</entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day -01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>900 * interval '1 second'</literal></entry>
        <entry><literal>interval '00:15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>21 * interval '1 day'</literal></entry>
        <entry><literal>interval '21 days'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>double precision '3.5' * interval '1 hour'</literal></entry>
        <entry><literal>interval '03:30:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40:00'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
     <title>Функции даты/времени</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <indexterm><primary>age</primary></indexterm>
         <literal><function>age(<type>timestamp</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>Вычитает аргументы и выдаёт <quote>символический</quote> результат с годами и месяцами, а не просто днями</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 9 mons 27 days (43 года 9 месяцев 27 дней)</literal></entry>
       </row>

       <row>
        <entry><literal><function>age(<type>timestamp</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
        <entry>Вычитает дату/время из <function>current_date</function> (полночь текущего дня)</entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days (43 года 8 месяцев 3 дня)</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>clock_timestamp</primary></indexterm>
         <literal><function>clock_timestamp&#8203;()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Текущая дата и время (меняется в процессе выполнения операторов); см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>current_date</primary></indexterm>
         <literal><function>current_date</function></literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>Текущая дата; см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>current_time</primary></indexterm>
         <literal><function>current_time</function></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
        <entry>Текущее время суток; см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>current_timestamp</primary></indexterm>
         <literal><function>current_timestamp</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Текущая дата и время (на момент начала транзакции); см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>date_part</primary></indexterm>
         <literal><function>date_part(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>double precision</type></entry>
        <entry>Возвращает поле даты (равнозначно <function>extract</function>); см. <xref remap="4" linkend="functions-datetime-extract"/></entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>Возвращает поле даты (равнозначно <function>extract</function>); см. <xref remap="4" linkend="functions-datetime-extract"/></entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>date_trunc</primary></indexterm>
         <literal><function>date_trunc(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>Отсекает компоненты даты до заданной точности; см. также <xref linkend="functions-datetime-trunc"/></entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
        <entry>Отсекает компоненты даты до заданной точности; см. также <xref linkend="functions-datetime-trunc"/></entry>
        <entry><literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal></entry>
        <entry><literal>2 days 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>extract</primary></indexterm>
         <literal><function>extract</function>(<parameter>field</parameter> from <type>timestamp</type>)</literal>
        </entry>
        <entry><type>double precision</type></entry>
        <entry>Возвращает поле даты; см. <xref remap="4" linkend="functions-datetime-extract"/></entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>field</parameter> from <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>Возвращает поле даты; см. <xref remap="4" linkend="functions-datetime-extract"/></entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>isfinite</primary></indexterm>
         <literal><function>isfinite(<type>date</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>Проверяет конечность даты (её отличие от +/-бесконечности)</entry>
        <entry><literal>isfinite(date '2001-02-16')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>timestamp</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>Проверяет конечность времени (его отличие от +/-бесконечности)</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>interval</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>Проверяет конечность интервала</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>justify_days</primary></indexterm>
         <literal><function>justify_days(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>Преобразует интервал так, что каждый 30-дневный период считается одним месяцем</entry>
        <entry><literal>justify_days(interval '35 days')</literal></entry>
        <entry><literal>1 mon 5 days (1 месяц 5 дней)</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>justify_hours</primary></indexterm>
         <literal><function>justify_hours(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>Преобразует интервал так, что каждый 24-часовой период считается одним днём</entry>
        <entry><literal>justify_hours(interval '27 hours')</literal></entry>
        <entry><literal>1 day 03:00:00 (1 день 03:00:00)</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>justify_interval</primary></indexterm>
         <literal><function>justify_interval(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>Преобразует интервал с применением <function>justify_days</function> и <function>justify_hours</function> и дополнительно корректирует знаки</entry>
        <entry><literal>justify_interval(interval '1 mon -1 hour')</literal></entry>
        <entry><literal>29 days 23:00:00 (29 дней 23:00:00)</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>localtime</primary></indexterm>
         <literal><function>localtime</function></literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>Текущее время суток; см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>localtimestamp</primary></indexterm>
         <literal><function>localtimestamp</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>Текущая дата и время (на момент начала транзакции); см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>make_date</primary></indexterm>
         <literal>
            <function>make_date(<parameter>year</parameter> <type>int</type>, <parameter>month</parameter> <type>int</type>, <parameter>day</parameter> <type>int</type>)</function>
         </literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>Образует дату из полей: year (год), month (месяц) и day (день)</entry>
        <entry><literal>make_date(2013, 7, 15)</literal></entry>
        <entry><literal>2013-07-15</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>make_interval</primary></indexterm>
         <literal>
          <function>make_interval(<parameter>years</parameter> <type>int</type> DEFAULT 0, <parameter>months</parameter> <type>int</type> DEFAULT 0, <parameter>weeks</parameter> <type>int</type> DEFAULT 0, <parameter>days</parameter> <type>int</type> DEFAULT 0, <parameter>hours</parameter> <type>int</type> DEFAULT 0, <parameter>mins</parameter> <type>int</type> DEFAULT 0, <parameter>secs</parameter> <type>double precision</type> DEFAULT 0.0)</function>
         </literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>Образует интервал из полей: years (годы), months (месяцы), weeks (недели), days (дни), hours (часы), minutes (минуты) и secs (секунды)</entry>
        <entry><literal>make_interval(days =&gt; 10)</literal></entry>
        <entry><literal>10 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>make_time</primary></indexterm>
         <literal>
          <function>make_time(<parameter>hour</parameter> <type>int</type>, <parameter>min</parameter> <type>int</type>, <parameter>sec</parameter> <type>double precision</type>)</function>
         </literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>Образует время из полей: hour (час), minute (минута) и sec (секунда)</entry>
        <entry><literal>make_time(8, 15, 23.5)</literal></entry>
        <entry><literal>08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>make_timestamp</primary></indexterm>
         <literal>
          <function>make_timestamp(<parameter>year</parameter> <type>int</type>, <parameter>month</parameter> <type>int</type>, <parameter>day</parameter> <type>int</type>, <parameter>hour</parameter> <type>int</type>, <parameter>min</parameter> <type>int</type>, <parameter>sec</parameter> <type>double precision</type>)</function>
         </literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>Образует дату и время из полей: year (год), month (месяц), day (день), hour (час), minute (минута) и sec (секунда)</entry>
        <entry><literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>make_timestamptz</primary></indexterm>
         <literal>
          <function>make_timestamptz(<parameter>year</parameter> <type>int</type>, <parameter>month</parameter> <type>int</type>, <parameter>day</parameter> <type>int</type>, <parameter>hour</parameter> <type>int</type>, <parameter>min</parameter> <type>int</type>, <parameter>sec</parameter> <type>double precision</type>, <optional><parameter>timezone</parameter> <type>text</type></optional>)</function>
         </literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Образует дату и время с часовым поясом из полей: year (год), month (месяц), day (день), hour (час), minute (минута) и sec (секунда). Если параметр <parameter>timezone</parameter> (часовой пояс) не указан, используется текущий часовой пояс.</entry>
        <entry><literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5+01</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm><primary>now</primary></indexterm>
         <literal><function>now()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Текущая дата и время (на момент начала транзакции); см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>statement_timestamp</primary></indexterm>
         <literal><function>statement_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Текущая дата и время (на момент начала текущего оператора); см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>timeofday</primary></indexterm>
         <literal><function>timeofday()</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>Текущая дата и время (как <function>clock_timestamp</function>, но в виде строки типа <type>text</type>); см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>

       <row>
        <entry>
         <indexterm><primary>transaction_timestamp</primary></indexterm>
         <literal><function>transaction_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Текущая дата и время (на момент начала транзакции); см. <xref remap="4" linkend="functions-datetime-current"/></entry>
        <entry/>
        <entry/>
       </row>
       <row>
        <entry>
         <indexterm><primary>to_timestamp</primary></indexterm>
         <literal><function>to_timestamp(<type>double precision</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Преобразует время эпохи Unix (число секунд с 1970-01-01 00:00:00+00) в стандартное время</entry>
        <entry><literal>to_timestamp(1284352323)</literal></entry>
        <entry><literal>2010-09-13 04:32:03+00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para><indexterm><primary>OVERLAPS</primary></indexterm> В дополнение к этим функциям поддерживается SQL-оператор <literal>OVERLAPS</literal>: <synopsis>
(<replaceable>начало1</replaceable>, <replaceable>конец1</replaceable>) OVERLAPS (<replaceable>начало2</replaceable>, <replaceable>конец2</replaceable>)
(<replaceable>начало1</replaceable>, <replaceable>длительность1</replaceable>) OVERLAPS (<replaceable>начало2</replaceable>, <replaceable>длительность2</replaceable>)
</synopsis> Его результатом будет true, когда два периода времени (определённые своими границами) пересекаются, и false в противном случае. Границы периода можно задать либо в виде пары дат, времени или дат со временем, либо как дату, время (или дату со временем) c интервалом. Когда указывается пара значений, первым может быть и начало, и конец периода: <literal>OVERLAPS</literal> автоматически считает началом периода меньшее значение. Периоды времени считаются наполовину открытыми, т. е. <replaceable>начало</replaceable><literal>&lt;=</literal><replaceable>время</replaceable><literal>&lt;</literal><replaceable>конец</replaceable>, если только <replaceable>начало</replaceable> и <replaceable>конец</replaceable> не равны &mdash; в этом случае период представляет один момент времени. Это означает, например, что два периода, имеющие только общую границу, не будут считаться пересекающимися.</para>

<screen>SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Результат:</lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Результат:</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Результат:</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Результат:</lineannotation><computeroutput>true</computeroutput></screen>

  <para>При добавлении к дате со временем типа <type>timestamp with time zone</type> значения <type>interval</type> (или при вычитании из него <type>interval</type>), поле дней в этой дате увеличивается (или уменьшается) на указанное число дней. При пересечении границы перехода на летнее время (если в часовом поясе текущего сеанса производится этот переход) это означает, что <literal>interval '1 day'</literal> и <literal>interval '24 hours'</literal> не обязательно будут равны. Например, в часовом поясе <literal>CST7CDT</literal> результатом выражения <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal> будет <literal>timestamp with time zone '2005-04-03 12:00-06'</literal>, тогда как, если добавить <literal>interval '24 hours'</literal> к тому же значению <type>timestamp with time zone</type>, в результате получится <literal>timestamp with time zone '2005-04-03 13:00-06'</literal>. Эта разница объясняется тем, что <literal>2005-04-03 02:00</literal> в часовом поясе <literal>CST7CDT</literal> произошёл переход на летнее время.</para>

  <para>Обратите внимание на возможную неоднозначность в поле <literal>months</literal> в результате функции <function>age</function>, вызванную тем, что число дней в разных месяцах неодинаково. Вычисляя оставшиеся дни месяца, <productname>&productname;</productname> рассматривает месяц меньшей из двух дат. Например, результатом <literal>age('2004-06-01', '2004-04-30')</literal> будет <literal>1 mon 1 day</literal>, так как в апреле 30 дней, а то же выражение с датой 30 мая выдаст <literal>1 mon 2 days</literal>, так как в мае 31 день.</para>

  <para>Вычитание дат и дат со временем также может быть нетривиальной операцией. Один принципиально простой способ выполнить такое вычисление &mdash; преобразовать каждое значение в количество секунд, используя <literal>EXTRACT(EPOCH FROM ...)</literal>, а затем найти разницу результатов; при этом будет получено число <emphasis>секунд</emphasis> между двумя датами. При этом будет учтено неодинаковое число дней в месяцах, изменения часовых поясов и переходы на летнее время. При вычитании дат или дат со временем с помощью оператора <quote><literal>-</literal></quote> выдаётся число дней (по 24 часа) и часов/минут/секунд между данными значениями, с учётом тех же факторов. Функция <function>age</function> возвращает число лет, месяцев, дней и часов/минут/секунд, выполняя вычитание по полям, а затем пересчитывая отрицательные значения. Различие этих подходов иллюстрируют следующие запросы. Показанные результаты были получены для часового пояса <literal>'US/Eastern'</literal>; между двумя заданными датами произошёл переход на летнее время:</para>

<screen>SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Результат:</lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Результат:</lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Результат:</lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Результат:</lineannotation><computeroutput>4 mons</computeroutput></screen>

  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm><primary>date_part</primary></indexterm>
   <indexterm><primary>extract</primary></indexterm>

<synopsis>EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)</synopsis>

   <para>Функция <function>extract</function> получает из значений даты/времени поля, такие как год или час. Здесь <replaceable>источник</replaceable> &mdash; значение типа <type>timestamp</type>, <type>time</type> или <type>interval</type>. (Выражения типа <type>date</type> приводятся к типу <type>timestamp</type>, так что допускается и этот тип.) Указанное <replaceable>поле</replaceable> представляет собой идентификатор, по которому из источника выбирается заданное поле. Функция <function>extract</function> возвращает значения типа <type>double precision</type>. Допустимые поля: <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>Век:</para>

<screen>SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Результат:</lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>21</computeroutput></screen>

       <para>Первый век начался 0001-01-01 00:00:00, хотя люди в то время и не считали так. Это определение распространяется на все страны с григорианским календарём. Века с номером 0 нет было; считается, что 1 наступил после -1. Если такое положение вещей вас не устраивает, направляйте жалобы по адресу: Ватикан, Собор Святого Петра, Папе.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>Для значений <type>timestamp</type> это день месяца (1 - 31), для значений <type>interval</type> &mdash; число дней</para>

<screen>SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Результат:</lineannotation><computeroutput>40</computeroutput></screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>Год, делённый на 10</para>

<screen>SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>200</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>День недели, считая с воскресенья (<literal>0</literal>) до субботы (<literal>6</literal>)</para>

<screen>SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>5</computeroutput></screen>
       <para>Заметьте, что в <function>extract</function> дни недели нумеруются не так, как в функции <function>to_char(..., 'D')</function>.</para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>День года (1 - 365/366)</para>

<screen>SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>47</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>Для значений <type>timestamp with time zone</type> это число секунд с 1970-01-01 00:00:00 UTC (может быть отрицательным); для значений <type>date</type> и <type>timestamp</type> это число секунд с 1970-01-01 00:00:00 по местному времени, а для <type>interval</type> &mdash; общая длительность интервала в секундах</para>

<screen>SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE
 '2001-02-16 20:38:40.12-08');
<lineannotation>Результат:</lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Результат:</lineannotation><computeroutput>442800</computeroutput></screen>

       <para>Преобразовать время эпохи назад, в значение дата/время, с помощью <function>to_timestamp</function> можно так:</para>
<screen>SELECT to_timestamp(982384720.12);
<lineannotation>Результат:</lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>Час (0 - 23)</para>

<screen>SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>20</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>День недели, считая с понедельника (<literal>1</literal>) до воскресенья (<literal>7</literal>)</para>

<screen>SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>7</computeroutput></screen>
       <para>Результат отличается от <literal>dow</literal> только для воскресенья. Такая нумерация соответствует <acronym>ISO</acronym> 8601.</para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>Год по недельному календарю <acronym>ISO</acronym> 8601, в который попадает дата (неприменимо к интервалам)</para>

<screen>SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Результат:</lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Результат:</lineannotation><computeroutput>2006</computeroutput></screen>

       <para>Год по недельному календарю <acronym>ISO</acronym> начинается с понедельника недели, в которой оказывается 4 января, так что в начале января или в конце декабря год по <acronym>ISO</acronym> может отличаться от года по григорианскому календарю. Подробнее об этом рассказывается в описании поля <literal>week</literal>.</para>
       <para>Этого поля не было в PostgreSQL до версии 8.3.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>Значение секунд с дробной частью, умноженное на 1 000 000; заметьте, что оно включает и целые секунды</para>

<screen>SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Результат:</lineannotation><computeroutput>28500000</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>Тысячелетие</para>

<screen>SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>3</computeroutput></screen>

       <para>Годы 20 века относятся ко второму тысячелетию. Третье тысячелетие началось 1 января 2001 г.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>Значение секунд с дробной частью, умноженное на 1 000; заметьте, что оно включает и целые секунды.</para>

<screen>SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Результат:</lineannotation><computeroutput>28500</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>Минуты (0 - 59)</para>

<screen>SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>38</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>Для значений <type>timestamp</type> это номер месяца в году (1 - 12), а для <type>interval</type> &mdash; остаток от деления числа месяцев на 12 (в интервале 0 - 11)</para>

<screen>SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Результат:</lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Результат:</lineannotation><computeroutput>1</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>Квартал года (1 - 4), к которому относится дата</para>

<screen>SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>1</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>Секунды, включая дробную часть (0 - 59<footnote><simpara>60, если операционная система поддерживает секунды координации</simpara></footnote>)</para>

<screen>SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Результат:</lineannotation><computeroutput>28.5</computeroutput></screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>Смещение часового пояса от UTC, представленное в секундах. Положительные значения соответствуют часовым поясам к востоку от UTC, а отрицательные &mdash; к западу. (Строго говоря, в <productname>&productname;</productname> используется не UTC, так как секунды координации не учитываются.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>Поле часов в смещении часового пояса</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>Поле минут в смещении часового пояса</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>Номер недели в году по недельному календарю <acronym>ISO</acronym> 8601. По определению, недели <acronym>ISO</acronym> 8601 начинаются с понедельника, а первая неделя года включает 4 января этого года. Другими словами, первый четверг года всегда оказывается в 1 неделе этого года.</para>
       <para>В системе нумерации недель ISO первые числа января могут относиться к 52-ой или 53-ей неделе предыдущего года, а последние числа декабря &mdash; к первой неделе следующего года. Например, <literal>2005-01-01</literal> относится к 53-ей неделе 2004 г., а <literal>2006-01-01</literal> &mdash; к 52-ей неделе 2005 г., тогда как <literal>2012-12-31</literal> включается в первую неделю 2013 г. Поэтому для получения согласованных результатов рекомендуется использовать поле <literal>isoyear</literal> в паре с <literal>week</literal>.</para>

<screen>SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>7</computeroutput></screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>Поле года. Учтите, что года <literal>0</literal> не было, и это следует иметь в виду, вычитая из годов нашей эры годы до нашей эры.</para>

<screen>SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>2001</computeroutput></screen>
      </listitem>
     </varlistentry>

    </variablelist></para>

   <note>
    <para>С аргументом +/-бесконечность <function>extract</function> возвращает +/-бесконечность для монотонно увеличивающихся полей (<literal>epoch</literal>, <literal>julian</literal>, <literal>year</literal>, <literal>isoyear</literal>, <literal>decade</literal>, <literal>century</literal> и <literal>millennium</literal>). Для других полей возвращается NULL. До версии 9.6 <productname>&productname;</productname> возвращал ноль для всех случаев с бесконечными аргументами.</para>
   </note>

   <para>Функция <function>extract</function> в основном предназначена для вычислительных целей. Функции форматирования даты/времени описаны в <xref remap="6" linkend="functions-formatting"/>.</para>

   <para>Функция <function>date_part</function> эмулирует традиционный для <productname>Ingres</productname> эквивалент стандартной <acronym>SQL</acronym>-функции <function>extract</function>: <synopsis>
date_part('<replaceable>поле</replaceable>', <replaceable>источник</replaceable>)
</synopsis> Заметьте, что здесь параметр <replaceable>поле</replaceable> должен быть строковым значением, а не именем. Функция <function>date_part</function> воспринимает те же поля, что и <function>extract</function>.</para>

<screen>SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат:</lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Результат:</lineannotation><computeroutput>4</computeroutput></screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm><primary>date_trunc</primary></indexterm>

   <para>Функция <function>date_trunc</function> работает подобно <function>trunc</function> для чисел.</para>

   <para><synopsis>
date_trunc('<replaceable>поле</replaceable>', <replaceable>значение</replaceable>)
</synopsis> Здесь <replaceable>значение</replaceable> &mdash; это выражение типа <type>timestamp</type> или <type>interval</type>. (Значения типов <type>date</type> и <type>time</type> автоматически приводятся к типам <type>timestamp</type> и <type>interval</type>, соответственно.) Параметр <replaceable>поле</replaceable> определяет, до какой точности обрезать переданное значение. Возвращаемое значение будет иметь тип <type>timestamp</type> или <type>interval</type> и все его значения, менее значимые, чем заданное поле, будут равны нулю (или единице, если это номер дня или месяца).</para>

   <para>Параметр <replaceable>поле</replaceable> может принимать следующие значения: <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist></para>

   <para>Примеры: <screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Результат: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
</screen></para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm><primary>часовой пояс</primary> <secondary>преобразование</secondary></indexterm>

   <indexterm><primary>AT TIME ZONE</primary></indexterm>

   <para>Конструкция <literal>AT TIME ZONE</literal> позволяет переводить время в разные часовые пояса. Все её разновидности показаны в <xref remap="6" linkend="functions-datetime-zoneconvert-table"/>.</para>

    <table id="functions-datetime-zoneconvert-table">
     <title>Разновидности <literal>AT TIME ZONE</literal></title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Выражение</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>часовой_пояс</replaceable></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Воспринимает заданное время <emphasis>без указания часового пояса</emphasis> как время в указанном часовом поясе</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>часовой_пояс</replaceable></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
        <entry>Переводит данное значение timestamp <emphasis>с часовым поясом</emphasis> в другой часовой пояс, но не сохраняет информацию о нём в результате</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>часовой_пояс</replaceable></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
        <entry>Переводит данное время <emphasis>с часовым поясом</emphasis> в другой часовой пояс</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>В этих выражениях желаемый <replaceable>часовой_пояс</replaceable> можно задать либо в виде текстовой строки (например, <literal>'PST'</literal>) или как интервал (например, <literal>INTERVAL '-08:00'</literal>). В первом случае название часового пояса можно указать любым из способов, описанных в <xref remap="6" linkend="datatype-timezones"/>.</para>

   <para>Примеры (в предположении, что местный часовой пояс <literal>PST8PDT</literal>): <screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';
<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';
<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
</screen> В первом примере время без часового пояса интерпретируется как время в часовом поясе MST (UTC-7), а затем оно преобразуется в PST (UTC-8) для вывода. Во втором примере время, указанное с часовым поясом EST (UTC-5), преобразуется во время для часового пояса MST (UTC-7).</para>

   <para>Функция <literal><function>timezone</function>(<replaceable>часовой_пояс</replaceable>, <replaceable>время</replaceable>)</literal> равнозначна SQL-совместимой конструкции <literal><replaceable>время</replaceable> AT TIME ZONE <replaceable>часовой_пояс</replaceable></literal>.</para>
  </sect2>

  <sect2 id="functions-datetime-current">
   <title>Текущая дата/время</title>

   <indexterm><primary>дата</primary> <secondary>текущая</secondary></indexterm>

   <indexterm><primary>время</primary> <secondary>текущее</secondary></indexterm>

   <para><productname>&productname;</productname> предоставляет набор функций, результат которых зависит от текущей даты и времени. Все следующие функции соответствуют стандарту SQL и возвращают значения, отражающие время начала текущей транзакции: <synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>точность</replaceable>)
CURRENT_TIMESTAMP(<replaceable>точность</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>точность</replaceable>)
LOCALTIMESTAMP(<replaceable>точность</replaceable>)
</synopsis></para>

    <para><function>CURRENT_TIME</function> и <function>CURRENT_TIMESTAMP</function> возвращают время с часовым поясом. В результатах <function>LOCALTIME</function> и <function>LOCALTIMESTAMP</function> нет информации о часовом поясе.</para>

    <para><function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, <function>LOCALTIME</function> и <function>LOCALTIMESTAMP</function> могут принимать необязательный параметр точности, определяющий, до какого знака после запятой следует округлять поле секунд. Если этот параметр отсутствует, результат будет иметь максимально возможную точность.</para>

   <para>Несколько примеров: <screen>
SELECT CURRENT_TIME;
<lineannotation>Результат: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen></para>

   <para>Так как эти функции возвращают время начала текущей транзакции, во время транзакции эти значения не меняются. Это считается не ошибкой, а особенностью реализации: цель такого поведения в том, чтобы в одной транзакции <quote>текущее</quote> время было одинаковым и для разных изменений в одной транзакций записывалась одна отметка времени.</para>

   <note>
    <para>В других СУБД эти значения могут изменяться чаще.</para>
   </note>

   <para>В <productname>&productname;</productname> есть также функции, возвращающие время начала текущего оператора, а также текущее время в момент вызова функции. Таким образом, в <productname>&productname;</productname> есть следующие функции, не описанные в стандарте SQL: <synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis></para>

   <para>Функция <function>transaction_timestamp()</function> равнозначна конструкции <function>CURRENT_TIMESTAMP</function>, но в её названии явно отражено, что она возвращает. Функция <function>statement_timestamp()</function> возвращает время начала текущего оператора (более точно, время получения последнего командного сообщения от клиента). Функции <function>statement_timestamp()</function> и <function>transaction_timestamp()</function> возвращают одно и то же значение в первой команде транзакции, но в последующих их показания будут расходиться. Функция <function>clock_timestamp()</function> возвращает фактическое текущее время, так что её значение меняется в рамках одной команды SQL. Функция <function>timeofday()</function> существует в <productname>&productname;</productname> по историческим причинам и, подобно <function>clock_timestamp()</function>, она возвращает фактическое текущее время, но представленное в виде форматированной строки типа <type>text</type>, а не значения <type>timestamp with time zone</type>. Функция <function>now()</function> &mdash; традиционный для <productname>&productname;</productname> эквивалент функции <function>transaction_timestamp()</function>.</para>

   <para>Все типы даты/времени также принимают специальное буквальное значение <literal>now</literal>, подразумевающее текущую дату и время (тоже на момент начала транзакции). Таким образом, результат следующих трёх операторов будет одинаковым: <programlisting>SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- не подходит для DEFAULT</programlisting></para>

    <tip>
     <para>Третья форма не подходит для указания в качестве значения <literal>DEFAULT</literal> при создании таблицы. Система преобразует <literal>now</literal> в значение <type>timestamp</type> в момент разбора константы, поэтому, когда будет вставляться значение по умолчанию, в соответствующем столбце окажется время создания таблицы! Первые две формы не будут вычисляться, пока не потребуется значение по умолчанию, так как это вызовы функции. Поэтому они дадут желаемый результат при добавлении строки в таблицу.</para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
   <title>Задержка выполнения</title>

   <indexterm><primary>pg_sleep</primary></indexterm>
   <indexterm><primary>pg_sleep_for</primary></indexterm>
   <indexterm><primary>pg_sleep_until</primary></indexterm>
   <indexterm><primary>sleep</primary></indexterm>
   <indexterm><primary>задержка</primary></indexterm>

   <para>В случае необходимости вы можете приостановить выполнение серверного процесса, используя следующие функции: <synopsis>
pg_sleep(<replaceable>сек</replaceable>)
pg_sleep_for(<type>interval</type>)
pg_sleep_until(<type>timestamp with time zone</type>)
</synopsis> Функция <function>pg_sleep</function> переводит процесс текущего сеанса в спящее состояние на указанное число секунд (<replaceable>сек</replaceable>). Параметр <replaceable>сек</replaceable> имеет тип <type>double precision</type>, так что в нём можно указать и дробное число. Функция <function>pg_sleep_for</function> введена для удобства, ей можно передать большие значения задержки в типе <type>interval</type>. А <function>pg_sleep_until</function> удобнее использовать, когда необходимо задать определённое время выхода из спящего состояния. Например: <programlisting>SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');</programlisting></para>

   <note>
     <para>Действительное разрешение интервала задержки зависит от платформы; обычно это 0.01. Фактическая длительность задержки не будет меньше указанного времени, но может быть больше, в зависимости, например от нагрузки на сервер. В частности, не гарантируется, что <function>pg_sleep_until</function> проснётся именно в указанное время, но она точно не проснётся раньше.</para>
   </note>

   <warning>
     <para>Прежде чем вызывать <function>pg_sleep</function> или её вариации, убедитесь в том, что в текущем сеансе нет ненужных блокировок. В противном случае в состояние ожидания могут перейти и другие сеансы, так что это отразится на системе в целом.</para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
  <title>Функции для перечислений</title>

  <para>Для типов перечислений (описанных в <xref remap="6" linkend="datatype-enum"/>) предусмотрено несколько функций, которые позволяют сделать код чище, не &laquo;зашивая&raquo; в нём конкретные значения перечисления. Эти функции перечислены в <xref remap="6" linkend="functions-enum-table"/>. В этих примерах подразумевается, что перечисление создано так: <programlisting>CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green',
 'blue', 'purple');</programlisting></para>

  <table id="functions-enum-table">
    <title>Функции для перечислений</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат примера</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm><primary>enum_first</primary></indexterm>
         <literal>enum_first(anyenum)</literal>
       </entry>
       <entry>Возвращает первое значение заданного перечисления</entry>
       <entry><literal>enum_first(null::rainbow)</literal></entry>
       <entry><literal>red</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm><primary>enum_last</primary></indexterm>
         <literal>enum_last(anyenum)</literal>
       </entry>
       <entry>Возвращает последнее значение заданного перечисления</entry>
       <entry><literal>enum_last(null::rainbow)</literal></entry>
       <entry><literal>purple</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm><primary>enum_range</primary></indexterm>
         <literal>enum_range(anyenum)</literal>
       </entry>
       <entry>Возвращает все значения заданного перечисления в упорядоченном массиве</entry>
       <entry><literal>enum_range(null::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green,blue,purple}</literal></entry>
      </row>
      <row>
       <entry morerows="2"><literal>enum_range(anyenum, anyenum)</literal></entry>
       <entry morerows="2">Возвращает набор значений, лежащих между двумя заданными, в виде упорядоченного массива. Эти значения должны принадлежать одному перечислению. Если первый параметр равен NULL, функция возвращает первое значение перечисления, а если NULL второй &mdash; последнее.</entry>
       <entry><literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal></entry>
       <entry><literal>{orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range(NULL, 'green'::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range('orange'::rainbow, NULL)</literal></entry>
       <entry><literal>{orange,yellow,green,blue,purple}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Заметьте, что за исключением варианта <function>enum_range</function> с двумя аргументами, эти функции не обращают внимание на конкретное переданное им значение; их интересует только объявленный тип. Они возвращают один и тот же результат, когда им передаётся NULL или любое другое значение типа. Обычно эти функции применяются к столбцам таблицы или аргументам внешних функций, а не к предопределённым типам, как показано в этих примерах.</para>
 </sect1>

 <sect1 id="functions-geometry">
  <title>Геометрические функции и операторы</title>

   <para>Для геометрических типов <type>point</type>, <type>box</type>, <type>lseg</type>, <type>line</type>, <type>path</type>, <type>polygon</type> и <type>circle</type> разработан большой набор встроенных функций и операторов, представленный в <xref remap="6" linkend="functions-geometry-op-table"/>, <xref remap="6" linkend="functions-geometry-func-table"/> и <xref remap="6" linkend="functions-geometry-conv-table"/>.</para>

   <caution>
    <para>Заметьте, что оператор <quote>идентичности</quote>, <literal>~=</literal>, представляет обычное сравнение на равенство значений <type>point</type>, <type>box</type>, <type>polygon</type> и <type>circle</type>. Для некоторых из этих типов определён также оператор <literal>=</literal>, но <literal>=</literal> проверяет только равенство <emphasis>площадей</emphasis>. Другие скалярные операторы сравнения (<literal>&lt;=</literal> и т. д.) так же сравнивают площади значений этих типов.</para>
   </caution>

   <table id="functions-geometry-op-table">
     <title>Геометрические операторы</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry>Сдвиг</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>Сдвиг</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
        <entry>Масштабирование/поворот</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
        <entry>Масштабирование/поворот</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <entry>Точка или прямоугольник в пересечении</entry>
        <entry><literal>box '((1,-1),(-1,1))' # box '((1,1),(-2,-2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <entry>Число точек в пути или вершин в многоугольнике</entry>
        <entry><literal># path '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
        <entry>Длина, периметр или длина окружности</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
        <entry>Центр</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
        <entry>Точка, ближайшая к первому операнду и принадлежащая второму</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
        <entry>Расстояние между операндами</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>Пересекаются ли операнды? (Для положительного ответа достаточно одной общей точки.)</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>Строго слева?</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>Строго справа?</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <entry>Не простирается правее?</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <entry>Не простирается левее?</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;|</literal> </entry>
        <entry>Строго ниже?</entry>
        <entry><literal>box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&gt;&gt;</literal> </entry>
        <entry>Строго выше?</entry>
        <entry><literal>box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;|</literal> </entry>
        <entry>Не простирается выше?</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&amp;&gt;</literal> </entry>
        <entry>Не простирается ниже?</entry>
        <entry><literal>box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
        <entry>Ниже (может касаться)?</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
        <entry>Выше (может касаться)?</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
        <entry>Пересекает?</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <entry>Горизонтальный объект?</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <entry>Выровнены по горизонтали?</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <entry>Вертикальный объект?</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <entry>Выровнены по вертикали?</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
        <entry>Перпендикулярны?</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
        <entry>Параллельны?</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>Первый объект включает второй?</entry>
        <entry><literal>circle '((0,0),2)' @&gt; point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>Первый объект включён во второй?</entry>
        <entry><literal>point '(1,1)' &lt;@ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
        <entry>Одинаковы?</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <note>
    <para>До <productname>PostgreSQL</productname> 8.2 операторы включения <literal>@&gt;</literal> и <literal>&lt;@</literal> назывались соответственно <literal>~</literal> и <literal>@</literal>. Эти имена по-прежнему доступны, но считаются устаревшими и в конце концов будут удалены.</para>
   </note>

   <indexterm><primary>area</primary></indexterm>
   <indexterm><primary>center</primary></indexterm>
   <indexterm><primary>diameter</primary></indexterm>
   <indexterm><primary>height</primary></indexterm>
   <indexterm><primary>isclosed</primary></indexterm>
   <indexterm><primary>isopen</primary></indexterm>
   <indexterm><primary>length</primary></indexterm>
   <indexterm><primary>npoints</primary></indexterm>
   <indexterm><primary>pclose</primary></indexterm>
   <indexterm><primary>popen</primary></indexterm>
   <indexterm><primary>radius</primary></indexterm>
   <indexterm><primary>width</primary></indexterm>

   <table id="functions-geometry-func-table">
     <title>Геометрические функции</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area(<replaceable>объект</replaceable>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>площадь</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center(<replaceable>объект</replaceable>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>центр</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>диаметр круга</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height(<type>box</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>вертикальный размер прямоугольника</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed(<type>path</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>замкнутый путь?</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen(<type>path</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
        <entry>открытый путь?</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length(<replaceable>объект</replaceable>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>длина</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>path</type>)</function></literal></entry>
        <entry><type>int</type></entry>
        <entry>число точек</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>polygon</type>)</function></literal></entry>
        <entry><type>int</type></entry>
        <entry>число точек</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose(<type>path</type>)</function></literal></entry>
        <entry><type>path</type></entry>
        <entry>преобразует путь в замкнутый</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
<!-- Not defined by this name. Implements the intersection operator '#' -->
<!--
       <row>
        <entry><literal><function>point(<type>lseg</>, <type>lseg</>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>intersection</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))',lseg '((-2,-2),(2,2))')</literal></entry>
       </row>
-->
       <row>
        <entry><literal><function>popen(<type>path</type>)</function></literal></entry>
        <entry><type>path</type></entry>
        <entry>преобразует путь в открытый</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>радиус окружности</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width(<type>box</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
        <entry>горизонтальный размер прямоугольника</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
     <title>Функции преобразования геометрических типов</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm><primary>box</primary></indexterm>
         <literal><function>box(<type>circle</type>)</function></literal>
        </entry>
        <entry><type>box</type></entry>
        <entry>окружность в прямоугольник</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>точка в пустой прямоугольник</entry>
        <entry><literal>box(point '(0,0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>точки в прямоугольник</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>polygon</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>многоугольник в прямоугольник</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>bound_box(<type>box</type>, <type>box</type>)</function></literal></entry>
        <entry><type>box</type></entry>
        <entry>прямоугольники в окружающий прямоугольник</entry>
        <entry><literal>bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>круг</primary></indexterm>
         <literal><function>circle(<type>box</type>)</function></literal>
        </entry>
        <entry><type>circle</type></entry>
        <entry>прямоугольник в окружность</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>point</type>, <type>double precision</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
        <entry>окружность из центра и радиуса</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>polygon</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
        <entry>многоугольник в окружность</entry>
        <entry><literal>circle(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>line(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>line</type></entry>
        <entry>точки в прямую</entry>
        <entry><literal>line(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>lseg</primary></indexterm>
         <literal><function>lseg(<type>box</type>)</function></literal>
        </entry>
        <entry><type>lseg</type></entry>
        <entry>диагональ прямоугольника в отрезок</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>lseg</type></entry>
        <entry>точки в отрезок</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>path</primary></indexterm>
         <literal><function>path(<type>polygon</type>)</function></literal>
        </entry>
        <entry><type>path</type></entry>
        <entry>многоугольник в путь</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>точка</primary></indexterm>
         <literal><function>point</function>(<type>double precision</type>, <type>double precision</type>)</literal>
        </entry>
        <entry><type>point</type></entry>
        <entry>образует точку</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>box</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>центр прямоугольника</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>circle</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>центр окружности</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>lseg</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>центр отрезка</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>polygon</type>)</function></literal></entry>
        <entry><type>point</type></entry>
        <entry>центр многоугольника</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>многоугольник</primary></indexterm>
         <literal><function>polygon(<type>box</type>)</function></literal>
        </entry>
        <entry><type>polygon</type></entry>
        <entry>прямоугольник в многоугольник с 4 вершинами</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <entry>круг в многоугольник с 12 вершинами</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<replaceable class="parameter">число_точек</replaceable>, <type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <entry>окружность с заданным <replaceable class="parameter">числом_точек</replaceable></entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>path</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
        <entry>путь в многоугольник</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <para>К двум компонентам типа <type>point</type> (точка) можно обратиться, как к элементам массива с индексами 0 и 1. Например, если <literal>t.p</literal> &mdash; столбец типа <type>point</type>, <literal>SELECT p[0] FROM t</literal> вернёт координату X, а <literal>UPDATE t SET p[1] = ...</literal> изменит координату Y. Таким же образом, значение типа <type>box</type> или <type>lseg</type> можно воспринимать как массив двух значений типа <type>point</type>.</para>

    <para>Функция <function>area</function> работает с типами <type>box</type>, <type>circle</type> и <type>path</type>. При этом для типа <type>path</type> заданный путь не должен быть самопересекающимся. Например, эта функция не примет значение типа <type>path</type> <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>, но примет визуально идентичный путь <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>. Если вы не вполне поняли, что здесь подразумевается под самопересечением пути, нарисуйте на бумаге две фигуры по приведённым координатам.</para>

  </sect1>


 <sect1 id="functions-net">
  <title>Функции и операторы для работы с сетевыми адресами</title>

  <para>В <xref linkend="cidr-inet-operators-table"/> показаны операторы, работающие с типами <type>cidr</type> и <type>inet</type>. Операторы <literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal>, <literal>&gt;&gt;=</literal> и <literal>&amp;&amp;</literal> проверяют включения подсетей, рассматривая только биты сети в обоих адресах (игнорируя биты узлов) и определяя, идентична ли одна сеть другой или её подсети.</para>

    <table id="cidr-inet-operators-table">
     <title>Операторы для типов <type>cidr</type> и <type>inet</type></title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>меньше</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>меньше или равно</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>равно</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>больше или равно</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>больше</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>не равно</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>содержится в</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
        <entry>равно или содержится в</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>содержит</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
        <entry>равно или содержит</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>содержит или содержится в</entry>
        <entry><literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal></entry>
       </row>
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>битовый NOT</entry>
        <entry><literal>~ inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;</literal> </entry>
        <entry>битовый AND</entry>
        <entry><literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>|</literal> </entry>
        <entry>битовый OR</entry>
        <entry><literal>inet '192.168.1.6' | inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry>сложение</entry>
        <entry><literal>inet '192.168.1.6' + 25</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>вычитание</entry>
        <entry><literal>inet '192.168.1.43' - 36</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>вычитание</entry>
        <entry><literal>inet '192.168.1.43' - inet '192.168.1.19'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>В <xref remap="6" linkend="cidr-inet-functions-table"/> перечислены функции, работающие с типами <type>cidr</type> и <type>inet</type>. Функции <function>abbrev</function>, <function>host</function> и <function>text</function> предназначены в основном для вывода данных в альтернативных форматах.</para>

    <table id="cidr-inet-functions-table">
     <title>Функции для типов <type>cidr</type> и <type>inet</type></title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm><primary>abbrev</primary></indexterm>
         <literal><function>abbrev(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>вывод адрес в кратком текстовом виде</entry>
        <entry><literal>abbrev(inet '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1.0.0/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>вывод адрес в кратком текстовом виде</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>broadcast</primary></indexterm>
         <literal><function>broadcast(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>широковещательный адрес сети</entry>
        <entry><literal>broadcast('192.168.1.5/&#8203;24')</literal></entry>
        <entry><literal>192.168.1.255/&#8203;24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>family</primary></indexterm>
         <literal><function>family(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>возвращает семейство адреса; <literal>4</literal> для адреса IPv4, <literal>6</literal> для IPv6</entry>
        <entry><literal>family('::1')</literal></entry>
        <entry><literal>6</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>host</primary></indexterm>
         <literal><function>host(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>извлекает IP-адрес в виде текста</entry>
        <entry><literal>host('192.168.1.5/&#8203;24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>hostmask</primary></indexterm>
         <literal><function>hostmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>вычисляет маску узла для сетевого адреса</entry>
        <entry><literal>hostmask('192.168.23.20/&#8203;30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>masklen</primary></indexterm>
         <literal><function>masklen(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>выдаёт длину маски сети</entry>
        <entry><literal>masklen('192.168.1.5/&#8203;24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>netmask</primary></indexterm>
         <literal><function>netmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>вычисляет маску сети для сетевого адреса</entry>
        <entry><literal>netmask('192.168.1.5/&#8203;24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>network</primary></indexterm>
         <literal><function>network(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
        <entry>извлекает компонент сети из адреса</entry>
        <entry><literal>network('192.168.1.5/&#8203;24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>set_masklen</primary></indexterm>
         <literal><function>set_masklen(<type>inet</type>, <type>int</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
        <entry>задаёт размер маски для значения <type>inet</type></entry>
        <entry><literal>set_masklen('192.168.1.5/&#8203;24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen(<type>cidr</type>, <type>int</type>)</function></literal></entry>
        <entry><type>cidr</type></entry>
        <entry>задаёт размер маски для значения <type>cidr</type></entry>
        <entry><literal>set_masklen('192.168.1.0/&#8203;24'::cidr, 16)</literal></entry>
        <entry><literal>192.168.0.0/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>text</primary></indexterm>
         <literal><function>text(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>выводит в текстовом виде IP-адрес и длину маски</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>inet_same_family</primary></indexterm>
         <literal><function>inet_same_family(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>адреса относятся к одному семейству?</entry>
        <entry><literal>inet_same_family('192.168.1.5/24', '::1')</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>inet_merge</primary></indexterm>
         <literal><function>inet_merge(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
        <entry>наименьшая сеть, включающая обе заданные сети</entry>
        <entry><literal>inet_merge('192.168.1.5/24', '192.168.2.5/24')</literal></entry>
        <entry><literal>192.168.0.0/22</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>Любое значение <type>cidr</type> можно привести к типу <type>inet</type>, явно или нет; поэтому все функции, показанные выше с типом <type>inet</type>, также будут работать со значениями <type>cidr</type>. (Некоторые из функций указаны отдельно для типов <type>inet</type> и <type>cidr</type>, потому что их поведение с разными типами различается.) Кроме того, значение <type>inet</type> тоже можно привести к типу <type>cidr</type>. При этом все биты справа от сетевой маски просто обнуляются, чтобы значение стало допустимым для типа <type>cidr</type>. К типам <type>inet</type> и <type>cidr</type> можно привести и обычные текстовые значения, используя обычный синтаксис, например: <literal>inet(<replaceable>выражение</replaceable>)</literal> или <literal><replaceable>столбец</replaceable>::cidr</literal>.</para>

  <para>В <xref remap="6" linkend="macaddr-functions-table"/> приведена функция, предназначенная для работы с типом <type>macaddr</type>. Функция <literal><function>trunc(<type>macaddr</type>)</function></literal> возвращает MAC-адрес, последние 3 байта в котором равны 0. Это может быть полезно для вычисления префикса, определяющего производителя.</para>

    <table id="macaddr-functions-table">
     <title>Функции <type>macaddr</type></title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm><primary>trunc</primary></indexterm>
         <literal><function>trunc(<type>macaddr</type>)</function></literal>
        </entry>
        <entry><type>macaddr</type></entry>
        <entry>обнуляет последние 3 байта</entry>
        <entry><literal>trunc(macaddr '12:34:56:&#8203;78:90:ab')</literal></entry>
        <entry><literal>12:34:56:&#8203;00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Тип <type>macaddr</type> также поддерживает стандартные реляционные операторы лексической сортировки (<literal>&gt;</literal>, <literal>&lt;=</literal> и т. д.) и операторы битовой арифметики (<literal>~</literal>, <literal>&amp;</literal> и <literal>|</literal>), соответствующие операциям NOT, AND и OR.</para>

  </sect1>


 <sect1 id="functions-textsearch">
  <title>Функции и операторы текстового поиска</title>

   <indexterm zone="datatype-textsearch"><primary>полнотекстовый поиск</primary> <secondary>функции и операторы</secondary></indexterm>

   <indexterm zone="datatype-textsearch"><primary>поиск текста</primary> <secondary>функции и операторы</secondary></indexterm>

  <para>В <xref remap="6" linkend="textsearch-operators-table"/>, <xref remap="6" linkend="textsearch-functions-table"/> и <xref remap="6" linkend="textsearch-functions-debug-table"/> собраны все существующие функции и операторы, предназначенные для полнотекстового поиска. Во всех деталях возможности полнотекстового поиска в <productname>&productname;</productname> описаны в <xref remap="6" linkend="textsearch"/>.</para>

    <table id="textsearch-operators-table">
     <title>Операторы текстового поиска</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>@@</literal> </entry>
        <entry><type>boolean</type></entry>
        <entry><type>tsvector</type> соответствует <type>tsquery</type> ?</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>@@@</literal> </entry>
        <entry><type>boolean</type></entry>
        <entry>устаревший синоним для <literal>@@</literal></entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry><type>tsvector</type></entry>
        <entry>объединяет два значения <type>tsvector</type></entry>
        <entry><literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal></entry>
        <entry><literal>'a':1 'b':2,5 'c':3 'd':4</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry><type>tsquery</type></entry>
        <entry>логическое И (AND) двух запросов <type>tsquery</type></entry>
        <entry><literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) &amp; 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry><type>tsquery</type></entry>
        <entry>логическое ИЛИ (OR) двух запросов <type>tsquery</type></entry>
        <entry><literal>'fat | rat'::tsquery || 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) | 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>!!</literal> </entry>
        <entry><type>tsquery</type></entry>
        <entry>отрицание запроса <type>tsquery</type></entry>
        <entry><literal>!! 'cat'::tsquery</literal></entry>
        <entry><literal>!'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
        <entry><type>tsquery</type></entry>
        <entry><type>tsquery</type> предшествует <type>tsquery</type></entry>
        <entry><literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry><type>boolean</type></entry>
        <entry>запрос <type>tsquery</type> включает другой?</entry>
        <entry><literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry><type>boolean</type></entry>
        <entry>запрос <type>tsquery</type> включён в другой?</entry>
        <entry><literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <para>Операторы включения <type>tsquery</type> рассматривают только лексемы двух запросов, игнорируя операторы их сочетания.</para>
    </note>

    <para>В дополнение к операторам, перечисленным в этой таблице, для типов <type>tsvector</type> и <type>tsquery</type> определены обычные операторы сравнения для B-дерева (<literal>=</literal>, <literal>&lt;</literal> и т. д.). Они не очень полезны для поиска, но позволяют, в частности, создавать индексы для столбцов этих типов.</para>

    <table id="textsearch-functions-table">
     <title>Функции текстового поиска</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm><primary>array_to_tsvector</primary></indexterm>
         <literal><function>array_to_tsvector(<type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>преобразует массив лексем в <type>tsvector</type></entry>
        <entry><literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>get_current_ts_config</primary></indexterm>
         <literal><function>get_current_ts_config()</function></literal>
        </entry>
        <entry><type>regconfig</type></entry>
        <entry>получает конфигурацию текстового поиска по умолчанию</entry>
        <entry><literal>get_current_ts_config()</literal></entry>
        <entry><literal>english</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>length</primary></indexterm>
         <literal><function>length(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
        <entry>число лексем в значении <type>tsvector</type></entry>
        <entry><literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>numnode</primary></indexterm>
         <literal><function>numnode(<type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
        <entry>число лексем и операторов в запросе <type>tsquery</type></entry>
        <entry><literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal></entry>
        <entry><literal>5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>plainto_tsquery</primary></indexterm>
         <literal><function>plainto_tsquery(<optional><replaceable class="parameter">конфигурация</replaceable> <type>regconfig</type> ,</optional> <replaceable class="parameter">запрос</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>выдаёт значение <type>tsquery</type>, игнорируя пунктуацию</entry>
        <entry><literal>plainto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>phraseto_tsquery</primary></indexterm>
         <literal><function>phraseto_tsquery(<optional><replaceable class="parameter">конфигурация</replaceable> <type>regconfig</type> ,</optional> <replaceable class="parameter">запрос</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>выдаёт значение <type>tsquery</type> для поиска фразы, игнорируя пунктуацию</entry>
        <entry><literal>phraseto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>querytree</primary></indexterm>
         <literal><function>querytree(<replaceable class="parameter">запрос</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>получает индексируемую часть запроса <type>tsquery</type></entry>
        <entry><literal>querytree('foo &amp; ! bar'::tsquery)</literal></entry>
        <entry><literal>'foo'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>setweight</primary></indexterm>
         <literal><function>setweight(<replaceable class="parameter">вектор</replaceable> <type>tsvector</type>, <replaceable class="parameter">вес</replaceable> <type>"char"</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>назначает <replaceable class="parameter">вес</replaceable> каждому элементу <replaceable class="parameter">вектора</replaceable></entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal></entry>
        <entry><literal>'cat':3A 'fat':2A,4A 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>setweight</primary> <secondary>назначение веса определённым лексемам</secondary></indexterm>
         <literal><function>setweight(<replaceable class="parameter">вектор</replaceable> <type>tsvector</type>, <replaceable class="parameter">вес</replaceable> <type>"char"</type>, <replaceable class="parameter">лексемы</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>назначает <replaceable class="parameter">вес</replaceable> элементам <replaceable class="parameter">вектора</replaceable>, перечисленным в массиве <replaceable class="parameter">лексемы</replaceable></entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')</literal></entry>
        <entry><literal>'cat':3A 'fat':2,4 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>strip</primary></indexterm>
         <literal><function>strip(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>убирает позиции и веса из значения <type>tsvector</type></entry>
        <entry><literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>to_tsquery</primary></indexterm>
         <literal><function>to_tsquery(<optional><replaceable class="parameter">конфигурация</replaceable> <type>regconfig</type> ,</optional> <replaceable class="parameter">запрос</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>нормализует слова и переводит их в <type>tsquery</type></entry>
        <entry><literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>to_tsvector</primary></indexterm>
         <literal><function>to_tsvector(<optional><replaceable class="parameter">конфигурация</replaceable> <type>regconfig</type> ,</optional> <replaceable class="parameter">документ</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>сокращает текст документа до значения <type>tsvector</type></entry>
        <entry><literal>to_tsvector('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_delete</primary></indexterm>
         <literal><function>ts_delete(<replaceable class="parameter">вектор</replaceable> <type>tsvector</type>, <replaceable class="parameter">лексема</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>удаляет заданную <replaceable class="parameter">лексему</replaceable> из <replaceable class="parameter">вектора</replaceable></entry>
        <entry><literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal></entry>
        <entry><literal>'cat':3 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <!-- previous indexterm entry covers this too -->
         <literal><function>ts_delete(<replaceable class="parameter">вектор</replaceable> <type>tsvector</type>, <replaceable class="parameter">лексемы</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>удаляет все вхождения лексем, перечисленных в массиве <replaceable class="parameter">лексемы</replaceable>, из <replaceable class="parameter">вектора</replaceable></entry>
        <entry><literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal></entry>
        <entry><literal>'cat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_filter</primary></indexterm>
         <literal><function>ts_filter(<replaceable class="parameter">вектор</replaceable> <type>tsvector</type>, <replaceable class="parameter">веса</replaceable> <type>"char"[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>выбирает из <replaceable class="parameter">вектора</replaceable> только элементы с заданным <replaceable class="parameter">весом</replaceable></entry>
        <entry><literal>ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')</literal></entry>
        <entry><literal>'cat':3B 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_headline</primary></indexterm>
         <literal><function>ts_headline(<optional><replaceable class="parameter">конфигурация</replaceable> <type>regconfig</type>,</optional> <replaceable class="parameter">документ</replaceable> <type>text</type>, <replaceable class="parameter">запрос</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">параметры</replaceable> <type>text</type></optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>выводит фрагмент, соответствующий запросу</entry>
        <entry><literal>ts_headline('x y z', 'z'::tsquery)</literal></entry>
        <entry><literal>x y &lt;b&gt;z&lt;/b&gt;</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_rank</primary></indexterm>
         <literal><function>ts_rank(<optional><replaceable class="parameter">веса</replaceable> <type>float4[]</type>,</optional> <replaceable class="parameter">вектор</replaceable> <type>tsvector</type>, <replaceable class="parameter">запрос</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">нормализация</replaceable> <type>integer</type></optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
        <entry>вычисляет ранг документа по отношению к запросу</entry>
        <entry><literal>ts_rank(textsearch, query)</literal></entry>
        <entry><literal>0.818</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_rank_cd</primary></indexterm>
         <literal><function>ts_rank_cd(<optional><replaceable class="parameter">веса</replaceable> <type>float4[]</type>,</optional> <replaceable class="parameter">вектор</replaceable> <type>tsvector</type>, <replaceable class="parameter">запрос</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">нормализация</replaceable> <type>integer</type></optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
        <entry>вычисляет ранг документа по отношению к запросу, используя плотность покрытия (CDR)</entry>
        <entry><literal>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</literal></entry>
        <entry><literal>2.01317</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_rewrite</primary></indexterm>
         <literal><function>ts_rewrite(<replaceable class="parameter">запрос</replaceable> <type>tsquery</type>, <replaceable class="parameter">цель</replaceable> <type>tsquery</type>, <replaceable class="parameter">замена</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>подставляет в запросе вместо <replaceable>цели</replaceable> <replaceable>замену</replaceable></entry>
        <entry><literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_rewrite(<replaceable class="parameter">запрос</replaceable> <type>tsquery</type>, <replaceable class="parameter">выборка</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>tsquery</type></entry>
        <entry>заменяет элементы запроса, выбирая цели и подстановки командой <command>SELECT</command></entry>
        <entry><literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>tsquery_phrase</primary></indexterm>
         <literal><function>tsquery_phrase(<replaceable class="parameter">запрос1</replaceable> <type>tsquery</type>, <replaceable class="parameter">запрос2</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>создаёт запрос, который ищет <replaceable>запрос1</replaceable>, за которым идёт <replaceable>запрос2</replaceable> (как делает оператор <literal>&lt;-&gt;</literal>)</entry>
        <entry><literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'cat'</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>tsquery_phrase(<replaceable class="parameter">запрос1</replaceable> <type>tsquery</type>, <replaceable class="parameter">запрос2</replaceable> <type>tsquery</type>, <replaceable class="parameter">расстояние</replaceable> <type>integer</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
        <entry>создаёт запрос, который ищет <replaceable>запрос1</replaceable>, за которым идёт <replaceable>запрос2</replaceable> на заданном <replaceable>расстоянии</replaceable></entry>
        <entry><literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal></entry>
        <entry><literal>'fat' &lt;10&gt; 'cat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>tsvector_to_array</primary></indexterm>
         <literal><function>tsvector_to_array(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
        <entry>преобразует <type>tsvector</type> в массив лексем</entry>
        <entry><literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>{cat,fat,rat}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>tsvector_update_trigger</primary></indexterm>
         <literal><function>tsvector_update_trigger()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
        <entry>триггерная функция для автоматического изменения столбца типа <type>tsvector</type></entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.&#8203;swedish', title, body)</literal></entry>
        <entry><literal/></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>tsvector_update_trigger_column</primary></indexterm>
         <literal><function>tsvector_update_trigger_column()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
        <entry>триггерная функция для автоматического изменения столбца типа <type>tsvector</type></entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, body)</literal></entry>
        <entry><literal/></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>unnest</primary> <secondary>для tsvector</secondary></indexterm>
         <literal><function>unnest(<type>tsvector</type>, OUT <replaceable class="parameter">лексема</replaceable> <type>text</type>, OUT <replaceable class="parameter">позиции</replaceable> <type>smallint[]</type>, OUT <replaceable class="parameter">веса</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>разворачивает tsvector в набор строк</entry>
        <entry><literal>unnest('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>(cat,{3},{D}) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <note>
   <para>Все функции текстового поиска, принимающие необязательный аргумент <type>regconfig</type>, будут использовать конфигурацию, указанную в параметре <xref linkend="guc-default-text-search-config"/>, когда этот аргумент опущен.</para>
  </note>

  <para>Функции в <xref remap="6" linkend="textsearch-functions-debug-table"/> перечислены отдельно, так как они не очень полезны в традиционных операциях поиска. Они предназначены в основном для разработки и отладки новых конфигураций текстового поиска.</para>

    <table id="textsearch-functions-debug-table">
     <title>Функции отладки текстового поиска</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm><primary>ts_debug</primary></indexterm>
         <literal><function>ts_debug(<optional><replaceable class="parameter">конфигурация</replaceable> <type>regconfig</type>,</optional> <replaceable class="parameter">документ</replaceable> <type>text</type>, OUT <replaceable class="parameter">псевдоним</replaceable> <type>text</type>, OUT <replaceable class="parameter">описание</replaceable> <type>text</type>, OUT <replaceable class="parameter">фрагмент</replaceable> <type>text</type>, OUT <replaceable class="parameter">словари</replaceable> <type>regdictionary[]</type>, OUT <replaceable class="parameter">словарь</replaceable> <type>regdictionary</type>, OUT <replaceable class="parameter">лексемы</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>проверяет конфигурацию</entry>
        <entry><literal>ts_debug('english', 'The Brightest supernovaes')</literal></entry>
        <entry><literal>(asciiword,"Word, all ASCII",The,{&#8203;english_stem&#8203;},&#8203;english_stem,{}) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_lexize</primary></indexterm>
         <literal><function>ts_lexize(<replaceable class="parameter">словарь</replaceable> <type>regdictionary</type>, <replaceable class="parameter">фрагмент</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
        <entry>проверяет словарь</entry>
        <entry><literal>ts_lexize('english_stem', 'stars')</literal></entry>
        <entry><literal>{star}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_parse</primary></indexterm>
         <literal><function>ts_parse(<replaceable class="parameter">имя_анализатора</replaceable> <type>text</type>, <replaceable class="parameter">документ</replaceable> <type>text</type>, OUT <replaceable class="parameter">код_фрагмента</replaceable> <type>integer</type>, OUT <replaceable class="parameter">фрагмент</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>проверяет анализатор</entry>
        <entry><literal>ts_parse('default', 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_parse(<replaceable class="parameter">oid_анализатора</replaceable> <type>oid</type>, <replaceable class="parameter">документ</replaceable> <type>text</type>, OUT <replaceable class="parameter">код_фрагмента</replaceable> <type>integer</type>, OUT <replaceable class="parameter">фрагмент</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>setof record</type></entry>
        <entry>проверяет анализатор</entry>
        <entry><literal>ts_parse(3722, 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_token_type</primary></indexterm>
         <literal><function>ts_token_type(<replaceable class="parameter">имя_анализатора</replaceable> <type>text</type>, OUT <replaceable class="parameter">код_фрагмента</replaceable> <type>integer</type>, OUT <replaceable class="parameter">псевдоним</replaceable> <type>text</type>, OUT <replaceable class="parameter">описание</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>получает типы фрагментов, определённые анализатором</entry>
        <entry><literal>ts_token_type('default')</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_token_type(<replaceable class="parameter">oid_анализатора</replaceable> <type>oid</type>, OUT <replaceable class="parameter">код_фрагмента</replaceable> <type>integer</type>, OUT <replaceable class="parameter">псевдоним</replaceable> <type>text</type>, OUT <replaceable class="parameter">описание</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>setof record</type></entry>
        <entry>получает типы фрагментов, определённые анализатором</entry>
        <entry><literal>ts_token_type(3722)</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm><primary>ts_stat</primary></indexterm>
         <literal><function>ts_stat(<replaceable class="parameter">sql_запрос</replaceable> <type>text</type>, <optional><replaceable class="parameter">веса</replaceable> <type>text</type>,</optional> OUT <replaceable class="parameter">слово</replaceable> <type>text</type>, OUT <replaceable class="parameter">число_док</replaceable> <type>integer</type>, OUT <replaceable class="parameter">число_вхожд</replaceable> <type>integer</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
        <entry>получает статистику столбца <type>tsvector</type></entry>
        <entry><literal>ts_stat('SELECT vector from apod')</literal></entry>
        <entry><literal>(foo,10,15) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

 </sect1>


 <sect1 id="functions-xml">
  <title>XML-функции</title>

  <para>Функции и подобные им выражения, описанные в этом разделе, работают со значениями типа <type>xml</type>. Информацию о типе <type>xml</type> вы можете найти в <xref remap="6" linkend="datatype-xml"/>. Выражения <function>xmlparse</function> и <function>xmlserialize</function>, преобразующие значения <type>xml</type> в текст и обратно, здесь повторно не рассматриваются. Для использования большинства этих функций дистрибутив должен быть собран с ключом <command>configure --with-libxml</command>.</para>

  <sect2 id="functions-producing-xml">
   <title>Создание XML-контента</title>

   <para>Для получения XML-контента из данных SQL существует целый набор функций и функциональных выражений, особенно полезных для выдачи клиентским приложениям результатов запроса в виде XML-документов.</para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm><primary>xmlcomment</primary></indexterm>

<synopsis><function>xmlcomment</function>(<replaceable>текст</replaceable>)</synopsis>

    <para>Функция <function>xmlcomment</function> создаёт XML-значение, содержащее XML-комментарий с заданным текстом. Этот текст не должен содержать <quote><literal>--</literal></quote> или заканчиваться знаком <quote><literal>-</literal></quote>, чтобы результирующая конструкция была допустимой в XML. Если аргумент этой функции NULL, результатом её тоже будет NULL.</para>

    <para>Пример: <screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen></para>
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm><primary>xmlconcat</primary></indexterm>

<synopsis><function>xmlconcat</function>(<replaceable>xml</replaceable><optional>, ...</optional>)</synopsis>

    <para>Функция <function>xmlconcat</function> объединяет несколько XML-значений и выдаёт в результате один фрагмент XML-контента. Значения NULL отбрасываются, так что результат будет равен NULL, только если все аргументы равны NULL.</para>

    <para>Пример: <screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen></para>

    <para>XML-объявления, если они присутствуют, обрабатываются следующим образом. Если во всех аргументах содержатся объявления одной версии XML, эта версия будет выдана в результате; в противном случае версии не будет. Если во всех аргументах определён атрибут standalone со значением <quote>yes</quote>, это же значение будет выдано в результате. Если во всех аргументах есть объявление standalone, но минимум в одном со значением <quote>no</quote>, в результате будет это значение. В противном случае в результате не будет объявления standalone. Если же окажется, что в результате должно присутствовать объявление standalone, а версия не определена, тогда в результате будет выведена версия 1.0, так как XML-объявление не будет допустимым без указания версии. Указания кодировки игнорируются и будут удалены в любых случаях.</para>

    <para>Пример: <screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen></para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm><primary>xmlelement</primary></indexterm>

<synopsis><function>xmlelement</function>(name <replaceable>имя</replaceable> <optional>, xmlattributes(<replaceable>значение</replaceable> <optional>AS <replaceable>атрибут</replaceable></optional> <optional>, ...</optional>)</optional>
  <optional><replaceable>, содержимое, ...</replaceable></optional>)</synopsis>

    <para>Выражение <function>xmlelement</function> создаёт XML-элемент с заданным именем, атрибутами и содержимым.</para>

    <para>Примеры: <screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen></para>

    <para>Если имена элементов и атрибутов содержат символы, недопустимые в XML, эти символы заменяются последовательностями <literal>_x<replaceable>HHHH</replaceable>_</literal>, где <replaceable>HHHH</replaceable> — шестнадцатеричный код символа в Unicode. Например: <screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen></para>

    <para>Если в качестве значения атрибута используется столбец таблицы, имя атрибута можно не указывать явно, этим именем станет имя столбца. Во всех остальных случаях имя атрибута должно быть определено явно. Таким образом, это выражение допустимо: <screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen> А следующие варианты &mdash; нет: <screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen></para>

    <para>Содержимое элемента, если оно задано, будет форматировано согласно его типу данных. Когда оно само имеет тип <type>xml</type>, из него можно конструировать сложные XML-документы. Например: <screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen> Содержимое других типов будет оформлено в виде блока символьных данных XML. Это, в частности, означает, что символы &lt;, &gt; и &amp; будут преобразованы в сущности XML. Двоичные данные (данные типа <type>bytea</type>) представляются в кодировке base64 или в шестнадцатеричном виде, в зависимости от значения параметра <xref linkend="guc-xmlbinary"/>. Следует ожидать, что конкретные представления отдельных типов данных могут быть изменены для приведения типов SQL и &productname; в соответствие со стандартом XML Schema, когда появится его более полное описание.</para>
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm><primary>xmlforest</primary></indexterm>

<synopsis><function>xmlforest</function>(<replaceable>содержимое</replaceable> <optional>AS <replaceable>имя</replaceable></optional> <optional>, ...</optional>)</synopsis>

    <para>Выражение <function>xmlforest</function> создаёт последовательность XML-элементов с заданными именами и содержимым.</para>

    <para>Примеры: <screen><![CDATA[
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 <foo>abc</foo><bar>123</bar>


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 <table_name>pg_authid</table_name><column_name>rolname</column_name>
 <table_name>pg_authid</table_name><column_name>rolsuper</column_name>
 ...
]]></screen> Как показано во втором примере, имя элемента можно опустить, если источником содержимого служит столбец (в этом случае именем элемента по умолчанию будет имя столбца). В противном случае это имя необходимо указывать.</para>

    <para>Имена элементов с символами, недопустимыми для XML, преобразуются так же, как и для <function>xmlelement</function>. Данные содержимого тоже приводятся к виду, допустимому для XML (кроме данных, которые уже имеют тип <type>xml</type>).</para>

    <para>Заметьте, что такие XML-последовательности не являются допустимыми XML-документами, если они содержат больше одного элемента на верхнем уровне, поэтому может иметь смысл вложить выражения <function>xmlforest</function> в <function>xmlelement</function>.</para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm><primary>xmlpi</primary></indexterm>

<synopsis><function>xmlpi</function>(name <replaceable>цель</replaceable> <optional>, <replaceable>содержимое</replaceable></optional>)</synopsis>

    <para>Выражение <function>xmlpi</function> создаёт инструкцию обработки XML. Содержимое, если оно задано, не должно содержать последовательность символов <literal>?&gt;</literal>.</para>

    <para>Пример: <screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen></para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm><primary>xmlroot</primary></indexterm>

<synopsis><function>xmlroot</function>(<replaceable>xml</replaceable>, version <replaceable>текст</replaceable> | нет значения <optional>, standalone yes|no|нет значения</optional>)</synopsis>

    <para>Выражение <function>xmlroot</function> изменяет свойства корневого узла XML-значения. Если в нём указывается версия, она заменяет значение в объявлении версии корневого узла; также в корневой узел переносится значение свойства standalone.</para>

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm><primary>xmlagg</primary></indexterm>

<synopsis><function>xmlagg</function>(<replaceable>xml</replaceable>)</synopsis>

    <para>Функция <function>xmlagg</function>, в отличие от других описанных здесь функций, является агрегатной. Она соединяет значения, поступающие на вход агрегатной функции, подобно функции <function>xmlconcat</function>, но делает это, обрабатывая множество строк, а не несколько выражений в одной строке. Дополнительно агрегатные функции описаны в <xref remap="6" linkend="functions-aggregate"/>.</para>

    <para>Пример: <screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen></para>

    <para>Чтобы задать порядок сложения элементов, в агрегатный вызов можно добавить предложение <literal>ORDER BY</literal>, описанное в <xref linkend="syntax-aggregates"/>. Например: <screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen></para>

    <para>Следующий нестандартный подход рекомендовался в предыдущих версиях и может быть по-прежнему полезен в некоторых случаях: <screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen></para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
    <title>Условия с XML</title>

    <para>Описанные в этом разделе выражения проверяют свойства значений <type>xml</type>.</para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm><primary>IS DOCUMENT</primary></indexterm>

<synopsis><replaceable>xml</replaceable> IS DOCUMENT</synopsis>

    <para>Выражение <literal>IS DOCUMENT</literal> возвращает true, если аргумент представляет собой правильный XML-документ, false в противном случае (т. е. если это фрагмент содержимого) и NULL, если его аргумент также NULL. Чем документы отличаются от фрагментов содержимого, вы можете узнать в <xref remap="6" linkend="datatype-xml"/>.</para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm><primary>XMLEXISTS</primary></indexterm>

<synopsis><function>XMLEXISTS</function>(<replaceable>текст</replaceable>
 PASSING <optional>BY REF</optional> <replaceable>xml</replaceable> <optional>BY REF</optional>)</synopsis>

    <para>Функция <function>xmlexists</function> возвращает true, если выражение XPath в первом аргументе возвращает какие либо узлы, и false &mdash; в противном случае. (Если один из аргументов равен NULL, результатом также будет NULL.)</para>

    <para>Пример: <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen></para>

    <para>Указания <literal>BY REF</literal> не несут смысловой нагрузки в &productname;, но могут присутствовать для соответствия стандарту SQL и совместимости с другими реализациями. По стандарту SQL первое указание <literal>BY REF</literal> является обязательным, а второе &mdash; нет. Также заметьте, что, согласно стандарту SQL, конструкция <function>xmlexists</function> должна принимать в первом аргументе выражение XQuery, но &productname; в настоящее время поддерживает только XPath, подмножество XQuery.</para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm><primary>xml_is_well_formed</primary></indexterm>

    <indexterm><primary>xml_is_well_formed_document</primary></indexterm>

    <indexterm><primary>xml_is_well_formed_content</primary></indexterm>

<synopsis><function>xml_is_well_formed</function>(<replaceable>текст</replaceable>)
<function>xml_is_well_formed_document</function>(<replaceable>текст</replaceable>)
<function>xml_is_well_formed_content</function>(<replaceable>текст</replaceable>)</synopsis>

    <para>Эти функции проверяют, является ли <type>текст</type> правильно оформленным XML, и возвращают соответствующее логическое значение. Функция <function>xml_is_well_formed_document</function> проверяет аргумент как правильно оформленный документ, а <function>xml_is_well_formed_content</function> &mdash; правильно оформленное содержание. Функция <function>xml_is_well_formed</function> может делать первое или второе, в зависимости от значения параметра конфигурации <xref linkend="guc-xmloption"/> (<literal>DOCUMENT</literal> или <literal>CONTENT</literal>, соответственно). Это значит, что <function>xml_is_well_formed</function> помогает понять, будет ли успешным простое приведение к типу <type>xml</type>, тогда как две другие функции проверяют, будут ли успешны соответствующие варианты <function>XMLPARSE</function>.</para>

    <para>Примеры: <screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen> Последний пример показывает, что при проверке также учитываются сопоставления пространств имён.</para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
   <title>Обработка XML</title>

   <indexterm><primary>XPath</primary></indexterm>

   <para>Для обработки значений типа <type>xml</type> с помощью выражений XPath 1.0 в &productname; представлены функции <function>xpath</function> и <function>xpath_exists</function>.</para>

<synopsis><function>xpath</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)</synopsis>

   <para>Функция <function>xpath</function> вычисляет выражение XPath (аргумент <replaceable>xpath</replaceable> типа <type>text</type>) для заданного <replaceable>xml</replaceable>. Она возвращает массив XML-значений с набором узлов, полученных в результате выражения XPath. Если выражение XPath выдаёт не набор узлов, а скалярное значение, возвращается массив из одного элемента.</para>

  <para>Вторым аргументом должен быть правильно оформленный XML-документ. В частности, в нём должен быть единственный корневой элемент.</para>

   <para>В необязательном третьем аргументе функции передаются сопоставления пространств имён. Эти сопоставления должны определяться в двумерном массиве типа <type>text</type>, во второй размерности которого 2 элемента (т. е. это должен быть массив массивов, состоящих из 2 элементов). В первом элементе каждого массива определяется псевдоним (префикс) пространства имён, а во втором &mdash; его URI. Псевдонимы, определённые в этом массиве, не обязательно должны совпадать с префиксами пространств имён в самом XML-документе (другими словами, для XML-документа и функции <function>xpath</function> псевдонимы имеют <emphasis>локальный</emphasis> характер).</para>

   <para>Пример: <screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen></para>

   <para>Для пространства имён по умолчанию (анонимного) это выражение можно записать так: <screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen></para>

   <indexterm><primary>xpath_exists</primary></indexterm>

<synopsis><function>xpath_exists</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)</synopsis>

   <para>Функция <function>xpath_exists</function> представляет собой специализированную форму функции <function>xpath</function>. Она возвращает не весь набор XML-узлов, удовлетворяющих выражению XPath, а только одно логическое значение, показывающее, есть ли такие узлы. Эта функция равнозначна стандартному условию <literal>XMLEXISTS</literal>, за исключением того, что она также поддерживает сопоставления пространств имён.</para>

   <para>Пример: <screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen></para>
  </sect2>

  <sect2 id="functions-xml-mapping">
   <title>Отображение таблиц в XML</title>

   <indexterm zone="functions-xml-mapping"><primary>экспорт в XML</primary></indexterm>

   <para>Следующие функции отображают содержимое реляционных таблиц в значения XML. Их можно рассматривать как средства экспорта в XML: <synopsis>
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</synopsis> Результат всех этих функций имеет тип <type>xml</type>.</para>

   <para><function>table_to_xml</function> отображает в xml содержимое таблицы, имя которой задаётся в параметре <parameter>tbl</parameter>. Тип <type>regclass</type> принимает идентификаторы строк в обычной записи, которые могут содержать указание схемы и кавычки. Функция <function>query_to_xml</function> выполняет запрос, текст которого передаётся в параметре <parameter>query</parameter>, и отображает в xml результирующий набор. Последняя функция, <function>cursor_to_xml</function> выбирает указанное число строк из курсора, переданного в параметре <parameter>cursor</parameter>. Этот вариант рекомендуется использовать с большими таблицами, так как все эти функции создают результирующий xml в памяти.</para>

   <para>Если параметр <parameter>tableforest</parameter> имеет значение false, результирующий XML-документ выглядит так: <screen><![CDATA[
<имя_таблицы>
  <row>
    <имя_столбца1> данные </имя_столбца1>
    <имя_столбца2> данные </имя_столбца2>
  </row>

  <row>
    ...
  </row>

  ...
</имя_таблицы>
]]></screen> А если <parameter>tableforest</parameter> равен true, в результате будет выведен следующий фрагмент XML: <screen><![CDATA[
<имя_таблицы>
  <имя_столбца1> данные </имя_столбца1>
  <имя_столбца2> данные </имя_столбца2>
</имя_таблицы>

<имя_таблицы>
  ...
</имя_таблицы>

...
]]></screen> Если имя таблицы неизвестно, например, при отображении результатов запроса или курсора, вместо него в первом случае вставляется <literal>table</literal>, а во втором — <literal>row</literal>.</para>

   <para>Выбор между этими форматами остаётся за пользователем. Первый вариант позволяет создать готовый XML-документ, что может быть полезно для многих приложений, а второй удобно применять с функцией <function>cursor_to_xml</function>, если её результаты будут собираться в документ позже. Полученный результат можно изменить по вкусу с помощью рассмотренных выше функций создания XML-содержимого, в частности <function>xmlelement</function>.</para>

   <para>Значения данных эти функции отображают так же, как и ранее описанная функция <function>xmlelement</function>.</para>

   <para>Параметр <parameter>nulls</parameter> определяет, нужно ли включать в результат значения NULL. Если он установлен, значения NULL в столбцах представляются так: <screen><![CDATA[
<имя_столбца xsi:nil="true"/>
]]></screen> Здесь <literal>xsi</literal> &mdash; префикс пространства имён XML Schema Instance. При этом в результирующий XML будет добавлено соответствующее объявление пространства имён. Если же данный параметр равен false, столбцы со значениями NULL просто не будут выводиться.</para>

   <para>Параметр <parameter>targetns</parameter> определяет целевое пространство имён для результирующего XML. Если пространство имён не нужно, значением этого параметра должна быть пустая строка.</para>

   <para>Следующие функции выдают документы XML Schema, которые содержат схемы отображений, выполняемых соответствующими ранее рассмотренными функциями: <synopsis>
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean,
  targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean,
  targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean,
  targetns text)
</synopsis> Чтобы результаты отображения данных в XML соответствовали XML-схемам, важно, чтобы паре функций передавались одинаковые параметры.</para>

   <para>Следующие функции выдают отображение данных в XML и соответствующую XML-схему в одном документе (или фрагменте), объединяя их вместе. Это может быть полезно там, где желательно получить самодостаточные результаты с описанием: <synopsis>
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean,
  targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean,
  targetns text)
</synopsis></para>

   <para>В дополнение к ним есть следующие функции, способные выдать аналогичные представления для целых схем в базе данных или даже всей текущей базы данных: <synopsis>
schema_to_xml(schema name, nulls boolean, tableforest boolean,
  targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean,
  targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean,
  targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean,
  targetns text)
</synopsis> Заметьте, что объём таких данных может быть очень большим, а XML будет создаваться в памяти. Поэтому, вместо того, чтобы пытаться отобразить в XML сразу всё содержимое больших схем или баз данных, лучше делать это по таблицам, возможно даже используя курсор.</para>

   <para>Результат отображения содержимого схемы будет выглядеть так: <screen><![CDATA[
<имя_схемы>

отображение-таблицы1

отображение-таблицы2

...

</имя_схемы>]]></screen> Формат отображения таблицы определяется параметром <parameter>tableforest</parameter>, описанным выше.</para>

   <para>Результат отображения содержимого базы данных будет таким: <screen><![CDATA[
<имя_схемы>

<имя_схемы1>
  ...
</имя_схемы1>

<имя_схемы2>
  ...
</имя_схемы2>

...

</имя_схемы>]]></screen> Здесь отображение схемы имеет вид, показанный выше.</para>

   <para>В качестве примера, иллюстрирующего использование результата этих функций, на <xref remap="6" linkend="xslt-xml-html"/> показано XSLT-преобразование, которое переводит результат функции <function>table_to_xml_and_xmlschema</function> в HTML-документ, содержащий таблицу с данными. Подобным образом результаты этих функций можно преобразовать и в другие форматы на базе XML.</para>

   <figure id="xslt-xml-html">
    <title>XSLT-преобразование, переводящее результат SQL/XML в формат HTML</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </figure>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
  <title>Функции и операторы JSON</title>

  <indexterm zone="functions-json"><primary>JSON</primary> <secondary>функции и операторы</secondary></indexterm>

   <para>В <xref remap="6" linkend="functions-json-op-table"/> перечислены функции, позволяющие создавать данные в формате JSON (см. <xref remap="4" linkend="datatype-json"/>).</para>

  <table id="functions-json-op-table">
     <title>Операторы для типов <type>json</type> и <type>jsonb</type></title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Тип правого операнда</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат примера</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>int</type></entry>
        <entry>Выдаёт элемент массива JSON (по номеру от 0, отрицательные числа задают позиции с конца)</entry>
        <entry><literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</literal></entry>
        <entry><literal>{"c":"baz"}</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>text</type></entry>
        <entry>Выдаёт поле объекта JSON по ключу</entry>
        <entry><literal>'{"a": {"b":"foo"}}'::json-&gt;'a'</literal></entry>
        <entry><literal>{"b":"foo"}</literal></entry>
       </row>
        <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>int</type></entry>
        <entry>Выдаёт элемент массива JSON в типе <type>text</type></entry>
        <entry><literal>'[1,2,3]'::json-&gt;&gt;2</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>text</type></entry>
        <entry>Выдаёт поле объекта JSON в типе <type>text</type></entry>
        <entry><literal>'{"a":1,"b":2}'::json-&gt;&gt;'b'</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>Выдаёт объект JSON по заданному пути</entry>
        <entry><literal>'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</literal></entry>
        <entry><literal>{"c": "foo"}</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>Выдаёт объект JSON по заданному пути в типе <type>text</type></entry>
        <entry><literal>'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <note>
   <para>Эти операторы существуют в двух вариациях для типов <type>json</type> и <type>jsonb</type>. Операторы извлечения поля/элемента/пути возвращают тот же тип, что у операнда слева (<type>json</type> или <type>jsonb</type>), за исключением тех, что возвращают тип <type>text</type> (они возвращают значение как текстовое). Если входные данные JSON не содержат структуры, удовлетворяющей запросу, например в них нет искомого элемента, то операторы извлечения поля/элемента/пути не выдают ошибку, а возвращают NULL. Все операторы извлечения поля/элемента/пути, принимающие целочисленные позиции в массивах JSON, поддерживают и отсчёт от конца массива по отрицательной позиции.</para>
  </note>
  <para>Стандартные операторы сравнения, приведённые в <xref remap="6" linkend="functions-comparison-op-table"/>, есть для типа <type>jsonb</type>, но не для <type>json</type>. Они следуют правилам сортировки для операций B-дерева, описанным в <xref remap="6" linkend="json-indexing"/>.</para>
  <para>Некоторые из следующих операторов существуют только для <type>jsonb</type>, как показано в <xref remap="6" linkend="functions-jsonb-op-table"/>. Многие из этих операторов могут быть проиндексированы с помощью классов операторов <type>jsonb</type>. Полное описание проверок на вхождение и существование для <type>jsonb</type> приведено в <xref remap="6" linkend="json-containment"/>. Как эти операторы могут использоваться для эффективного индексирования данных <type>jsonb</type>, описано в <xref remap="6" linkend="json-indexing"/>.</para>
  <table id="functions-jsonb-op-table">
     <title>Дополнительные операторы <type>jsonb</type></title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Тип правого операнда</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>@&gt;</literal></entry>
        <entry><type>jsonb</type></entry>
        <entry>Левое значение JSON содержит на верхнем уровне путь/значение JSON справа?</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;@</literal></entry>
        <entry><type>jsonb</type></entry>
        <entry>Путь/значение JSON слева содержится на верхнем уровне в правом значении JSON?</entry>
        <entry><literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>?</literal></entry>
        <entry><type>text</type></entry>
        <entry>Присутствует ли <emphasis>строка</emphasis> в качестве ключа верхнего уровня в значении JSON?</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal></entry>
       </row>
       <row>
        <entry><literal>?|</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>Какие-либо <emphasis>строки</emphasis> массива присутствуют в качестве ключей верхнего уровня?</entry>
        <entry><literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</literal></entry>
       </row>
       <row>
        <entry><literal>?&amp;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>Все <emphasis>строки</emphasis> массива присутствуют в качестве ключей верхнего уровня?</entry>
        <entry><literal>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</literal></entry>
       </row>
       <row>
        <entry><literal>||</literal></entry>
        <entry><type>jsonb</type></entry>
        <entry>Соединяет два значения <type>jsonb</type> в новое значение <type>jsonb</type></entry>
        <entry><literal>'["a", "b"]'::jsonb || '["c", "d"]'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>-</literal></entry>
        <entry><type>text</type></entry>
        <entry>Удаляет пару ключ/значение или элемент-<emphasis>строку</emphasis> из левого операнда. Пары ключ/значение выбираются по значению ключа.</entry>
        <entry><literal>'{"a": "b"}'::jsonb - 'a'</literal></entry>
       </row>
       <row>
        <entry><literal>-</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Удаляет из массива элемент в заданной позиции (отрицательные номера позиций отсчитываются от конца). Выдаёт ошибку, если контейнер верхнего уровня — не массив.</entry>
        <entry><literal>'["a", "b"]'::jsonb - 1</literal></entry>
       </row>
       <row>
        <entry><literal>#-</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>Удаляет поле или элемент с заданным путём (для массивов JSON отрицательные номера позиций отсчитываются от конца)</entry>
        <entry><literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <note>
   <para>Оператор <literal>||</literal> соединяет элементы верхнего уровня обоих операндов. Вложенность при этом не учитывается. Например, если оба операнда содержат поле с одноимённым ключом, значением поля в результате будет значение, взятое из правого операнда.</para>
  </note>

  <para>В <xref remap="6" linkend="functions-json-creation-table"/> показаны функции, позволяющие создавать значения типов <type>json</type> и <type>jsonb</type>. (Для типа <type>jsonb</type> нет аналогов функций <literal>row_to_json</literal> и <literal>array_to_json</literal>, но практически тот же результат можно получить с помощью <literal>to_jsonb</literal>.)</para>

  <indexterm><primary>to_json</primary></indexterm>
  <indexterm><primary>array_to_json</primary></indexterm>
  <indexterm><primary>row_to_json</primary></indexterm>
  <indexterm><primary>json_build_array</primary></indexterm>
  <indexterm><primary>json_build_object</primary></indexterm>
  <indexterm><primary>json_object</primary></indexterm>
  <indexterm><primary>to_jsonb</primary></indexterm>
  <indexterm><primary>jsonb_build_array</primary></indexterm>
  <indexterm><primary>jsonb_build_object</primary></indexterm>
  <indexterm><primary>jsonb_object</primary></indexterm>

  <table id="functions-json-creation-table">
    <title>Функции для создания JSON</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат примера</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>to_json(anyelement)</literal>
          </para><para><literal>to_jsonb(anyelement)</literal>
       </para></entry>
       <entry>Возвращает значение в виде <type>json</type> или <type>jsonb</type>. Массивы и составные структуры преобразуются (рекурсивно) в массивы и объекты; для других типов, для которых определено приведение к <type>json</type>, применяется эта функция приведения, а для всех остальных выдаётся скалярное значение. Значения всех скалярных типов, кроме числового, логического и NULL, представляются в текстовом виде, в стиле, допустимом для значений <type>json</type> или <type>jsonb</type>.</entry>
       <entry><literal>to_json('Fred said "Hi."'::text)</literal></entry>
       <entry><literal>"Fred said \"Hi.\""</literal></entry>
      </row>
      <row>
       <entry>
         <literal>array_to_json(anyarray [, pretty_bool])</literal>
       </entry>
       <entry>Возвращает массив в виде массива JSON. Многомерный массив &productname; становится массивом массивов JSON. Если параметр <parameter>pretty_bool</parameter> равен true, между элементами 1-ой размерности вставляются разрывы строк.</entry>
       <entry><literal>array_to_json('{{1,5},{99,100}}'::int[])</literal></entry>
       <entry><literal>[[1,5],[99,100]]</literal></entry>
      </row>
      <row>
       <entry>
         <literal>row_to_json(record [, pretty_bool])</literal>
       </entry>
       <entry>Возвращает кортеж в виде объекта JSON. Если параметр <parameter>pretty_bool</parameter> равен true, между элементами 1-ой размерности вставляются разрывы строк.</entry>
       <entry><literal>row_to_json(row(1,'foo'))</literal></entry>
       <entry><literal>{"f1":1,"f2":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_build_array(VARIADIC "any")</literal>
          </para><para><literal>jsonb_build_array(VARIADIC "any")</literal>
       </para></entry>
       <entry>Формирует массив JSON (возможно, разнородный) из переменного списка аргументов.</entry>
       <entry><literal>json_build_array(1,2,'3',4,5)</literal></entry>
       <entry><literal>[1, 2, "3", 4, 5]</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_build_object(VARIADIC "any")</literal>
          </para><para><literal>jsonb_build_object(VARIADIC "any")</literal>
       </para></entry>
       <entry>Формирует объект JSON из переменного списка аргументов. По соглашению в этом списке перечисляются по очереди ключи и значения.</entry>
       <entry><literal>json_build_object('foo',1,'bar',2)</literal></entry>
       <entry><literal>{"foo": 1, "bar": 2}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object(text[])</literal>
          </para><para><literal>jsonb_object(text[])</literal>
       </para></entry>
       <entry>Формирует объект JSON из текстового массива. Этот массив должен иметь либо одну размерность с чётным числом элементов (в этом случае они воспринимаются как чередующиеся ключи/значения), либо две размерности и при этом каждый внутренний массив содержит ровно два элемента, которые воспринимаются как пара ключ/значение.</entry>
       <entry><para><literal>json_object('{a, 1, b, "def", c, 3.5}')</literal></para>
        <para><literal>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</literal></para></entry>
       <entry><literal>{"a": "1", "b": "def", "c": "3.5"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object(keys text[], values text[])</literal>
          </para><para><literal>jsonb_object(keys text[], values text[])</literal>
       </para></entry>
       <entry>Эта форма <function>json_object</function> принимает ключи и значения по парам из двух отдельных массивов. Во всех остальных отношениях она не отличается от формы с одним аргументом.</entry>
       <entry><literal>json_object('{a, b}', '{1,2}')</literal></entry>
       <entry><literal>{"a": "1", "b": "2"}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>Функции <function>array_to_json</function> и <function>row_to_json</function> подобны <function>to_json</function>, но предлагают возможность улучшенного вывода. Действие <function>to_json</function>, описанное выше, распространяется на каждое отдельное значение, преобразуемое этими функциями.</para>
  </note>

  <note>
    <para>В расширении <xref linkend="hstore"/> определено преобразование из <type>hstore</type> в <type>json</type>, так что значения <type>hstore</type>, преобразуемые функциями создания JSON, будут представлены в виде объектов JSON, а не как примитивные строковые значения.</para>
  </note>

  <para>В <xref remap="6" linkend="functions-json-processing-table"/> показаны функции, предназначенные для работы со значениями <type>json</type> и <type>jsonb</type>.</para>

  <indexterm><primary>json_array_length</primary></indexterm>
  <indexterm><primary>jsonb_array_length</primary></indexterm>
  <indexterm><primary>json_each</primary></indexterm>
  <indexterm><primary>jsonb_each</primary></indexterm>
  <indexterm><primary>json_each_text</primary></indexterm>
  <indexterm><primary>jsonb_each_text</primary></indexterm>
  <indexterm><primary>json_extract_path</primary></indexterm>
  <indexterm><primary>jsonb_extract_path</primary></indexterm>
  <indexterm><primary>json_extract_path_text</primary></indexterm>
  <indexterm><primary>jsonb_extract_path_text</primary></indexterm>
  <indexterm><primary>json_object_keys</primary></indexterm>
  <indexterm><primary>jsonb_object_keys</primary></indexterm>
  <indexterm><primary>json_populate_record</primary></indexterm>
  <indexterm><primary>jsonb_populate_record</primary></indexterm>
  <indexterm><primary>json_populate_recordset</primary></indexterm>
  <indexterm><primary>jsonb_populate_recordset</primary></indexterm>
  <indexterm><primary>json_array_elements</primary></indexterm>
  <indexterm><primary>jsonb_array_elements</primary></indexterm>
  <indexterm><primary>json_array_elements_text</primary></indexterm>
  <indexterm><primary>jsonb_array_elements_text</primary></indexterm>
  <indexterm><primary>json_typeof</primary></indexterm>
  <indexterm><primary>jsonb_typeof</primary></indexterm>
  <indexterm><primary>json_to_record</primary></indexterm>
  <indexterm><primary>jsonb_to_record</primary></indexterm>
  <indexterm><primary>json_to_recordset</primary></indexterm>
  <indexterm><primary>jsonb_to_recordset</primary></indexterm>
  <indexterm><primary>json_strip_nulls</primary></indexterm>
  <indexterm><primary>jsonb_strip_nulls</primary></indexterm>
  <indexterm><primary>jsonb_set</primary></indexterm>
  <indexterm><primary>jsonb_insert</primary></indexterm>
  <indexterm><primary>jsonb_pretty</primary></indexterm>

  <table id="functions-json-processing-table">
    <title>Функции для обработки JSON</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
       <entry>Пример</entry>
       <entry>Результат примера</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>json_array_length(json)</literal>
         </para><para><literal>jsonb_array_length(jsonb)</literal>
       </para></entry>
       <entry><type>int</type></entry>
       <entry>Возвращает число элементов во внешнем массиве JSON.</entry>
       <entry><literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_each(json)</literal>
         </para><para><literal>jsonb_each(jsonb)</literal>
       </para></entry>
       <entry><para><literal>setof key text, value json</literal>
         </para><para><literal>setof key text, value jsonb</literal>
       </para></entry>
       <entry>Разворачивает внешний объект JSON в набор пар ключ/значение (key/value).</entry>
       <entry><literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting> key | value
-----+-------
 a   | "foo"
 b   | "bar"</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_each_text(json)</literal>
         </para><para><literal>jsonb_each_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof key text, value text</type></entry>
       <entry>Разворачивает внешний объект JSON в набор пар ключ/значение (key/value). Возвращаемые значения будут иметь тип <type>text</type>.</entry>
       <entry><literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting> key | value
-----+-------
 a   | foo
 b   | bar</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path(from_json json, VARIADIC path_elems text[])</literal>
        </para><para><literal>jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type>
       </para></entry>
       <entry>Возвращает значение JSON по пути, заданному элементами пути (<replaceable>path_elems</replaceable>) (равнозначно оператору <literal>#&gt;</literal> operator).</entry>
       <entry><literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</literal></entry>
       <entry><literal>{"f5":99,"f6":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path_text(from_json json, VARIADIC path_elems text[])</literal>
         </para><para><literal>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>Возвращает значение JSON по пути, заданному элементами пути <replaceable>path_elems</replaceable>, как <type>text</type> (равнозначно оператору <literal>#&gt;&gt;</literal>).</entry>
       <entry><literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</literal></entry>
       <entry><literal>foo</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object_keys(json)</literal>
         </para><para><literal>jsonb_object_keys(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>Возвращает набор ключей во внешнем объекте JSON.</entry>
       <entry><literal>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal></entry>
       <entry>
<programlisting> json_object_keys
-----------------
 f1
 f2</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_record(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_record(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>anyelement</type></entry>
       <entry>Разворачивает объект из <replaceable>from_json</replaceable> в табличную строку, в которой столбцы соответствуют типу строки, заданному параметром <replaceable>base</replaceable> (см. примечания ниже).</entry>
       <entry><literal>select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')</literal></entry>
       <entry>
<programlisting> a | b
---+---
 1 | 2</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_recordset(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_recordset(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>setof anyelement</type></entry>
       <entry>Разворачивает внешний массив объектов из <replaceable>from_json</replaceable> в набор табличных строк, в котором столбцы соответствуют типу строки, заданному параметром <replaceable>base</replaceable> (см. примечания ниже).</entry>
       <entry><literal>select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</literal></entry>
       <entry>
<programlisting> a | b
---+---
 1 | 2
 3 | 4</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements(json)</literal>
         </para><para><literal>jsonb_array_elements(jsonb)</literal>
       </para></entry>
       <entry><para><type>setof json</type>
         </para><para><type>setof jsonb</type>
       </para></entry>
       <entry>Разворачивает массив JSON в набор значений JSON.</entry>
       <entry><literal>select * from json_array_elements('[1,true, [2,false]]')</literal></entry>
       <entry>
<programlisting>   value
-----------
 1
 true
 [2,false]</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements_text(json)</literal>
         </para><para><literal>jsonb_array_elements_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>Разворачивает массив JSON в набор значений <type>text</type>.</entry>
       <entry><literal>select * from json_array_elements_text('["foo", "bar"]')</literal></entry>
       <entry>
<programlisting>   value
-----------
 foo
 bar</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_typeof(json)</literal>
         </para><para><literal>jsonb_typeof(jsonb)</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>Возвращает тип внешнего значения JSON в виде текстовой строки. Возможные типы: <literal>object</literal>, <literal>array</literal>, <literal>string</literal>, <literal>number</literal>, <literal>boolean</literal> и <literal>null</literal>.</entry>
       <entry><literal>json_typeof('-123.4')</literal></entry>
       <entry><literal>number</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_to_record(json)</literal>
          </para><para><literal>jsonb_to_record(jsonb)</literal>
       </para></entry>
       <entry><type>record</type></entry>
       <entry>Формирует обычную запись из объекта JSON (см. примечания ниже). Как и со всеми функциями, возвращающими <type>record</type>, при вызове необходимо явно определить структуру записи с помощью предложения <literal>AS</literal>.</entry>
       <entry><literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text)</literal></entry>
       <entry>
<programlisting> a |    b    | d
---+---------+---
 1 | [1,2,3] |</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_to_recordset(json)</literal>
         </para><para><literal>jsonb_to_recordset(jsonb)</literal>
       </para></entry>
       <entry><type>setof record</type></entry>
       <entry>Формирует обычный набор записей из массива объекта JSON (см. примечания ниже). Как и со всеми функциями, возвращающими <type>record</type>, при вызове необходимо явно определить структуру записи с помощью предложения <literal>AS</literal>.</entry>
       <entry><literal>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</literal></entry>
       <entry>
<programlisting> a |  b
---+-----
 1 | foo
 2 |</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_strip_nulls(from_json json)</literal>
         </para><para><literal>jsonb_strip_nulls(from_json jsonb)</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type></para></entry>
       <entry>Возвращает значение <replaceable>from_json</replaceable>, из которого исключаются все поля объекта, содержащие значения NULL. Другие значения NULL остаются нетронутыми.</entry>
       <entry><literal>json_strip_nulls('[{"f1":1,"f2":null},2,null,3]')</literal></entry>
       <entry><literal>[{"f1":1},2,null,3]</literal></entry>
       </row>
      <row>
       <entry><para><literal>jsonb_set(target jsonb, path text[], new_value jsonb<optional>, <parameter>create_missing</parameter> <type>boolean</type></optional>)</literal>
         </para></entry>
       <entry><para><type>jsonb</type></para></entry>
       <entry>Возвращает значение <replaceable>target</replaceable>, в котором раздел с заданным путём (<replaceable>path</replaceable>) заменяется новым значением (<replaceable>new_value</replaceable>), либо в него добавляется значение <replaceable>new_value</replaceable>, если аргумент <replaceable>create_missing</replaceable> равен <literal>true</literal> (это значение по умолчанию) и элемент, на который ссылается <replaceable>path</replaceable>, не существует. Как и с операторами, рассчитанными на пути, отрицательные числа в пути (<replaceable>path</replaceable>) обозначают отсчёт от конца массивов JSON.</entry>
       <entry><para><literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</literal>
         </para><para><literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}','[2,3,4]')</literal>
         </para></entry>
       <entry><para><literal>[{"f1":[2,3,4],"f2":null},2,null,3]</literal>
         </para><para><literal>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</literal>
        </para></entry>
       </row>
      <row>
       <entry>
           <para><literal>jsonb_insert(target jsonb, path text[], new_value jsonb, <optional><parameter>insert_after</parameter> <type>boolean</type></optional>)</literal></para>
       </entry>
       <entry><para><type>jsonb</type></para></entry>
       <entry>Возвращает значение <replaceable>target</replaceable> с вставленным в него новым значением <replaceable>new_value</replaceable>. Если место в <replaceable>target</replaceable>, выбранное путём <replaceable>path</replaceable>, оказывается в массиве JSONB, <replaceable>new_value</replaceable> будет вставлен до (по умолчанию) или после (если параметр <replaceable>insert_after</replaceable> равен true) выбранной позиции. Если место в <replaceable>target</replaceable>, выбранное путём <replaceable>path</replaceable>, оказывается в объекте JSONB, значение <replaceable>new_value</replaceable> будет вставлено в него, только если заданный путь <replaceable>path</replaceable> не существует. Как и с операторами, рассчитанными на пути, отрицательные числа в пути (<replaceable>path</replaceable>) обозначают отсчёт от конца массивов JSON.</entry>
       <entry>
           <para><literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal></para>
           <para><literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal></para>
       </entry>
       <entry><para><literal>{"a": [0, "new_value", 1, 2]}</literal>
         </para><para><literal>{"a": [0, 1, "new_value", 2]}</literal>
        </para></entry>
       </row>
      <row>
       <entry><para><literal>jsonb_pretty(from_json jsonb)</literal>
         </para></entry>
       <entry><para><type>text</type></para></entry>
       <entry>Возвращает значение <replaceable>from_json</replaceable> в виде текста JSON с отступами.</entry>
       <entry><literal>jsonb_pretty('[{"f1":1,"f2":null},2,null,3]')</literal></entry>
       <entry>
<programlisting>[
    {
        "f1": 1,
        "f2": null
    },
    2,
    null,
    3
]</programlisting>
        </entry>
       </row>
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>Многие из этих функций и операторов преобразуют спецпоследовательности Unicode в JSON-строках в соответствующие одиночные символы. Для входных данных типа <type>jsonb</type> это ничем не грозит, так как преобразование уже выполнено; однако для типа <type>json</type> в результате может произойти ошибка, как отмечено в <xref remap="6" linkend="datatype-json"/>.</para>
  </note>

  <note>
    <para>В <function>json_populate_record</function>, <function>json_populate_recordset</function>, <function>json_to_record</function> и <function>json_to_recordset</function> приведение типов из JSON выполняется <quote>насколько это возможно</quote> и его результаты могут быть не вполне ожидаемыми для некоторых типов. Ключи JSON сопоставляются с идентичными именами столбцов в целевом типе записей. Поля JSON, отсутствующие в целевом типе, в выходные данные не попадают, а целевые столбцы, для которых нет соответствующих полей JSON, будут просто содержать NULL.</para>
  </note>

  <note>
    <para>В <literal>target</literal> должны присутствовать все элементы пути, заданного параметром <literal>path</literal> функций <literal>jsonb_set</literal> и <literal>jsonb_insert</literal>, за исключением последнего. Если <literal>create_missing</literal> равен false, должны присутствовать абсолютно все элементы пути <literal>path</literal>, переданного функции <literal>jsonb_set</literal>. Если это условие не выполняется, значение <literal>target</literal> возвращается неизменённым.</para>
    <para>Если последним элементом пути оказывается ключ объекта, он будет создан в случае отсутствия и получит новое значение. Если последний элемент пути — позиция в массиве, то когда она положительна, целевой элемент отсчитывается слева, а когда отрицательна — справа, то есть <literal>-1</literal> указывает на самый правый элемент и т. д. Если позиция лежит вне диапазона -длина_массива .. длина_массива -1, и параметр create_missing равен true, новое значение добавляется в начало массива, если позиция отрицательна, и в конец, если положительна.</para>
  </note>

  <note>
    <para>Значение <literal>null</literal>, возвращаемое функцией <literal>json_typeof</literal>, не следует путать с SQL NULL. Тогда как при вызове <literal>json_typeof('null'::json)</literal> возвращается <literal>null</literal>, при вызове <literal>json_typeof(NULL::json)</literal> будет возвращено значение SQL NULL.</para>
  </note>

  <note>
    <para>Если аргумент функции <literal>json_strip_nulls</literal> содержит повторяющиеся имена полей в любом объекте, в результате могут проявиться семантические различия, в зависимости от порядка этих полей. Это не проблема для функции <literal>jsonb_strip_nulls</literal>, так как в значениях <type>jsonb</type> имена полей не могут дублироваться.</para>
  </note>

  <para>В <xref remap="6" linkend="functions-aggregate"/> вы также можете узнать об агрегатной функции <function>json_agg</function>, которая агрегирует значения записи в виде JSON, и агрегатной функции <function>json_object_agg</function>, агрегирующей пары значений в объект JSON, а также их аналогах для <type>jsonb</type>, функциях <function>jsonb_agg</function> и <function>jsonb_object_agg</function>.</para>

 </sect1>

 <sect1 id="functions-sequence">
  <title>Функции для работы с последовательностями</title>

  <indexterm><primary>последовательность</primary></indexterm>
  <indexterm><primary>nextval</primary></indexterm>
  <indexterm><primary>currval</primary></indexterm>
  <indexterm><primary>lastval</primary></indexterm>
  <indexterm><primary>setval</primary></indexterm>

  <para>В этом разделе описаны функции для работы с объектами, представляющими <firstterm>последовательности</firstterm>. Такие объекты (также называемыми генераторами последовательностей или просто последовательностями) являются специальными таблицами из одной строки и создаются командой <xref linkend="sql-createsequence"/>. Используются они обычно для получения уникальных идентификаторов строк таблицы. Функции, перечисленные в <xref remap="6" linkend="functions-sequence-table"/>, предоставляют простые и безопасные для параллельного использования методы получения очередных значений таких последовательностей.</para>

   <table id="functions-sequence-table">
    <title>Функции для работы с последовательностями</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Функция</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
        <entry><literal><function>currval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Выдаёт значение заданной последовательности, которое было возвращено при последнем вызове функции <function>nextval</function></entry>
      </row>
      <row>
        <entry><literal><function>lastval()</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Выдаёт значение любой последовательности, которое было возвращено при последнем вызове функции <function>nextval</function></entry>
      </row>
      <row>
        <entry><literal><function>nextval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Продвигает последовательность к следующему значению и возвращает его</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Устанавливает текущее значение последовательности</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>, <type>boolean</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Устанавливает текущее значение последовательности и флаг <literal>is_called</literal>, указывающий на то, что это значение использовалось</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Последовательность, к которой будет обращаться одна из этих функций, определяется аргументом <type>regclass</type>, задающим просто OID последовательности в системном каталоге <structname>pg_class</structname>. Вычислять этот OID вручную не нужно, так как процедура ввода данных <type>regclass</type> автоматически выполнит эту работу за вас. Просто запишите имя последовательности в апострофах, чтобы оно выглядело как строковая константа. Для совместимости с обычными именами <acronym>SQL</acronym> эта строка будет переведена в нижний регистр, если только она не заключена в кавычки. Например: <programlisting>nextval('foo')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>обращается к последовательности <literal>Foo</literal></lineannotation></programlisting> При необходимости имя последовательности можно дополнить именем схемы: <programlisting>nextval('myschema.foo')     <lineannotation>обращается к <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>то же самое</lineannotation>
nextval('foo')              <lineannotation>ищет <literal>foo</literal> в пути поиска</lineannotation></programlisting> Подробнее тип <type>regclass</type> описан в <xref remap="6" linkend="datatype-oid"/>.</para>

  <note>
   <para>В <productname>PostgreSQL</productname> до версии 8.1 аргументы этих функций имели тип <type>text</type>, а не <type>regclass</type>, и поэтому описанное выше преобразование текстовой строки в OID имело место при каждом вызове функции. Это поведение сохраняется и сейчас для обратной совместимости, но сейчас оно реализовано как неявное приведение типа <type>text</type> к типу <type>regclass</type> перед вызовом функции.</para>

   <para>Когда вы записываете аргумент функции, работающей с последовательностью, как текстовую строку в чистом виде, она становится константой типа <type>regclass</type>. Так как фактически это будет просто значение OID, оно будет привязано к изначально идентифицированной последовательности, несмотря на то, что она может быть переименована, перенесена в другую схему и т. д. Такое <quote>раннее связывание</quote> обычно желательно для ссылок на последовательности в значениях столбцов по умолчанию и представлениях. Но иногда возникает необходимость в <quote>позднем связывании</quote>, когда ссылки на последовательности распознаются в процессе выполнения. Чтобы получить такое поведение, нужно принудительно изменить тип константы с <type>regclass</type> на <type>text</type>: <programlisting>nextval('foo'::text)      <lineannotation><literal>foo</literal> распознаётся во время выполнения</lineannotation></programlisting> Заметьте, что версии <productname>PostgreSQL</productname> до 8.1 поддерживали только позднее связывание, так что это может быть полезно и для совместимости со старыми приложениями.</para>

   <para>Конечно же, аргументом таких функций может быть не только константа, но и выражение. Если это выражение текстового типа, неявное приведение типов повлечёт разрешение имени во время выполнения.</para>
  </note>

  <para>Ниже описаны все функции, предназначенные для работы с последовательностями: <variablelist>
     <varlistentry>
      <term><function>nextval</function></term>
      <listitem>
       <para>Продвигает последовательность к следующему значению и возвращает его. Это атомарная операция: если <function>nextval</function> вызывается одновременно в нескольких сеансах, в результате каждого вызова будут гарантированно получены разные значения.</para>

       <para>Если последовательность создаётся с параметрами по умолчанию, успешные вызовы <function>nextval</function> получают очередные значения по возрастанию, начиная с 1. Другое поведение можно получить с помощью специальных параметров в команде <xref linkend="sql-createsequence"/>; подробнее это описано на странице описания команды.</para>

       <important>
        <para>Во избежание блокирования параллельных транзакций, пытающихся получить значения одной последовательности, операция <function>nextval</function> никогда не откатывается; то есть, как только значение было выбрано, оно считается использованным и не будет возвращено снова. Это утверждение верно, даже когда окружающая транзакция впоследствии прерывается или вызывающий запрос никак не использует это значение. Например, команда <command>INSERT</command> с предложением <literal>ON CONFLICT</literal> вычислит кортеж, претендующий на добавление, произведя все требуемые вызовы <function>nextval</function>, прежде чем выявит конфликты, которые могут привести к отработке правил <literal>ON CONFLICT</literal> вместо добавления. В таких ситуациях в последовательности задействованных значений могут образовываться <quote>дыры</quote>. Таким образом, объекты последовательностей <productname>PostgreSQL</productname> <emphasis>не годятся для получения непрерывных последовательностей</emphasis>.</para>
       </important>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>currval</function></term>
      <listitem>
       <para>Возвращает значение, выданное при последнем вызове <function>nextval</function> для этой последовательности в текущем сеансе. (Если в данном сеансе <function>nextval</function> ни разу не вызывалась для данной последовательности, возвращается ошибка.) Так как это значение ограничено рамками сеанса, эта функция выдаёт предсказуемый результат вне зависимости от того, вызвалась ли впоследствии <function>nextval</function> в других сеансах или нет.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>lastval</function></term>
      <listitem>
       <para>Возвращает значение, выданное при последнем вызове <function>nextval</function> в текущем сеансе. Эта функция подобна <function>currval</function>, но она не принимает в параметрах имя последовательности, а обращается к той последовательности, для которой вызывалась <function>nextval</function> в последний раз в текущем сеансе. Если в текущем сеансе функция <function>nextval</function> ещё не вызывалась, при вызове <function>lastval</function> произойдёт ошибка.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>setval</function></term>
      <listitem>
       <para>Сбрасывает счётчик последовательности. В форме с двумя параметрами устанавливает для последовательности заданное значение поля <literal>last_value</literal> и значение <literal>true</literal> для флага <literal>is_called</literal>, показывающего, что при следующем вызове <function>nextval</function> последовательность должна сначала продвинуться к очередному значению, которое будет возвращено. При этом <function>currval</function> также возвратит заданное значение. В форме с тремя параметрами флагу <literal>is_called</literal> можно присвоить <literal>true</literal> или <literal>false</literal>. Со значением <literal>true</literal> она действует так же, как и форма с двумя параметрами. Если же присвоить этому флагу значение <literal>false</literal>, первый вызов <function>nextval</function> после этого вернёт именно заданное значение, а продвижение последовательности произойдёт при последующем вызове <function>nextval</function>. Кроме того, значение, возвращаемое <function>currval</function> в этом случае, не меняется. Например, <screen>
SELECT setval('foo', 42);           <lineannotation>Следующий вызов <function>nextval</function> вернёт 43</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>То же самое</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>Следующий вызов <function>nextval</function> вернёт 42</lineannotation>
</screen> Результатом самой функции <function>setval</function> будет просто значение её второго аргумента.</para>
       <important>
        <para>Так как значения последовательностей изменяются вне транзакций, действие функции <function>setval</function> не отменяется при откате транзакции.</para>
       </important>
      </listitem>
     </varlistentry>
    </variablelist></para>

 </sect1>


 <sect1 id="functions-conditional">
  <title>Условные выражения</title>

  <indexterm><primary>CASE</primary></indexterm>

  <indexterm><primary>условное выражение</primary></indexterm>

  <para>В этом разделе описаны <acronym>SQL</acronym>-совместимые условные выражения, которые поддерживаются в <productname>&productname;</productname>.</para>

  <tip>
   <para>Если возможностей этих условных выражений оказывается недостаточно, вероятно, имеет смысл перейти к написанию хранимых процедур на более мощном языке программирования.</para>
  </tip>

  <sect2 id="functions-case">
   <title><literal>CASE</literal></title>

  <para>Выражение <token>CASE</token> в <acronym>SQL</acronym> представляет собой общее условное выражение, напоминающее операторы if/else в других языках программирования: <synopsis>
CASE WHEN <replaceable>условие</replaceable> THEN <replaceable>результат</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>результат</replaceable></optional>
END
</synopsis>Предложения <token>CASE</token> можно использовать везде, где допускаются выражения. Каждое <replaceable>условие</replaceable> в нём представляет собой выражение, возвращающее результат типа <type>boolean</type>. Если результатом выражения оказывается true, значением выражения <token>CASE</token> становится <replaceable>результат</replaceable>, следующий за условием, а остальная часть выражения <token>CASE</token> не вычисляется. Если же условие не выполняется, за ним таким же образом проверяются все последующие предложения <token>WHEN</token>. Если не выполняется ни одно из <replaceable>условий</replaceable> <token>WHEN</token>, значением <token>CASE</token> становится <replaceable>результат</replaceable>, записанный в предложении <token>ELSE</token>. Если при этом предложение <token>ELSE</token> отсутствует, результатом выражения будет NULL.</para>

   <para>Пример: <screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen></para>

  <para>Типы данных всех выражений <replaceable>результатов</replaceable> должны приводиться к одному выходному типу. Подробнее это описано в <xref remap="6" linkend="typeconv-union-case"/>.</para>

  <para>Существует также <quote>простая</quote> форма выражения <token>CASE</token>, разновидность вышеприведённой общей формы: <synopsis>
CASE <replaceable>выражение</replaceable>
    WHEN <replaceable>значение</replaceable> THEN <replaceable>результат</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>результат</replaceable></optional>
END
</synopsis> В такой форме сначала вычисляется первое <replaceable>выражение</replaceable>, а затем его результат сравнивается с выражениями <replaceable>значений</replaceable> в предложениях <token>WHEN</token>, пока не будет найдено равное ему. Если такого не значения не находится, возвращается <replaceable>результат</replaceable> предложения <token>ELSE</token> (или NULL). Эта форма больше похожа на оператор <function>switch</function>, существующий в языке C.</para>

   <para>Показанный ранее пример можно записать по-другому, используя простую форму <token>CASE</token>: <screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen></para>

   <para>В выражении <token>CASE</token> вычисляются только те подвыражения, которые необходимы для получения результата. Например, так можно избежать ошибки деления на ноль: <programlisting>SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;</programlisting></para>

   <note>
    <para>Как было описано в <xref remap="6" linkend="syntax-express-eval"/>, всё же возможны ситуации, когда подвыражения вычисляются на разных этапах, так что железной гарантии, что в <quote><token>CASE</token> вычисляются только необходимые подвыражения</quote>, в принципе нет. Например, константное подвыражение <literal>1/0</literal> обычно вызывает ошибку деления на ноль на этапе планирования, хотя эта ветвь <token>CASE</token> может вовсе не вычисляться во время выполнения.</para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</literal></title>

  <indexterm><primary>COALESCE</primary></indexterm>

  <indexterm><primary>NVL</primary></indexterm>

  <indexterm><primary>IFNULL</primary></indexterm>

<synopsis><function>COALESCE</function>(<replaceable>значение</replaceable> <optional>, ...</optional>)</synopsis>

  <para>Функция <function>COALESCE</function> возвращает первый попавшийся аргумент, отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет NULL. Это часто используется при отображении данных для подстановки некоторого значения по умолчанию вместо значений NULL: <programlisting>SELECT COALESCE(description, short_description, '(none)') ...</programlisting> Этот запрос вернёт значение <varname>description</varname>, если оно не равно NULL, либо <varname>short_description</varname>, если оно не NULL, и строку <literal>(none)</literal>, если оба эти значения равны NULL.</para>

   <para>Как и выражение <token>CASE</token>, <function>COALESCE</function> вычисляет только те аргументы, которые необходимы для получения результата; то есть, аргументы правее первого отличного от NULL аргумента не вычисляются. Эта функция соответствует стандарту SQL, а в некоторых других СУБД её аналоги называются <function>NVL</function> и <function>IFNULL</function>.</para>
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</literal></title>

  <indexterm><primary>NULLIF</primary></indexterm>

<synopsis><function>NULLIF</function>(<replaceable>значение1</replaceable>, <replaceable>значение2</replaceable>)</synopsis>

  <para>Функция <function>NULLIF</function> возвращает значение NULL, если <replaceable>значение1</replaceable> равно <replaceable>значение2</replaceable>; в противном случае она возвращает <replaceable>значение1</replaceable>. Это может быть полезно для реализации обратной операции к <function>COALESCE</function>. В частности, для примера, показанного выше: <programlisting>SELECT NULLIF(value, '(none)') ...</programlisting></para>
  <para>Если аргумент <literal>value</literal> равен <literal>(none)</literal>, результатом выражения будет NULL, а в противном случае &mdash; значение аргумента <literal>value</literal>.</para>

  </sect2>

  <sect2 id="functions-greatest-least">
   <title><literal>GREATEST</literal> и <literal>LEAST</literal></title>

  <indexterm><primary>GREATEST</primary></indexterm>
  <indexterm><primary>LEAST</primary></indexterm>

<synopsis><function>GREATEST</function>(<replaceable>значение</replaceable> <optional>, ...</optional>)</synopsis>
<synopsis><function>LEAST</function>(<replaceable>значение</replaceable> <optional>, ...</optional>)</synopsis>

   <para>Функции <function>GREATEST</function> и <function>LEAST</function> выбирают наибольшее или наименьшее значение из списка выражений. Все эти выражения должны приводиться к общему типу данных, который станет типом результата (подробнее об этом в <xref remap="6" linkend="typeconv-union-case"/>). Значения NULL в этом списке игнорируются, так что результат выражения будет равен NULL, только если все его аргументы равны NULL.</para>

   <para>Заметьте, что функции <function>GREATEST</function> и <function>LEAST</function> не описаны в стандарте SQL, но часто реализуются в СУБД как расширения. В некоторых других СУБД они могут возвращать NULL, когда не все, а любой из аргументов равен NULL.</para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
  <title>Функции и операторы для работы с массивами</title>

  <para>В <xref remap="6" linkend="array-operators-table"/> показаны операторы, предназначенные для работы с массивами.</para>

    <table id="array-operators-table">
     <title>Операторы для работы с массивами</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>равно</entry>
        <entry><literal>ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>не равно</entry>
        <entry><literal>ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>меньше</entry>
        <entry><literal>ARRAY[1,2,3] &lt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>больше</entry>
        <entry><literal>ARRAY[1,4,3] &gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>меньше или равно</entry>
        <entry><literal>ARRAY[1,2,3] &lt;= ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>больше или равно</entry>
        <entry><literal>ARRAY[1,4,3] &gt;= ARRAY[1,4,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>содержит</entry>
        <entry><literal>ARRAY[1,4,3] @&gt; ARRAY[3,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>содержится в</entry>
        <entry><literal>ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>пересечение (есть общие элементы)</entry>
        <entry><literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>соединение массива с массивом</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{1,2,3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>соединение массива с массивом</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[[4,5,6], [7,8,9]]</literal></entry>
        <entry><literal>{{1,2,3},{4,5,6},{7,8,9}}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>соединение элемента с массивом</entry>
        <entry><literal>3 || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>соединение массива с элементом</entry>
        <entry><literal>ARRAY[4,5,6] || 7</literal></entry>
        <entry><literal>{4,5,6,7}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>Операторы сравнения массивов сравнивают содержимое массивов по элементам, используя при этом функцию сравнения для B-дерева, определённую для типа данного элемента по умолчанию. В многомерных массивах элементы просматриваются по строкам (индекс последней размерности меняется в первую очередь). Если содержимое двух массивов совпадает, а размерности различаются, результат их сравнения будет определяться первым отличием в размерностях. (В <productname>PostgreSQL</productname> до версии 8.2 поведение было другим: два массива с одинаковым содержимом считались одинаковыми, даже если число их размерностей и границы индексов различались.)</para>

  <para>Подробнее поведение операторов с массивами описано в <xref remap="6" linkend="arrays"/>. За дополнительными сведениями об операторах, поддерживающих индексы, обратитесь к <xref remap="3" linkend="indexes-types"/>.</para>

  <para>В <xref remap="6" linkend="array-functions-table"/> перечислены функции, предназначенные для работы с массивами. Дополнительная информация о них и примеры использования приведены в <xref remap="6" linkend="arrays"/>.</para>

  <indexterm><primary>array_append</primary></indexterm>
  <indexterm><primary>array_cat</primary></indexterm>
  <indexterm><primary>array_ndims</primary></indexterm>
  <indexterm><primary>array_dims</primary></indexterm>
  <indexterm><primary>array_fill</primary></indexterm>
  <indexterm><primary>array_length</primary></indexterm>
  <indexterm><primary>array_lower</primary></indexterm>
  <indexterm><primary>array_position</primary></indexterm>
  <indexterm><primary>array_positions</primary></indexterm>
  <indexterm><primary>array_prepend</primary></indexterm>
  <indexterm><primary>array_remove</primary></indexterm>
  <indexterm><primary>array_replace</primary></indexterm>
  <indexterm><primary>array_to_string</primary></indexterm>
 <indexterm><primary>array_upper</primary></indexterm>
  <indexterm><primary>cardinality</primary></indexterm>
  <indexterm><primary>string_to_array</primary></indexterm>
  <indexterm><primary>unnest</primary></indexterm>

    <table id="array-functions-table">
     <title>Функции для работы с массивами</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal><function>array_append</function>(<type>anyarray</type>, <type>anyelement</type>)</literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>добавляет элемент в конец массива</entry>
        <entry><literal>array_append(ARRAY[1,2], 3)</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_cat</function>(<type>anyarray</type>, <type>anyarray</type>)</literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>соединяет два массива</entry>
        <entry><literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal></entry>
        <entry><literal>{1,2,3,4,5}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_ndims</function>(<type>anyarray</type>)</literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>возвращает число размерностей массива</entry>
        <entry><literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_dims</function>(<type>anyarray</type>)</literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>возвращает текстовое представление размерностей массива</entry>
        <entry><literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>[1:2][1:3]</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_fill</function>(<type>anyelement</type>, <type>int[]</type>, <optional>, <type>int[]</type></optional>)</literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>возвращает массив, заполненный заданным значением и имеющий указанные размерности, в которых нижняя граница может быть отлична от 1</entry>
        <entry><literal>array_fill(7, ARRAY[3], ARRAY[2])</literal></entry>
        <entry><literal>[2:4]={7,7,7}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_length</function>(<type>anyarray</type>, <type>int</type>)</literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>возвращает длину указанной размерности массива</entry>
        <entry><literal>array_length(array[1,2,3], 1)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_lower</function>(<type>anyarray</type>, <type>int</type>)</literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>возвращает нижнюю границу указанной размерности массива</entry>
        <entry><literal>array_lower('[0:2]=&#8203;{1,2,3}'::int[], 1)</literal></entry>
        <entry><literal>0</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_position</function>(<type>anyarray</type>, <type>anyelement</type> <optional>, <type>int</type></optional>)</literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>возвращает позицию первого вхождения второго аргумента в массиве, начиная с элемента, выбираемого третьим аргументом, либо с первого элемента (массив должен быть одномерным)</entry>
        <entry><literal>array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_positions</function>(<type>anyarray</type>, <type>anyelement</type>)</literal>
        </entry>
        <entry><type>int[]</type></entry>
        <entry>возвращает массив с позициями всех вхождений второго аргумента в массиве, задаваемым первым аргументом (массив должен быть одномерным)</entry>
        <entry><literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal></entry>
        <entry><literal>{1,2,4}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_prepend</function>(<type>anyelement</type>, <type>anyarray</type>)</literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>вставляет элемент в начало массива</entry>
        <entry><literal>array_prepend(1, ARRAY[2,3])</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_remove</function>(<type>anyarray</type>, <type>anyelement</type>)</literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>удаляет из массива все элементы, равные заданному значению (массив должен быть одномерным)</entry>
        <entry><literal>array_remove(ARRAY[1,2,3,2], 2)</literal></entry>
        <entry><literal>{1,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_replace</function>(<type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type>)</literal>
        </entry>
        <entry><type>anyarray</type></entry>
        <entry>заменяет в массиве все элементы, равные заданному значению, другим значением</entry>
        <entry><literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal></entry>
        <entry><literal>{1,2,3,4}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_to_string</function>(<type>anyarray</type>, <type>text</type> <optional>, <type>text</type></optional>)</literal>
        </entry>
        <entry><type>text</type></entry>
        <entry>выводит элементы массива через заданный разделитель и позволяет определить замену для значения NULL</entry>
        <entry><literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal></entry>
        <entry><literal>1,2,3,*,5</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>array_upper</function>(<type>anyarray</type>, <type>int</type>)</literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>возвращает верхнюю границу указанной размерности массива</entry>
        <entry><literal>array_upper(ARRAY[1,8,3,7], 1)</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>cardinality</function>(<type>anyarray</type>)</literal>
        </entry>
        <entry><type>int</type></entry>
        <entry>возвращает общее число элементов в массиве, либо 0, если массив пуст</entry>
        <entry><literal>cardinality(ARRAY[[1,2],[3,4]])</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>string_to_array</function>(<type>text</type>, <type>text</type> <optional>, <type>text</type></optional>)</literal>
        </entry>
        <entry><type>text[]</type></entry>
        <entry>разбивает строку на элементы массива, используя заданный разделитель и, возможно, замену для значений NULL</entry>
        <entry><literal>string_to_array('xx~^~yy~&#8203;^~zz', '~^~', 'yy')</literal></entry>
        <entry><literal>{xx,NULL,zz}</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>unnest</function>(<type>anyarray</type>)</literal>
        </entry>
        <entry><type>setof anyelement</type></entry>
        <entry>разворачивает массив в набор строк</entry>
        <entry><literal>unnest(ARRAY[1,2])</literal></entry>
        <entry><literallayout class="monospaced">1
2</literallayout>(2 строки)</entry>
       </row>
       <row>
        <entry>
         <literal><function>unnest</function>(<type>anyarray</type>, <type>anyarray</type> [, ...])</literal>
        </entry>
        <entry><type>setof anyelement, anyelement [, ...]</type></entry>
        <entry>разворачивает массивы (возможно разных типов) в набор строк. Это допускается только в предложении FROM; см. <xref remap="4" linkend="queries-tablefunctions"/></entry>
        <entry><literal>unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])</literal></entry>
        <entry><literallayout class="monospaced">1    foo
2    bar
NULL baz</literallayout>(3 строки)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>В функциях <function>array_position</function> и <function>array_positions</function> каждый элемент массива сравнивается с искомым значением по принципу <literal>IS NOT DISTINCT FROM</literal>.</para>

   <para>Функция <function>array_position</function> возвращает <literal>NULL</literal>, если искомое значение не находится.</para>

   <para>Функция <function>array_positions</function> возвращает <literal>NULL</literal>, только если в качестве массива передаётся <literal>NULL</literal>; если же в массиве не находится значение, она возвращает пустой массив.</para>

   <para>Если для функции <function>string_to_array</function> в качестве разделителя задан NULL, каждый символ входной строки станет отдельным элементов в полученном массиве. Если разделитель пустая строка, строка будет возвращена целиком в массиве из одного элемента. В противном случае входная строка разбивается по вхождениям подстроки, указанной в качестве разделителя.</para>

   <para>Если для функции <function>string_to_array</function> параметр замены значения NULL опущен или равен NULL, никакие подстроки во входных данных не будут заменяться на NULL. Если же параметр замены NULL опущен или равен NULL для функции <function>array_to_string</function>, все значения NULL просто пропускаются и никак не представляются в выходной строке.</para>

   <note>
    <para>В поведении <function>string_to_array</function> по сравнению с <productname>PostgreSQL</productname> версий до 9.1 произошли два изменения. Во-первых, эта функция возвращает пустой массив (содержащий 0 элементов), а не NULL, когда входная строка имеет нулевую длину. Во-вторых, если в качестве разделителя задан NULL, эта функция разбивает строку по символам, а не просто возвращает NULL, как было раньше.</para>
   </note>

   <para>Вы также можете узнать об агрегатной функции, работающей с массивами, <function>array_agg</function> в <xref remap="6" linkend="functions-aggregate"/>.</para>
  </sect1>

 <sect1 id="functions-range">
  <title>Диапазонные функции и операторы</title>

  <para>Диапазонные типы данных рассматриваются в <xref remap="6" linkend="rangetypes"/>.</para>

  <para>В <xref remap="6" linkend="range-operators-table"/> показаны операторы, предназначенные для работы с диапазонами.</para>

    <table id="range-operators-table">
     <title>Диапазонные операторы</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Оператор</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>равно</entry>
        <entry><literal>int4range(1,5) = '[1,4]'::int4range</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>не равно</entry>
        <entry><literal>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>меньше</entry>
        <entry><literal>int4range(1,10) &lt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>больше</entry>
        <entry><literal>int4range(1,10) &gt; int4range(1,5)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>меньше или равно</entry>
        <entry><literal>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>больше или равно</entry>
        <entry><literal>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>содержит диапазон</entry>
        <entry><literal>int4range(2,4) @&gt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry>содержит элемент</entry>
        <entry><literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>диапазон содержится в</entry>
        <entry><literal>int4range(2,4) &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry>элемент содержится в</entry>
        <entry><literal>42 &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>пересекает (есть общие точки)</entry>
        <entry><literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>строго слева от</entry>
        <entry><literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>строго справа от</entry>
        <entry><literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <entry>не простирается правее</entry>
        <entry><literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <entry>не простирается левее</entry>
        <entry><literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>-|-</literal> </entry>
        <entry>примыкает к</entry>
        <entry><literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry>union</entry>
        <entry><literal>numrange(5,15) + numrange(10,20)</literal></entry>
        <entry><literal>[5,20)</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry>пересечение</entry>
        <entry><literal>int8range(5,15) * int8range(10,20)</literal></entry>
        <entry><literal>[10,15)</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry>вычитание</entry>
        <entry><literal>int8range(5,15) - int8range(10,20)</literal></entry>
        <entry><literal>[5,10)</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

  <para>Простые операторы сравнения <literal>&lt;</literal>, <literal>&gt;</literal>, <literal>&lt;=</literal> и <literal>&gt;=</literal> сначала сравнивают нижние границы, и только если они равны, сравнивают верхние. Эти операторы сравнения обычно не очень полезны для диапазонов; основное их предназначение &mdash; сделать возможным построение индексов-B-деревьев по диапазонам.</para>

  <para>Операторы слева/справа/примыкает всегда возвращают false, если один из диапазонов пуст; то есть, считается, что пустой диапазон находится не слева и не справа от какого-либо другого диапазона.</para>

  <para>Операторы сложения и вычитания вызывают ошибку, если получающийся в результате диапазон оказывается состоящим из двух разделённых поддиапазонов, так как его нельзя представить в этом типе данных.</para>

  <para>В <xref remap="6" linkend="range-functions-table"/> перечислены функции, предназначенные для работы с диапазонными типами.</para>

  <indexterm><primary>lower</primary></indexterm>
  <indexterm><primary>upper</primary></indexterm>
  <indexterm><primary>isempty</primary></indexterm>
  <indexterm><primary>lower_inc</primary></indexterm>
  <indexterm><primary>upper_inc</primary></indexterm>
  <indexterm><primary>lower_inf</primary></indexterm>
  <indexterm><primary>upper_inf</primary></indexterm>

    <table id="range-functions-table">
     <title>Диапазонные функции</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Функция</entry>
        <entry>Тип результата</entry>
        <entry>Описание</entry>
        <entry>Пример</entry>
        <entry>Результат</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal><function>lower</function>(<type>anyrange</type>)</literal>
        </entry>
        <entry>тип элемента диапазона</entry>
        <entry>нижняя граница диапазона</entry>
        <entry><literal>lower(numrange(1.1, 2.2))</literal></entry>
        <entry><literal>1.1</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>upper</function>(<type>anyrange</type>)</literal>
        </entry>
        <entry>тип элемента диапазона</entry>
        <entry>верхняя граница диапазона</entry>
        <entry><literal>upper(numrange(1.1, 2.2))</literal></entry>
        <entry><literal>2.2</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>isempty</function>(<type>anyrange</type>)</literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>диапазон пуст?</entry>
        <entry><literal>isempty(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>lower_inc</function>(<type>anyrange</type>)</literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>нижняя граница включается?</entry>
        <entry><literal>lower_inc(numrange(1.1, 2.2))</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>upper_inc</function>(<type>anyrange</type>)</literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>верхняя граница включается?</entry>
        <entry><literal>upper_inc(numrange(1.1, 2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>lower_inf</function>(<type>anyrange</type>)</literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>нижняя граница равна бесконечности?</entry>
        <entry><literal>lower_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>upper_inf</function>(<type>anyrange</type>)</literal>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>верхняя граница равна бесконечности?</entry>
        <entry><literal>upper_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>range_merge</function>(<type>anyrange</type>, <type>anyrange</type>)</literal>
        </entry>
        <entry><type>anyrange</type></entry>
        <entry>наименьший диапазон, включающий оба заданных диапазона</entry>
        <entry><literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal></entry>
        <entry><literal>[1,4)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>Функции <function>lower</function> и <function>upper</function> возвращают NULL, если диапазон пуст или указанная граница равна бесконечности. Если же пустой диапазон передаётся функциям <function>lower_inc</function>, <function>upper_inc</function>, <function>lower_inf</function> и <function>upper_inf</function>, все они возвращают false.</para>
  </sect1>

 <sect1 id="functions-aggregate">
  <title>Агрегатные функции</title>

  <indexterm zone="functions-aggregate"><primary>агрегатные функции</primary> <secondary>встроенные</secondary></indexterm>

  <para><firstterm>Агрегатные функции</firstterm> получают единственный результат из набора входных значений. Встроенные обычные агрегатные функции перечислены в <xref remap="6" linkend="functions-aggregate-table"/> и <xref remap="6" linkend="functions-aggregate-statistics-table"/>, а сортирующие агрегатные функции &mdash; в <xref remap="6" linkend="functions-orderedset-table"/> и <xref remap="6" linkend="functions-hypothetical-table"/>. Операции группирования, тесно связанные с агрегатными функциями, перечислены в <xref remap="6" linkend="functions-grouping-table"/>. Особенности синтаксиса агрегатных функций разъясняются в <xref remap="6" linkend="syntax-aggregates"/>. За дополнительной вводной информацией обратитесь к <xref remap="3" linkend="tutorial-agg"/>.</para>

  <table id="functions-aggregate-table">
   <title>Агрегатные функции общего назначения</title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Типы аргумента</entry>
      <entry>Тип результата</entry>
      <entry>Частичный режим</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm><primary>array_agg</primary></indexterm>
       <function>array_agg(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>любой тип не массива</entry>
      <entry>массив элементов с типом аргумента</entry>
      <entry>Нет</entry>
      <entry>входные значения, включая NULL, объединяются в массив</entry>
     </row>

     <row>
      <entry>
       <function>array_agg(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>любой тип массива</entry>
      <entry>тот же, что и тип аргумента</entry>
      <entry>Нет</entry>
      <entry>входные массивы собираются в массив большей размерности (они должны иметь одну размерность и не могут быть пустыми или равны NULL)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>среднее</primary></indexterm>
       <indexterm><primary>avg</primary></indexterm>
       <function>avg(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type>, <type>numeric</type> или <type>interval</type></entry>
      <entry><type>numeric</type> для любых целочисленных аргументов, <type>double precision</type> для аргументов с плавающей точкой, в противном случае тип данных аргумента</entry>
      <entry>Да</entry>
      <entry>арифметическое среднее для всех входных значений</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>bit_and</primary></indexterm>
       <function>bit_and(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type> или <type>bit</type></entry>
      <entry>тот же, что и тип аргумента</entry>
      <entry>Да</entry>
      <entry>побитовое И для всех входных значений, не равных NULL, или NULL, если таких нет</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>bit_or</primary></indexterm>
       <function>bit_or(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type> или <type>bit</type></entry>
      <entry>тот же, что и тип аргумента</entry>
      <entry>Да</entry>
      <entry>побитовое ИЛИ для всех входных значений, не равных NULL, или NULL, если таких нет</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>bool_and</primary></indexterm>
       <function>bool_and(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Да</entry>
      <entry>true, если все входные значения равны true, и false в противном случае</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>bool_or</primary></indexterm>
       <function>bool_or(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Да</entry>
      <entry>true, если хотя бы одно входное значение равно true, и false в противном случае</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>count</primary></indexterm>
       <function>count(*)</function>
      </entry>
      <entry/>
      <entry><type>bigint</type></entry>
      <entry>Да</entry>
      <entry>количество входных строк</entry>
     </row>

     <row>
      <entry><function>count(<replaceable class="parameter">выражение</replaceable>)</function></entry>
      <entry>any</entry>
      <entry><type>bigint</type></entry>
      <entry>Да</entry>
      <entry>количество входных строк, для которых значение <replaceable class="parameter">выражения</replaceable> не равно NULL</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>every</primary></indexterm>
       <function>every(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>Да</entry>
      <entry>синоним <function>bool_and</function></entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>json_agg</primary></indexterm>
       <function>json_agg(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>Нет</entry>
      <entry>агрегирует значения в виде массива JSON</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>jsonb_agg</primary></indexterm>
       <function>jsonb_agg(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>Нет</entry>
      <entry>агрегирует значения в виде массива JSON</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>json_object_agg</primary></indexterm>
       <function>json_object_agg(<replaceable class="parameter">имя</replaceable>, <replaceable class="parameter">значение</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
      <entry>Нет</entry>
      <entry>агрегирует пары имя/значение в виде объекта JSON</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>jsonb_object_agg</primary></indexterm>
       <function>jsonb_object_agg(<replaceable class="parameter">имя</replaceable>, <replaceable class="parameter">значение</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
      <entry>Нет</entry>
      <entry>агрегирует пары имя/значение в виде объекта JSON</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>max</primary></indexterm>
       <function>max(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>любой числовой, строковый, сетевой тип или тип даты/времени, либо массив этих типов</entry>
      <entry>тот же, что и тип аргумента</entry>
      <entry>Да</entry>
      <entry>максимальное значение <replaceable class="parameter">выражения</replaceable> среди всех входных данных</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>min</primary></indexterm>
       <function>min(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>любой числовой, строковый, сетевой тип или тип даты/времени, либо массив этих типов</entry>
      <entry>тот же, что и тип аргумента</entry>
      <entry>Да</entry>
      <entry>минимальное значение <replaceable class="parameter">выражения</replaceable> среди всех входных данных</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>string_agg</primary></indexterm>
       <function>string_agg(<replaceable class="parameter">выражение</replaceable>, <replaceable class="parameter">разделитель</replaceable>)</function>
      </entry>
      <entry>(<type>text</type>, <type>text</type>) или (<type>bytea</type>, <type>bytea</type>)</entry>
      <entry>тот же, что и типы аргументов</entry>
      <entry>Нет</entry>
      <entry>входные данные складываются в строку через заданный разделитель</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>sum</primary></indexterm>
       <function>sum(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type>, <type>numeric</type>, <type>interval</type> или <type>money</type></entry>
      <entry><type>bigint</type> для аргументов <type>smallint</type> или <type>int</type>, <type>numeric</type> для аргументов <type>bigint</type>, и тип аргумента в остальных случаях</entry>
      <entry>Да</entry>
      <entry>сумма значений <replaceable class="parameter">выражения</replaceable> по всем входным данным</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>xmlagg</primary></indexterm>
       <function>xmlagg(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>Нет</entry>
      <entry>соединение XML-значений (см. также <xref remap="4" linkend="functions-xml-xmlagg"/>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Следует заметить, что за исключением <function>count</function>, все эти функции возвращают NULL, если для них не была выбрана ни одна строка. В частности, функция <function>sum</function>, не получив строк, возвращает NULL, а не 0, как можно было бы ожидать, и <function>array_agg</function> в этом случае возвращает NULL, а не пустой массив. Если необходимо, подставить в результат 0 или пустой массив вместо NULL можно с помощью функции <function>coalesce</function>.</para>

  <para>Агрегатные функции, поддерживающие <firstterm>частичный режим</firstterm>, являются кандидатами на участие в различных оптимизациях, например, в параллельном агрегировании.</para>

  <note>
    <indexterm><primary>ANY</primary></indexterm>
    <indexterm><primary>SOME</primary></indexterm>
    <para>Булевы агрегатные функции <function>bool_and</function> и <function>bool_or</function> соответствуют стандартным SQL-агрегатам <function>every</function> и <function>any</function> или <function>some</function>. Что касается <function>any</function> и <function>some</function>, по стандарту их синтаксис допускает некоторую неоднозначность: <programlisting>SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;</programlisting> Здесь <function>ANY</function> можно рассматривать и как объявление подзапроса, и как агрегатную функцию, если этот подзапрос возвращает одну строку с булевым значением. Таким образом, этим агрегатным функциям нельзя было дать стандартные имена.</para>
  </note>

  <note>
   <para>Пользователи с опытом использования других СУБД SQL могут быть недовольны скоростью агрегатной функции <function>count</function>, когда она применяется ко всей таблице. Подобный запрос: <programlisting>SELECT count(*) FROM sometable;</programlisting> потребует затрат в количестве, пропорциональном размеру таблицы: <productname>&productname;</productname> придётся полностью просканировать либо всю таблицу, либо один из индексов, включающий все её строки.</para>
  </note>

  <para>Агрегатные функции <function>array_agg</function>, <function>json_agg</function>, <function>jsonb_agg</function>, <function>json_object_agg</function>, <function>jsonb_object_agg</function>, <function>string_agg</function> и <function>xmlagg</function> так же, как и подобные пользовательские агрегатные функции, выдают разные по содержанию результаты в зависимости от порядка входных значений. По умолчанию порядок не определён, но его можно задать, дополнив вызов агрегатной функции предложением <literal>ORDER BY</literal>, как описано в <xref remap="6" linkend="syntax-aggregates"/>. Обычно нужного результата также можно добиться, передав для агрегирования результат подзапроса с сортировкой. Например: <screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen> Но учтите, что этот подход может не работать, если на внешнем уровне запроса выполняется дополнительная обработка, например, соединение, так как при этом результат подзапроса может быть переупорядочен перед вычислением агрегатной функции.</para>

  <para>В <xref remap="6" linkend="functions-aggregate-statistics-table"/> перечислены агрегатные функции, обычно применяемые в статистическом анализе. (Они выделены просто для того, чтобы не загромождать список наиболее популярных агрегатных функций.) В их описании под <replaceable class="parameter">N</replaceable> подразумевается число входных строк, для которых входные выражения не равны NULL. Все эти функции возвращают NULL во всех случаях, когда вычисление бессмысленно, например, когда <replaceable class="parameter">N</replaceable> равно 0.</para>

  <indexterm><primary>статистика</primary></indexterm>
  <indexterm><primary>линейная регрессия</primary></indexterm>

  <table id="functions-aggregate-statistics-table">
   <title>Агрегатные функции для статистических вычислений</title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип аргумента</entry>
      <entry>Тип результата</entry>
      <entry>Частичный режим</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm><primary>корреляция</primary></indexterm>
       <indexterm><primary>corr</primary></indexterm>
       <function>corr(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>коэффициент корреляции</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>ковариация</primary> <secondary>совокупности</secondary></indexterm>
       <indexterm><primary>covar_pop</primary></indexterm>
       <function>covar_pop(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>ковариация совокупности</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>ковариация</primary> <secondary>выборки</secondary></indexterm>
       <indexterm><primary>covar_samp</primary></indexterm>
       <function>covar_samp(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>ковариация выборки</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>regr_avgx</primary></indexterm>
       <function>regr_avgx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>среднее независимой переменной (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>regr_avgy</primary></indexterm>
       <function>regr_avgy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>среднее зависимой переменной (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>regr_count</primary></indexterm>
       <function>regr_count(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>Да</entry>
      <entry>число входных строк, в которых оба выражения не NULL</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>пересечение линии регрессии</primary></indexterm>
       <indexterm><primary>regr_intercept</primary></indexterm>
       <function>regr_intercept(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>пересечение с осью OY линии, полученной методом наименьших квадратов по данным (<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>regr_r2</primary></indexterm>
       <function>regr_r2(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>квадрат коэффициента корреляции</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>наклон линии регрессии</primary></indexterm>
       <indexterm><primary>regr_slope</primary></indexterm>
       <function>regr_slope(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry>наклон линии, полученной методом наименьших квадратов по данным (<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>regr_sxx</primary></indexterm>
       <function>regr_sxx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry><literal>sum(<replaceable class="parameter">X</replaceable>^2) - sum(<replaceable class="parameter">X</replaceable>)^2/<replaceable class="parameter">N</replaceable></literal> (<quote>сумма квадратов</quote> независимой переменной)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>regr_sxy</primary></indexterm>
       <function>regr_sxy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry><literal>sum(<replaceable class="parameter">X</replaceable>*<replaceable class="parameter">Y</replaceable>) - sum(<replaceable class="parameter">X</replaceable>) * sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal> (<quote>сумма произведений</quote> независимых и зависимых переменных)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>regr_syy</primary></indexterm>
       <function>regr_syy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Да</entry>
      <entry><literal>sum(<replaceable class="parameter">Y</replaceable>^2) - sum(<replaceable class="parameter">Y</replaceable>)^2/<replaceable class="parameter">N</replaceable></literal> (<quote>сумма квадратов</quote> зависимой переменной)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>стандартное отклонение</primary></indexterm>
       <indexterm><primary>stddev</primary></indexterm>
       <function>stddev(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type> или <type>numeric</type></entry>
      <entry><type>double precision</type> для аргументов с плавающей точкой, <type>numeric</type> для остальных</entry>
      <entry>Да</entry>
      <entry>сохранившийся синоним <function>stddev_samp</function></entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>стандартное отклонение</primary> <secondary>по совокупности</secondary></indexterm>
       <indexterm><primary>stddev_pop</primary></indexterm>
       <function>stddev_pop(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type> или <type>numeric</type></entry>
      <entry><type>double precision</type> для аргументов с плавающей точкой, <type>numeric</type> для остальных</entry>
      <entry>Да</entry>
      <entry>стандартное отклонение по генеральной совокупности входных значений</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>стандартное отклонение</primary> <secondary>по выборке</secondary></indexterm>
       <indexterm><primary>stddev_samp</primary></indexterm>
       <function>stddev_samp(<replaceable class="parameter">выражение</replaceable>)</function>
      </entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type> или <type>numeric</type></entry>
      <entry><type>double precision</type> для аргументов с плавающей точкой, <type>numeric</type> для остальных</entry>
      <entry>Да</entry>
      <entry>стандартное отклонение по выборке входных значений</entry>
     </row>

     <row>
      <entry><indexterm><primary>дисперсия</primary></indexterm> <function>variance</function>(<replaceable class="parameter">выражение</replaceable>)</entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type> или <type>numeric</type></entry>
      <entry><type>double precision</type> для аргументов с плавающей точкой, <type>numeric</type> для остальных</entry>
      <entry>Да</entry>
      <entry>сохранившийся синоним <function>var_samp</function></entry>
     </row>

     <row>
      <entry><indexterm><primary>дисперсия</primary> <secondary>для совокупности</secondary></indexterm> <indexterm><primary>var_pop</primary></indexterm> <function>var_pop</function>(<replaceable class="parameter">выражение</replaceable>)</entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type> или <type>numeric</type></entry>
      <entry><type>double precision</type> для аргументов с плавающей точкой, <type>numeric</type> для остальных</entry>
      <entry>Да</entry>
      <entry>дисперсия для генеральной совокупности входных значений (квадрат стандартного отклонения)</entry>
     </row>

     <row>
      <entry><indexterm><primary>дисперсия</primary> <secondary>по выборке</secondary></indexterm> <indexterm><primary>var_samp</primary></indexterm> <function>var_samp</function>(<replaceable class="parameter">выражение</replaceable>)</entry>
      <entry><type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</type>, <type>double precision</type> или <type>numeric</type></entry>
      <entry><type>double precision</type> для аргументов с плавающей точкой, <type>numeric</type> для остальных</entry>
      <entry>Да</entry>
      <entry>дисперсия по выборке для входных значений (квадрат отклонения по выборке)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>В <xref remap="6" linkend="functions-orderedset-table"/> показаны некоторые агрегатные функции, использующие синтаксис <firstterm>сортирующих агрегатных функций</firstterm>. Иногда такие функции функциями называют функциями <quote>обратного распределения</quote>.</para>

  <indexterm><primary>сортирующие агрегатные функции</primary> <secondary>встроенные</secondary></indexterm>
  <indexterm><primary>обратное распределение</primary></indexterm>

  <table id="functions-orderedset-table">
   <title>Сортирующие агрегатные функции</title>

   <tgroup cols="6">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип непосредственного аргумента</entry>
      <entry>Тип агрегированного аргумента</entry>
      <entry>Тип результата</entry>
      <entry>Частичный режим</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm><primary>мода</primary> <secondary>статистическая функция</secondary></indexterm>
       <function>mode() WITHIN GROUP (ORDER BY <replaceable class="parameter">выражение_сортировки</replaceable>)</function>
      </entry>
      <entry>
      </entry>
      <entry>любой сортируемый тип</entry>
      <entry>тот же, что у выражения сортировки</entry>
      <entry>Нет</entry>
      <entry>возвращает значение, наиболее часто встречающееся во входных данных (если одинаково часто встречаются несколько значений, произвольно выбирается первое из них)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>процентиль</primary> <secondary>непрерывный</secondary></indexterm>
       <function>percentile_cont(<replaceable class="parameter">дробь</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">выражение_сортировки</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry><type>double precision</type> или <type>interval</type></entry>
      <entry>тот же, что у выражения сортировки</entry>
      <entry>Нет</entry>
      <entry>непрерывный процентиль: возвращает значение, соответствующее заданной дроби по порядку, интерполируя соседние входные значения, если необходимо</entry>
     </row>

     <row>
      <entry>
       <function>percentile_cont(<replaceable class="parameter">дроби</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">выражение_сортировки</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry><type>double precision</type> или <type>interval</type></entry>
      <entry>массив типа выражения сортировки</entry>
      <entry>Нет</entry>
      <entry>множественный непрерывный процентиль: возвращает массив результатов, соответствующих форме параметра <replaceable>дроби</replaceable> (для каждого элемента не NULL подставляется значение, соответствующее данному процентилю)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>процентиль</primary> <secondary>дискретный</secondary></indexterm>
       <function>percentile_disc(<replaceable class="parameter">дробь</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">выражение_сортировки</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>любой сортируемый тип</entry>
      <entry>тот же, что у выражения сортировки</entry>
      <entry>Нет</entry>
      <entry>дискретный процентиль: возвращает первое значение из входных данных, позиция которого по порядку равна или превосходит указанную дробь</entry>
     </row>

     <row>
      <entry>
       <function>percentile_disc(<replaceable class="parameter">дроби</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">выражение_сортировки</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>любой сортируемый тип</entry>
      <entry>массив типа выражения сортировки</entry>
      <entry>Нет</entry>
      <entry>множественный дискретный процентиль: возвращает массив результатов, соответствующих форме параметра <replaceable>дроби</replaceable> (для каждого элемента не NULL подставляется входное значение, соответствующее данному процентилю)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Все агрегатные функции, перечисленные в <xref remap="6" linkend="functions-orderedset-table"/>, игнорируют значения NULL при сортировке данных. Для функций, принимающих параметр <replaceable>дробь</replaceable>, значение этого параметра должно быть от 0 до 1; в противном случае возникает ошибка. Однако, если в этом параметре передаётся NULL, эти функции просто выдают NULL.</para>

  <indexterm><primary>гипотезирующие агрегатные функции</primary> <secondary>встроенные</secondary></indexterm>

  <para>Все агрегатные функции, перечисленные в <xref remap="6" linkend="functions-hypothetical-table"/>, связаны с одноимёнными оконными функциями, определёнными в <xref remap="6" linkend="functions-window"/>. В каждом случае их результат &mdash; значение, которое вернула бы связанная оконная функция для <quote>гипотетической</quote> строки, полученной из <replaceable>аргументов</replaceable>, если бы такая строка была добавлена в сортированную группу строк, которую образуют <replaceable>сортированные_аргументы</replaceable>.</para>

  <table id="functions-hypothetical-table">
   <title>Гипотезирующие агрегатные функции</title>

   <tgroup cols="6">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип непосредственного аргумента</entry>
      <entry>Тип агрегированного аргумента</entry>
      <entry>Тип результата</entry>
      <entry>Частичный режим</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm><primary>rank</primary> <secondary>гипотезирующая функция</secondary></indexterm>
       <function>rank(<replaceable class="parameter">аргументы</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">сортированные_аргументы</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>Нет</entry>
      <entry>ранг гипотетической строки, с пропусками повторяющихся строк</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>dense_rank</primary> <secondary>гипотезирующая функция</secondary></indexterm>
       <function>dense_rank(<replaceable class="parameter">аргументы</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">сортированные_аргументы</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>Нет</entry>
      <entry>ранг гипотетической строки, без пропусков</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>percent_rank</primary> <secondary>гипотезирующая функция</secondary></indexterm>
       <function>percent_rank(<replaceable class="parameter">аргументы</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">сортированные_аргументы</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Нет</entry>
      <entry>относительный ранг гипотетической строки, от 0 до 1</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>cume_dist</primary> <secondary>гипотезирующая функция</secondary></indexterm>
       <function>cume_dist(<replaceable class="parameter">аргументы</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">сортированные_аргументы</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>Нет</entry>
      <entry>относительный ранг гипотетической строки, от 1/<replaceable>N</replaceable> до 1</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Для всех этих гипотезирующих агрегатных функций непосредственные <replaceable>аргументы</replaceable> должны соответствовать (по количеству и типу) <replaceable>сортированным_аргументам</replaceable>. В отличие от встроенных агрегатных функций, они не являются строгими, то есть не отбрасывают входные строки, содержащие NULL. Значения NULL сортируются согласно правилу, указанному в предложении <literal>ORDER BY</literal>.</para>

  <table id="functions-grouping-table">
   <title>Операции группировки</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип результата</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm><primary>GROUPING</primary></indexterm>
       <function>GROUPING(<replaceable class="parameter">аргументы...</replaceable>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>Целочисленная битовая маска, показывающая, какие аргументы не вошли в текущий набор группирования</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <para>Операции группировки применяются в сочетании с наборами группирования (см. <xref remap="4" linkend="queries-grouping-sets"/>) для различения результирующих строк. Аргументы операции <literal>GROUPING</literal> на самом деле не вычисляются, но они должны в точности соответствовать выражениям, заданным в предложении <literal>GROUP BY</literal> на их уровне запроса. Биты назначаются справа налево (правый аргумент отражается в младшем бите); бит равен 0, если соответствующее выражение вошло в критерий группировки набора группирования, для которого сформирована строка результата, или 1 в противном случае. Например: <screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen></para>

 </sect1>

 <sect1 id="functions-window">
  <title>Оконные функции</title>

  <indexterm zone="functions-window"><primary>оконные функции</primary> <secondary>встроенные</secondary></indexterm>

  <para><firstterm>Оконные функции</firstterm> дают возможность выполнять вычисления с набором строк, каким-либо образом связанным с текущей строкой запроса. Вводную информацию об этом можно получить в <xref remap="6" linkend="tutorial-window"/>, а подробнее узнать о синтаксисе можно в <xref remap="6" linkend="syntax-window-functions"/>.</para>

  <para>Встроенные оконные функции перечислены в <xref remap="6" linkend="functions-window-table"/>. Заметьте, что эти функции <emphasis>должны</emphasis> вызываться именно как оконные, т. е. при вызове необходимо использовать предложение <literal>OVER</literal>.</para>

  <para>В дополнение к этим функциям в качестве оконных можно использовать любые встроенные или пользовательские обычные (но не сортирующие и не гипотезирующие) агрегатные функции (встроенные функции перечислены в <xref remap="6" linkend="functions-aggregate"/>). Агрегатные функции работают как оконные, только когда за их вызовом следует предложение <literal>OVER</literal>; в противном случае они останутся обычными агрегатными.</para>

  <table id="functions-window-table">
   <title>Оконные функции общего назначения</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип результата</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm><primary>row_number</primary></indexterm>
       <function>row_number()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>номер текущей строки в её разделе, начиная с 1</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>rank</primary></indexterm>
       <function>rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>ранг текущей строки с пропусками; то же, что и <function>row_number</function> для первой родственной ей строки</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>dense_rank</primary></indexterm>
       <function>dense_rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>ранг текущей строки без пропусков; эта функция считает группы родственных строк</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>percent_rank</primary></indexterm>
       <function>percent_rank()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>относительный ранг текущей строки: (<function>rank</function> - 1) / (общее число строк - 1)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>cume_dist</primary></indexterm>
       <function>cume_dist()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>относительный ранг текущей строки: (число строк, предшествующих или родственных текущей) / (общее число строк)</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>ntile</primary></indexterm>
       <function>ntile(<replaceable class="parameter">число_групп</replaceable> <type>integer</type>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>ранжирование по целым числам от 1 до значения аргумента так, чтобы размеры групп были максимально близки</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>lag</primary></indexterm>
       <function>lag(<replaceable class="parameter">значение</replaceable> <type>anyelement</type> [, <replaceable class="parameter">смещение</replaceable> <type>integer</type> [, <replaceable class="parameter">по_умолчанию</replaceable> <type>anyelement</type> ]])</function>
      </entry>
      <entry>
       <type>тип аргумента <replaceable class="parameter">значение</replaceable></type>
      </entry>
      <entry>возвращает <replaceable class="parameter">значение</replaceable> для строки, положение которой задаётся <replaceable class="parameter">смещением</replaceable> от текущей строки к началу раздела; если такой строки нет, возвращается значение <replaceable class="parameter">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и <replaceable class="parameter">значение</replaceable>). Оба параметра <replaceable class="parameter">смещение</replaceable> и <replaceable class="parameter">по_умолчанию</replaceable> вычисляются для текущей строки. Если они не указываются, то <replaceable class="parameter">смещение</replaceable> считается равным 1, а <replaceable class="parameter">по_умолчанию</replaceable> &mdash; NULL</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>lead</primary></indexterm>
       <function>lead(<replaceable class="parameter">значение</replaceable> <type>anyelement</type> [, <replaceable class="parameter">смещение</replaceable> <type>integer</type> [, <replaceable class="parameter">по_умолчанию</replaceable> <type>anyelement</type> ]])</function>
      </entry>
      <entry>
       <type>тип аргумента <replaceable class="parameter">значение</replaceable></type>
      </entry>
      <entry>возвращает <replaceable class="parameter">значение</replaceable> для строки, положение которой задаётся <replaceable class="parameter">смещением</replaceable> от текущей строки к концу раздела; если такой строки нет, возвращается значение <replaceable class="parameter">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и <replaceable class="parameter">значение</replaceable>). Оба параметра <replaceable class="parameter">смещение</replaceable> и <replaceable class="parameter">по_умолчанию</replaceable> вычисляются для текущей строки. Если они не указываются, то <replaceable class="parameter">смещение</replaceable> считается равным 1, а <replaceable class="parameter">по_умолчанию</replaceable> &mdash; NULL</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>first_value</primary></indexterm>
       <function>first_value(<replaceable class="parameter">значение</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
       <type>тип аргумента <replaceable class="parameter">значение</replaceable></type>
      </entry>
      <entry>возвращает <replaceable class="parameter">значение</replaceable>, вычисленное для первой строки в рамке окна</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>last_value</primary></indexterm>
       <function>last_value(<replaceable class="parameter">значение</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
       <type>тип аргумента <replaceable class="parameter">значение</replaceable></type>
      </entry>
      <entry>возвращает <replaceable class="parameter">значение</replaceable>, вычисленное для последней строки в рамке окна</entry>
     </row>

     <row>
      <entry>
       <indexterm><primary>nth_value</primary></indexterm>
       <function>nth_value(<replaceable class="parameter">значение</replaceable> <type>any</type>, <replaceable class="parameter">n</replaceable> <type>integer</type>)</function>
      </entry>
      <entry>
       <type>тип аргумента <replaceable class="parameter">значение</replaceable></type>
      </entry>
      <entry>возвращает <replaceable class="parameter">значение</replaceable>, вычисленное в <replaceable class="parameter">н-ой</replaceable> строке в рамке окна (считая с 1), или NULL, если такой строки нет</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Результат всех функций, перечисленных в <xref remap="6" linkend="functions-window-table"/>, зависит от порядка сортировки, заданного предложением <literal>ORDER BY</literal> в определении соответствующего окна. Строки, которые являются одинаковыми с точки зрения сортировки <literal>ORDER BY</literal>, считаются <firstterm>родственными</firstterm>; четыре функции, вычисляющие ранг, реализованы так, что их результат будет одинаковым для любых двух родственных строк.</para>

  <para>Заметьте, что функции <function>first_value</function>, <function>last_value</function> и <function>nth_value</function> рассматривают только строки в <quote>рамке окна</quote>, которая по умолчанию содержит строки от начала раздела до последней родственной строки для текущей. Поэтому результаты <function>last_value</function> и иногда <function>nth_value</function> могут быть не очень полезны. В таких случаях можно переопределить рамку, добавив в предложение <literal>OVER</literal> подходящее указание (<literal>RANGE</literal> или <literal>ROWS</literal>). Подробнее эти указания описаны в <xref remap="6" linkend="syntax-window-functions"/>.</para>

  <para>Когда в качестве оконной функции используется агрегатная, она обрабатывает строки в рамке текущей строки. Агрегатная функция с <literal>ORDER BY</literal> и определением рамки окна по умолчанию будет вычисляться как <quote>бегущая сумма</quote>, что может не соответствовать желаемому результату. Чтобы агрегатная функция работала со всем разделом, следует опустить <literal>ORDER BY</literal> или использовать <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>. Используя другие указания в определении рамки, можно получить и другие эффекты.</para>

  <note>
   <para>В стандарте SQL определены параметры <literal>RESPECT NULLS</literal> или <literal>IGNORE NULLS</literal> для функций <function>lead</function>, <function>lag</function>, <function>first_value</function>, <function>last_value</function> и <function>nth_value</function>. В <productname>&productname;</productname> такие параметры не реализованы: эти функции ведут себя так, как положено в стандарте по умолчанию (или с подразумеваемым параметром <literal>RESPECT NULLS</literal>). Также функция <function>nth_value</function> не поддерживает предусмотренные стандартом параметры <literal>FROM FIRST</literal> и <literal>FROM LAST</literal>: реализовано только поведение по умолчанию (с подразумеваемым параметром <literal>FROM FIRST</literal>). (Получить эффект параметра <literal>FROM LAST</literal> можно, изменив порядок <literal>ORDER BY</literal> на обратный.)</para>
  </note>

 </sect1>

 <sect1 id="functions-subquery">
  <title>Выражения подзапросов</title>

  <indexterm><primary>EXISTS</primary></indexterm>

  <indexterm><primary>IN</primary></indexterm>

  <indexterm><primary>NOT IN</primary></indexterm>

  <indexterm><primary>ANY</primary></indexterm>

  <indexterm><primary>ALL</primary></indexterm>

  <indexterm><primary>SOME</primary></indexterm>

  <indexterm><primary>подзапрос</primary></indexterm>

  <para>В этом разделе описаны выражения подзапросов, которые реализованы в <productname>&productname;</productname> в соответствии со стандартом <acronym>SQL</acronym>. Все рассмотренные здесь формы выражений возвращает булевы значения (true/false).</para>

  <sect2 id="functions-subquery-exists">
   <title><literal>EXISTS</literal></title>

<synopsis>EXISTS (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>Аргументом <token>EXISTS</token> является обычный оператор <command>SELECT</command>, т. е. <firstterm>подзапрос</firstterm>. Выполнив запрос, система проверяет, возвращает ли он строки в результате. Если он возвращает минимум одну строку, результатом <token>EXISTS</token> будет <quote>true</quote>, а если не возвращает ни одной &mdash; <quote>false</quote>.</para>

  <para>Подзапрос может обращаться к переменным внешнего запроса, которые в рамках одного вычисления подзапроса считаются константами.</para>

  <para>Вообще говоря, подзапрос может выполняться не полностью, а завершаться, как только будет возвращена хотя бы одна строка. Поэтому в подзапросах следует избегать побочных эффектов (например, обращений к генераторам последовательностей); проявление побочного эффекта может быть непредсказуемым.</para>

  <para>Так как результат этого выражения зависит только от того, возвращаются строки или нет, но не от их содержимого, список выходных значений подзапроса обычно не имеет значения. Как следствие, широко распространена практика, когда проверки <literal>EXISTS</literal> записываются в форме <literal>EXISTS(SELECT 1 WHERE ...)</literal>. Однако из этого правила есть и исключения, например с подзапросами с предложением <token>INTERSECT</token>.</para>

  <para>Этот простой пример похож на внутреннее соединение по столбцу <literal>col2</literal>, но он выдаёт максимум одну строку для каждой строки в <literal>tab1</literal>, даже если в <literal>tab2</literal> ей соответствуют несколько строк: <screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen></para>
  </sect2>

  <sect2 id="functions-subquery-in">
   <title><literal>IN</literal></title>

<synopsis><replaceable>выражение</replaceable> IN (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В правой стороне этого выражения в скобках задаётся подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значениями во всех строках, возвращённых подзапросом. Результатом всего выражения <token>IN</token> будет <quote>true</quote>, если строка с таким значением находится, и <quote>false</quote> в противном случае (в том числе, когда подзапрос вообще не возвращает строк).</para>

  <para>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</para>

  <para>Так же, как и с <token>EXISTS</token>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</para>

<synopsis><replaceable>конструктор_строки</replaceable> IN (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В левой части этой формы <token>IN</token> записывается конструктор строки (подробнее они рассматриваются в <xref remap="6" linkend="sql-syntax-row-constructors"/>). Справа в скобках записывается подзапрос, который должен вернуть ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом. Результатом всего выражения <token>IN</token> будет <quote>true</quote>, если строка с такими значениями находится, и <quote>false</quote> в противном случае (в том числе, когда подзапрос вообще не возвращает строк).</para>

  <para>Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам сравнения. Две строки считаются равными, если все их соответствующие элементы не равны NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не равные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён (равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы один NULL, результатом <token>IN</token> будет NULL.</para>
  </sect2>

  <sect2 id="functions-subquery-notin">
   <title><literal>NOT IN</literal></title>

<synopsis><replaceable>выражение</replaceable> NOT IN (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>Справа в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значением во всех строках, возвращённых подзапросом. Результатом всего выражения <token>NOT IN</token> будет <quote>true</quote>, если находятся только несовпадающие строки (в том числе, когда подзапрос вообще не возвращает строк). Если же находится хотя бы одна подходящая строка, результатом будет <quote>false</quote>.</para>

  <para>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <token>NOT IN</token> возвращает NULL, а не true. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</para>

  <para>Так же, как и с <token>EXISTS</token>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</para>

<synopsis><replaceable>конструктор_строки</replaceable> NOT IN (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В левой части этой формы <token>NOT IN</token> записывается конструктор строки (подробнее они описываются в <xref remap="6" linkend="sql-syntax-row-constructors"/>). Справа в скобках записывается подзапрос, который должен вернуть ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом. Результатом всего выражения <token>NOT IN</token> будет <quote>true</quote>, если равных строк не найдётся (в том числе, и когда подзапрос не возвращает строк), и <quote>false</quote>, если такие строки есть.</para>

  <para>Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам сравнения. Две строки считаются равными, если все их соответствующие элементы не равны NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не равные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён (равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы один NULL, результатом <token>NOT IN</token> будет NULL.</para>
  </sect2>

  <sect2 id="functions-subquery-any-some">
   <title><literal>ANY</literal>/<literal>SOME</literal></title>

<synopsis><replaceable>выражение</replaceable> <replaceable>оператор</replaceable> ANY (<replaceable>подзапрос</replaceable>)
<replaceable>выражение</replaceable> <replaceable>оператор</replaceable> SOME (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В правой части конструкции в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой строке результата подзапроса с помощью заданного <replaceable>оператора</replaceable> условия, который должен выдавать логическое значение. Результатом <token>ANY</token> будет <quote>true</quote>, если хотя бы для одной строки условие истинно, и <quote>false</quote> в противном случае (в том числе, и когда подзапрос не возвращает строк).</para>

  <para>Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>. Конструкцию <token>IN</token> можно записать также записать как <literal>= ANY</literal>.</para>

  <para>Заметьте, что если условие не выполняется ни для одной из строк, а хотя бы для одной строки условный оператор выдаёт NULL, конструкция <token>ANY</token> возвращает NULL, а не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</para>

  <para>Так же, как и с <token>EXISTS</token>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</para>

<synopsis><replaceable>конструктор_строки</replaceable> <replaceable>оператор</replaceable> ANY (<replaceable>подзапрос</replaceable>)
<replaceable>конструктор_строки</replaceable> <replaceable>оператор</replaceable> SOME (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В левой части этой формы <token>ANY</token> записывается конструктор строки (подробнее они описываются в <xref remap="6" linkend="sql-syntax-row-constructors"/>). Справа в скобках записывается подзапрос, который должен возвращать ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом, с применением заданного <replaceable>оператора</replaceable>. Результатом всего выражения <token>ANY</token> будет <quote>true</quote>, если для какой-либо из строк результатом сравнения будет true, и <quote>false</quote>, если для всех строк результатом сравнения оказывается false (в том числе, и когда подзапрос не возвращает строк). Результат будет равен NULL, если сравнение не возвращает true ни для одной из строк, но как минимум для одной результат сравнения NULL.</para>

  <para>Подробнее логика сравнения конструкторов строк описана в <xref remap="6" linkend="row-wise-comparison"/>.</para>
  </sect2>

  <sect2 id="functions-subquery-all">
   <title><literal>ALL</literal></title>

<synopsis><replaceable>выражение</replaceable> <replaceable>оператор</replaceable> ALL (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В правой части конструкции в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой строке результата подзапроса с помощью заданного <replaceable>оператора</replaceable> условия, который должен выдавать логическое значение. Результатом <token>ALL</token> будет <quote>true</quote>, если условие истинно для всех строк (и когда подзапрос не возвращает строк), и <quote>false</quote>, если находятся строки, для которых оно ложно. Результат будет равен NULL, если сравнение не возвращает false ни для одной из строк, но как минимум для одной результат сравнения NULL.</para>

  <para>Конструкция <token>NOT IN</token> равнозначна <literal>&lt;&gt; ALL</literal>.</para>

  <para>Так же, как и с <token>EXISTS</token>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</para>

<synopsis><replaceable>конструктор_строки</replaceable> <replaceable>оператор</replaceable> ALL (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В левой части этой формы <token>ALL</token> записывается конструктор строки (подробнее они описываются в <xref remap="6" linkend="sql-syntax-row-constructors"/>). Справа в скобках записывается подзапрос, который должен возвращать ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом, с применением заданного <replaceable>оператора</replaceable>. Результатом всего выражения <token>ALL</token> будет <quote>true</quote>, если для всех строк подзапроса результатом сравнения будет true (или если подзапрос не возвращает строк), и <quote>false</quote>, если результат сравнения равен false для любой из строк подзапроса. Результат будет равен NULL, если сравнение не возвращает false ни для одной из строк, но как минимум для одной результат сравнения NULL.</para>

  <para>Подробнее логика сравнения конструкторов строк описана в <xref remap="6" linkend="row-wise-comparison"/>.</para>
  </sect2>

  <sect2>
   <title>Сравнение единичных строк</title>

   <indexterm zone="functions-subquery"><primary>сравнение</primary> <secondary>со строкой-результатом подзапроса</secondary></indexterm>

<synopsis><replaceable>конструктор_строки</replaceable> <replaceable>оператор</replaceable> (<replaceable>подзапрос</replaceable>)</synopsis>

  <para>В левой части конструкции записывается конструктор строки (подробнее они описываются в <xref remap="6" linkend="sql-syntax-row-constructors"/>). Справа в скобках записывается подзапрос, который должен возвращать ровно столько столбцов, сколько содержит строка в выражении слева. Более того, подзапрос может вернуть максимум одну строку. (Если он не вернёт строк, результатом будет NULL.) Конструкция возвращает результат сравнения строки слева с этой одной строкой результата подзапроса.</para>

  <para>Подробнее логика сравнения конструкторов строк описана в <xref remap="6" linkend="row-wise-comparison"/>.</para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
  <title>Сравнение табличных строк и массивов</title>

  <indexterm><primary>IN</primary></indexterm>

  <indexterm><primary>NOT IN</primary></indexterm>

  <indexterm><primary>ANY</primary></indexterm>

  <indexterm><primary>ALL</primary></indexterm>

  <indexterm><primary>SOME</primary></indexterm>

  <indexterm><primary>составной тип</primary> <secondary>сравнение</secondary></indexterm>

  <indexterm><primary>сравнение табличных строк</primary></indexterm>

  <indexterm><primary>сравнение</primary> <secondary>составных типов</secondary></indexterm>

  <indexterm><primary>сравнение</primary> <secondary>конструкторов строк</secondary></indexterm>

  <indexterm><primary>IS DISTINCT FROM</primary></indexterm>

  <indexterm><primary>IS NOT DISTINCT FROM</primary></indexterm>

  <para>В этом разделе описываются несколько специальных конструкций, позволяющих сравнивать группы значений. Синтаксис этих конструкций связан с формами выражений с подзапросами, описанными в предыдущем разделе, а отличаются они отсутствием подзапросов. Конструкции, в которых в качестве подвыражений используются массивы, являются расширениями <productname>&productname;</productname>; все остальные формы соответствуют стандарту <acronym>SQL</acronym>. Все описанные здесь выражения возвращают логические значения (true/false).</para>

  <sect2 id="functions-comparisons-in-scalar">
   <title><literal>IN</literal></title>

<synopsis><replaceable>выражение</replaceable> IN (<replaceable>значение</replaceable> <optional>, ...</optional>)</synopsis>

  <para>Справа в скобках записывается список скалярных выражений. Результатом будет <quote>true</quote>, если значение левого выражения равняется одному из значений выражений в правой части. Эту конструкцию можно считать краткой записью условия <synopsis>
<replaceable>выражение</replaceable> = <replaceable>значение1</replaceable>
OR
<replaceable>выражение</replaceable> = <replaceable>значение2</replaceable>
OR
...
</synopsis></para>

  <para>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</para>
  </sect2>

  <sect2>
   <title><literal>NOT IN</literal></title>

<synopsis><replaceable>выражение</replaceable> NOT IN (<replaceable>значение</replaceable> <optional>, ...</optional>)</synopsis>

  <para>Справа в скобках записывается список скалярных выражений. Результатом будет <quote>true</quote>, если значение левого выражения не равно ни одному из значений выражений в правой части. Эту конструкцию можно считать краткой записью условия <synopsis>
<replaceable>выражение</replaceable> &lt;&gt; <replaceable>значение1</replaceable>
AND
<replaceable>выражение</replaceable> &lt;&gt; <replaceable>значение2</replaceable>
AND
...
</synopsis></para>

  <para>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <token>NOT IN</token> возвращает NULL, а не true, как можно было бы наивно полагать. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</para>

  <tip>
  <para>Выражения <literal>x NOT IN y</literal> и <literal>NOT (x IN y)</literal> полностью равнозначны. Учитывая, что значения NULL могут ввести в заблуждение начинающих скорее в конструкции <token>NOT IN</token>, чем в <token>IN</token>, лучше формулировать условия так, чтобы в них было как можно меньше отрицаний.</para>
  </tip>
  </sect2>

  <sect2>
   <title><literal>ANY</literal>/<literal>SOME</literal> (с массивом)</title>

<synopsis><replaceable>выражение</replaceable> <replaceable>оператор</replaceable> ANY (<replaceable>выражение массива</replaceable>)
<replaceable>выражение</replaceable> <replaceable>оператор</replaceable> SOME (<replaceable>выражение массива</replaceable>)</synopsis>

  <para>Справа в скобках записывается выражение, результатом которого является массив. Вычисленное значение левого выражения сравнивается с каждым элементом этого массива с применением заданного <replaceable>оператора</replaceable> условия, который должен выдавать логическое значение. Результатом <token>ANY</token> будет <quote>true</quote>, если для какого-либо элемента условие истинно, и <quote>false</quote> в противном случае (в том числе, и когда массив оказывается пустым).</para>

  <para>Если значением массива оказывается NULL, результатом <token>ANY</token> также будет NULL. Если NULL получен в левой части, результатом <token>ANY</token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может выдать другой результат). Кроме того, если массив в правой части содержит элементы NULL и ни c одним из элементов условие не выполняется, результатом <token>ANY</token> будет NULL, а не false (опять же, если используется оператор строгого сравнения). Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</para>

  <para>Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>.</para>
  </sect2>

  <sect2>
   <title><literal>ALL</literal> (с массивом)</title>

<synopsis><replaceable>выражение</replaceable> <replaceable>оператор</replaceable> ALL (<replaceable>выражение массива</replaceable>)</synopsis>

  <para>Справа в скобках записывается выражение, результатом которого является массив. Вычисленное значение левого выражения сравнивается с каждым элементом этого массива с применением заданного <replaceable>оператора</replaceable> условия, который должен выдавать логическое значение. Результатом <token>ALL</token> будет <quote>true</quote>, если для всех элементов условие истинно (или массив не содержит элементов), и <quote>false</quote>, если находятся строки, для которых оно ложно.</para>

  <para>Если значением массива оказывается NULL, результатом <token>ALL</token> также будет NULL. Если NULL получен в левой части, результатом <token>ALL</token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может выдать другой результат). Кроме того, если массив в правой части содержит элементы NULL и при этом нет элементов, с которыми условие не выполняется, результатом <token>ALL</token> будет NULL, а не true (опять же, если используется оператор строгого сравнения). Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</para>
  </sect2>

  <sect2 id="row-wise-comparison">
   <title>Сравнение конструкторов строк</title>

<synopsis>
<replaceable>конструктор_строки</replaceable> <replaceable>оператор</replaceable> <replaceable>конструктор_строки</replaceable>
</synopsis>

  <para>С обеих сторон представлены конструкторы строк (они описываются в <xref remap="6" linkend="sql-syntax-row-constructors"/>). При этом данные строки должны содержать одинаковое число полей. После вычисления каждой стороны они сравниваются по строкам. Сравнения конструкторов строк возможны с <replaceable>оператором</replaceable> <literal>=</literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> или <literal>&gt;=</literal>. Каждый элемент строки должен иметь тип, для которого определён класс операторов B-дерева; в противном случае при попытке сравнения может возникнуть ошибка.</para>

  <note>
   <para>Ошибок, связанных с числом или типов элементов, не должно быть, если сравнение выполняется с ранее полученными столбцами.</para>
  </note>

  <para>Сравнения <literal>=</literal> и <literal>&lt;&gt;</literal> несколько отличаются от других. С этими операторами две строки считаются равными, если все их соответствующие поля не равны NULL и равны между собой, и неравными, если какие-либо соответствующие их поля не NULL и не равны между собой. В противном случае результатом сравнения будет неопределённость (NULL).</para>

  <para>С операторами <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> и <literal>&gt;=</literal> элементы строк сравниваются слева направо до тех пор, пока не будет найдена пара неравных элементов или значений NULL. Если любым из элементов пары оказывается NULL, результатом сравнения будет неопределённость (NULL), в противном случае результат всего выражения определяется результатом сравнения этих двух элементов. Например, результатом <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal> будет true, а не NULL, так как третья пара элементов не принимается в рассмотрение.</para>

  <note>
   <para>До версии 8.2 <productname>PostgreSQL</productname> обрабатывал условия <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> и <literal>&gt;=</literal> не так, как это описано в стандарте SQL. Сравнение <literal>ROW(a,b) &lt; ROW(c,d)</literal> выполнялось как <literal>a &lt; c AND b &lt; d</literal>, тогда как по стандарту должно быть <literal>a &lt; c OR (a = c AND b &lt; d)</literal>.</para>
  </note>

<synopsis><replaceable>конструктор_строки</replaceable> IS DISTINCT FROM <replaceable>конструктор_строки</replaceable></synopsis>

  <para>Эта конструкция похожа на сравнение строк с оператором <literal>&lt;&gt;</literal>, но со значениями NULL она выдаёт не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого выражения будет true или false, но не NULL.</para>

<synopsis><replaceable>конструктор_строки</replaceable> IS NOT DISTINCT FROM <replaceable>конструктор_строки</replaceable></synopsis>

  <para>Эта конструкция похожа на сравнение строк с оператором <literal>=</literal>, но со значениями NULL она выдаёт не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого выражения всегда будет true или false, но не NULL.</para>

  </sect2>

  <sect2 id="composite-type-comparison">
   <title>Сравнение составных типов</title>

<synopsis>
<replaceable>запись</replaceable> <replaceable>оператор</replaceable> <replaceable>запись</replaceable>
</synopsis>

  <para>Стандарт SQL требует, чтобы при сравнении строк возвращался NULL, если результат зависит от сравнения двух значений NULL или значения NULL и не NULL. <productname>&productname;</productname> выполняет это требование только при сравнении строк, созданных конструкторами (как описано в <xref remap="6" linkend="row-wise-comparison"/>), или строки, созданной конструктором, со строкой результата подзапроса (как было описано в <xref remap="6" linkend="functions-subquery"/>). В других контекстах при сравнении полей составных типов два значения NULL считаются равными, а любое значение не NULL полагается меньшим NULL. Это отклонение от правила необходимо для полноценной реализации сортировки и индексирования составных типов.</para>

  <para>После вычисления каждой стороны они сравниваются по строкам. Сравнения составных типов возможны с <replaceable>оператором</replaceable> <literal>=</literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> или <literal>&gt;=</literal>, либо другим подобным. (Точнее, оператором сравнения строк может быть любой оператор, входящий в класс операторов B-дерева, либо обратный к оператору <literal>=</literal>, входящему в класс операторов B-дерева.) По умолчанию вышеперечисленные операторы действуют так же, как выражение <literal>IS [ NOT ] DISTINCT FROM</literal> для конструкторов строк (см. <xref remap="4" linkend="row-wise-comparison"/>).</para>

  <para>Для поддержки сравнения строк с элементами, для которых не определён класс операторов B-дерева по умолчанию, введены следующие операторы: <literal>*=</literal>, <literal>*&lt;&gt;</literal>, <literal>*&lt;</literal>, <literal>*&lt;=</literal>, <literal>*&gt;</literal> и <literal>*&gt;=</literal>. Эти операторы сравнивают внутреннее двоичное представление двух строк. Учтите, что две строки могут иметь различное двоичное представление, даже когда при сравнении оператором равенства считаются равными. Порядок строк с такими операторами детерминирован, но не несёт смысловой нагрузки. Данные операторы применяются внутри системы для материализованных представлений и могут быть полезны для других специальных целей (например, репликации), но, вообще говоря, не предназначены для использования в обычных запросах.</para>
  </sect2>
 </sect1>

 <sect1 id="functions-srf">
  <title>Функции, возвращающие множества</title>

  <indexterm zone="functions-srf"><primary>функции, возвращающие множества</primary> <secondary>функции</secondary></indexterm>

  <indexterm><primary>generate_series</primary></indexterm>

  <para>В этом разделе описаны функции, которые могут возвращать не одну, а множество строк. Чаще всего из их числа используются функции, генерирующие ряды значений, которые перечислены в <xref remap="6" linkend="functions-srf-series"/> и <xref remap="6" linkend="functions-srf-subscripts"/>. Другие, более специализированные функции множеств описаны в других разделах этой документации. Варианты комбинирования нескольких функций, возвращающих множества строк, описаны в <xref remap="6" linkend="queries-tablefunctions"/>.</para>

  <table id="functions-srf-series">
   <title>Функции, генерирующие ряды значений</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип аргумента</entry>
      <entry>Тип результата</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>)</function></literal></entry>
      <entry><type>int</type>, <type>bigint</type> или <type>numeric</type></entry>
      <entry><type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</type> (определяется типом аргумента)</entry>
      <entry>Выдаёт ряд целых чисел от <parameter>start</parameter> до <parameter>stop</parameter> с шагом 1</entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter>)</function></literal></entry>
      <entry><type>int</type>, <type>bigint</type> или <type>numeric</type></entry>
      <entry><type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</type> (определяется типом аргумента)</entry>
      <entry>Выдаёт ряд значений от <parameter>start</parameter> до <parameter>stop</parameter> с заданным шагом (<parameter>step</parameter>)</entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter> <type>interval</type>)</function></literal></entry>
      <entry><type>timestamp</type> или <type>timestamp with time zone</type></entry>
      <entry><type>setof timestamp</type> или <type>setof timestamp with time zone</type> (определяется типом аргумента)</entry>
      <entry>Выдаёт ряд значений от <parameter>start</parameter> до <parameter>stop</parameter> с заданным шагом (<parameter>step</parameter>)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>Если заданный шаг (<parameter>step</parameter>) положительный, а <parameter>start</parameter> оказывается больше <parameter>stop</parameter>, эти функции возвращают 0 строк. Тот же результат будет, если <parameter>step</parameter> меньше 0, а <parameter>start</parameter> меньше <parameter>stop</parameter>, или если какой-либо аргумент равен <literal>NULL</literal>. Если же <parameter>step</parameter> будет равен 0, произойдёт ошибка. Несколько примеров: <programlisting>SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series 
-----------------
             1.1
             2.4
             3.7
(3 rows)

-- этот пример задействует оператор прибавления к дате целого числа
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series   
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)</programlisting></para>

  <table id="functions-srf-subscripts">
   <title>Функции, генерирующие индексы массивов</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип результата</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>Выдаёт ряд значений для использования в качестве индекса данного массива.</entry>
     </row>

     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>, <parameter>reverse boolean</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>Выдаёт ряд значений для использования в качестве индекса данного массива. Если параметр <parameter>reverse</parameter> равен true, значения выдаются от большего к меньшему.</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <indexterm><primary>generate_subscripts</primary></indexterm>

  <para>Функция <function>generate_subscripts</function> позволяет упростить получение всего набора индексов для указанной размерности заданного массива. Она выдаёт 0 строк, если в массиве нет указанной размерности или сам массив равен NULL (хотя для элементов, равных NULL, индексы будут выданы, как и для любых других). Взгляните на следующие примеры: <programlisting>-- простой пример использования
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s 
---
 1
 2
 3
 4
(4 rows)

-- для показанного массива получение индекса и обращение
-- к элементу по индексу выполняется с помощью подзапроса
SELECT * FROM arrays;
         a          
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-- разворачивание двумерного массива
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
---------
       1
       2
       3
       4
(4 rows)</programlisting></para>

  <indexterm><primary>ordinality</primary></indexterm>

  <para>Когда после функции в предложении <literal>FROM</literal> добавляется <literal>WITH ORDINALITY</literal>, в выходные данные добавляется столбец типа <type>bigint</type>, числа в котором начинаются с 1 и увеличиваются на 1 для каждой строки, выданной функцией. В первую очередь это полезно для функций, возвращающих множества, например, <function>unnest()</function>. <programlisting>-- функция, возвращающая множество, с нумерацией
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_clog         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_xlog         | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 строк)</programlisting></para>

 </sect1>

 <sect1 id="functions-info">
  <title>Системные информационные функции</title>

  <para>В <xref remap="6" linkend="functions-info-session-table"/> перечислен ряд функций, предназначенных для получения информации о текущем сеансе и системе.</para>

  <para>В дополнение к перечисленным здесь функциям существуют также функции, связанные с подсистемой статистики, которые тоже предоставляют системную информацию. Подробнее они рассматриваются в <xref remap="6" linkend="monitoring-stats-views"/>.</para>

   <table id="functions-info-session-table">
    <title>Функции получения информации о сеансе</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>current_catalog</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>имя текущей базы данных (в стандарте SQL она называется <quote>каталогом</quote>)</entry>
      </row>

      <row>
       <entry><literal><function>current_database()</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>имя текущей базы данных</entry>
      </row>

      <row>
       <entry><literal><function>current_query()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>текст запроса, выполняемого в данный момент, в том виде, в каком его передал клиент (может состоять из нескольких операторов)</entry>
      </row>

      <row>
       <entry><literal><function>current_role</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>синоним <function>current_user</function></entry>
      </row>

      <row>
       <entry><literal><function>current_schema</function>[()]</literal></entry>
       <entry><type>name</type></entry>
       <entry>имя текущей схемы</entry>
      </row>

      <row>
       <entry><literal><function>current_schemas(<type>boolean</type>)</function></literal></entry>
       <entry><type>name[]</type></entry>
       <entry>имена схем в пути поиска, возможно включая схемы, добавляемые в него неявно</entry>
      </row>

      <row>
       <entry><literal><function>current_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>имя пользователя в текущем контексте выполнения</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>адрес удалённой стороны соединения</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>порт удалённой стороны соединения</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
       <entry>адрес локальной стороны соединения</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_port()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>порт локальной стороны соединения</entry>
      </row>

      <row>
       <!-- See also the entry for this in monitoring.xml -->
       <entry><literal><function>pg_backend_pid()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>код серверного процесса, обслуживающего текущий сеанс</entry>
      </row>

      <row>
       <entry><literal><function>pg_blocking_pids(<type>int</type>)</function></literal></entry>
       <entry><type>int[]</type></entry>
       <entry>идентификаторы процессов, блокирующих серверный процесс с определённым ID</entry>
      </row>

      <row>
       <entry><literal><function>pg_conf_load_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>время загрузки конфигурации</entry>
      </row>

      <row>
       <entry><literal><function>pg_my_temp_schema()</function></literal></entry>
       <entry><type>oid</type></entry>
       <entry>OID временной схемы этого сеанса или 0, если её нет</entry>
      </row>

      <row>
       <entry><literal><function>pg_is_other_temp_schema(<type>oid</type>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>является ли заданная схема временной в другом сеансе?</entry>
      </row>

      <row>
       <entry><literal><function>pg_listening_channels()</function></literal></entry>
       <entry><type>setof text</type></entry>
       <entry>имена каналов, по которым текущий сеанс принимает сигналы</entry>
      </row>

      <row>
       <entry><literal><function>pg_notification_queue_usage()</function></literal></entry>
       <entry><type>double</type></entry>
       <entry>занятая доля очереди асинхронных уведомлений (0-1)</entry>
      </row>

      <row>
       <entry><literal><function>pg_postmaster_start_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>время запуска сервера</entry>
      </row>

      <row>
       <entry><literal><function>pg_trigger_depth()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>текущий уровень вложенности в триггерах <productname>&productname;</productname> (0, если эта функция вызывается (прямо или косвенно) не из тела триггера)</entry>
      </row>

      <row>
       <entry><literal><function>session_user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>имя пользователя сеанса</entry>
      </row>

      <row>
       <entry><literal><function>user</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>синоним <function>current_user</function></entry>
      </row>

      <row>
       <entry><literal><function>version()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>информация о версии <productname>PostgreSQL</productname>. Также можно прочитать версию в машинно-ориентированном виде, обратившись к переменной <xref linkend="guc-server-version-num"/>.</entry>
      </row>
      <row>
       <entry><literal><function>pgpro_version()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>информация о версии <productname>&productname;</productname></entry>
       </row>
      <row>
       <entry><literal><function>pgpro_edition()</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>название редакции <productname>Postgres Pro</productname></entry>
       </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>Функции <function>current_catalog</function>, <function>current_role</function>, <function>current_schema</function>, <function>current_user</function>, <function>session_user</function> и <function>user</function> имеют особый синтаксический статус в <acronym>SQL</acronym>: они должны вызываться без скобок после имени. (&productname; позволяет добавить скобки в вызове <function>current_schema</function>, но не других функций.)</para>
   </note>

   <indexterm><primary>current_catalog</primary></indexterm>

   <indexterm><primary>current_database</primary></indexterm>

   <indexterm><primary>current_query</primary></indexterm>

   <indexterm><primary>current_role</primary></indexterm>

   <indexterm><primary>current_schema</primary></indexterm>

   <indexterm><primary>current_schemas</primary></indexterm>

   <indexterm><primary>current_user</primary></indexterm>

   <indexterm><primary>pg_backend_pid</primary></indexterm>

   <indexterm><primary>схема</primary> <secondary>текущая</secondary></indexterm>

   <indexterm><primary>путь поиска</primary> <secondary>текущий</secondary></indexterm>

   <indexterm><primary>session_user</primary></indexterm>

   <indexterm><primary>пользователь</primary> <secondary>текущий</secondary></indexterm>

   <indexterm><primary>пользователь</primary></indexterm>

   <para>Функция <function>session_user</function> обычно возвращает имя пользователя, установившего текущее соединение с базой данных, но суперпользователи могут изменить это имя, выполнив команду <xref linkend="sql-set-session-authorization"/>. Функция <function>current_user</function> возвращает идентификатор пользователя, по которому будут проверяться его права. Обычно это тот же пользователь, что и пользователь сеанса, но его можно сменить с помощью <xref linkend="sql-set-role"/>. Этот идентификатор также меняется при выполнении функций с атрибутом <literal>SECURITY DEFINER</literal>. На языке Unix пользователь сеанса называется <quote>реальным</quote>, а текущий — <quote>эффективным</quote>. Имена <function>current_role</function> и <function>user</function> являются синонимами <function>current_user</function>. (В стандарте SQL <function>current_role</function> и <function>current_user</function> имеют разное значение, но в <productname>PostgreSQL</productname> они не различаются, так как пользователи и роли объединены в единую сущность.)</para>

   <para>Функция <function>current_schema</function> возвращает имя схемы, которая стоит первой в пути поиска (или NULL, если путь поиска пуст). Эта схема будет задействована при создании таблиц или других именованных объектов, если целевая схема не указана явно. Функция <function>current_schemas(boolean)</function> возвращает массив имён всех схем, находящихся в пути поиска. Её логический параметр определяет, будут ли включаться в результат неявно добавляемые в путь поиска системные схемы, такие как <literal>pg_catalog</literal>.</para>

   <note>
    <para>Путь поиска можно изменить во время выполнения следующей командой: <programlisting>SET search_path TO <replaceable>схема</replaceable> <optional>, <replaceable>схема</replaceable>, ...</optional></programlisting></para>
   </note>

   <indexterm><primary>inet_client_addr</primary></indexterm>

   <indexterm><primary>inet_client_port</primary></indexterm>

   <indexterm><primary>inet_server_addr</primary></indexterm>

   <indexterm><primary>inet_server_port</primary></indexterm>

   <para>Функция <function>inet_client_addr</function> возвращает IP-адрес текущего клиента, <function>inet_client_port</function> &mdash; номер его порта, <function>inet_server_addr</function> &mdash; IP-адрес сервера, по которому он принял подключение клиента, а <function>inet_server_port</function> &mdash; соответствующий номер порта. Все эти функции возвращают NULL, если текущее соединение устанавливается через доменный сокет Unix.</para>

   <indexterm><primary>pg_blocking_pids</primary></indexterm>

   <para>Функция <function>pg_blocking_pids</function> возвращает массив идентификаторов процессов сеансов, которые блокирует серверный процесс с указанным идентификатором, либо пустой массив, если такой серверный процесс не найден или не заблокирован. Один серверный процесс блокирует другой, если он либо удерживает блокировку, конфликтующую с блокировкой, запрашиваемой серверным процессом (жёсткая блокировка), либо ждёт блокировки, которая вызвала бы конфликт с запросом блокировки заблокированного процесса и находится перед ней в очереди ожидания (мягкая блокировка). При распараллеливании запросов эта функция всегда выдаёт видимые клиентом идентификаторы процессов (то есть, результаты <function>pg_backend_pid</function>), даже если фактическая блокировка удерживается или ожидается дочерним рабочим процессом. Вследствие этого, в результатах могут оказаться дублирующиеся PID. Также заметьте, что когда конфликтующую блокировку удерживает подготовленная транзакция, в выводе этой функции она будет представлена нулевым ID процесса. Частые вызовы этой функции могут отразиться на производительности базы данных, так как ей нужен монопольный доступ к общему состоянию менеджера блокировок, хоть и на короткое время.</para>

   <indexterm><primary>pg_conf_load_time</primary></indexterm>

   <para>Функция <function>pg_conf_load_time</function> возвращает время (<type>timestamp with time zone</type>), когда в последний раз сервер загружал файлы конфигурации. (Если текущий сеанс начался раньше, она возвращает время, когда эти файлы были перезагружены для данного сеанса, так что в разных сеансах это значение может немного различаться. В противном случае это будет время, когда файлы конфигурации считал главный процесс.)</para>

   <indexterm><primary>pg_my_temp_schema</primary></indexterm>

   <indexterm><primary>pg_is_other_temp_schema</primary></indexterm>

   <para><function>pg_my_temp_schema</function> возвращает OID временной схемы текущего сеанса или 0, если такой нет (в рамках сеанса не создавались временные таблицы). <function>pg_is_other_temp_schema</function> возвращает true, если заданный OID относится к временной схеме другого сеанса. (Это может быть полезно, например для исключения временных таблиц других сеансов из общего списка при просмотре таблиц базы данных.)</para>

   <indexterm><primary>pg_listening_channels</primary></indexterm>

   <indexterm><primary>pg_notification_queue_usage</primary></indexterm>

   <para>Функция <function>pg_listening_channels</function> возвращает набор имён каналов асинхронных уведомлений, на которые подписан текущий сеанс. Функция <function>pg_notification_queue_usage</function> возвращает долю от всего свободного пространства для уведомлений, в настоящее время занятую уведомлениями, ожидающими обработки, в виде значения <type>double</type> в диапазоне 0..1. За дополнительными сведениями обратитесь к <xref remap="3" linkend="sql-listen"/> и <xref remap="3" linkend="sql-notify"/>.</para>

   <indexterm><primary>pg_postmaster_start_time</primary></indexterm>

   <para><function>pg_postmaster_start_time</function> возвращает время (<type>timestamp with time zone</type>), когда был запущен сервер.</para>

   <indexterm><primary>версия</primary></indexterm>

   <para>Функция <function>version</function> возвращает строку, описывающую версию сервера <productname>&productname;</productname>. Эту информацию также можно получить из переменной <xref linkend="guc-server-version"/> или, в более машинно-ориентированном формате, из переменной <xref linkend="guc-server-version-num"/>. При разработке программ следует использовать <literal>server_version_num</literal> (она появилась в версии 8.2) либо <xref linkend="libpq-pqserverversion"/>, а не разбирать текстовую версию.</para>
  <indexterm><primary>pgpro_edition</primary></indexterm>
  <para><literal><function>pgpro_edition()</function></literal> возвращает текстовую строку, описывающую редакцию <productname>Postgres Pro</productname>, например <literal>standard</literal> или <literal>enterprise</literal>.</para>
  <indexterm><primary>pgpro_version</primary></indexterm>
  <para><literal><function>pgpro_version()</function></literal> возвращает текстовую строку, описывающую версию сервера <productname>Postgres Pro</productname>.</para>
  <indexterm><primary>права</primary> <secondary>проверка</secondary></indexterm>

  <para>В <xref remap="6" linkend="functions-info-access-table"/> перечислены функции, позволяющую пользователю программно проверить свои права доступа к объектам. Подробнее о правах можно узнать в <xref remap="6" linkend="ddl-priv"/>.</para>

   <table id="functions-info-access-table">
    <title>Функции для проверки прав доступа</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>user</parameter>, <parameter>table</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для какого-либо столбца таблицы</entry>
      </row>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>table</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для какого-либо столбца таблицы</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>user</parameter>, <parameter>table</parameter>, <parameter>column</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для столбца</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>table</parameter>, <parameter>column</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для столбца</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>user</parameter>, <parameter>database</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для базы данных</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>database</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для базы данных</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>user</parameter>, <parameter>fdw</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для обёртки сторонних данных</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>fdw</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для обёртки сторонних данных</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>user</parameter>, <parameter>function</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для функции</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>function</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для функции</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>user</parameter>, <parameter>language</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для языка</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>language</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для языка</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>user</parameter>, <parameter>schema</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для схемы</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>schema</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для схемы</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>user</parameter>, <parameter>sequence</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для последовательности</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>sequence</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для последовательности</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>user</parameter>, <parameter>server</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для стороннего сервера</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>server</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для стороннего сервера</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>user</parameter>, <parameter>table</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для таблицы</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>table</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для таблицы</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>user</parameter>, <parameter>tablespace</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для табличного пространства</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>tablespace</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для табличного пространства</entry>
      </row>
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>user</parameter>, <parameter>type</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для типа</entry>
      </row>
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>type</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для типа</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>user</parameter>, <parameter>role</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли пользователь указанное право для роли</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>role</parameter>, <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>имеет ли текущий пользователь указанное право для роли</entry>
      </row>
      <row>
       <entry><literal><function>row_security_active</function>(<parameter>table</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>включена ли для текущего пользователя защита на уровне строк для таблицы</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm><primary>has_any_column_privilege</primary></indexterm>
   <indexterm><primary>has_column_privilege</primary></indexterm>
   <indexterm><primary>has_database_privilege</primary></indexterm>
   <indexterm><primary>has_function_privilege</primary></indexterm>
   <indexterm><primary>has_foreign_data_wrapper_privilege</primary></indexterm>
   <indexterm><primary>has_language_privilege</primary></indexterm>
   <indexterm><primary>has_schema_privilege</primary></indexterm>
   <indexterm><primary>has_server_privilege</primary></indexterm>
   <indexterm><primary>has_sequence_privilege</primary></indexterm>
   <indexterm><primary>has_table_privilege</primary></indexterm>
   <indexterm><primary>has_tablespace_privilege</primary></indexterm>
   <indexterm><primary>has_type_privilege</primary></indexterm>
   <indexterm><primary>pg_has_role</primary></indexterm>
   <indexterm><primary>row_security_active</primary></indexterm>

   <para><function>has_table_privilege</function> проверяет, может ли пользователь выполнять с таблицей заданные действия. В качестве идентификатора пользователя можно задать его имя, OID (<literal>pg_authid.oid</literal>) или <literal>public</literal> (это будет указывать на псевдороль PUBLIC). Если этот аргумент опущен, подразумевается текущий пользователь (<function>current_user</function>). Таблицу можно указать по имени или по OID. (Таким образом, фактически есть шесть вариантов функции <function>has_table_privilege</function>, различающихся по числу и типу аргументов.) Когда указывается имя объекта, его можно дополнить именем схемы, если это необходимо. Интересующее право доступа записывается в виде текста и может быть одним из следующих: <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal> и <literal>TRIGGER</literal>. Дополнительно к названию права можно добавить <literal>WITH GRANT OPTION</literal> и проверить, разрешено ли пользователю передавать это право другим. Кроме того, в одном параметре можно перечислить несколько названий прав через запятую, и тогда функция возвратит <literal>true</literal>, если пользователь имеет одно из этих прав. (Регистр в названии прав не имеет значения, а между ними (но не внутри) разрешены пробельные символы.) Пара примеров: <programlisting>SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable',
  'INSERT, SELECT WITH GRANT OPTION');</programlisting></para>

   <para><function>has_sequence_privilege</function> проверяет, может ли пользователь выполнять заданные действия с последовательностью. В определении аргументов эта функция аналогична <function>has_table_privilege</function>. Допустимые для неё права складываются из <literal>USAGE</literal>, <literal>SELECT</literal> и <literal>UPDATE</literal>.</para>

   <para><function>has_any_column_privilege</function> проверяет, может ли пользователь выполнять заданные действия с каким-либо столбцом таблицы. В определении аргументов эта функция аналогична <function>has_table_privilege</function>, а допустимые права складываются из <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal> и <literal>REFERENCES</literal>. Заметьте, что любое из этих прав, назначенное на уровне таблицы, автоматически распространяется на все её столбцы, так что <function>has_any_column_privilege</function> всегда возвращает <literal>true</literal>, если <function>has_table_privilege</function> даёт положительный ответ для тех же аргументов. Но <function>has_any_column_privilege</function> возвращает <literal>true</literal> ещё и тогда, когда право назначено только для некоторых столбцов.</para>

   <para><function>has_column_privilege</function> проверяет, может ли пользователь выполнять заданные действия со столбцом таблицы. В определении аргументов эта функция аналогична <function>has_table_privilege</function>, с небольшим дополнением: столбец можно задать по имени или номеру атрибута. Для неё допустимые права складываются из <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal> и <literal>REFERENCES</literal>. Заметьте, что любое из этих прав, назначенное на уровне таблицы, автоматически распространяется на все столбцы таблицы.</para>

   <para><function>has_database_privilege</function> проверяет, может ли пользователь выполнять заданные действия с базой данных. В определении аргументов эта функция аналогична <function>has_table_privilege</function>. Для неё допустимые права складываются из <literal>CREATE</literal>, <literal>CONNECT</literal> и <literal>TEMPORARY</literal> (или <literal>TEMP</literal>, что равносильно <literal>TEMPORARY</literal>).</para>

   <para><function>has_function_privilege</function> проверяет, может ли пользователь обратиться к заданной функции. В определении аргументов эта функция аналогична <function>has_table_privilege</function>. Когда функция определяется не своим OID, а текстовой строкой, эта строка должна быть допустимой для вводимого значения типа <type>regprocedure</type> (см. <xref remap="4" linkend="datatype-oid"/>). Для этой функции допустимо только право <literal>EXECUTE</literal>. Например: <programlisting>SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');</programlisting></para>

   <para><function>has_foreign_data_wrapper_privilege</function> проверяет, может ли пользователь обращаться к обёртке сторонних данных. В определении аргументов она аналогична <function>has_table_privilege</function>. Для неё допустимо только право <literal>USAGE</literal>.</para>

   <para><function>has_language_privilege</function> проверяет, может ли пользователь обращаться к процедурному языку. В определении аргументов эта функция аналогична <function>has_table_privilege</function>. Для неё допустимо только право <literal>USAGE</literal>.</para>

   <para><function>has_schema_privilege</function> проверяет, может ли пользователь выполнять заданные действия со схемой. В определении аргументов эта функция аналогична <function>has_table_privilege</function>. Для неё допустимые права складываются из <literal>CREATE</literal> и <literal>USAGE</literal>.</para>

   <para><function>has_server_privilege</function> проверяет, может ли пользователь обращаться к стороннему серверу. В определении аргументов она аналогична <function>has_table_privilege</function>. Для неё допустимо только право <literal>USAGE</literal>.</para>

   <para><function>has_tablespace_privilege</function> проверяет, может ли пользователь выполнять заданное действие в табличном пространстве. В определении аргументов эта функция аналогична <function>has_table_privilege</function>. Для неё допустимо только право <literal>CREATE</literal>.</para>

   <para><function>has_type_privilege</function> проверяет, может ли пользователь обратиться к типу определённым образом. Возможные аргументы аналогичны <function>has_table_privilege</function>. При указании типа текстовой строкой, а не по OID, допускаются те же входные значения, что и для типа данных <type>regtype</type> (см. <xref remap="4" linkend="datatype-oid"/>). Для неё допустимо только право <literal>USAGE</literal>.</para>

   <para><function>pg_has_role</function> проверяет, может ли пользователь выполнять заданные действия с ролью. В определении аргументов эта функция аналогична <function>has_table_privilege</function>, за исключением того, что именем пользователя не может быть <literal>public</literal>. Для неё допустимые права складываются из <literal>MEMBER</literal> и <literal>USAGE</literal>. <literal>MEMBER</literal> обозначает прямое или косвенное членство в данной роли (то есть наличие права выполнить команду <command>SET ROLE</command>), тогда как <literal>USAGE</literal> показывает, что пользователь получает все права роли сразу, без <command>SET ROLE</command>.</para>

   <para><function>row_security_active</function> проверяет, включена ли защита на уровне строк для указанной таблицы в контексте и окружении текущего пользователя (<function>current_user</function>). Таблицу можно задать по имени или OID.</para>

  <para>В <xref remap="6" linkend="functions-info-schema-table"/> перечислены функции, определяющие <firstterm>видимость</firstterm> объекта с текущим путём поиска схем. К примеру, таблица считается видимой, если содержащая её схема включена в путь поиска и нет другой таблицы с тем же именем, которая была бы найдена по пути поиска раньше. Другими словами, к этой таблице можно будет обратиться просто по её имени, без явного указания схемы. Просмотреть список всех видимых таблиц можно так: <programlisting>SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);</programlisting></para>

   <indexterm><primary>путь поиска</primary> <secondary>видимость объектов</secondary></indexterm>

   <table id="functions-info-schema-table">
    <title>Функции для определения видимости</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_collation_is_visible(<parameter>collation_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видимо ли правило сортировки</entry>
      </row>
      <row>
       <entry><literal><function>pg_conversion_is_visible(<parameter>conversion_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видимо ли преобразование</entry>
      </row>
      <row>
       <entry><literal><function>pg_function_is_visible(<parameter>function_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видима ли функция</entry>
      </row>
      <row>
       <entry><literal><function>pg_opclass_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видим ли класс операторов</entry>
      </row>
      <row>
       <entry><literal><function>pg_operator_is_visible(<parameter>operator_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видим ли оператор</entry>
      </row>
      <row>
       <entry><literal><function>pg_opfamily_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видимо ли семейство операторов</entry>
      </row>
      <row>
       <entry><literal><function>pg_table_is_visible(<parameter>table_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видима ли таблица</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_config_is_visible(<parameter>config_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видима ли конфигурация текстового поиска</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_dict_is_visible(<parameter>dict_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видим ли словарь текстового поиска</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_parser_is_visible(<parameter>parser_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видим ли анализатор текстового поиска</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_template_is_visible(<parameter>template_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видим ли шаблон текстового поиска</entry>
      </row>
      <row>
       <entry><literal><function>pg_type_is_visible(<parameter>type_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>видим ли тип (или домен)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm><primary>pg_collation_is_visible</primary></indexterm>
   <indexterm><primary>pg_conversion_is_visible</primary></indexterm>
   <indexterm><primary>pg_function_is_visible</primary></indexterm>
   <indexterm><primary>pg_opclass_is_visible</primary></indexterm>
   <indexterm><primary>pg_operator_is_visible</primary></indexterm>
   <indexterm><primary>pg_opfamily_is_visible</primary></indexterm>
   <indexterm><primary>pg_table_is_visible</primary></indexterm>
   <indexterm><primary>pg_ts_config_is_visible</primary></indexterm>
   <indexterm><primary>pg_ts_dict_is_visible</primary></indexterm>
   <indexterm><primary>pg_ts_parser_is_visible</primary></indexterm>
   <indexterm><primary>pg_ts_template_is_visible</primary></indexterm>
   <indexterm><primary>pg_type_is_visible</primary></indexterm>

   <para>Каждая из этих функций проверяет видимость объектов определённого типа. Заметьте, что <function>pg_table_is_visible</function> можно также использовать для представлений, материализованных представлений, индексов, последовательностей и сторонних таблиц; <function>pg_type_is_visible</function> можно также использовать и для доменов. Для функций и операторов объект считается видимым в пути поиска, если при просмотре пути не находится предшествующий ему другой объект с тем же именем <emphasis>и типами аргументов</emphasis>. Для классов операторов во внимание принимается и имя оператора, и связанный с ним метод доступа к индексу.</para>

   <para>Всем этим функциям должен передаваться OID проверяемого объекта. Если вы хотите проверить объект по имени, удобнее использовать типы-псевдонимы OID (<type>regclass</type>, <type>regtype</type>, <type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type> или <type>regdictionary</type>), например: <programlisting>SELECT pg_type_is_visible('myschema.widget'::regtype);</programlisting> Заметьте, что проверять таким способом имена без указания схемы не имеет большого смысла &mdash; если имя удастся распознать, значит и объект будет видимым.</para>

   <indexterm><primary>format_type</primary></indexterm>

   <indexterm><primary>pg_get_constraintdef</primary></indexterm>

   <indexterm><primary>pg_get_expr</primary></indexterm>

   <indexterm><primary>pg_get_functiondef</primary></indexterm>

   <indexterm><primary>pg_get_function_arguments</primary></indexterm>

   <indexterm><primary>pg_get_function_identity_arguments</primary></indexterm>

   <indexterm><primary>pg_get_function_result</primary></indexterm>

   <indexterm><primary>pg_get_indexdef</primary></indexterm>

   <indexterm><primary>pg_get_keywords</primary></indexterm>

   <indexterm><primary>pg_get_ruledef</primary></indexterm>

   <indexterm><primary>pg_get_serial_sequence</primary></indexterm>

   <indexterm><primary>pg_get_triggerdef</primary></indexterm>

   <indexterm><primary>pg_get_userbyid</primary></indexterm>

   <indexterm><primary>pg_get_viewdef</primary></indexterm>

   <indexterm><primary>pg_index_column_has_property</primary></indexterm>

   <indexterm><primary>pg_index_has_property</primary></indexterm>

   <indexterm><primary>pg_indexam_has_property</primary></indexterm>

   <indexterm><primary>pg_options_to_table</primary></indexterm>

   <indexterm><primary>pg_tablespace_databases</primary></indexterm>

   <indexterm><primary>pg_tablespace_location</primary></indexterm>

   <indexterm><primary>pg_typeof</primary></indexterm>

   <indexterm><primary>collation for</primary></indexterm>

   <indexterm><primary>to_regclass</primary></indexterm>

   <indexterm><primary>to_regproc</primary></indexterm>

   <indexterm><primary>to_regprocedure</primary></indexterm>

   <indexterm><primary>to_regoper</primary></indexterm>

   <indexterm><primary>to_regoperator</primary></indexterm>

   <indexterm><primary>to_regtype</primary></indexterm>

   <indexterm><primary>to_regnamespace</primary></indexterm>

   <indexterm><primary>to_regrole</primary></indexterm>

  <para>В <xref remap="6" linkend="functions-info-catalog-table"/> перечислены функции, извлекающие информацию из системных каталогов.</para>

   <table id="functions-info-catalog-table">
    <title>Функции для обращения к системным каталогам</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>format_type(<parameter>type_oid</parameter>, <parameter>typemod</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает имя типа данных в формате SQL</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает определение ограничения</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает определение ограничения</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>декомпилирует внутреннюю форму выражения, в предположении, что все переменные в нём ссылаются на таблицу или отношение, указанное вторым параметром</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>декомпилирует внутреннюю форму выражения, в предположении, что все переменные в нём ссылаются на таблицу или отношение, указанное вторым параметром</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_functiondef(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает определение функции</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает список аргументов из определения функции (со значениями по умолчанию)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_identity_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает список аргументов, идентифицирующий функцию (без значений по умолчанию)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_result(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает предложение <literal>RETURNS</literal> для функции</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>CREATE INDEX</command> для индекса</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>CREATE INDEX</command> для индекса или определение одного индексированного столбца, когда <parameter>column_no</parameter> не равен 0</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_keywords()</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>получает список ключевых слов SQL по категориям</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>CREATE RULE</command> для правила</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>CREATE RULE</command> для правила</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_serial_sequence(<parameter>table_name</parameter>, <parameter>column_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает имя последовательности, связанной со столбцом типа <type>serial</type>, <type>smallserial</type> или <type>bigserial</type></entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>CREATE [ CONSTRAINT ] TRIGGER</command> для триггера</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, <parameter>pretty_bool</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>CREATE [ CONSTRAINT ] TRIGGER</command> для триггера</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_userbyid(<parameter>role_oid</parameter>)</function></literal></entry>
       <entry><type>name</type></entry>
       <entry>получает имя роли по заданному OID</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>SELECT</command>, определяющую представление или материализованное представление (<emphasis>устаревшая</emphasis> функция)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>SELECT</command>, определяющую представление или материализованное представление (<emphasis>устаревшая</emphasis> функция)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>SELECT</command>, определяющую представление или материализованное представление</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>SELECT</command>, определяющую представление или материализованное представление</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>wrap_column_int</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает команду <command>SELECT</command>, определяющую представление или материализованное представление; при необходимости разбивает строки с полями, выходящие за wrap_int символов, подразумевая форматированный вывод</entry>
      </row>
      <row>
       <entry><literal><function>pg_index_column_has_property(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>проверяет, имеет ли столбец индекса заданное свойство</entry>
      </row>
      <row>
       <entry><literal><function>pg_index_has_property(<parameter>index_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>проверяет, имеет ли индекс заданное свойство</entry>
      </row>
      <row>
       <entry><literal><function>pg_indexam_has_property(<parameter>am_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>проверяет, имеет ли метод доступа индекса заданное свойство</entry>
      </row>
      <row>
       <entry><literal><function>pg_options_to_table(<parameter>reloptions</parameter>)</function></literal></entry>
       <entry><type>setof record</type></entry>
       <entry>получает набор параметров хранилища в виде имя/значение</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_databases(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>setof oid</type></entry>
       <entry>получает или устанавливает OID баз данных, объекты которых содержатся в заданном табличном пространстве</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_location(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает путь в файловой системе к местоположению заданного табличного пространства</entry>
      </row>
      <row>
       <entry><literal><function>pg_typeof(<parameter>any</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>получает тип данных любого значения</entry>
      </row>
      <row>
       <entry><literal><function>collation for (<parameter>any</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает правило сортировки для аргумента</entry>
      </row>
      <row>
       <entry><literal><function>to_regclass(<parameter>rel_name</parameter>)</function></literal></entry>
       <entry><type>regclass</type></entry>
       <entry>получает OID указанного отношения</entry>
      </row>
      <row>
       <entry><literal><function>to_regproc(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regproc</type></entry>
       <entry>получает OID указанной функции</entry>
      </row>
      <row>
       <entry><literal><function>to_regprocedure(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regprocedure</type></entry>
       <entry>получает OID указанной функции</entry>
      </row>
      <row>
       <entry><literal><function>to_regoper(<parameter>имя_оператора</parameter>)</function></literal></entry>
       <entry><type>regoper</type></entry>
       <entry>получает OID указанного оператора</entry>
      </row>
      <row>
       <entry><literal><function>to_regoperator(<parameter>имя_оператора</parameter>)</function></literal></entry>
       <entry><type>regoperator</type></entry>
       <entry>получает OID указанного оператора</entry>
      </row>
      <row>
       <entry><literal><function>to_regtype(<parameter>type_name</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
       <entry>получает OID указанного типа</entry>
      </row>
      <row>
       <entry><literal><function>to_regnamespace(<parameter>schema_name</parameter>)</function></literal></entry>
       <entry><type>regnamespace</type></entry>
       <entry>получает OID указанной схемы</entry>
      </row>
      <row>
       <entry><literal><function>to_regrole(<parameter>role_name</parameter>)</function></literal></entry>
       <entry><type>regrole</type></entry>
       <entry>получает OID указанной роли</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para><function>format_type</function> возвращает в формате SQL имя типа данных, определяемого по OID и, возможно, модификатору типа. Если модификатор неизвестен, вместо него можно передать NULL.</para>

  <para><function>pg_get_keywords</function> возвращает таблицу с ключевыми словами SQL, которые воспринимает сервер. Столбец <structfield>word</structfield> содержит ключевое слово, а <structfield>catcode</structfield> &mdash; код категории: <literal>U</literal> &mdash; не зарезервировано, <literal>C</literal> &mdash; имя столбца, <literal>T</literal> &mdash; имя типа или функции, <literal>R</literal> &mdash; зарезервировано. Столбец <structfield>catdesc</structfield> содержит возможно локализованное описание категории.</para>

  <para><function>pg_get_constraintdef</function>, <function>pg_get_indexdef</function>, <function>pg_get_ruledef</function> и <function>pg_get_triggerdef</function> восстанавливают команду, создававшую заданное ограничение, индекс, правило или триггер, соответственно. (Учтите, что они возвращают не изначальный текст команды, а результат декомпиляции.) <function>pg_get_expr</function> декомпилирует внутреннюю форму отдельного выражения, например значения по умолчанию для столбца. Это может быть полезно для изучения содержимого системных каталогов. Если выражение может содержать переменные, укажите во втором параметре OID отношения, на который они ссылаются; если таких переменных нет, вместо OID можно передать 0. <function>pg_get_viewdef</function> восстанавливает запрос <command>SELECT</command>, определяющий представление. Многие из этих функций имеют две версии, одна из которых позволяет получить форматированный вывод (параметр pretty_bool). Форматированный текст легче читается, но нет гарантии, что он будет всегда восприниматься одинаково будущими версиями <productname>&productname;</productname>, поэтому не следует применять форматирование при выгрузке метаданных. Если параметр pretty_bool равен <literal>false</literal>, эта версия функции выдаёт тот же результат, что и версия без параметров.</para>

  <para><function>pg_get_functiondef</function> возвращает полный оператор <command>CREATE OR REPLACE FUNCTION</command> для заданной функции. <function>pg_get_function_arguments</function> возвращает список аргументов функции, в виде достаточном для включения в команду <command>CREATE FUNCTION</command>. <function>pg_get_function_result</function> в дополнение возвращает готовое предложение <literal>RETURNS</literal> для функции. <function>pg_get_function_identity_arguments</function> возвращает список аргументов, достаточный для однозначной идентификации функции, в форме, допустимой, например для команды <command>ALTER FUNCTION</command>. Значения по умолчанию в этой форме опускаются.</para>

  <para><function>pg_get_serial_sequence</function> возвращает имя последовательности, связанной со столбцом, и NULL, если такой последовательности нет. В первом параметре функции указывается имя таблицы, возможно дополненное схемой, а во втором имя столбца. Так как первый параметр может содержать имя схемы и таблицы, он воспринимается не как идентификатор в кавычках и поэтому по умолчанию приводится к нижнему регистру, тогда как имя столбца воспринимается как заключённое в кавычки и в нём регистр символов сохраняется. Эта функция возвращает имя в виде, пригодном для передачи функциям, работающим с последовательностями (см. <xref remap="4" linkend="functions-sequence"/>). Связь последовательности со столбцом можно изменить или удалить с помощью команды <command>ALTER SEQUENCE OWNED BY</command>. (Данную функцию можно было бы назвать <function>pg_get_owned_sequence</function>; настоящее её имя отражает то, что она обычно используется со столбцами <type>serial</type> и <type>bigserial</type>.)</para>

  <para><function>pg_get_userbyid</function> получает имя роли по её OID.</para>

  <para>Функции <function>pg_index_column_has_property</function>, <function>pg_index_has_property</function> и <function>pg_indexam_has_property</function> показывают, обладает ли указанный столбец индекса, индекс или метод доступа индекса заданным свойством. Они возвращают <literal>NULL</literal>, если имя свойства неизвестно или неприменимо к конкретному объекту, либо если OID или номер столбца не указывают на действительный объект. Описание свойств столбцов вы можете найти в <xref remap="6" linkend="functions-info-index-column-props"/>, свойства индексов описаны в <xref remap="6" linkend="functions-info-index-props"/>, а свойства методов доступа — в <xref linkend="functions-info-indexam-props"/>. (Заметьте, что методы доступа, реализуемые расширениями, могут определять для своих индексов дополнительные имена свойств.)</para>

  <table id="functions-info-index-column-props">
   <title>Свойства столбца индекса</title>
   <tgroup cols="2">
    <thead>
     <row><entry>Имя</entry><entry>Описание</entry></row>
    </thead>
    <tbody>
     <row>
      <entry><literal>asc</literal></entry>
      <entry>Сортируется ли столбец по возрастанию при сканировании вперёд?</entry>
     </row>
     <row>
      <entry><literal>desc</literal></entry>
      <entry>Сортируется ли столбец по убыванию при сканировании вперёд?</entry>
     </row>
     <row>
      <entry><literal>nulls_first</literal></entry>
      <entry>Выдаются ли NULL в начале при сканирования вперёд?</entry>
     </row>
     <row>
      <entry><literal>nulls_last</literal></entry>
      <entry>Выдаются ли NULL в конце при сканировании вперёд?</entry>
     </row>
     <row>
      <entry><literal>orderable</literal></entry>
      <entry>Связан ли со столбцом некоторый порядок сортировки?</entry>
     </row>
     <row>
      <entry><literal>distance_orderable</literal></entry>
      <entry>Может ли столбец сканироваться по порядку оператором <quote>расстояния</quote>, например, <literal>ORDER BY столбец &lt;-&gt; константа</literal> ?</entry>
     </row>
     <row>
      <entry><literal>returnable</literal></entry>
      <entry>Может ли значение столбца быть получено при сканировании только индекса?</entry>
     </row>
     <row>
      <entry><literal>search_array</literal></entry>
      <entry>Поддерживает ли столбец внутренними средствами поиск <literal>столбец = ANY(массив)</literal>?</entry>
     </row>
     <row>
      <entry><literal>search_nulls</literal></entry>
      <entry>Поддерживает ли столбец поиск <literal>IS NULL</literal> и <literal>IS NOT NULL</literal>?</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-index-props">
   <title>Свойства индекса</title>
   <tgroup cols="2">
    <thead>
     <row><entry>Имя</entry><entry>Описание</entry></row>
    </thead>
    <tbody>
     <row>
      <entry><literal>clusterable</literal></entry>
      <entry>Может ли индекс использоваться в команде <literal>CLUSTER</literal>?</entry>
     </row>
     <row>
      <entry><literal>index_scan</literal></entry>
      <entry>Поддерживает ли индекс простое сканирование (не по битовой карте)?</entry>
     </row>
     <row>
      <entry><literal>bitmap_scan</literal></entry>
      <entry>Поддерживает ли индекс сканирование по битовой карте?</entry>
     </row>
     <row>
      <entry><literal>backward_scan</literal></entry>
      <entry>Может ли индекс сканироваться в обратном направлении?</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-indexam-props">
   <title>Свойства метода доступа индекса</title>
   <tgroup cols="2">
    <thead>
     <row><entry>Имя</entry><entry>Описание</entry></row>
    </thead>
    <tbody>
     <row>
      <entry><literal>can_order</literal></entry>
      <entry>Поддерживает ли метод доступа <literal>ASC</literal>, <literal>DESC</literal> и связанные ключевые слова в <literal>CREATE INDEX</literal>?</entry>
     </row>
     <row>
      <entry><literal>can_unique</literal></entry>
      <entry>Поддерживает ли метод доступа уникальные индексы?</entry>
     </row>
     <row>
      <entry><literal>can_multi_col</literal></entry>
      <entry>Поддерживает ли метод доступа индексы по нескольким столбцам?</entry>
     </row>
     <row>
      <entry><literal>can_exclude</literal></entry>
      <entry>Поддерживает ли метод доступа ограничения-исключения?</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para><function>pg_options_to_table</function> возвращает набор параметров хранилища в виде пар (<replaceable>имя_параметра</replaceable>/<replaceable>значение_параметра</replaceable>), когда ей передаётся <structname>pg_class</structname>.<structfield>reloptions</structfield> или <structname>pg_attribute</structname>.<structfield>attoptions</structfield>.</para>

  <para><function>pg_tablespace_databases</function> позволяет изучить содержимое табличного пространства. Она возвращает набор OID баз данных, объекты которых размещены в этом табличном пространстве. Если эта функция возвращает строки, это означает, что табличное пространство не пустое и удалить его нельзя. Какие именно объекты находятся в табличном пространстве, можно узнать, подключаясь к базам данных, OID которых сообщила <function>pg_tablespace_databases</function>, и анализируя их каталоги <structname>pg_class</structname>.</para>

  <para><function>pg_typeof</function> возвращает OID типа данных для переданного значения. Это может быть полезно для разрешения проблем или динамического создания SQL-запросов. Эта функция объявлена как возвращающая тип <type>regtype</type>, который является псевдонимом типа OID (см. <xref remap="4" linkend="datatype-oid"/>); это означает, что значение этого типа можно сравнивать как OID, но выводится оно как название типа. Например: <programlisting>SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)</programlisting></para>

  <para>Выражение <literal>collation for</literal> возвращает правило сортировки для переданного значения. Например: <programlisting>SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)</programlisting> Это значение может быть заключено в кавычки и дополнено схемой. Если для выражения аргумента нет правила сортировки, возвращается значение NULL. Если же правила сортировки не применимы для типа аргумента, происходит ошибка.</para>

  <para>Функции <function>to_regclass</function>, <function>to_regproc</function>, <function>to_regprocedure</function>, <function>to_regoper</function>, <function>to_regoperator</function>, <function>to_regtype</function>, <function>to_regnamespace</function> и <function>to_regrole</function> преобразуют имена отношений, функций, операторов, типов, схем и ролей (заданных значением <type>text</type>) в объекты типа <type>regclass</type>, <type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, <type>regoperator</type>, <type>regtype</type>, <type>regnamespace</type> и <type>regrole</type>, соответственно. Перечисленные функции отличаются от явных приведений к этим типам тем, что они не принимают числовые OID и возвращают NULL вместо ошибки, если имя не найдено (или, в случае с <function>to_regproc</function> и <function>to_regoper</function>, если данному имени соответствуют несколько объектов).</para>

   <indexterm><primary>pg_describe_object</primary></indexterm>

   <indexterm><primary>pg_identify_object</primary></indexterm>

   <indexterm><primary>pg_identify_object_as_address</primary></indexterm>

   <indexterm><primary>pg_get_object_address</primary></indexterm>

  <para>В <xref remap="6" linkend="functions-info-object-table"/> перечислены функции, связанные с идентификацией и адресацией объектов баз данных.</para>

   <table id="functions-info-object-table">
    <title>Функции получения информации и адресации объектов</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_describe_object(<parameter>catalog_id</parameter>, <parameter>object_id</parameter>, <parameter>object_sub_id</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает описание объекта базы данных</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object(<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</parameter> <type>oid</type>, <parameter>object_sub_id</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> <type>text</type>, <parameter>name</parameter> <type>text</type>, <parameter>identity</parameter> <type>text</type></entry>
       <entry>получает идентификатор объекта базы данных</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object_as_address(<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</parameter> <type>oid</type>, <parameter>object_sub_id</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>name</parameter> <type>text[]</type>, <parameter>args</parameter> <type>text[]</type></entry>
       <entry>получает внешнее представление адреса объекта базы данных</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_object_address(<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> <type>text[]</type>, <parameter>аргументы</parameter> <type>text[]</type>)</function></literal></entry>
       <entry><parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</parameter> <type>oid</type>, <parameter>object_sub_id</parameter> <type>int32</type></entry>
       <entry>получает адрес объекта базы данных из его внешнего представления</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para><function>pg_describe_object</function> возвращает текстовое описание объекта БД, идентифицируемого по OID каталога, OID объекта и ID подобъекта (может быть нулевым). Это описание предназначено для человека и может переводиться, в зависимости от конфигурации сервера. С помощью этой функции, например, можно узнать, что за объект хранится в каталоге <structname>pg_depend</structname>.</para>

  <para><function>pg_identify_object</function> возвращает запись, содержащую достаточно информации для однозначной идентификации объекта БД по OID каталога, OID объекта и ID подобъекта (может быть нулевым). Эта информация предназначена для машины и поэтому никогда не переводится. Столбец <parameter>type</parameter> содержит тип объекта БД; <parameter>schema</parameter> &mdash; имя схемы, к которой относится объект (либо <literal>NULL</literal> для объектов, не относящихся к схемам); <parameter>name</parameter> &mdash; имя объекта, при необходимости в кавычках, которое присутствует только если оно (возможно, вместе со схемой) однозначно идентифицирует объект (в противном случае <literal>NULL</literal>); <parameter>identity</parameter> &mdash; полный идентификатор объекта, точный формат которого зависит от типа объекта, а каждая его часть дополняется схемой и заключается в кавычки, если требуется.</para>

  <para><function>pg_identify_object_as_address</function> возвращает строку, содержащую достаточно информации для однозначной идентификации объекта БД по OID каталога, OID объекта и ID подобъекта (может быть нулевым). Выдаваемая информация не зависит от текущего сервера, то есть по ней можно идентифицировать одноимённый объект на другом сервере. Столбец <parameter>type</parameter> содержит тип объекта БД, а <parameter>name</parameter> и <parameter>args</parameter> — текстовые массивы, в совокупности формирующие ссылку на объект. Эти три столбца можно передать функции <function>pg_get_object_address</function>, чтобы получить внутренний адрес объекта. Данная функция является обратной к <function>pg_get_object_address</function>.</para>

  <para><function>pg_get_object_address</function> возвращает запись, содержащую достаточно информации для уникальной идентификации объекта БД по его типу и массивам имён и аргументов. В ней возвращаются значения, которые используются в системных каталогах, например <structname>pg_depend</structname>, и могут передаваться в другие системные функции, например <function>pg_identify_object</function> или <function>pg_describe_object</function>. Столбец <parameter>catalog_id</parameter> содержит OID системного каталога, к которому относится объект; <parameter>object_id</parameter> — OID самого объекта, а <parameter>object_sub_id</parameter> — идентификатор подобъекта, или 0 в случае его отсутствия. Эта функция является обратной к <function>pg_identify_object_as_address</function>.</para>

   <indexterm><primary>col_description</primary></indexterm>

   <indexterm><primary>obj_description</primary></indexterm>

   <indexterm><primary>shobj_description</primary></indexterm>

   <indexterm><primary>комментарии</primary> <secondary sortas="database objects">к объектам баз данных</secondary></indexterm>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-info-comment-table"/>, извлекают комментарии, заданные для объектов с помощью команды <xref linkend="sql-comment"/>. Если найти комментарий для заданных параметров не удаётся, они возвращают NULL.</para>

   <table id="functions-info-comment-table">
    <title>Функции получения комментариев</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>col_description(<parameter>table_oid</parameter>, <parameter>column_number</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает комментарий для столбца таблицы</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает комментарий для объекта базы данных</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает комментарий для объекта базы данных (<emphasis>устаревшая</emphasis> форма)</entry>
      </row>
      <row>
       <entry><literal><function>shobj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>получает комментарий для разделяемого объекта баз данных</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><function>col_description</function> возвращает комментарий для столбца с заданным номером в таблице с указанным OID. (<function>obj_description</function> нельзя использовать для столбцов таблицы, так столбцы не имеют собственных OID.)</para>

   <para>Функция <function>obj_description</function> с двумя параметрами возвращает комментарий для объекта, имеющего заданный OID и находящегося в указанном системном каталоге. Например, <literal>obj_description(123456,'pg_class')</literal> вернёт комментарий для таблицы с OID 123456. Форма <function>obj_description</function> с одним параметром принимает только OID. Она является устаревшей, так как значения OID могут повторяться в разных системных каталогах, и поэтому она может возвращать комментарий для другого объекта.</para>

   <para><function>shobj_description</function> работает подобно <function>obj_description</function>, но она получает комментарии для разделяемых объектов. Некоторые системные каталоги являются глобальными для всех баз данных в кластере и описания объектов в них также хранятся глобально.</para>

   <indexterm><primary>txid_current</primary></indexterm>

   <indexterm><primary>txid_current_snapshot</primary></indexterm>

   <indexterm><primary>txid_snapshot_xip</primary></indexterm>

   <indexterm><primary>txid_snapshot_xmax</primary></indexterm>

   <indexterm><primary>txid_snapshot_xmin</primary></indexterm>

   <indexterm><primary>txid_visible_in_snapshot</primary></indexterm>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-txid-snapshot"/>, выдают информацию о транзакциях сервера в форме во внешнем представлении. В основном эти функции используются, чтобы определить, какие транзакции были зафиксированы между двумя снимками состояния.</para>

   <table id="functions-txid-snapshot">
    <title>Идентификаторы транзакций и снимков состояния</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>txid_current()</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>получает идентификатор текущей транзакции и присваивает новый, если текущая транзакция его не имеет</entry>
      </row>
      <row>
       <entry><literal><function>txid_current_snapshot()</function></literal></entry>
       <entry><type>txid_snapshot</type></entry>
       <entry>получает код текущего снимка</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xip(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>setof bigint</type></entry>
       <entry>возвращает идентификаторы выполняющихся транзакций в снимке</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmax(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>возвращает значение <literal>xmax</literal> для заданного снимка</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmin(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
       <entry>возвращает значение <literal>xmin</literal> для заданного снимка</entry>
      </row>
      <row>
       <entry><literal><function>txid_visible_in_snapshot(<parameter>bigint</parameter>, <parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
       <entry>видима ли транзакция с указанным идентификатором в данном снимке? (коды подтранзакций не поддерживаются)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>В <productname>&productname;</productname> идентификаторы транзакций представлены 64-битными счётчиками для предотвращения зацикливания этих идентификаторов. Следующие функции выдают 64-битные значения, так что эти значения останутся уникальными на протяжении всей жизни сервера. Используемый этими функциями тип данных <type>txid_snapshot</type>, сохраняет информацию о видимости транзакций в определённый момент времени. Его состав описан в <xref remap="6" linkend="functions-txid-snapshot-parts"/>.</para>

   <table id="functions-txid-snapshot-parts">
    <title>Состав информации о снимке</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Имя</entry>
       <entry>Описание</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>xmin</type></entry>
       <entry>Идентификатор самой ранней транзакции (txid) из активных. Все предыдущие транзакции либо зафиксированы и видимы, либо отменены и мертвы.</entry>
      </row>

      <row>
       <entry><type>xmax</type></entry>
       <entry>Первый txid из ещё не назначенных. На момент снимка не было запущенных (а значит и видимых) транзакций с идентификатором, большим или равным данному.</entry>
      </row>

      <row>
       <entry><type>xip_list</type></entry>
       <entry>Список идентификаторов транзакций, активных в момент снимка. Он включает только идентификаторы с номерами от <literal>xmin</literal> до <literal>xmax</literal>; хотя уже могут быть транзакции с идентификаторами больше <literal>xmax</literal>. Если в этом списке не оказывается идентификатора транзакции <literal>xmin &lt;= txid &lt; xmax</literal>, это означает, что она уже не выполнялась к моменту снимка и, таким образом, видима или мертва, в зависимости от типа завершения. Идентификаторы подтранзакций в этот список не включаются.</entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>В текстовом виде <type>txid_snapshot</type> представляется как <literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>. Например, <literal>10:20:10,14,15</literal> означает <literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>.</para>

   <para>Функции, показанные в <xref remap="6" linkend="functions-commit-timestamp"/>, выдают информацию об уже зафиксированных транзакциях. Они возвращают полезные данные, только когда включён параметр конфигурации <xref linkend="guc-track-commit-timestamp"/> и только для транзакций, зафиксированных после его включения.</para>

   <table id="functions-commit-timestamp">
    <title>Информация о фиксации транзакций</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_xact_commit_timestamp</primary></indexterm>
        <literal><function>pg_xact_commit_timestamp(<parameter>xid</parameter>)</function></literal>
       </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>выдаёт время фиксации транзакции</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_last_committed_xact</primary></indexterm>
        <literal><function>pg_last_committed_xact()</function></literal>
       </entry>
       <entry><parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</parameter> <type>timestamp with time zone</type></entry>
       <entry>выдаёт идентификатор и время фиксации транзакции, зафиксированной последней</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-controldata"/>, выводят свойства, установленные командой <command>initdb</command>, например, версию каталога. Они также выводят сведения о работе журнала предзаписи и контрольных точках. Эта информация относится ко всему кластеру, а не к отдельной базе данных. Данные функции выдают практически всю ту же информацию, и из того же источника, что и <xref linkend="app-pgcontroldata"/>, но в форме, более подходящей для функций <acronym>SQL</acronym>.</para>

   <table id="functions-controldata">
    <title>Функции управления данными</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_control_checkpoint</primary></indexterm>
        <literal><function>pg_control_checkpoint()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>Возвращает информацию о состоянии текущей контрольной точки.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_control_system</primary></indexterm>
        <literal><function>pg_control_system()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>Возвращает информацию о текущем состоянии управляющего файла.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_control_init</primary></indexterm>
        <literal><function>pg_control_init()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>Возвращает информацию о состоянии инициализации кластера.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_control_recovery</primary></indexterm>
        <literal><function>pg_control_recovery()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>Возвращает информацию о состоянии восстановления.</entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>Функция <function>pg_control_checkpoint</function> возвращает запись, показанную в <xref remap="6" linkend="functions-pg-control-checkpoint"/>.</para>

   <table id="functions-pg-control-checkpoint">
    <title>Столбцы результата <function>pg_control_checkpoint</function></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Имя столбца</entry>
       <entry>Тип данных</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>checkpoint_location</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>prior_location</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>redo_location</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>redo_wal_file</literal></entry>
       <entry><type>text</type></entry>
      </row>

      <row>
       <entry><literal>timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>prev_timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>full_page_writes</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

      <row>
       <entry><literal>next_xid</literal></entry>
       <entry><type>text</type></entry>
      </row>

      <row>
       <entry><literal>next_oid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

      <row>
       <entry><literal>next_multixact_id</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>next_multi_offset</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_xid_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_active_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_multi_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_multi_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>newest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>checkpoint_time</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>Функция <function>pg_control_system</function> возвращает запись, показанную в <xref remap="6" linkend="functions-pg-control-system"/>.</para>

   <table id="functions-pg-control-system">
    <title>Столбцы результата <function>pg_control_system</function></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Имя столбца</entry>
       <entry>Тип данных</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>pg_control_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>catalog_version_no</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>system_identifier</literal></entry>
       <entry><type>bigint</type></entry>
      </row>

      <row>
       <entry><literal>pg_control_last_modified</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>Функция <function>pg_control_init</function> возвращает запись, показанную в <xref remap="6" linkend="functions-pg-control-init"/>.</para>

   <table id="functions-pg-control-init">
    <title>Столбцы результата <function>pg_control_init</function></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Имя столбца</entry>
       <entry>Тип данных</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>max_data_alignment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>database_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>blocks_per_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>wal_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>bytes_per_wal_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>max_identifier_length</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>max_index_columns</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>max_toast_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>large_object_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>bigint_timestamps</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

      <row>
       <entry><literal>float4_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

      <row>
       <entry><literal>float8_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

      <row>
       <entry><literal>data_page_checksum_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>Функция <function>pg_control_recovery</function> возвращает запись, показанную в <xref remap="6" linkend="functions-pg-control-recovery"/></para>

   <table id="functions-pg-control-recovery">
    <title>Столбцы результата <function>pg_control_recovery</function></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Имя столбца</entry>
       <entry>Тип данных</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>min_recovery_end_location</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>min_recovery_end_timeline</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>backup_start_location</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>backup_end_location</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>end_of_backup_record_required</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-admin">
   <title>Функции для системного администрирования</title>

   <para>Функции, описанные в этом разделе, предназначены для контроля и управления сервером <productname>&productname;</productname>.</para>

  <sect2 id="functions-admin-set">
   <title>Функции для управления конфигурацией</title>

   <para>В <xref remap="6" linkend="functions-admin-set-table"/> показаны функции, позволяющие получить и изменить значения параметров конфигурации выполнения.</para>

   <table id="functions-admin-set-table">
    <title>Функции для управления конфигурацией</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>current_setting</primary></indexterm>
        <literal><function>current_setting(<parameter>setting_name</parameter> [, <parameter>missing_ok</parameter> ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>получает текущее значение параметра</entry>
      </row>
      <row>
       <entry>
        <indexterm><primary>set_config</primary></indexterm>
        <literal><function>set_config(<parameter>setting_name</parameter>, <parameter>new_value</parameter>, <parameter>is_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>устанавливает новое значение параметра и возвращает его</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm><primary>SET</primary></indexterm>

   <indexterm><primary>SHOW</primary></indexterm>

   <indexterm><primary>конфигурация</primary> <secondary sortas="сервера">сервера</secondary> <tertiary>функции</tertiary></indexterm>

   <para>Функция <function>current_setting</function> выдаёт текущее значение параметра <parameter>setting_name</parameter>. Она соответствует стандартной <acronym>SQL</acronym>-команде <command>SHOW</command>. Пример использования: <programlisting>SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)</programlisting> Если параметра с именем <parameter>setting_name</parameter> нет, функция <function>current_setting</function> выдаёт ошибку, если только дополнительно не передан параметр <parameter>missing_ok</parameter> со значением <literal>true</literal>.</para>

   <para><function>set_config</function> устанавливает для параметра <parameter>setting_name</parameter> значение <parameter>new_value</parameter>. Если параметр <parameter>is_local</parameter> равен <literal>true</literal>, новое значение будет действовать только в рамках текущей транзакции. Чтобы это значение действовало на протяжении текущего сеанса, ему нужно присвоить <literal>false</literal>. Эта функция соответствует SQL-команде <command>SET</command>. Пример использования: <programlisting>SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)</programlisting></para>

  </sect2>

  <sect2 id="functions-admin-signal">
   <title>Функции для передачи сигналов серверу</title>

   <indexterm><primary>pg_cancel_backend</primary></indexterm>
   <indexterm><primary>pg_reload_conf</primary></indexterm>
   <indexterm><primary>pg_rotate_logfile</primary></indexterm>
   <indexterm><primary>pg_terminate_backend</primary></indexterm>

   <indexterm><primary>сигнал</primary> <secondary sortas="сервер">серверные процессы</secondary></indexterm>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-admin-signal-table"/>, позволяют передавать управляющие сигналы другим серверным процессам. Вызывать эти функции по умолчанию разрешено только суперпользователям, но доступ к ним можно дать и другим пользователям командой <command>GRANT</command>, кроме явно отмеченных исключений.</para>

   <table id="functions-admin-signal-table">
    <title>Функции для передачи сигналов серверу</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_cancel_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Отменяет текущий запрос в обслуживающем процессе. Это действие разрешается и ролям, являющимся членами роли, обслуживающий процесс которой затрагивается, и ролям, которым дано право <literal>pg_signal_backend</literal>; однако только суперпользователям разрешено воздействовать на обслуживающие процессы других суперпользователей.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_reload_conf()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Даёт команду серверным процессам перегрузить конфигурацию</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_rotate_logfile()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Прокручивает журнал сообщений сервера</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_terminate_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Завершает обслуживающий процесс. Это действие разрешается и ролям, являющимся членами роли, обслуживающий процесс которой прерывается, и ролям, которым дано право <literal>pg_signal_backend</literal>; однако только суперпользователям разрешено прерывать обслуживающие процессы других суперпользователей.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Каждая из этих функций возвращает <literal>true</literal> при успешном завершении и <literal>false</literal> в противном случае.</para>

   <para><function>pg_cancel_backend</function> и <function>pg_terminate_backend</function> передают сигналы (<systemitem>SIGINT</systemitem> и <systemitem>SIGTERM</systemitem>, соответственно) серверному процессу с заданным кодом PID. Код активного процесса можно получить из столбца <structfield>pid</structfield> представления <structname>pg_stat_activity</structname> или просмотрев на сервере процессы с именем <command>postgres</command> (используя <application>ps</application> в Unix или <application>Диспетчер задач</application> в <productname>Windows</productname>). Роль пользователя активного процесса можно узнать в столбце <structfield>usename</structfield> представления <structname>pg_stat_activity</structname>.</para>

   <para><function>pg_reload_conf</function> отправляет сигнал <systemitem>SIGHUP</systemitem> главному серверному процессу, который командует всем подчинённым процессам перезагрузить файлы конфигурации.</para>

   <para><function>pg_rotate_logfile</function> указывает менеджеру журнала сообщений немедленно переключиться на новый файл. Это имеет смысл, только когда работает встроенный сборщик сообщений, так как без него подпроцесс менеджера журнала не запускается.</para>

  </sect2>

  <sect2 id="functions-admin-backup">
   <title>Функции управления резервным копированием</title>

   <indexterm><primary>резервная копия</primary></indexterm>
   <indexterm><primary>pg_create_restore_point</primary></indexterm>
   <indexterm><primary>pg_current_xlog_flush_location</primary></indexterm>
   <indexterm><primary>pg_current_xlog_insert_location</primary></indexterm>
   <indexterm><primary>pg_current_xlog_location</primary></indexterm>
   <indexterm><primary>pg_start_backup</primary></indexterm>
   <indexterm><primary>pg_stop_backup</primary></indexterm>
   <indexterm><primary>pg_is_in_backup</primary></indexterm>
   <indexterm><primary>pg_backup_start_time</primary></indexterm>
   <indexterm><primary>pg_switch_xlog</primary></indexterm>
   <indexterm><primary>pg_xlogfile_name</primary></indexterm>
   <indexterm><primary>pg_xlogfile_name_offset</primary></indexterm>
   <indexterm><primary>pg_xlog_location_diff</primary></indexterm>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-admin-backup-table"/>, предназначены для выполнения резервного копирования &laquo;на ходу&raquo;. Эти функции нельзя выполнять во время восстановления (за исключением <function>pg_is_in_backup</function>, <function>pg_backup_start_time</function> и <function>pg_xlog_location_diff</function>).</para>

   <table id="functions-admin-backup-table">
    <title>Функции управления резервным копированием</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_create_restore_point(<parameter>name</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Создаёт именованную точку для восстановления (по умолчанию разрешено только суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим пользователям)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_flush_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Получает текущую позицию сброса данных в журнале транзакций</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_insert_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Получает текущую позицию добавления в журнале транзакций</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Получает текущую позицию записи в журнале транзакций</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_start_backup(<parameter>label</parameter> <type>text</type> <optional>, <parameter>fast</parameter> <type>boolean</type> <optional>, <parameter>exclusive</parameter> <type>boolean</type></optional></optional>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Подготавливает сервер к резервному копированию (по умолчанию разрешено только суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим пользователям)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Завершает монопольное резервное копирование (по умолчанию разрешено только суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим пользователям)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup(<parameter>exclusive</parameter> <type>boolean</type>)</function></literal>
        </entry>
       <entry><type>setof record</type></entry>
       <entry>Завершает монопольное или немонопольное резервное копирование (по умолчанию разрешено только суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим пользователям)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_is_in_backup()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>Возвращает true в процессе исключительного резервного копирования</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_backup_start_time()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>Получает время запуска выполняющегося исключительного резервного копирования</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_switch_xlog()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Инициирует переключение на новый файл журнала транзакций (по умолчанию разрешено только суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим пользователям)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name(<parameter>location</parameter> <type>pg_lsn</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>Получает из строки позиции в журнале транзакций имя соответствующего файла</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name_offset(<parameter>location</parameter> <type>pg_lsn</type>)</function></literal>
        </entry>
       <entry><type>text</type>, <type>integer</type></entry>
       <entry>Получает из строки позиции в журнале транзакций имя соответствующего файла и десятичное смещение в нём</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_location_diff(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>location</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry><type>numeric</type></entry>
       <entry>Вычисляет разницу между двумя позициями в журнале транзакций</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><function>pg_start_backup</function> принимает произвольную заданную пользователем метку резервной копии. (Обычно это имя файла, в котором будет сохранена резервная копия.) При копировании в монопольном режиме эта функция записывает файл метки (<filename>backup_label</filename>) и, если есть ссылки в каталоге <filename>pg_tblspc/</filename>, файл карты табличных пространств (<filename>tablespace_map</filename>) в каталог данных кластера БД, выполняет процедуру контрольной точки, а затем возвращает в текстовом виде начальную позицию в журнале транзакций для данной резервной копии. Результат этой функции может быть полезен, но если он не нужен, его можно просто игнорировать. При копировании в немонопольном режиме содержимое этих файлов выдаётся функцией <function>pg_stop_backup</function> и должно быть записано в архивную копию вызывающим субъектом. <programlisting>postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)</programlisting> У этой функции есть также второй, необязательный параметр типа <type>boolean</type>. Если он равен <literal>true</literal>, <function>pg_start_backup</function> начнёт работу максимально быстро. При этом будет немедленно выполнена процедура контрольной точки, что может повлечь массу операций ввода/вывода и затормозить параллельные запросы.</para>

   <para>При монопольном копировании функция <function>pg_stop_backup</function> удаляет файл метки (и, если существует, файл <filename>tablespace_map</filename>), созданный функцией <function>pg_start_backup</function>. При немонопольном копировании содержимое <filename>backup_label</filename> и <filename>tablespace_map</filename> возвращается в результате функции, и должно быть записано в файлы в архиве (а не в каталоге данных). При выполнении функции <function>pg_stop_backup</function> на ведущем она будет ждать архивирования WAL, если архивация настроена.</para>

   <para>На ведомом сервере <function>pg_stop_backup</function> завершится немедленно, без ожидания, поэтому важно убедиться в том, что все нужные сегменты WAL были заархивированы. В случае низкой активности записи на ведущем сервере может иметь смысл выполнить на нём <function>pg_switch_xlog</function>, чтобы произошло переключение сегмента.</para>

   <para>При выполнении на ведущем эта функция также создаёт файл истории резервного копирования в области архива журнала предзаписи. В этом файле для данной резервной копии сохраняется метка, заданная при вызове <function>pg_start_backup</function>, начальная и конечная позиция в журнале транзакций, а также время начала и окончания. Возвращает данная функция позицию окончания резервной копии в журнале транзакций (которую тоже можно игнорировать). После записи конечной позиции текущая позиция записи автоматически перемещается к следующему файлу журнала транзакций, чтобы файл конечной позиции можно было немедленно архивировать для завершения резервного копирования.</para>

   <para><function>pg_switch_xlog</function> производит переключение на следующий файл журнала транзакций, что позволяет архивировать текущий (в ситуации, когда архивация выполняется непрерывно). Эта функция возвращает конечную позицию + 1 в только что законченном файле журнала транзакций. Если с момента последнего переключения файлов не было активности, отражающейся в журнале транзакций, <function>pg_switch_xlog</function> ничего не делает и возвращает начальную позицию в файле журнала транзакций, используемом в данный момент.</para>

   <para><function>pg_create_restore_point</function> создаёт именованную запись в журнале транзакций, которую можно использовать как цель при восстановлении, и возвращает соответствующую позицию в журнале транзакций. Затем полученное имя можно присвоить параметру <xref linkend="recovery-target-name"/>, указав тем самым точку, до которой будет выполняться восстановление. Учтите, что если вы создадите несколько точек восстановления с одним именем, восстановление будет остановлено на первой точке с этим именем.</para>

   <para><function>pg_current_xlog_location</function> выводит текущую позицию записи в журнале транзакций в том же формате, что и вышеописанные функции. <function>pg_current_xlog_insert_location</function> подобным образом выводит текущую позицию добавления, а <function>pg_current_xlog_flush_location</function> — позицию сброса данных журнала. Позицией добавления называется <quote>логический</quote> конец журнала транзакций в любой момент времени, тогда как позиция записи указывает на конец данных, фактически вынесённых из внутренних буферов сервера, а позиция сброса показывает, до какого места данные гарантированно сохранены в надёжном хранилище. Позиция записи отмечает конец данных, которые может видеть снаружи внешний процесс, и именно она представляет интерес при копировании частично заполненных файлов журнала транзакций. Позиция добавления и позиция сброса выводятся в основном для отладки серверной части. Все эти операции выполняются в режиме &laquo;только чтение&raquo; и не требуют прав суперпользователя.</para>

   <para>Из результатов всех описанных выше функций можно получить соответствующее имя файла журнала транзакций и смещение в нём, используя функцию <function>pg_xlogfile_name_offset</function>. Например: <programlisting>postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)</programlisting> Подобная ей функция <function>pg_xlogfile_name</function> извлекает только имя файла журнала транзакций. Когда позиция в журнале транзакций находится ровно на границе файлов, обе эти функции возвращают имя предыдущего файла. Обычно это поведение предпочтительно при архивировании журнала, так как именно предыдущий файл является последним подлежащим архивации.</para>

   <para><function>pg_xlog_location_diff</function> вычисляет разницу в байтах между двумя позициями в журнале транзакций. Полученный результат можно использовать с <structname>pg_stat_replication</structname> или другими функциями, перечисленными в <xref remap="6" linkend="functions-admin-backup-table"/>, для определения задержки репликации.</para>

   <para>Подробнее практическое применение этих функций описывается в <xref remap="6" linkend="continuous-archiving"/>.</para>

  </sect2>

  <sect2 id="functions-recovery-control">
   <title>Функции управления восстановлением</title>

   <indexterm><primary>pg_is_in_recovery</primary></indexterm>
   <indexterm><primary>pg_last_xlog_receive_location</primary></indexterm>
   <indexterm><primary>pg_last_xlog_replay_location</primary></indexterm>
   <indexterm><primary>pg_last_xact_replay_timestamp</primary></indexterm>

   <para>Функции, приведённые в <xref remap="6" linkend="functions-recovery-info-table"/>, предоставляют сведения о текущем состоянии ведомого сервера. Эти функции могут выполняться, как во время восстановления, так и в обычном режиме работы.</para>

   <table id="functions-recovery-info-table">
    <title>Функции для получения информации о восстановлении</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_in_recovery()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>Возвращает true в процессе восстановления.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_receive_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Получает позицию последней записи журнала транзакций, полученной и записанной на диск в процессе потоковой репликации. Пока выполняется потоковая репликация, эта позиция постоянно увеличивается. По окончании восстановления она останавливается на записи WAL, полученной и записанной на диск последней. Если потоковая репликация отключена или ещё не запускалась, функция возвращает NULL.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_replay_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
       <entry>Получает позицию последней записи журнала транзакций, воспроизведённой при восстановлении. В процессе восстановления эта позиция постоянно увеличивается. По окончании восстановления она останавливается на записи WAL, которая была восстановлена последней. Если сервер был запущен не в режиме восстановления, эта функция возвращает NULL.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xact_replay_timestamp()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
       <entry>Получает отметку времени последней транзакции, воспроизведённой при восстановлении. Это время, когда на главном сервере произошла фиксация или откат записи WAL для этой транзакции. Если в процессе восстановления не была воспроизведена ни одна транзакция, эта функция возвращает NULL. В противном случае это значение постоянно увеличивается в процессе восстановления. По окончании восстановления оно останавливается на транзакции, которая была восстановлена последней. Если сервер был запущен не в режиме восстановления, эта функция возвращает NULL.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm><primary>pg_is_xlog_replay_paused</primary></indexterm>
   <indexterm><primary>pg_xlog_replay_pause</primary></indexterm>
   <indexterm><primary>pg_xlog_replay_resume</primary></indexterm>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-recovery-control-table"/> управляют процессом восстановления. Вызывать их в другое время нельзя.</para>

   <table id="functions-recovery-control-table">
    <title>Функции управления восстановлением</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_xlog_replay_paused()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
       <entry>Возвращает true, если восстановление приостановлено.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_pause()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>Немедленно приостанавливает восстановление (по умолчанию разрешено только суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим пользователям).</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_resume()</function></literal>
        </entry>
       <entry><type>void</type></entry>
       <entry>Перезапускает восстановление, если оно было приостановлено (по умолчанию разрешено только суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим пользователям).</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Когда восстановление приостановлено, запись изменений в базу не производится. Если она находится в &laquo;горячем резерве&raquo;, все последующие запросы будут видеть один согласованный снимок базы данных и до продолжения восстановления конфликты запросов исключаются.</para>

   <para>Когда потоковая репликация выключена, пауза при восстановлении может длиться сколь угодно долго без каких-либо проблем. Если же запущена потоковая репликация, новые записи WAL продолжат поступать и заполнят весь диск рано или поздно, в зависимости от длительности паузы, интенсивности записи в WAL и объёма свободного пространства.</para>

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
   <title>Функции синхронизации снимков</title>

   <indexterm><primary>pg_export_snapshot</primary></indexterm>

   <para><productname>&productname;</productname> позволяет синхронизировать снимки состояния между сеансами баз данных. <firstterm>Снимок состояния</firstterm> определяет, какие данные видны транзакции, работающей с этим снимком. Синхронизация снимков необходима, когда в двух или более сеансах нужно видеть одно и то же содержимое базы данных. Если в двух сеансах транзакции запускаются независимо, всегда есть вероятность, что некая третья транзакция будет зафиксирована между командами <command>START TRANSACTION</command> для первых двух, и в результате в одном сеансе будет виден результат третьей, а в другом &mdash; нет.</para>

   <para>Для решения этой проблемы <productname>&productname;</productname> позволяет транзакции <firstterm>экспортировать</firstterm> снимок состояния, с которым она работает. Пока экспортирующая этот снимок транзакция выполняется, другие транзакции могут <firstterm>импортировать</firstterm> его и, таким образом, увидеть абсолютно то же состояние базы данных, что видит первая транзакция. Но учтите, что любые изменения, произведённые этими транзакциями, будут не видны для других, как это и должно быть с изменениями в незафиксированных транзакциях. Таким образом, транзакции синхронизируют только начальное состояние данных, а последующие производимые в них изменения изолируются как обычно.</para>

   <para>Снимки состояния экспортируются с помощью функции <function>pg_export_snapshot</function>, показанной в <xref remap="6" linkend="functions-snapshot-synchronization-table"/>, и импортируются командой <xref linkend="sql-set-transaction"/>.</para>

   <table id="functions-snapshot-synchronization-table">
    <title>Функции синхронизации снимков</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_export_snapshot()</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Сохраняет снимок текущего состояния и возвращает его идентификатор</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Функция <function>pg_export_snapshot</function> создаёт снимок текущего состояния и возвращает его идентификатор в строке типа <type>text</type>. Данная строка должна передаваться (за рамками базы данных) клиентам, которые будут импортировать этот снимок. При этом импортировать его нужно раньше, чем завершится транзакция, которая его экспортировала. Если необходимо, транзакция может экспортировать несколько снимков. Заметьте, что это имеет смысл только для транзакций уровня <literal>READ COMMITTED</literal>, так как транзакции <literal>REPEATABLE READ</literal> и более высоких уровней изоляции работают с одним снимком состояния. После того, как транзакция экспортировала снимок, её нельзя подготовить с помощью <xref linkend="sql-prepare-transaction"/>.</para>

   <para>Подробнее использование экспортированных снимков рассматривается в описании <xref linkend="sql-set-transaction"/>.</para>
  </sect2>

  <sect2 id="functions-replication">
   <title>Функции репликации</title>

   <para>В <xref remap="6" linkend="functions-replication-table"/> перечислены функции, предназначенные для управления и взаимодействия с механизмом репликации. Чтобы изучить этот механизм детальнее, обратитесь к <xref remap="3" linkend="streaming-replication"/>, <xref remap="3" linkend="streaming-replication-slots"/> и <xref remap="3" linkend="replication-origins"/>. Использовать эти функции разрешено только суперпользователям.</para>

   <para>Многие из этих функций соответствуют командам в протоколе репликации; см. <xref remap="4" linkend="protocol-replication"/>.</para>

   <para>Функции, описанные в <xref remap="6" linkend="functions-admin-backup"/>, <xref linkend="functions-recovery-control"/> и <xref remap="6" linkend="functions-snapshot-synchronization"/> также имеют отношение к репликации.</para>

   <table id="functions-replication-table">
    <title>Функции репликации <acronym>SQL</acronym></title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Тип результата</entry>
       <entry>Описание</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_create_physical_replication_slot</primary></indexterm>
        <literal><function>pg_create_physical_replication_slot(<parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>(<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)</entry>
       <entry>Создаёт новый физический слот репликации с именем <parameter>slot_name</parameter>. Необязательный второй параметр, когда он равен <literal>true</literal>, указывает, что <acronym>LSN</acronym> для этого слота репликации должен быть зарезервирован немедленно; в противном случае <acronym>LSN</acronym> резервируется при первом подключении клиента потоковой репликации. Передача изменений из физического слота возможна только по протоколу потоковой репликации &mdash; см. <xref remap="4" linkend="protocol-replication"/>. Эта функция соответствует команде протокола репликации <literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>.</entry>
      </row>
      <row>
       <entry>
        <indexterm><primary>pg_drop_replication_slot</primary></indexterm>
        <literal><function>pg_drop_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>Удаляет физический или логический слот репликации с именем <parameter>slot_name</parameter>. Соответствует команде протокола репликации <literal>DROP_REPLICATION_SLOT</literal>.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_create_logical_replication_slot</primary></indexterm>
        <literal><function>pg_create_logical_replication_slot(<parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>(<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)</entry>
       <entry>Создаёт новый логический (декодирующий) слот репликации с именем <parameter>slot_name</parameter>, используя модуль вывода <parameter>plugin</parameter>. Эта функция работает так же, как и команда протокола репликации <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_logical_slot_get_changes</primary></indexterm>
        <literal><function>pg_logical_slot_get_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)</entry>
       <entry>Возвращает изменения в слоте <parameter>slot_name</parameter> с позиции, до которой ранее были получены изменения. Если параметры <parameter>upto_lsn</parameter> и <parameter>upto_nchanges</parameter> равны NULL, логическое декодирование продолжится до конца журнала транзакций. Если <parameter>upto_lsn</parameter> не NULL, декодироваться будут только транзакции, зафиксированные до заданного LSN. Если <parameter>upto_nchanges</parameter> не NULL, декодирование остановится, когда число строк, полученных при декодировании, превысит заданное значение. Заметьте, однако, что фактическое число возвращённых строк может быть больше, так как это ограничение проверяется только после добавления строк, декодированных для очередной транзакции.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_logical_slot_peek_changes</primary></indexterm>
        <literal><function>pg_logical_slot_peek_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>(<parameter>location</parameter> <type>text</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)</entry>
       <entry>Работает так же, как функция <function>pg_logical_slot_get_changes()</function>, но не забирает изменения; то есть, они будут получены снова при следующих вызовах.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_logical_slot_get_binary_changes</primary></indexterm>
        <literal><function>pg_logical_slot_get_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)</entry>
       <entry>Работает так же, как функция <function>pg_logical_slot_get_changes()</function>, но выдаёт изменения в типе <type>bytea</type>.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_logical_slot_peek_binary_changes</primary></indexterm>
        <literal><function>pg_logical_slot_peek_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)</entry>
       <entry>Работает так же, как функция <function>pg_logical_slot_get_changes()</function>, но выдаёт изменения в типе <type>bytea</type> и не забирает их; то есть, они будут получены снова при следующих вызовах.</entry>
      </row>

      <row>
       <entry id="pg-replication-origin-create">
        <indexterm><primary>pg_replication_origin_create</primary></indexterm>
        <literal><function>pg_replication_origin_create(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>Создаёт источник репликации с заданным внешним именем и возвращает назначенный ему внутренний идентификатор.</entry>
      </row>

      <row>
       <entry id="pg-replication-origin-drop">
        <indexterm><primary>pg_replication_origin_drop</primary></indexterm>
        <literal><function>pg_replication_origin_drop(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>Удаляет ранее созданный источник репликации, в том числе связанную информацию о воспроизведении.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_replication_origin_oid</primary></indexterm>
        <literal><function>pg_replication_origin_oid(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>Ищет источник репликации по имени и возвращает внутренний идентификатор. Если такой источник не находится, выдаётся ошибка.</entry>
      </row>

      <row>
       <entry id="pg-replication-origin-session-setup">
        <indexterm><primary>pg_replication_origin_session_setup</primary></indexterm>
        <literal><function>pg_replication_origin_session_setup(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>Помечает текущий сеанс, как воспроизводящий журнал из указанного источника, что позволяет отслеживать положение воспроизведения. Чтобы отменить это действие, вызовите <function>pg_replication_origin_session_reset</function>. Может использоваться, только если не был настроен предыдущий источник.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_replication_origin_session_reset</primary></indexterm>
        <literal><function>pg_replication_origin_session_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>Отменяет действие <function>pg_replication_origin_session_setup()</function>.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_replication_origin_session_is_setup</primary></indexterm>
        <literal><function>pg_replication_origin_session_is_setup()</function></literal>
       </entry>
       <entry>
        <type>bool</type>
       </entry>
       <entry>В текущем сеансе настроен источник репликации?</entry>
      </row>

      <row>
       <entry id="pg-replication-origin-session-progress">
        <indexterm><primary>pg_replication_origin_session_progress</primary></indexterm>
        <literal><function>pg_replication_origin_session_progress(<parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>Возвращает позицию воспроизведения для источника репликации, настроенного в текущем сеансе. Параметр <parameter>flush</parameter> определяет, будет ли гарантироваться сохранение локальной транзакции на диске.</entry>
      </row>

      <row>
       <entry id="pg-replication-origin-xact-setup">
        <indexterm><primary>pg_replication_origin_xact_setup</primary></indexterm>
        <literal><function>pg_replication_origin_xact_setup(<parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamptz</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>Помечает текущую транзакцию как воспроизводящую транзакцию, зафиксированную с указанным <acronym>LSN</acronym> и временем. Может вызываться только после того, как был настроен источник репликации в результате вызова <function>pg_replication_origin_session_setup()</function>.</entry>
      </row>

      <row>
       <entry id="pg-replication-origin-xact-reset">
        <indexterm><primary>pg_replication_origin_xact_reset</primary></indexterm>
        <literal><function>pg_replication_origin_xact_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>Отменяет действие <function>pg_replication_origin_xact_setup()</function>.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_replication_origin_advance</primary></indexterm>
        <literal>pg_replication_origin_advance<function>(<parameter>node_name</parameter> <type>text</type>, <parameter>pos</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>Устанавливает положение репликации для заданного узла в указанную позицию. Это в основном полезно для установки начальной позиции или новой позиции после изменения конфигурации и подобных действий. Но учтите, что неосторожное использование этой функции может привести к несогласованности реплицированных данных.</entry>
      </row>

      <row>
       <entry id="pg-replication-origin-progress">
        <indexterm><primary>pg_replication_origin_progress</primary></indexterm>
        <literal><function>pg_replication_origin_progress(<parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>Возвращает позицию воспроизведения для заданного источника репликации. Параметр <parameter>flush</parameter> определяет, будет ли гарантироваться сохранение локальной транзакции на диске.</entry>
      </row>

      <row>
       <entry id="pg-logical-emit-message-text">
        <indexterm><primary>pg_logical_emit_message</primary></indexterm>
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>Выдаёт текстовое сообщение логического декодирования. Её можно использовать для передачи произвольных сообщений через WAL модулям логического декодирования. Параметр <parameter>transactional</parameter> устанавливает, должно ли сообщение быть частью текущей транзакции или оно должно записываться немедленно и декодироваться сразу, как только эта запись будет прочитана при логическом декодировании. Параметр <parameter>prefix</parameter> задаёт текстовый префикс, по которому модули логического декодирования могут легко распознать интересующие их сообщения. В параметре <parameter>content</parameter> передаётся текст сообщения.</entry>
      </row>

      <row>
       <entry id="pg-logical-emit-message-bytea">
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>Выдаёт двоичное сообщение логического декодирования. Её можно использовать для передачи произвольных сообщений через WAL модулям логического декодирования. Параметр <parameter>transactional</parameter> устанавливает, должно ли сообщение быть частью текущей транзакции или оно должно записываться немедленно и декодироваться сразу, как только эта запись будет прочитана при логическом декодировании. Параметр <parameter>prefix</parameter> задаёт текстовый префикс, по которому модули логического декодирования могут легко распознать интересующие их сообщения. В параметре <parameter>content</parameter> передаётся двоичное содержание сообщения.</entry>
      </row>

     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-dbobject">
   <title>Функции управления объектами баз данных</title>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-admin-dbsize"/>, вычисляют объём, который занимают на диске различные объекты баз данных.</para>

   <indexterm><primary>pg_column_size</primary></indexterm>
   <indexterm><primary>pg_database_size</primary></indexterm>
   <indexterm><primary>pg_indexes_size</primary></indexterm>
   <indexterm><primary>pg_relation_size</primary></indexterm>
   <indexterm><primary>pg_size_bytes</primary></indexterm>
   <indexterm><primary>pg_size_pretty</primary></indexterm>
   <indexterm><primary>pg_table_size</primary></indexterm>
   <indexterm><primary>pg_tablespace_size</primary></indexterm>
   <indexterm><primary>pg_total_relation_size</primary></indexterm>

   <table id="functions-admin-dbsize">
    <title>Функции получения размера объектов БД</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_column_size(<type>any</type>)</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>Число байт, необходимых для хранения заданного значения (возможно, в сжатом виде)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Объём, который занимает на диске база данных с заданным OID</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Объём, который занимает на диске база данных с заданным именем</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_indexes_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Общий объём индексов, связанных с указанной таблицей</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>, <parameter>fork</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Объём, который занимает на диске указанный слой (<literal>'main'</literal>, <literal>'fsm'</literal>, <literal>'vm'</literal> или <literal>'init'</literal>) заданной таблицы или индекса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Краткая форма <literal>pg_relation_size(..., 'main')</literal></entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_temp_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Общее пространство, занятое слоем <literal>main</literal> заданной временной таблицы.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_bytes(<type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Преобразует размер в понятном человеку формате с единицами измерения в число байт</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>bigint</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>Преобразует размер в байтах, представленный в 64-битном целом, в понятный человеку формат с единицами измерения</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>numeric</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>Преобразует размер в байтах, представленный в значении числового типа, в понятный человеку формат с единицами измерения</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_table_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Объём, который занимает на диске данная таблица, за исключением индексов (но включая TOAST, карту свободного места и карту видимости)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Объём, который занимает на диске табличное пространство с указанным OID</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Объём, который занимает на диске табличное пространство с заданным именем</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_total_relation_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>Общий объём, который занимает на диске заданная таблица, включая все индексы и данные <acronym>TOAST</acronym></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><function>pg_column_size</function> показывает, какой объём требуется для хранения данного значения.</para>

   <para><function>pg_total_relation_size</function> принимает OID или имя таблицы или данных TOAST и возвращает общий объём, который занимает на диске эта таблица, включая все связанные с ней индексы. Результат этой функции равняется <function>pg_table_size</function> <literal>+</literal> <function>pg_indexes_size</function>.</para>

   <para><function>pg_table_size</function> принимает OID или имя таблицы и возвращает объём, который занимает на диске эта таблица без индексов. (При этом учитывается размер TOAST, карты свободного места и карты видимости.)</para>

   <para><function>pg_indexes_size</function> принимает OID или имя таблицы и возвращает общий объём, который занимают все индексы таблицы.</para>

   <para><function>pg_database_size</function> и <function>pg_tablespace_size</function> принимают OID или имя базы данных либо табличного пространства и возвращают общий объём, который они занимают на диске. Для использования <function>pg_database_size</function> требуется право <literal>CONNECT</literal> для указанной базы данных (оно имеется по умолчанию). Для использования <function>pg_tablespace_size</function> необходимо иметь право <literal>CREATE</literal> в указанном табличном пространстве, если только это не табличное пространство по умолчанию для текущей базы данных.</para>

   <para><function>pg_relation_size</function> принимает OID или имя таблицы, индекса или TOAST-таблицы и возвращает размер одного слоя этого отношения (в байтах). (Заметьте, что в большинстве случаев удобнее использовать более высокоуровневые функции <function>pg_total_relation_size</function> и <function>pg_table_size</function>, которые суммируют размер всех слоёв.) С одним аргументом она возвращает размер основного слоя для данных заданного отношения. Название другого интересующего слоя можно передать во втором аргументе: <itemizedlist spacing="compact">
     <listitem>
      <para><literal>'main'</literal> возвращает размер основного слоя данных заданного отношения.</para>
     </listitem>
     <listitem>
      <para><literal>'fsm'</literal> возвращает размер карты свободного места (см. <xref remap="4" linkend="storage-fsm"/>), связанной с заданным отношением.</para>
     </listitem>
     <listitem>
      <para><literal>'vm'</literal> возвращает размер карты видимости (см. <xref remap="4" linkend="storage-vm"/>), связанной с заданным отношением.</para>
     </listitem>
     <listitem>
      <para><literal>'init'</literal> возвращает размер слоя инициализации для заданного отношения, если он имеется.</para>
     </listitem>
    </itemizedlist></para>

   <para>Функция <function>pg_temp_relation_size</function> принимает OID или имя временной таблицы и возвращает общий размер в байтах слоя <literal>main</literal> данного отношения. Физический файл временной таблицы расширяется только когда она перестаёт помещаться в кеш <literal>temp_buffers</literal>. Поэтому общий размер временной таблицы может отличаться от её размера на диске. Если отношение не является временной таблицей, эта функция не выдаёт ошибку, а просто возвращает NULL.</para>

   <para><function>pg_size_pretty</function> можно использовать для форматирования результатов других функций в виде, более понятном человеку, с единицами измерения bytes, kB, MB, GB и TB.</para>

   <para><function>pg_size_bytes</function> можно использовать для получения размера в байтах из строки в формате, понятном человеку. Входная строка может содержать единицы bytes, kB, MB, GB и TB, и разбирается без учёта регистра. Если единицы не указываются, подразумеваются байты.</para>

   <note>
    <para>Единицы kB, MB, GB и TB, фигурирующие в функциях <function>pg_size_pretty</function> и <function>pg_size_bytes</function>, определяются как степени 2, а не 10, так что 1kB равен 1024 байтам, 1MB равен 1024<superscript>2</superscript> = 1048576 байтов и т. д.</para>
   </note>

   <para>Вышеописанные функции, работающие с таблицами или индексами, принимают аргумент типа <type>regclass</type>, который представляет собой просто OID таблицы или индекса в системном каталоге <structname>pg_class</structname>. Однако вам не нужно вручную вычислять OID, так как процедура ввода значения <type>regclass</type> может сделать это за вас. Для этого достаточно записать имя таблицы в апострофах, как обычную текстовую константу. В соответствии с правилами обработки обычных имён <acronym>SQL</acronym>, если имя таблицы не заключено в кавычки, эта строка будет переведена в нижний регистр.</para>

   <para>Если переданному значению OID не соответствуют существующий объект, эти функции возвращают NULL.</para>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-admin-dblocation"/>, помогают определить, в каких файлах на диске хранятся объекты базы данных.</para>

   <indexterm><primary>pg_relation_filenode</primary></indexterm>
   <indexterm><primary>pg_relation_filepath</primary></indexterm>
   <indexterm><primary>pg_filenode_relation</primary></indexterm>

   <table id="functions-admin-dblocation">
    <title>Функции определения расположения объектов</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_relation_filenode(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>oid</type></entry>
       <entry>Номер файлового узла для указанного отношения</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_filepath(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>Путь к файлу, в котором хранится указанное отношение</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_filenode_relation(<parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type>)</function></literal>
        </entry>
       <entry><type>regclass</type></entry>
       <entry>Находит отношение, связанное с данным табличным пространством и файловым узлом</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><function>pg_relation_filenode</function> принимает OID или имя таблицы, индекса, последовательности или таблицы TOAST и возвращает номер <quote>файлового узла</quote>, связанным с этим объектом. Файловым узлом называется основной компонент имени файла, используемого для хранения данных (подробнее это описано в <xref remap="6" linkend="storage-file-layout"/>). Для большинства таблиц этот номер совпадает со значением <structname>pg_class</structname>.<structfield>relfilenode</structfield>, но для некоторых системных каталогов <structfield>relfilenode</structfield> равен 0, и нужно использовать эту функцию, чтобы узнать действительное значение. Если указанное отношение не хранится на диске, как например представление, данная функция возвращает NULL.</para>

   <para><function>pg_relation_filepath</function> подобна <function>pg_relation_filenode</function>, но возвращает полный путь к файлу (относительно каталога данных <varname>PGDATA</varname>) отношения.</para>

   <para>Функция <function>pg_filenode_relation</function> является обратной к <function>pg_relation_filenode</function>. Она возвращает OID отношения по заданному OID <quote>табличного пространства</quote> и <quote>файловому узлу</quote>. Для таблицы в табличном пространстве по умолчанию в первом параметре можно передать 0.</para>

  </sect2>

  <sect2 id="functions-admin-index">
   <title>Функции обслуживания индексов</title>

   <indexterm><primary>brin_summarize_new_values</primary></indexterm>

   <indexterm><primary>gin_clean_pending_list</primary></indexterm>

   <para>В <xref remap="6" linkend="functions-admin-index-table"/> перечислены функции, предназначенные для обслуживания индексов. Эти функции нельзя вызывать в процессе восстановления. Использовать эти функции разрешено только суперпользователям и владельцу определённого индекса.</para>

   <table id="functions-admin-index-table">
    <title>Функции обслуживания индексов</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>brin_summarize_new_values(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
       <entry>обобщает ещё не обобщённые зоны страниц</entry>
      </row>
      <row>
       <entry>
        <literal><function>gin_clean_pending_list(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>bigint</type></entry>
       <entry>перемещает элементы из списка записей GIN, ожидающих обработки, в основную структуру индекса</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Функция <function>brin_summarize_new_values</function> принимает OID или имя индекса BRIN и просматривает индекс в поисках зон страниц в базовой таблице, ещё не обобщённых в индексе; для каждой такой зоны в результате сканирования страниц таблицы создаётся новый обобщающий кортеж в индексе. Возвращает эта функция число вставленных в индекс обобщающих записей о зонах страниц.</para>

   <para>Функция <function>gin_clean_pending_list</function> принимает OID или имя индекса GIN и очищает очередь указанного индекса, массово перемещая элементы из неё в основную структуру данных GIN. Возвращает она число страниц, убранных из очереди. Заметьте, что если для обработки ей передаётся индекс GIN, построенный с отключённым параметром <literal>fastupdate</literal>, очистка не производится и возвращается значение 0, так как у такого индекса нет очереди записей. Подробнее об очереди записей и параметре <literal>fastupdate</literal> рассказывается в <xref remap="6" linkend="gin-fast-update"/> и <xref remap="6" linkend="gin-tips"/>.</para>

  </sect2>

  <sect2 id="functions-admin-genfile">
   <title>Функции для работы с обычными файлами</title>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-admin-genfile-table"/>, предоставляют прямой доступ к файлам, находящимся на сервере. Они позволяют обращаться только к файлам в каталоге кластера баз данных (по относительному пути) или в каталоге <varname>log_directory</varname> (по пути, заданному в параметре конфигурации <varname>log_directory</varname>). Использовать эти функции могут только суперпользователи.</para>

   <table id="functions-admin-genfile-table">
    <title>Функции для работы с обычными файлами</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_ls_dir(<parameter>dirname</parameter> <type>text</type> [, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>Возвращает список содержимого каталога.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>Возвращает содержимое текстового файла.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_binary_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>Возвращает содержимое файла.</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stat_file(<parameter>filename</parameter> <type>text</type>[, <parameter>missing_ok</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>Возвращает информацию о файле.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Все эти функции принимают необязательный параметр <parameter>missing_ok</parameter>, который определяет их поведение в случае отсутствия файла или каталога. Если он равен <literal>true</literal>, функция возвращает NULL (за исключением <function>pg_ls_dir</function>, которая возвращает пустое множество). Если он равен <literal>false</literal>, возникает ошибка. Значение по умолчанию — <literal>false</literal>.</para>

   <indexterm><primary>pg_ls_dir</primary></indexterm>
   <para><function>pg_ls_dir</function> возвращает имена всех файлов (а также каталогов и других специальных файлов) в заданном каталоге. Параметр <parameter>include_dot_dirs</parameter> определяет, будут ли в результирующий набор включаться каталоги <quote>.</quote> и <quote>..</quote>. По умолчанию они не включаются (<literal>false</literal>), но их можно включить, чтобы с параметром <parameter>missing_ok</parameter> равным <literal>true</literal>, пустой каталог можно было отличить от несуществующего.</para>

   <indexterm><primary>pg_read_file</primary></indexterm>
   <para><function>pg_read_file</function> возвращает фрагмент текстового файла с заданного смещения (<parameter>offset</parameter>), размером не больше <parameter>length</parameter> байт (размер может быть меньше, если файл кончится раньше). Если смещение <parameter>offset</parameter> отрицательно, оно отсчитывается от конца файла. Если параметры <parameter>offset</parameter> и <parameter>length</parameter> опущены, возвращается всё содержимое файла. Прочитанные из файла байты обрабатываются как символы в серверной кодировке; если они оказываются недопустимыми для этой кодировки, возникает ошибка.</para>

   <indexterm><primary>pg_read_binary_file</primary></indexterm>
   <para><function>pg_read_binary_file</function> подобна <function>pg_read_file</function>, но её результат имеет тип <type>bytea</type>; как следствие, никакие проверки кодировки не выполняются. В сочетании с <function>convert_from</function> эту функцию можно применять для чтения файлов в произвольной кодировке: <programlisting>SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');</programlisting></para>

   <indexterm><primary>pg_stat_file</primary></indexterm>
   <para><function>pg_stat_file</function> возвращает запись, содержащую размер файла, время последнего обращения и последнего изменения, а также время последнего изменения состояния (только в Unix-системах), время создания (только в Windows) и признак типа <type>boolean</type>, показывающий, что это каталог. Примеры использования: <programlisting>SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;</programlisting></para>

  </sect2>

  <sect2 id="functions-advisory-locks">
   <title>Функции управления рекомендательными блокировками</title>

   <para>Функции, перечисленные в <xref remap="6" linkend="functions-advisory-locks-table"/>, предназначены для управления рекомендательными блокировками. Подробнее об их использовании можно узнать в <xref remap="6" linkend="advisory-locks"/>.</para>

   <table id="functions-advisory-locks-table">
    <title>Функции управления рекомендательными блокировками</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает исключительную блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает исключительную блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает разделяемую блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает разделяемую блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Освобождает исключительную блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Освобождает исключительную блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_all()</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Освобождает все блокировки на уровне сеанса, удерживаемые в данном сеансе</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Освобождает разделяемую блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Освобождает разделяемую блокировку на уровне сеанса</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает исключительную блокировку на уровне транзакции</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает исключительную блокировку на уровне транзакции</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает разделяемую блокировку на уровне транзакции</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
       <entry>Получает разделяемую блокировку на уровне транзакции</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает исключительную блокировку на уровне сеанса, если это возможно</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает исключительную блокировку на уровне сеанса, если это возможно</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает разделяемую блокировку на уровне сеанса, если это возможно</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает разделяемую блокировку на уровне сеанса, если это возможно</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает исключительную блокировку на уровне транзакции, если это возможно</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает исключительную блокировку на уровне транзакции, если это возможно</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает разделяемую блокировку на уровне транзакции, если это возможно</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>Получает разделяемую блокировку на уровне транзакции, если это возможно</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm><primary>pg_advisory_lock</primary></indexterm>
   <para><function>pg_advisory_lock</function> блокирует определённый приложением ресурс, задаваемый одним 64-битным или двумя 32-битными ключами (заметьте, что их значения не пересекаются). Если идентификатор этого ресурса удерживает другой сеанс, эта функция не завершится, пока ресурс не станет доступным. Данная функция устанавливает блокировку в исключительном режиме. Если поступает сразу несколько запросов на блокировку, они накапливаются, так что если один ресурс был заблокирован три раза, его необходимо три раза разблокировать, чтобы он был доступен в других сеансах.</para>

   <indexterm><primary>pg_advisory_lock_shared</primary></indexterm>
   <para><function>pg_advisory_lock_shared</function> работает подобно <function>pg_advisory_lock</function>, но позволяет разделять блокировку с другими сеансами, запрашивающими её как разделяемую. Выполнение может быть приостановлено, только если другой сеанс запросил её в исключительном режиме.</para>

   <indexterm><primary>pg_try_advisory_lock</primary></indexterm>
   <para><function>pg_try_advisory_lock</function> работает подобно <function>pg_advisory_lock</function>, но не ждёт освобождения ресурса. Эта функция либо немедленно получает блокировку и возвращает <literal>true</literal>, либо сразу возвращает <literal>false</literal>, если получить её не удаётся.</para>

   <indexterm><primary>pg_try_advisory_lock_shared</primary></indexterm>
   <para><function>pg_try_advisory_lock_shared</function> работает как <function>pg_try_advisory_lock</function>, но пытается получить разделяемую, а не исключительную блокировку.</para>

   <indexterm><primary>pg_advisory_unlock</primary></indexterm>
   <para><function>pg_advisory_unlock</function> освобождает ранее полученную исключительную блокировку на уровне сеанса. Если блокировка освобождена успешна, эта функция возвращает <literal>true</literal>, а если она не была занята &mdash; <literal>false</literal>, при этом сервер выдаёт предупреждение SQL.</para>

   <indexterm><primary>pg_advisory_unlock_shared</primary></indexterm>
   <para><function>pg_advisory_unlock_shared</function> работает подобно <function>pg_advisory_unlock</function>, но освобождает разделяемую блокировку на уровне сеанса.</para>

   <indexterm><primary>pg_advisory_unlock_all</primary></indexterm>
   <para><function>pg_advisory_unlock_all</function> освобождает все блокировки на уровне сеанса, закреплённые за текущим сеансом. (Эта функция неявно вызывается в конце любого сеанса, даже при нештатном отключении клиента.)</para>

   <indexterm><primary>pg_advisory_xact_lock</primary></indexterm>
   <para><function>pg_advisory_xact_lock</function> работает подобно <function>pg_advisory_lock</function>, но её блокировка автоматически освобождается в конце текущей транзакции и не может быть освобождена явным образом.</para>

   <indexterm><primary>pg_advisory_xact_lock_shared</primary></indexterm>
   <para><function>pg_advisory_xact_lock_shared</function> подобна функции <function>pg_advisory_lock_shared</function>, но её блокировка автоматически освобождается в конце текущей транзакции и не может быть освобождена явным образом.</para>

   <indexterm><primary>pg_try_advisory_xact_lock</primary></indexterm>
   <para><function>pg_try_advisory_xact_lock</function> работает подобно <function>pg_try_advisory_lock</function>, но её блокировка (если она была получена) автоматически освобождается в конце текущей транзакции и не может быть освобождена явным образом.</para>

   <indexterm><primary>pg_try_advisory_xact_lock_shared</primary></indexterm>
   <para><function>pg_try_advisory_xact_lock_shared</function> работает подобно <function>pg_try_advisory_lock_shared</function>, но её блокировка (если она была получена) автоматически освобождается в конце текущей транзакции и не может быть освобождена явным образом.</para>

  </sect2>
  <sect2 id="functions-compression-control">
   <title>Функции управления сжатием</title>

   <indexterm><primary>cfs_start_gc</primary></indexterm>
   <indexterm><primary>cfs_enable_gc</primary></indexterm>
   <indexterm><primary>cfs_gc_relation</primary></indexterm>
   <indexterm><primary>cfs_version</primary></indexterm>
   <indexterm><primary>cfs_estimate</primary></indexterm>
   <indexterm><primary>cfs_compression_ratio</primary></indexterm>
   <indexterm><primary>cfs_fragmentation</primary></indexterm>
   <indexterm><primary>cfs_gc_activity_processed_bytes</primary></indexterm>
   <indexterm><primary>cfs_gc_activity_processed_pages</primary></indexterm>
   <indexterm><primary>cfs_gc_activity_processed_files</primary></indexterm>
   <indexterm><primary>cfs_gc_activity_scanned_files</primary></indexterm>

   <para>Функции, приведённые в <xref remap="6" linkend="functions-cfs-table"/>, выдают информацию о состоянии и активности CFS, а также управляют сборкой мусора CFS.</para>

   <table id="functions-cfs-table">
    <title>Функции управления сжатием</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>cfs_start_gc(n_workers integer)</function></literal>
        </entry>
       <entry><type>integer</type></entry>
       <entry>Запускает сборку мусора с заданным числом рабочих процессов. Вы можете запустить её вручную с помощью этой функции, только если фоновая сборка мусора отключена.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_enable_gc(enabled boolean)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>Включает/отключает фоновый процесс сборки мусора. Для управления вы также можете использовать переменную конфигурации <xref linkend="guc-cfs-gc"/>.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_gc_relation(rel regclass)</function></literal>
        </entry>
       <entry><type>integer</type></entry>
       <entry>Выполняет сборку мусора для заданной таблицы. Эта функция возвращает число обработанных сегментов.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_version()</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>Выводит версию CFS и используемый алгоритм сжатия.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_estimate(rel regclass)</function></literal>
        </entry>
       <entry><type>float8</type></entry>
       <entry>Оценивает возможный эффект от сжатия таблицы. Возвращает средний коэффициент сжатия для первых десяти блоков отношения.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_compression_ratio(rel regclass)</function></literal>
        </entry>
       <entry><type>float8</type></entry>
       <entry>Возвращает фактический коэффициент сжатия для всех сегментов сжатого отношения.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_fragmentation(rel regclass)</function></literal>
        </entry>
       <entry><type>float8</type></entry>
       <entry>Возвращает средний коэффициент сжатия для файлов заданного отношения.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_gc_activity_processed_bytes()</function></literal>
        </entry>
       <entry><type>int64</type></entry>
       <entry>Возвращает общий размер страниц, обработанных механизмом CFS в процессе сборки мусора.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_gc_activity_processed_pages()</function></literal>
        </entry>
       <entry><type>int64</type></entry>
       <entry>Возвращает число страниц, обработанных механизмом CFS в процессе сборки мусора.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_gc_activity_processed_files()</function></literal>
        </entry>
       <entry><type>int64</type></entry>
       <entry>Возвращает число файлов, сжатых механизмом CFS в процессе сборки мусора.</entry>
      </row>
      <row>
       <entry>
        <literal><function>cfs_gc_activity_scanned_files()</function></literal>
        </entry>
       <entry><type>int64</type></entry>
       <entry>Возвращает число файлов, просканированных механизмом CFS в процессе сборки мусора.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
  </sect1>

  <sect1 id="functions-trigger">
   <title>Триггерные функции</title>

   <indexterm><primary>suppress_redundant_updates_trigger</primary></indexterm>

   <para>В настоящее время в <productname>&productname;</productname> есть единственная встроенная триггерная функция, <function>suppress_redundant_updates_trigger</function>, которая предотвращает изменения, фактически не влияющие на данные в строке, тогда как обычно изменения выполняются вне зависимости от того, были ли изменены данные. (Обычное поведение не предполагает сравнения данных, поэтому изменения выполняются быстрее, и в ряде случаев именно это поведение желательно.)</para>

    <para>В идеале, следует избегать операций изменения, которые фактически не меняют данные в записях. Подобные ненужные изменения могут обходиться дорого, особенно когда требуется обновлять множество индексов, к тому же впоследствии базу данных придётся очищать от &laquo;мёртвых&raquo; строк. Однако выявить такие изменения в клиентском коде бывает сложно, если вообще возможно, а при составлении соответствующих проверочных выражений легко допустить ошибку. В качестве альтернативного решения можно использовать функцию <function>suppress_redundant_updates_trigger</function>, которая опускает изменения, не меняющие данные. Однако использовать её следует с осторожностью. Данный триггер выполняется не большое, но значительное время для каждой записи, так что если большинство записей всё-таки фактически изменяются, этот триггер скорее замедлит операцию изменения.</para>

    <para>Функцию <function>suppress_redundant_updates_trigger</function> можно привязать к таблице так: <programlisting>CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();</programlisting> В большинстве случаев этот триггер должен вызываться для каждой строки последним. А так как триггеры вызываются по порядку сортировки их имён, имя для него нужно выбирать таким, чтобы оно было последним среди имён всех триггеров, которые могут быть в таблице.</para>
    <para>Подробнее о создании триггеров можно узнать в описании <xref linkend="sql-createtrigger"/>.</para>
  </sect1>

  <sect1 id="functions-event-triggers">
   <title>Функции событийных триггеров</title>

   <para><productname>&productname;</productname> предоставляет следующие вспомогательные функции для получения информации в событийных триггерах.</para>

   <para>Подробнее о событийных триггерах можно узнать в <xref remap="6" linkend="event-triggers"/>.</para>

  <sect2 id="pg-event-trigger-ddl-command-end-functions">
   <title>Получение изменений в конце команды</title>

   <indexterm><primary>pg_event_trigger_ddl_commands</primary></indexterm>

   <para>Функция <function>pg_event_trigger_ddl_commands</function> возвращает список команд <acronym>DDL</acronym>, выполняемых в результате действия пользователя. Вызывать её можно только в функции, реализующей событийный триггер <literal>ddl_command_end</literal>. При попытке вызвать её в любом другом контексте возникнет ошибка. Функция <function>pg_event_trigger_ddl_commands</function> возвращает одну строку для каждой базовой команды; для некоторых команд, записываемых в виде одного предложения SQL, может возвращаться несколько строк. Эта функция возвращает следующие столбцы: <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Тип</entry>
        <entry>Описание</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>OID каталога, к которому относится объект</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>OID объекта в каталоге</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Идентификатор подобъекта (например, номер для столбцов)</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>Тег команды</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Тип объекта</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>Имя схемы, к которой относится объект; если объект не относится ни к какой схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается.</entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>Текстовое представление идентификатора объекта, дополненного схемой. Компоненты этого идентификаторы могут заключаться в кавычки, если требуется.</entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>bool</type></entry>
        <entry>является ли команда частью скрипта расширения</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>Полное представление команды, во внутреннем формате. Его нельзя вывести непосредственно, но можно передать другим функциям, чтобы получить различные сведения о команде.</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable></para>
  </sect2>

  <sect2 id="pg-event-trigger-sql-drop-functions">
   <title>Обработка объектов, удалённых командой DDL</title>

   <indexterm><primary>pg_event_trigger_dropped_objects</primary></indexterm>

   <para>Функция <function>pg_event_trigger_dropped_objects</function> возвращает список всех объектов, удалённых командой, вызвавшей событие <literal>sql_drop</literal>. При вызове в другом контексте <function>pg_event_trigger_dropped_objects</function> выдаёт ошибку. <function>pg_event_trigger_dropped_objects</function> возвращает следующие столбцы: <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Тип</entry>
        <entry>Описание</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>OID каталога, к которому относился объект</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>Oid</type></entry>
        <entry>OID, который имел объект в каталоге</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>int32</type></entry>
        <entry>Идентификатор подобъекта (например, номер для столбцов)</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>bool</type></entry>
        <entry>Флаг, обозначающий исходный удаляемый объект(ы)</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>bool</type></entry>
        <entry>Флаг, обозначающий, что к этому объекту в графе зависимостей привело отношение обычной зависимости</entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>bool</type></entry>
        <entry>Флаг, обозначающий, что объект был временным.</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Тип объекта</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>Имя схемы, к которой относился объект; если объект не относился ни к какой схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается.</entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>Имя объекта, если сочетание схемы и имени позволяет уникально идентифицировать объект; в противном случае &mdash; <literal>NULL</literal>. Имя не заключается в кавычки и не дополняется именем схемы.</entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>Текстовое представление идентификатора объекта, дополненного схемой. Компоненты этого идентификаторы могут заключаться в кавычки, если требуется.</entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>Массив, который в сочетании с <literal>object_type</literal> и массивом <literal>address_args</literal> можно передать функции <function>pg_get_object_address()</function> и воссоздать адрес объекта на удалённом сервере, содержащем одноимённый объект того же рода.</entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>Дополнение предшествующего массива <literal>address_names</literal>.</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable></para>

   <para>Функцию <function>pg_event_trigger_dropped_objects</function> можно использовать в событийном триггере так: <programlisting>CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE PROCEDURE test_event_trigger_for_drops();</programlisting></para>
  </sect2>

  <sect2 id="pg-event-trigger-table-rewrite-functions">
   <title>Обработка события перезаписи таблицы</title>

   <para>В <xref remap="6" linkend="functions-event-trigger-table-rewrite"/> показаны функции, выдающие информацию о таблице, для которой произошло событие перезаписи таблицы (<literal>table_rewrite</literal>). При попытке вызвать их в другом контексте возникнет ошибка.</para>

   <table id="functions-event-trigger-table-rewrite">
    <title>Информация о перезаписи таблицы</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Имя</entry> <entry>Тип результата</entry> <entry>Описание</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_oid</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_oid()</function></literal>
       </entry>
       <entry><type>Oid</type></entry>
       <entry>OID таблицы, которая будет перезаписана.</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_reason</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_reason()</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>Код причины, показывающий, чем вызвана перезапись. Точное значение кодов зависит от выпуска (версии).</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Функцию <function>pg_event_trigger_table_rewrite_oid</function> можно использовать в событийном триггере так: <programlisting>CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();</programlisting></para>
  </sect2>
  </sect1>

</chapter>
