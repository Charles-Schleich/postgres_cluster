<!-- doc/src/xml/planstats.xml -->

<chapter id="planner-stats-details">
 <title>Как планировщик использует статистику</title>

  <para>Данная глава основана на материалах, рассмотренных ранее (см. <xref remap="4" linkend="using-explain"/> и <xref remap="4" linkend="planner-stats"/>), и подробнее рассказывает о том, как планировщик использует статистику для определения количества строк, которое может вернуть каждая часть запроса. Это важная составляющая процесса создания плана запроса, предоставляющая большую часть исходного материала для расчёта стоимости.</para>

  <para>Целью данной главы является не подробное документирование кода, а общее описание его работы. Возможно, это поможет тем, кто пожелает в дальнейшем ознакомиться с кодом.</para>

 <sect1 id="row-estimation-examples">
  <title>Примеры оценки количества строк</title>

  <indexterm zone="row-estimation-examples"><primary>Оценка количества строк</primary> <secondary> планировщик</secondary></indexterm>

  <para>В приведённых ниже примерах используются таблицы базы данных регрессионного тестирования <productname>&productname;</productname>. Приведённые листинги получены в версии 8.3. Поведение более ранних (или поздних) версий может отличаться. Заметьте также, что поскольку команда <command>ANALYZE</command> использует случайную выборку при формировании статистики, после любого нового выполнения команды <command>ANALYZE</command> результаты незначительно изменятся.</para>

  <para>Давайте начнём с очень простого запроса: <programlisting>EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)</programlisting> Как планировщик определяет мощность <structname>tenk1</structname>, рассматривается выше (см. <xref remap="4" linkend="planner-stats"/>), но для полноты здесь говорится об этом ещё раз. Количество страниц и строк берётся в <structname>pg_class</structname>: <programlisting>SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';

 relpages | reltuples
----------+-----------
      358 |     10000</programlisting>Это текущие цифры, полученные при последнем выполнении команд <command>VACUUM</command> или <command>ANALYZE</command>, применённых к этой таблице. Затем планировщик выполняет выборку фактического текущего числа страниц в таблице (это недорогая операция, для которой не требуется сканирование таблицы). Если оно отличается от <structfield>relpages</structfield>, то <structfield>reltuples</structfield> изменяется для того, чтобы привести это значение к текущей оценке количества строк. В показанном выше примере значение <structfield>relpages</structfield> является актуальным, поэтому количество строк берётся равным <structfield>reltuples</structfield>.</para>

  <para>Давайте обратимся к примеру с диапазонным условием в предложении <literal>WHERE</literal>: <programlisting>EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;

                                   QUERY PLAN
--------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)
   Recheck Cond: (unique1 &lt; 1000)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)
         Index Cond: (unique1 &lt; 1000)</programlisting> Планировщик рассматривает условие предложения <literal>WHERE</literal> и находит в справочнике функцию избирательности для оператора <literal>&lt;</literal> в <structname>pg_operator</structname>. Это значение содержится в столбце <structfield>oprrest</structfield>, и в данном случае значением является <function>scalarltsel</function>. Функция <function>scalarltsel</function> извлекает гистограмму для <structfield>unique1</structfield> из <structname>pg_statistics</structname>. Для вводимых вручную запросов удобнее просматривать более простое представление <structname>pg_stats</structname>: <programlisting>SELECT histogram_bounds FROM pg_stats
WHERE tablename='tenk1' AND attname='unique1';

                   histogram_bounds
------------------------------------------------------
 {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}</programlisting> Затем обрабатывается часть гистограммы, которая соответствует условию <quote>&lt; 1000</quote>. Таким образом и определяется избирательность. Гистограмма делит диапазон на равные частотные группы, поэтому нужно лишь определить группу, содержащую наше значение, и подсчитать её <emphasis> долю </emphasis> и <emphasis> долю групп</emphasis>, предшествующих данной. Очевидно, что значение 1000 находится во второй группе (993-1997). Если предположить, что внутри каждой группы распределение значений линейное, мы можем вычислить избирательность следующим образом: <programlisting>selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets
            = (1 + (1000 - 993)/(1997 - 993))/10
            = 0.100697</programlisting> т. е. сумма элементов одной целой группы и пропорциональной части элементов второй, делённая на число групп. Теперь примерное число строк может быть рассчитано как произведение избирательности и мощности <structname>tenk1</structname>: <programlisting>rows = rel_cardinality * selectivity
     = 10000 * 0.100697
     = 1007  (округлённо)</programlisting></para>

  <para>Далее, давайте рассмотрим пример с условием на равенство в предложении <literal>WHERE</literal>: <programlisting>EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';

                        QUERY PLAN
----------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)
   Filter: (stringu1 = 'CRAAAA'::name)</programlisting> Планировщик вновь проверяет условие в предложении <literal>WHERE</literal> и определяет функцию избирательности для <literal>=</literal>, и этой функцией является <function>eqsel</function>. Для оценки равенства гистограмма бесполезна, вместо неё для оценки избирательности используется список <firstterm>наиболее распространённых значений</firstterm> (Most Commom Values, <acronym>MCV</acronym>). Давайте рассмотрим MCV и соответствующие дополнительные столбцы, которые пригодятся позже: <programlisting>SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats
WHERE tablename='tenk1' AND attname='stringu1';

null_frac         | 0
n_distinct        | 676
most_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}
most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}</programlisting> Так как значение <literal>CRAAAA</literal> оказалось в списке MCV, избирательность будет определяться просто соответствующим элементом в списке частот наиболее распространённых значений (Most Common Frequencies, MCF): <programlisting>selectivity = mcf[3]
            = 0.003</programlisting> Как и в предыдущем примере, оценка числа строк берётся как произведение мощности и избирательности <structname>tenk1</structname>: <programlisting>rows = 10000 * 0.003
     = 30</programlisting></para>

  <para>Теперь рассмотрим тот же самый запрос, но с константой, которой нет в списке <acronym>MCV</acronym>: <programlisting>EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';

                        QUERY PLAN
----------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)
   Filter: (stringu1 = 'xxx'::name)</programlisting> Это совершенно другая задача — как оценить избирательность значения, которого <emphasis>нет</emphasis> в списке <acronym>MCV</acronym>. При её решении используется факт отсутствия данного значения в списке в сочетании с частотой для каждого значения из списка <acronym>MCV</acronym>. <programlisting>selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)
            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +
                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)
            = 0.0014559</programlisting> Т. е. нужно сложить частоты значений из списка <acronym>MCV</acronym>, отнять полученное число от единицы, и полученное значение разделить на количество <emphasis>остальных</emphasis> уникальных значений. Эти вычисления основаны на предположении, что значения, которые не входят в список MCV, имеют равномерное распределение. Заметьте, что в данном примере нет неопределённых значений, поэтому о них беспокоиться не нужно (иначе их долю также пришлось бы вычитать из числителя). Оценка числа строк затем производится как обычно: <programlisting>rows = 10000 * 0.0014559
     = 15  (округлённо)</programlisting></para>

  <para>Предыдущий пример с <literal>unique1 &lt; 1000</literal> был большим упрощением того, что в действительности делает <function>scalarltsel</function>. Но после того, как мы увидели пример использования списка MCV, мы можем внести некоторые дополнения. Что касается самого примера, в нём все было правильно, поскольку <structfield>unique1</structfield> это уникальный столбец, у него нет значений в списке MCV (очевидно, в данном случае нет значения, которое является более распространённым, чем любое другое). Для неуникального столбца обычно создаётся как гистограмма, так и список MCV, при этом <emphasis>гистограмма не включает значения, представленные в списке MCV</emphasis>. Данный способ позволяет выполнить более точный подсчёт. В этой ситуации <function>scalarltsel</function> напрямую применяет условие <quote>&lt; 1000</quote> к каждому значению списка MCV и суммирует частоты значений MCV, для которых условие является верным. Это даёт точную оценку избирательности для той части таблицы, которая содержит значения из списка MCV. Подобным же образом используется гистограмма для оценки избирательности для той части таблицы, которая не содержит значения из списка MCV, а затем эти две цифры складываются для оценки общей избирательности. Например, рассмотрим <programlisting>EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)
   Filter: (stringu1 &lt; 'IAAAAA'::name)</programlisting> Мы уже видели данные списка MCV для <structfield>stringu1</structfield>, а это его гистограмма: <programlisting>SELECT histogram_bounds FROM pg_stats
WHERE tablename='tenk1' AND attname='stringu1';

                                histogram_bounds
--------------------------------------------------------------------------------
 {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}</programlisting> Проверяя список MCV, находим, что условие <literal>stringu1 &lt; 'IAAAAA'</literal> соответствует первым шести записям, но не соответствует последним четырём, поэтому избирательность для значений, соответствующих значениям в списке MCV, такова: <programlisting>selectivity = sum(relevant mvfs)
            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003
            = 0.01833333</programlisting> Сумма всех частот из списка MCF также сообщает нам, что общая часть представленной списком MCV совокупности записей равняется 0.03033333, и поэтому представленная гистограммой часть равняется 0.96966667 (в этом случае тоже нет неопределённых значений, иначе их пришлось бы также исключить). Видно, что значение <literal>IAAAAA</literal> попадает почти в конец третьего столбца гистограммы. Основываясь на простых предположениях относительно частоты различных символов, планировщик получает число 0.298387 для части значений, представленных в гистограмме, которые меньше чем <literal>IAAAAA</literal>. Затем объединяем оценки части значений из списка MCV и значений, не содержащихся в нём: <programlisting>selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction
            = 0.01833333 + 0.298387 * 0.96966667
            = 0.307669

rows        = 10000 * 0.307669
            = 3077  (округлённо)</programlisting> В этом конкретном примере, корректировка со стороны списка MCV достаточно мала, потому что распределение значений столбца довольно плоское (статистика, показывающая конкретные значения как более распространённые, чаще всего получается вследствие статистической погрешности). В более типичном случае, когда некоторые значения являются значительно более распространёнными по сравнению с другими, этот более сложный метод повышает точность вследствие точного определения избирательности наиболее распространённых значений.</para>

  <para>Теперь давайте рассмотрим случай с более чем одним условием в предложении <literal>WHERE</literal>: <programlisting>EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';

                                   QUERY PLAN
--------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)
   Recheck Cond: (unique1 &lt; 1000)
   Filter: (stringu1 = 'xxx'::name)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)
         Index Cond: (unique1 &lt; 1000)</programlisting> Планировщик исходит из того, что два условия независимы, таким образом, отдельные значения избирательности можно перемножить: <programlisting>selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')
            = 0.100697 * 0.0014559
            = 0.0001466

rows        = 10000 * 0.0001466
            = 1  (округлённо)</programlisting> Заметьте, что число строк, которые предполагается вернуть через сканирование битового индекса, соответствует условию, используемому при работе индекса; это важно, так как влияет на оценку стоимости для последующих выборок из таблицы.</para>

  <para>В заключение исследуем запрос, выполняющий соединение: <programlisting>EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=4.64..456.23 rows=50 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)
         Recheck Cond: (unique1 &lt; 50)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)
               Index Cond: (unique1 &lt; 50)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)</programlisting> Ограничение, накладываемое на <structname>tenk1</structname>, <literal>unique1 &lt; 50</literal>, производится до соединения вложенным циклом. Это обрабатывается аналогично предыдущему примеру с диапазонным условием. На этот раз значение 50 попадает в первый столбец гистограммы <structfield>unique1</structfield>: <programlisting>selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets
            = (0 + (50 - 0)/(993 - 0))/10
            = 0.005035

rows        = 10000 * 0.005035
            = 50  (округлённо)</programlisting> Ограничение для соединения следующее <literal>t2.unique2 = t1.unique2</literal>. Здесь используется уже известный нам оператор <literal>=</literal>, однако функцию избирательности получаем из столбца <structfield>oprjoin</structfield> представления <structname>pg_operator</structname>, и эта функция — <function>eqjoinsel</function>. Функция <function>eqjoinsel</function> находит статистические данные как для <structname>tenk2</structname>, так и для <structname>tenk1</structname>: <programlisting>SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats
WHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';

tablename  | null_frac | n_distinct | most_common_vals
-----------+-----------+------------+------------------
 tenk1     |         0 |         -1 |
 tenk2     |         0 |         -1 |</programlisting> В этом случае нет данных <acronym>MCV</acronym> для <structfield>unique2</structfield>, потому что все значения будут уникальными. Таким образом, используется алгоритм, зависящий только от числа различающихся значений для обеих таблиц и от данных с неопределёнными значениями: <programlisting>selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)
            = (1 - 0) * (1 - 0) / max(10000, 10000)
            = 0.0001</programlisting> Т. е., вычитаем долю неопределённых значений из единицы для каждой таблицы и делим на максимальное из чисел различающихся значений. Количество строк, которое соединение, вероятно, сгенерирует, вычисляется как мощность декартова произведения двух входных значений, умноженная на избирательность: <programlisting>rows = (outer_cardinality * inner_cardinality) * selectivity
     = (50 * 10000) * 0.0001
     = 50</programlisting></para>

  <para>Если бы имелись списки MCV для двух столбцов, функцией <function>eqjoinsel</function> использовалось бы прямое сравнение со списками MCV для определения общей избирательности той части данных, которая содержит значения списка MCV. Оценка остальной части данных при этом выполнялась бы представленным выше способом.</para>

  <para>Заметьте, что здесь выводится для <literal>inner_cardinality</literal> значение 10000, то есть исходный размер <structname>tenk2</structname>. Если изучить вывод <command>EXPLAIN</command>, может показаться, что оценка количества строк вычисляется как 50 * 1, то есть число внешних строк умножается на ориентировочное число строк, получаемых при каждом внутреннем сканировании индекса в <structname>tenk2</structname>. Но это не так, ведь размер результата соединения оценивается до того, как выбирается конкретный план соединения. Если всё работает корректно, оба варианта вычисления этого размера должны давать один и тот же ответ, но из-за ошибок округления и других факторов иногда они значительно различаются.</para>

  <para>Для интересующихся более подробной информацией: оценка размера таблицы (до выполнения условий в предложении <literal>WHERE</literal>) реализована в файле <filename>src/backend/optimizer/util/plancat.c</filename>. Основная логика для вычисления избирательности предложений находится в <filename>src/backend/optimizer/path/clausesel.c</filename>. Специфичные для отдельных операторов функции избирательности, в основном, расположены в <filename>src/backend/utils/adt/selfuncs.c</filename>.</para>

 </sect1>

 <sect1 id="planner-stats-security">
  <title>Статистика планировщика и безопасность</title>

  <para>Доступ к таблице <structname>pg_statistic</structname> разрешён только суперпользователям, так что обычные пользователи не могут получить из неё сведения о содержимом таблиц других пользователей. Но некоторые функции оценки избирательности будут использовать пользовательский оператор (оператор, фигурирующий в запросе, или связанный) для анализа сохранённой статистики. Например, чтобы определить применимость сохранённого самого частого значения, функция оценки избирательности должна задействовать соответствующий оператор <literal>=</literal> для сравнения константы в запросе с этим сохранённым значением. Таким образом, данные <structname>pg_statistic</structname> в принципе могут передаваться пользовательским операторам. А особым образом сконструированный оператор может выводить наружу передаваемые ему операнды преднамеренно (например, записывая их в журнал или помещая в другую таблицу) либо непреднамеренно (показывая их значения в сообщениях об ошибках). В любом случае это даёт возможность пользователю, не имеющему доступа к таблице <structname>pg_statistic</structname>, увидеть содержащиеся в ней данные.</para>

  <para>Для предотвращения этого все встроенные функции оценки избирательности действуют по следующим правилам. Чтобы сохранённая статистика могла использоваться при планировании запроса, текущий пользователь должен иметь либо право <literal>SELECT</literal> для таблицы или задействованных столбцов, либо у оператора должна быть характеристика <literal>LEAKPROOF</literal> (точнее, она должна быть у функции, реализующей этот оператор). В противном случае оценка избирательности будет осуществляться так, как если бы статистики не было вовсе, и планировщик продолжит работу с общими или вторичными предположениями.</para>

  <para>Если пользователь не имеет требуемого права доступа к таблице или столбцам, то во многих случаях при выполнении запроса в конце концов возникнет ошибка &laquo;нет доступа&raquo;, так что этот механизм будет незаметен на практике. Но если пользователь читает данные из представления с барьером безопасности, планировщик может захотеть проверить статистику нижележащей таблицы, которая недоступна пользователю непосредственно. В этом случае оператор должен быть герметичным; иначе статистика не будет использоваться. Это не будет иметь внешних проявлений кроме того, что план запроса может быть неоптимальным. В случае подозрений, что вы столкнулись с этим, попробуйте запустить запрос от имени пользователя с расширенными правами и проверьте, не выбирается ли другой план запроса.</para>

  <para>Это ограничение применяется только тогда, когда планировщику может потребоваться выполнить пользовательский оператор с одним или несколькими значениями из <structname>pg_statistic</structname>. При этом планировщику разрешено использовать общую статистическую информацию, например, процент значений NULL или количество различных значений в столбце, вне зависимости от прав доступа.</para>

  <para>Реализуемые в дополнительных расширениях функции оценки избирательности, которые могут обращаться к статистике, вызывая пользовательские операторы, должны следовать тем же правилам безопасности. За практическими указаниями обратитесь к исходному коду PostgreSQL.</para>
 </sect1>
</chapter>
