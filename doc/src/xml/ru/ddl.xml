<!-- doc/src/xml/ddl.xml -->

<chapter id="ddl">
 <title>Определение данных</title>

 <para>Эта глава рассказывает, как создавать структуры базы данных, в которых будут храниться данные. В реляционной базе данных данные хранятся в таблицах, так что большая часть этой главы будет посвящена созданию и изменению таблиц, а также средствам управления данными в них. Затем мы обсудим, как таблицы можно объединять в схемы и как ограничивать доступ к ним. Наконец, мы кратко рассмотрим другие возможности, связанные с хранением данных, в частности наследование, представления, функции и триггеры.</para>

 <sect1 id="ddl-basics">
  <title>Основы таблиц</title>

  <indexterm zone="ddl-basics"><primary>таблица</primary></indexterm>

  <indexterm><primary>строка</primary></indexterm>

  <indexterm><primary>столбец</primary></indexterm>

  <para>Таблица в реляционной базе данных похожа на таблицу на бумаге: она так же состоит из строк и столбцов. Число и порядок столбцов фиксированы, а каждый столбец имеет имя. Число строк переменно &mdash; оно отражает текущее количество находящихся в ней данных. SQL не даёт никаких гарантий относительно порядка строк таблицы. При чтении таблицы строки выводятся в произвольном порядке, если только явно не требуется сортировка. Подробнее это рассматривается в <xref remap="6" linkend="queries"/>. Более того, SQL не назначает строкам уникальные идентификаторы, так что можно иметь в таблице несколько полностью идентичных строк. Это вытекает из математической модели, которую реализует SQL, но обычно такое дублирование нежелательно. Позже в этой главе мы увидим, как его избежать.</para>

  <para>Каждому столбцу сопоставлен тип данных. Тип данных ограничивает набор допустимых значений, которые можно присвоить столбцу, и определяет смысловое значение данных для вычислений. Например, в столбец числового типа нельзя записать обычные текстовые строки, но зато его данные можно использовать в математических вычислениях. И наоборот, если столбец имеет тип текстовой строки, для него допустимы практически любые данные, но он непригоден для математических действий (хотя другие операции, например конкатенация строк, возможны).</para>

  <para>В <productname>&productname;</productname> есть внушительный набор встроенных типов данных, удовлетворяющий большинство приложений. Пользователи также могут определять собственные типы данных. Большинство встроенных типов данных имеют понятные имена и семантику, так что мы отложим их подробное рассмотрение до <xref remap="2" linkend="datatype"/>. Наиболее часто применяются следующие типы данных: <type>integer</type> для целых чисел, <type>numeric</type> для чисел, которые могут быть дробными, <type>text</type> для текстовых строк, <type>date</type> для дат, <type>time</type> для времени и <type>timestamp</type> для значений, включающих дату и время.</para>

  <indexterm><primary>таблица</primary> <secondary>создание</secondary></indexterm>

  <para>Для создания таблицы используется команда <xref linkend="sql-createtable"/>. В этой команде вы должны указать как минимум имя новой таблицы и имена и типы данных каждого столбца. Например: <programlisting>CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);</programlisting> Так вы создадите таблицу <literal>my_first_table</literal> с двумя столбцами. Первый столбец называется <literal>first_column</literal> и имеет тип данных <type>text</type>; второй столбец называется <literal>second_column</literal> и имеет тип <type>integer</type>. Имена таблицы и столбцов соответствуют синтаксису идентификаторов, описанному в <xref remap="6" linkend="sql-syntax-identifiers"/>. Имена типов также являются идентификаторами, хотя есть некоторые исключения. Заметьте, что список столбцов заключается в скобки, а его элементы разделяются запятыми.</para>

  <para>Конечно, предыдущий пример ненатурален. Обычно в именах таблиц и столбцов отражается, какие данные они будут содержать. Поэтому давайте взглянем на более реалистичный пример: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);</programlisting> (Тип <type>numeric</type> может хранить дробные числа, в которых обычно выражаются денежные суммы.)</para>

  <tip>
   <para>Когда вы создаёте много взаимосвязанных таблиц, имеет смысл заранее выбрать единый шаблон именования таблиц и столбцов. Например, решить, будут ли в именах таблиц использоваться существительные во множественном или в единственном числе (есть соображения в пользу каждого варианта).</para>
  </tip>

  <para>Число столбцов в таблице не может быть бесконечным. Это число ограничивается максимумом в пределах от 250 до 1600, в зависимости от типов столбцов. Однако создавать таблицы с таким большим числом столбцов обычно не требуется, а если такая потребность возникает, это скорее признак сомнительного дизайна.</para>

  <indexterm><primary>таблица</primary> <secondary>удаление</secondary></indexterm>

  <para>Если таблица вам больше не нужна, вы можете удалить её, выполнив команду <xref linkend="sql-droptable"/>. Например: <programlisting>DROP TABLE my_first_table;
DROP TABLE products;</programlisting> Попытка удаления несуществующей таблицы считается ошибкой. Тем не менее в SQL-скриптах часто применяют безусловное удаление таблиц перед созданием, игнорируя все сообщения об ошибках, так что они выполняют свою задачу независимо от того, существовали таблицы или нет. (Если вы хотите избежать таких ошибок, можно использовать вариант <literal>DROP TABLE IF EXISTS</literal>, но это не будет соответствовать стандарту SQL.)</para>

  <para>Как изменить существующую таблицу, будет рассмотрено в этой главе позже, в <xref remap="6" linkend="ddl-alter"/>.</para>

  <para>Имея средства, которые мы обсудили, вы уже можете создавать полностью функциональные таблицы. В продолжении этой главы рассматриваются дополнительные возможности, призванные обеспечить целостность данных, безопасность и удобство. Если вам не терпится наполнить свои таблицы данными, вы можете вернуться к этой главе позже, а сейчас перейти к <xref remap="3" linkend="dml"/>.</para>
 </sect1>

 <sect1 id="ddl-default">
  <title>Значения по умолчанию</title>

  <indexterm zone="ddl-default"><primary>значение по умолчанию</primary></indexterm>

  <para>Столбцу можно назначить значение по умолчанию. Когда добавляется новая строка и каким-то её столбцам не присваиваются значения, эти столбцы принимают значения по умолчанию. Также команда управления данными может явно указать, что столбцу должно быть присвоено значение по умолчанию, не зная его. (Подробнее команды управления данными описаны в <xref remap="6" linkend="dml"/>.)</para>

  <para><indexterm><primary>значение NULL</primary> <secondary>значение по умолчанию</secondary></indexterm> Если значение по умолчанию не объявлено явно, им считается значение NULL. Обычно это имеет смысл, так как можно считать, что NULL представляет неизвестные данные.</para>

  <para>В определении таблицы значения по умолчанию указываются после типа данных столбца. Например: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);</programlisting></para>

  <para>Значение по умолчанию может быть выражением, которое в этом случае вычисляется в момент присваивания значения по умолчанию (а <emphasis>не</emphasis> когда создаётся таблица). Например, столбцу <type>timestamp</type> в качестве значения по умолчания часто присваивается <literal>CURRENT_TIMESTAMP</literal>, чтобы в момент добавления строки в нём оказалось текущее время. Ещё один распространённый пример &mdash; генерация <quote>последовательных номеров</quote> для всех строк. В <productname>&productname;</productname> это обычно делается примерно так: <programlisting>CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);</programlisting> здесь функция <literal>nextval()</literal> выбирает очередное значение из <firstterm>последовательности</firstterm> (см. <xref remap="4" linkend="functions-sequence"/>). Это употребление настолько распространено, что для него есть специальная короткая запись: <programlisting>CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);</programlisting> <literal>SERIAL</literal> обсуждается позже в <xref remap="6" linkend="datatype-serial"/>.</para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>Ограничения</title>

  <indexterm zone="ddl-constraints"><primary>ограничение</primary></indexterm>

  <para>Типы данных сами по себе ограничивают множество данных, которые можно сохранить в таблице. Однако для многих приложений такие ограничения слишком грубые. Например, столбец, содержащий цену продукта, должен, вероятно, принимать только положительные значения. Но такого стандартного типа данных нет. Возможно, вы также захотите ограничить данные столбца по отношению к другим столбцам или строкам. Например, в таблице с информацией о товаре должна быть только одна строка с определённым кодом товара.</para>

  <para>Для решения подобных задач SQL позволяет вам определять ограничения для столбцов и таблиц. Ограничения дают вам возможность управлять данными в таблицах так, как вы захотите. Если пользователь попытается сохранить в столбце значение, нарушающее ограничения, возникнет ошибка. Ограничения будут действовать, даже если это значение по умолчанию.</para>

  <sect2 id="ddl-constraints-check-constraints">
   <title>Ограничения-проверки</title>

   <indexterm><primary>ограничение-проверка</primary></indexterm>

   <indexterm><primary>ограничение</primary> <secondary>проверка</secondary></indexterm>

   <para>Ограничение-проверка &mdash; наиболее общий тип ограничений. В его определении вы можете указать, что значение данного столбца должно удовлетворять логическому выражению (проверке истинности). Например, цену товара можно ограничить положительными значениями так: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);</programlisting></para>

   <para>Как вы видите, ограничение определяется после типа данных, как и значение по умолчанию. Значения по умолчанию и ограничения могут указываться в любом порядке. Ограничение-проверка состоит из ключевого слова <literal>CHECK</literal>, за которым идёт выражение в скобках. Это выражение должно включать столбец, для которого задаётся ограничение, иначе оно не имеет большого смысла.</para>

   <indexterm><primary>ограничение</primary> <secondary>имя</secondary></indexterm>

   <para>Вы можете также присвоить ограничению отдельное имя. Это улучшит сообщения об ошибках и позволит вам ссылаться на это ограничение, когда вам понадобится изменить его. Сделать это можно так: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);</programlisting> То есть, чтобы создать именованное ограничение, напишите ключевое слово <literal>CONSTRAINT</literal>, а за ним идентификатор и собственно определение ограничения. (Если вы не определите имя ограничения таким образом, система выберет для него имя за вас.)</para>

   <para>Ограничение-проверка может также ссылаться на несколько столбцов. Например, если вы храните обычную цену и цену со скидкой, так вы можете гарантировать, что цена со скидкой будет всегда меньше обычной: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);</programlisting></para>

   <para>Первые два ограничения определяются похожим образом, но для третьего используется новый синтаксис. Оно не связано с определённым столбцом, а представлено отдельным элементом в списке. Определения столбцов и такие определения ограничений можно переставлять в произвольном порядке.</para>

   <para>Про первые два ограничения можно сказать, что это ограничения столбцов, тогда как третье является ограничением таблицы, так как оно написано отдельно от определений столбцов. Ограничения столбцов также можно записать в виде ограничений таблицы, тогда как обратное не всегда возможно, так как подразумевается, что ограничение столбца ссылается только на связанный столбец. (Хотя <productname>&productname;</productname> этого не требует, но для совместимости с другими СУБД лучше следовать это правилу.) Ранее приведённый пример можно переписать и так: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);</programlisting> Или даже так: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);</programlisting> Это дело вкуса.</para>

   <para>Ограничениям таблицы можно присваивать имена так же, как и ограничениям столбцов: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);</programlisting></para>

   <indexterm><primary>значение NULL</primary> <secondary sortas="ограничение-проверка">с ограничениями-проверками</secondary></indexterm>

   <para>Следует заметить, что ограничение-проверка удовлетворяется, если выражение принимает значение true или NULL. Так как результатом многих выражений с операндами NULL будет значение NULL, такие ограничения не будут препятствовать записи NULL в связанные столбцы. Чтобы гарантировать, что столбец не содержит значения NULL, можно использовать ограничение NOT NULL, описанное в следующем разделе.</para>
  </sect2>

  <sect2>
   <title>Ограничения NOT NULL</title>

   <indexterm><primary>ограничение NOT NULL</primary></indexterm>

   <indexterm><primary>ограничение</primary> <secondary>NOT NULL</secondary></indexterm>

   <para>Ограничение NOT NULL просто указывает, что столбцу нельзя присваивать значение NULL. Пример синтаксиса: <programlisting>CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);</programlisting></para>

   <para>Ограничение NOT NULL всегда записывается как ограничение столбца и функционально эквивалентно ограничению <literal>CHECK (<replaceable>имя_столбца</replaceable> IS NOT NULL)</literal>, но в <productname>&productname;</productname> явное ограничение NOT NULL работает более эффективно. Хотя у такой записи есть недостаток &mdash; назначить имя таким ограничениям нельзя.</para>

   <para>Естественно, для столбца можно определить больше одного ограничения. Для этого их нужно просто указать одно за другим: <programlisting>CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);</programlisting> Порядок здесь не имеет значения, он не обязательно соответствует порядку проверки ограничений.</para>

   <para>Для ограничения <literal>NOT NULL</literal> есть и обратное: ограничение <literal>NULL</literal>. Оно не означает, что столбец должен иметь только значение NULL, что конечно было бы бессмысленно. Суть же его в простом указании, что столбец может иметь значение NULL (это поведение по умолчанию). Ограничение <literal>NULL</literal> отсутствует в стандарте SQL и использовать его в переносимых приложениях не следует. (Оно было добавлено в <productname>&productname;</productname> только для совместимости с некоторыми другими СУБД.) Однако некоторые пользователи любят его использовать, так как оно позволяет легко переключать ограничения в скрипте. Например, вы можете начать с: <programlisting>CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);</programlisting> и затем вставить ключевое слово <literal>NOT</literal>, где потребуется.</para>

   <tip>
    <para>При проектировании баз данных чаще всего большинство столбцов должны быть помечены как NOT NULL.</para>
   </tip>
  </sect2>

  <sect2 id="ddl-constraints-unique-constraints">
   <title>Ограничения уникальности</title>

   <indexterm><primary>ограничение уникальности</primary></indexterm>

   <indexterm><primary>ограничение</primary> <secondary>уникальности</secondary></indexterm>

   <para>Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы. Ограничение записывается так: <programlisting>CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);</programlisting> в виде ограничения столбца и так: <programlisting>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);</programlisting> в виде ограничения таблицы.</para>

   <para>Чтобы определить ограничение уникальности для группы столбцов, запишите его в виде ограничения таблицы, перечислив имена столбцов через запятую: <programlisting>CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);</programlisting> Такое ограничение указывает, что сочетание значений перечисленных столбцов должно быть уникально во всей таблице, тогда как значения каждого столбца по отдельности не должны быть (и обычно не будут) уникальными.</para>

   <para>Вы можете назначить уникальному ограничению имя обычным образом: <programlisting>CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);</programlisting></para>

   <para>При добавлении ограничения уникальности будет автоматически создан уникальный индекс-B-дерево для столбца или группы столбцов, перечисленных в ограничении. Условие уникальности, распространяющееся только на некоторые строки, нельзя записать в виде ограничения уникальности, однако такое условие можно установить, создав уникальный <link linkend="indexes-partial">частичный индекс</link>.</para>

   <indexterm><primary>значение NULL</primary> <secondary sortas="unique constraints">с ограничениями уникальности</secondary></indexterm>

   <para>Вообще говоря, ограничение уникальности нарушается, если в таблице оказывается несколько строк, у которых совпадают значения всех столбцов, включённых в ограничение. Однако два значения NULL при сравнении никогда не считаются равными. Это означает, что даже при наличии ограничения уникальности в таблице можно сохранить строки с дублирующимися значениями, если они содержат NULL в одном или нескольких столбцах ограничения. Это поведение соответствует стандарту SQL, но мы слышали о СУБД, которые ведут себя по-другому. Имейте в виду эту особенность, разрабатывая переносимые приложения.</para>
  </sect2>

  <sect2 id="ddl-constraints-primary-keys">
   <title>Первичные ключи</title>

   <indexterm><primary>первичный ключ</primary></indexterm>

   <indexterm><primary>ограничение</primary> <secondary>первичный ключ</secondary></indexterm>

   <para>Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были одновременно уникальными и отличными от NULL. Таким образом, таблицы со следующими двумя определениями будут принимать одинаковые данные: <programlisting>CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);</programlisting> <programlisting>CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);</programlisting></para>

   <para>Первичные ключи могут включать несколько столбцов; синтаксис похож на запись ограничений уникальности: <programlisting>CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);</programlisting></para>

   <para>При добавлении первичного ключа автоматически создаётся уникальный индекс-B-дерево для столбца или группы столбцов, перечисленных в первичном ключе, и данные столбцы помечаются как <literal>NOT NULL</literal>.</para>

   <para>Таблица может иметь максимум один первичный ключ. (Ограничений уникальности и ограничений NOT NULL, которые функционально почти равнозначны первичным ключам, может быть сколько угодно, но назначить ограничением первичного ключа можно только одно.) Теория реляционных баз данных говорит, что первичный ключ должен быть в каждой таблице. В <productname>&productname;</productname> такого жёсткого требования нет, но обычно лучше ему следовать.</para>

   <para>Первичные ключи полезны и для документирования, и для клиентских приложений. Например, графическому приложению с возможностями редактирования содержимого таблицы, вероятно, потребуется знать первичный ключ таблицы, чтобы однозначно идентифицировать её строки. Первичные ключи находят и другое применение в СУБД; в частности, первичный ключ в таблице определяет целевые столбцы по умолчанию для сторонних ключей, ссылающихся на эту таблицу.</para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
   <title>Внешние ключи</title>

   <indexterm><primary>внешний ключ</primary></indexterm>

   <indexterm><primary>ограничение</primary> <secondary>внешний ключ</secondary></indexterm>

   <indexterm><primary>ссылочная целостность</primary></indexterm>

   <para>Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. Это называется <firstterm>ссылочной целостностью</firstterm> двух связанных таблиц.</para>

   <para>Пусть у вас уже есть таблица продуктов, которую мы неоднократно использовали ранее: <programlisting>CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);</programlisting> Давайте предположим, что у вас есть таблица с заказами этих продуктов. Мы хотим, чтобы в таблице заказов содержались только заказы действительно существующих продуктов. Поэтому мы определим в ней ограничение внешнего ключа, ссылающееся на таблицу продуктов: <programlisting>CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);</programlisting> С таким ограничением создать заказ со значением <structfield>product_no</structfield>, отсутствующим в таблице products (и не равным NULL), будет невозможно.</para>

   <para>В такой схеме таблицу orders называют <firstterm>подчинённой</firstterm> таблицей, а products &mdash; <firstterm>главной</firstterm>. Соответственно, столбцы называют так же подчинённым и главным (или ссылающимся и целевым).</para>

   <para>Предыдущую команду можно сократить так: <programlisting>CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);</programlisting> то есть, если опустить список столбцов, внешний ключ будет неявно связан с первичным ключом главной таблицы.</para>

   <para>Внешний ключ также может ссылаться на группу столбцов. В этом случае его нужно записать в виде обычного ограничения таблицы. Например: <programlisting>CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);</programlisting> Естественно, число и типы столбцов в ограничении должны соответствовать числу и типам целевых столбцов.</para>

   <para>Ограничению внешнего ключа можно назначить имя стандартным способом.</para>

   <para>Таблица может содержать несколько ограничений внешнего ключа. Это полезно для связи таблиц в отношении многие-ко-многим. Скажем, у вас есть таблицы продуктов и заказов, но вы хотите, чтобы один заказ мог содержать несколько продуктов (что невозможно в предыдущей схеме). Для этого вы можете использовать такую схему: <programlisting>CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);</programlisting> Заметьте, что в последней таблице первичный ключ покрывает внешние ключи.</para>

   <indexterm><primary>CASCADE</primary> <secondary>действие внешнего ключа</secondary></indexterm>

   <indexterm><primary>RESTRICT</primary> <secondary>действие внешнего ключа</secondary></indexterm>

   <para>Мы знаем, что внешние ключи запрещают создание заказов, не относящихся ни к одному продукту. Но что делать, если после создания заказов с определённым продуктом мы захотим удалить его? SQL справится с этой ситуацией. Интуиция подсказывает следующие варианты поведения: <itemizedlist spacing="compact">
     <listitem><para>Запретить удаление продукта</para></listitem>
     <listitem><para>Удалить также связанные заказы</para></listitem>
     <listitem><para>Что-то ещё?</para></listitem>
    </itemizedlist></para>

   <para>Для иллюстрации давайте реализуем следующее поведение в вышеприведённом примере: при попытке удаления продукта, на который ссылаются заказы (через таблицу <literal>order_items</literal>), мы запрещаем эту операцию. Если же кто-то попытается удалить заказ, то удалится и его содержимое: <programlisting>CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);</programlisting></para>

   <para>Ограничивающие и каскадные удаления &mdash; два наиболее распространённых варианта. <literal>RESTRICT</literal> предотвращает удаление связанной строки. <literal>NO ACTION</literal> означает, что если зависимые строки продолжают существовать при проверке ограничения, возникает ошибка (это поведение по умолчанию). (Главным отличием этих двух вариантов является то, что <literal>NO ACTION</literal> позволяет отложить проверку в процессе транзакции, а <literal>RESTRICT</literal> &mdash; нет.) <literal>CASCADE</literal> указывает, что при удалении связанных строк зависимые от них будут так же автоматически удалены. Есть ещё два варианта: <literal>SET NULL</literal> и <literal>SET DEFAULT</literal>. При удалении связанных строк они назначают зависимым столбцам в подчинённой таблице значения NULL или значения по умолчанию, соответственно. Заметьте, что это не будет основанием для нарушения ограничений. Например, если в качестве действия задано <literal>SET DEFAULT</literal>, но значение по умолчанию не удовлетворяет ограничению внешнего ключа, операция закончится ошибкой.</para>

   <para>Аналогично указанию <literal>ON DELETE</literal> существует <literal>ON UPDATE</literal>, которое срабатывает при изменении заданного столбца. При этом возможные действия те же, а <literal>CASCADE</literal> в данном случае означает, что изменённые значения связанных столбцов будут скопированы в зависимые строки.</para>

   <para>Обычно зависимая строка не должна удовлетворять ограничению внешнего ключа, если один из связанных столбцов содержит NULL. Если в объявление внешнего ключа добавлено <literal>MATCH FULL</literal>, строка будет удовлетворять ограничению, только если все связанные столбцы равны NULL (то есть при разных значениях (NULL и не NULL) гарантируется невыполнение ограничения <literal>MATCH FULL</literal>). Если вы хотите, чтобы зависимые строки не могли избежать и этого ограничения, объявите связанные столбцы как <literal>NOT NULL</literal>.</para>

   <para>Внешний ключ должен ссылаться на столбцы, образующие первичный ключ или ограничение уникальности. Таким образом, для связанных столбцов всегда будет существовать индекс (определённый соответствующим первичным ключом или ограничением), а значит проверки соответствия связанной строки будут выполняться эффективно. Так как команды <command>DELETE</command> для строк главной таблицы или <command>UPDATE</command> для зависимых столбцов потребуют просканировать подчинённую таблицу и найти строки, ссылающиеся на старые значения, полезно будет иметь индекс и для подчинённых столбцов. Но это нужно не всегда, и создать соответствующий индекс можно по-разному, поэтому объявление внешнего ключа не создаёт автоматически индекс по связанным столбцам.</para>

   <para>Подробнее об изменении и удалении данных рассказывается в <xref remap="6" linkend="dml"/>. Вы также можете подробнее узнать о синтаксисе ограничений внешнего ключа в справке <xref linkend="sql-createtable"/>.</para>
  </sect2>

  <sect2 id="ddl-constraints-exclusion">
   <title>Ограничения-исключения</title>

   <indexterm><primary>ограничение-исключение</primary></indexterm>

   <indexterm><primary>ограничение</primary> <secondary>исключение</secondary></indexterm>

   <para>Ограничения-исключения гарантируют, что при сравнении любых двух строк по указанным столбцам или выражениям с помощью заданных операторов, минимум одно из этих сравнений возвратит false или NULL. Записывается это так: <programlisting>CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);</programlisting></para>

   <para>Подробнее об этом см. <link linkend="sql-createtable-exclude"><command>CREATE TABLE ... CONSTRAINT ... EXCLUDE</command></link>.</para>

   <para>При добавлении ограничения-исключения будет автоматически создан индекс того типа, который указан в объявлении ограничения.</para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
  <title>Системные столбцы</title>

  <para>В каждой таблице есть несколько <firstterm>системных столбцов</firstterm>, неявно определённых системой. Как следствие, их имена нельзя использовать в качестве имён пользовательских столбцов. (Заметьте, что это не зависит от того, является ли имя ключевым словом или нет; заключение имени в кавычки не поможет избежать этого ограничения.) Эти столбцы не должны вас беспокоить, вам лишь достаточно знать об их существовании.</para>

  <indexterm><primary>столбец</primary> <secondary>системный столбец</secondary></indexterm>

  <variablelist>
   <varlistentry>
    <term><structfield>oid</structfield></term>
    <listitem>
     <para><indexterm><primary>OID</primary> <secondary>столбец</secondary></indexterm> Идентификатор объекта (object ID) для строки. Этот столбец присутствует, только если таблица была создана с указанием <literal>WITH OIDS</literal>, или если в момент её создания была установлена переменная конфигурации <xref linkend="guc-default-with-oids"/>. Этот столбец имеет тип <type>oid</type> (с тем же именем, что и сам столбец); подробнее об этом типе см. <xref remap="4" linkend="datatype-oid"/>.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>tableoid</structfield></term>
    <listitem>
     <indexterm><primary>tableoid</primary></indexterm>

     <para>Идентификатор объекта для таблицы, содержащей строку. Этот столбец особенно полезен для запросов, имеющих дело с иерархией наследования (см. <xref remap="4" linkend="ddl-inherit"/>), так как без него сложно определить, из какой таблицы выбрана строка. Связав <structfield>tableoid</structfield> со столбцом <structfield>oid</structfield> в таблице <structname>pg_class</structname>, можно будет получить имя таблицы.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmin</structfield></term>
    <listitem>
     <indexterm><primary>xmin</primary></indexterm>

     <para>Идентификатор (код) транзакции, добавившей строку этой версии. (Версия строки &mdash; это её индивидуальное состояние; при каждом изменении создаётся новая версия одной и той же логической строки.)</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmin</structfield></term>
    <listitem>
     <indexterm><primary>cmin</primary></indexterm>

     <para>Номер команды (начиная с нуля) внутри транзакции, добавившей строку.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmax</structfield></term>
    <listitem>
     <indexterm><primary>xmax</primary></indexterm>

     <para>Идентификатор транзакции, удалившей строку, или 0 для неудалённой версии строки. Значение этого столбца может быть ненулевым и для видимой версии строки. Это обычно означает, что удаляющая транзакция ещё не была зафиксирована, или удаление было отменено.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmax</structfield></term>
    <listitem>
     <indexterm><primary>cmax</primary></indexterm>

     <para>Номер команды в удаляющей транзакции или ноль.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>ctid</structfield></term>
    <listitem>
     <indexterm><primary>ctid</primary></indexterm>

     <para>Физическое расположение данной версии строки в таблице. Заметьте, что хотя по <structfield>ctid</structfield> можно очень быстро найти версию строки, значение <structfield>ctid</structfield> изменится при выполнении <command>VACUUM FULL</command>. Таким образом, <structfield>ctid</structfield> нельзя применять в качестве долгосрочного идентификатора строки. Для идентификации логических строк лучше использовать OID или даже дополнительный последовательный номер.</para>
    </listitem>
   </varlistentry>
  </variablelist>

   <para>Коды OID представляют собой 32-битные значения и выбираются из единого для всей СУБД счётчика. В больших или долгоживущих базах данных этот счётчик может пойти по кругу. Таким образом, не рекомендуется рассчитывать на уникальность OID, если только вы не обеспечите её дополнительно. Если вам нужно идентифицировать строки таблицы, настоятельно рекомендуется использовать последовательности. Однако можно использовать и коды OID, при выполнении следующих условий: <itemizedlist>
     <listitem>
      <para>Когда для идентификации строк таблиц применяется OID, в каждой такой таблице должно создаваться ограничение уникальности для столбца OID. Когда такое ограничение уникальности (или уникальный индекс) существует, система позаботится о том, чтобы OID новой строки не совпал с уже существующими. (Конечно, это возможно, только если в таблице меньше 2<superscript>32</superscript> (4 миллиардов) строк, а на практике таблицы должны быть гораздо меньше, иначе может пострадать производительность системы.)</para>
     </listitem>
     <listitem>
      <para>Никогда не следует рассчитывать, что OID будут уникальны среди всех таблиц; в качестве глобального идентификатора в рамках базы данных используйте комбинацию <structfield>tableoid</structfield> и OID строки.</para>
     </listitem>
     <listitem>
      <para>Конечно, все эти таблицы должны быть созданы с указанием <literal>WITH OIDS</literal>. В <productname>PostgreSQL</productname> 8.1 и новее по умолчанию подразумевается <literal>WITHOUT OIDS</literal>.</para>
     </listitem>
    </itemizedlist></para>

   <para>В <productname>&productname;</productname> идентификаторы транзакций реализованы как 64-битные счётчики, что позволяет предотвратить зацикливание идентификаторов. За подробностями обратитесь к <xref remap="3" linkend="vacuum-for-wraparound"/>.</para>

   <para>Идентификаторы команд 32-битные. Это создаёт жёсткий лимит на 2<superscript>32</superscript> (4 миллиарда) команд <acronym>SQL</acronym> в одной транзакции. На практике это не проблема &mdash; заметьте, что это лимит числа команд <acronym>SQL</acronym>, а не количества обрабатываемых строк. Кроме того, идентификатор получают только те команды, которые фактически изменяют содержимое базы данных.</para>
 </sect1>

 <sect1 id="ddl-alter">
  <title>Изменение таблиц</title>

  <indexterm zone="ddl-alter"><primary>таблица</primary> <secondary>изменение</secondary></indexterm>

  <para>Если вы создали таблицы, а затем поняли, что допустили ошибку, или изменились требования вашего приложения, вы можете удалить её и создать заново. Но это будет неудобно, если таблица уже заполнена данными, или если на неё ссылаются другие объекты базы данных (например, по внешнему ключу). Поэтому <productname>&productname;</productname> предоставляет набор команд для модификации таблиц. Заметьте, что это по сути отличается от изменения данных, содержащихся в таблице: здесь мы обсуждаем модификацию определения, или структуры, таблицы.</para>

  <para>Вы можете: <itemizedlist spacing="compact">
    <listitem>
     <para>Добавлять столбцы</para>
    </listitem>
    <listitem>
     <para>Удалять столбцы</para>
    </listitem>
    <listitem>
     <para>Добавлять ограничения</para>
    </listitem>
    <listitem>
     <para>Удалять ограничения</para>
    </listitem>
    <listitem>
     <para>Изменять значения по умолчанию</para>
    </listitem>
    <listitem>
     <para>Изменять типы столбцов</para>
    </listitem>
    <listitem>
     <para>Переименовывать столбцы</para>
    </listitem>
    <listitem>
     <para>Переименовывать таблицы</para>
    </listitem>
   </itemizedlist> Все эти действия выполняются с помощью команды <xref linkend="sql-altertable"/>; подробнее о ней вы можете узнать в её справке.</para>

  <sect2 id="ddl-alter-adding-a-column">
   <title>Добавление столбца</title>

   <indexterm><primary>столбец</primary> <secondary>добавление</secondary></indexterm>

   <para>Добавить столбец вы можете так: <programlisting>ALTER TABLE products ADD COLUMN description text;</programlisting> Новый столбец заполняется заданным для него значением по умолчанию (или значением NULL, если вы не добавите указание <literal>DEFAULT</literal>).</para>

   <para>При этом вы можете сразу определить ограничения столбца, используя обычный синтаксис: <programlisting>ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');</programlisting> На самом деле здесь можно использовать все конструкции, допустимые в определении столбца в команде <command>CREATE TABLE</command>. Помните однако, что значение по умолчанию должно удовлетворять данным ограничениям, чтобы операция <literal>ADD</literal> выполнилась успешно. Вы также можете сначала заполнить столбец правильно, а затем добавить ограничения (см. ниже).</para>

  <tip>
   <para>Добавление столбца со значением по умолчанию приводит к изменению всех строк таблицы (в них будет сохранено новое значение). Однако, если значение по умолчанию не указано, <productname>&productname;</productname> может обойтись без физического изменения. Поэтому, если вы планируете заполнить столбец в основном не значениями по умолчанию, лучше будет добавить столбец без значения по умолчанию, затем вставить требуемые значения с помощью <command>UPDATE</command>, а потом определить значение по умолчанию, как описано ниже.</para>
  </tip>
  </sect2>

  <sect2 id="ddl-alter-removing-a-column">
   <title>Удаление столбца</title>

   <indexterm><primary>столбец</primary> <secondary>удаление</secondary></indexterm>

   <para>Удалить столбец можно так: <programlisting>ALTER TABLE products DROP COLUMN description;</programlisting> Данные, которые были в этом столбце, исчезают. Вместе со столбцом удаляются и включающие его ограничения таблицы. Однако, если на столбец ссылается ограничение внешнего ключа другой таблицы, <productname>&productname;</productname> не удалит это ограничение неявно. Разрешить удаление всех зависящих от этого столбца объектов можно, добавив указание <literal>CASCADE</literal>: <programlisting>ALTER TABLE products DROP COLUMN description CASCADE;</programlisting> Общий механизм, стоящий за этим, описывается в <xref remap="6" linkend="ddl-depend"/>.</para>
  </sect2>

  <sect2 id="ddl-alter-adding-a-constraint">
   <title>Добавление ограничения</title>

   <indexterm><primary>ограничение</primary> <secondary>добавление</secondary></indexterm>

   <para>Для добавления ограничения используется синтаксис ограничения таблицы. Например: <programlisting>ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id)
  REFERENCES product_groups;</programlisting> Чтобы добавить ограничение NOT NULL, которое нельзя записать в виде ограничения таблицы, используйте такой синтаксис: <programlisting>ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;</programlisting></para>

   <para>Ограничение проходит проверку автоматически и будет добавлено, только если ему удовлетворяют данные таблицы.</para>
  </sect2>

  <sect2 id="ddl-alter-removing-a-constraint">
   <title>Удаление ограничения</title>

   <indexterm><primary>ограничение</primary> <secondary>удаление</secondary></indexterm>

   <para>Для удаления ограничения вы должны знать его имя. Если вы не присваивали ему имя, это неявно сделала система, и вы должны выяснить его. Здесь может быть полезна команда <application>psql</application> <literal>\d <replaceable>имя_таблицы</replaceable></literal> (или другие программы, показывающие подробную информацию о таблицах). Зная имя, вы можете использовать команду: <programlisting>ALTER TABLE products DROP CONSTRAINT some_name;</programlisting> (Если вы имеете дело с именем ограничения вида <literal>$2</literal>, не забудьте заключить его в кавычки, чтобы это был допустимый идентификатор.)</para>

   <para>Как и при удалении столбца, если вы хотите удалить ограничение с зависимыми объектами, добавьте указание <literal>CASCADE</literal>. Примером такой зависимости может быть ограничение внешнего ключа, связанное со столбцами ограничения первичного ключа.</para>

   <para>Так можно удалить ограничения любых типов, кроме NOT NULL. Чтобы удалить ограничение NOT NULL, используйте команду: <programlisting>ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;</programlisting> (Вспомните, что у ограничений NOT NULL нет имён.)</para>
  </sect2>

  <sect2>
   <title>Изменение значения по умолчанию</title>

   <indexterm><primary>значение по умолчанию</primary> <secondary>изменение</secondary></indexterm>

   <para>Назначить столбцу новое значение по умолчанию можно так: <programlisting>ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;</programlisting> Заметьте, что это никак не влияет на существующие строки таблицы, а просто задаёт значение по умолчанию для последующих команд <command>INSERT</command>.</para>

   <para>Чтобы удалить значение по умолчанию, выполните: <programlisting>ALTER TABLE products ALTER COLUMN price DROP DEFAULT;</programlisting> При этом по сути значению по умолчанию просто присваивается NULL. Как следствие, ошибки не будет, если вы попытаетесь удалить значение по умолчанию, не определённое явно, так как неявно оно существует и равно NULL.</para>
  </sect2>

  <sect2>
   <title>Изменение типа данных столбца</title>

   <indexterm><primary>тип данных столбца</primary> <secondary>изменение</secondary></indexterm>

   <para>Чтобы преобразовать столбец в другой тип данных, используйте команду: <programlisting>ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);</programlisting> Она будет успешна, только если все существующие значения в столбце могут быть неявно приведены к новому типу. Если требуется более сложное преобразование, вы можете добавить указание <literal>USING</literal>, определяющее, как получить новые значения из старых.</para>

   <para><productname>&productname;</productname> попытается также преобразовать к новому типу значение столбца по умолчанию (если оно определено) и все связанные с этим столбцом ограничения. Но преобразование может оказаться неправильным, и тогда вы получите неожиданные результаты. Поэтому обычно лучше удалить все ограничения столбца, перед тем как менять его тип, а затем воссоздать модифицированные должным образом ограничения.</para>
  </sect2>

  <sect2>
   <title>Переименование столбца</title>

   <indexterm><primary>столбец</primary> <secondary>переименование</secondary></indexterm>

   <para>Чтобы переименовать столбец, выполните: <programlisting>ALTER TABLE products RENAME COLUMN product_no TO product_number;</programlisting></para>
  </sect2>

  <sect2>
   <title>Переименование таблицы</title>

   <indexterm><primary>таблица</primary> <secondary>переименование</secondary></indexterm>

   <para>Таблицу можно переименовать так: <programlisting>ALTER TABLE products RENAME TO items;</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
  <title>Права</title>

  <indexterm zone="ddl-priv"><primary>право</primary></indexterm>

  <indexterm><primary>разрешение</primary> <see>право</see></indexterm>

  <indexterm zone="ddl-priv"><primary>владелец</primary></indexterm>

  <indexterm zone="ddl-priv"><primary>GRANT</primary></indexterm>

  <indexterm zone="ddl-priv"><primary>REVOKE</primary></indexterm>

  <para>Когда в базе данных создаётся объект, ему назначается владелец. Владельцем обычно становится роль, с которой был выполнен оператор создания. Для большинства типов объектов в исходном состоянии только владелец (или суперпользователь) может делать с объектом всё, что угодно. Чтобы разрешить использовать его другим ролям, нужно дать им <firstterm>права</firstterm>.</para>

  <para>Существует несколько типов прав: <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>, <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal> и <literal>USAGE</literal>. Набор прав, применимых к определённому объекту, зависит от типа объекта (таблица, функция и т. д.) Полную информацию о различных типах прав, поддерживаемых <productname>&productname;</productname>, вы найдете на странице справки <xref linkend="sql-grant"/>. Вы также увидите, как применяются эти права, в следующих разделах и главах.</para>

  <para>Неотъемлемое право изменять или удалять объект имеет только владелец объекта.</para>

  <para>Объекту можно назначить нового владельца с помощью команды <command>ALTER</command> для соответствующего типа объекта, например <xref linkend="sql-altertable"/>. Суперпользователь может делать это без ограничений, а обычный пользователь, только если он является одновременно текущим владельцем объекта (или членом роли владельца) и членом новой роли.</para>

  <para>Для назначения прав применяется команда <command>GRANT</command>. Например, если в базе данных есть роль <literal>joe</literal> и таблица <literal>accounts</literal>, право на изменение таблицы можно дать этой роли так: <programlisting>GRANT UPDATE ON accounts TO joe;</programlisting> Если вместо конкретного права написать <literal>ALL</literal>, роль получит все права, применимые для объекта этого типа.</para>

  <para>Для назначения права всем ролям в системе можно использовать специальное имя <quote>роли</quote>: <literal>PUBLIC</literal>. Также для упрощения управления ролями, когда в базе данных есть множество пользователей, можно настроить <quote>групповые</quote> роли; подробнее об этом см. <xref remap="4" linkend="user-manag"/>.</para>

  <para>Чтобы лишить пользователей прав, используйте команду <command>REVOKE</command>: <programlisting>REVOKE ALL ON accounts FROM PUBLIC;</programlisting> Особые права владельца объекта (то есть права на выполнение <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command> и т. д.) всегда неявно закреплены за владельцем и их нельзя назначить или отобрать. Но владелец объекта может лишить себя обычных прав, например, разрешить всем, включая себя, только чтение таблицы.</para>

  <para>Обычно распоряжаться правами может только владелец объекта (или суперпользователь). Однако возможно дать право доступа к объекту <quote>с правом передачи</quote>, что позволит получившему такое право назначать его другим. Если такое право передачи впоследствии будет отозвано, то все, кто получил данное право доступа (непосредственно или по цепочке передачи), потеряют его. Подробнее об этом см. справку <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/>.</para>
 </sect1>

 <sect1 id="ddl-rowsecurity">
  <title>Политики защиты строк</title>

  <indexterm zone="ddl-rowsecurity"><primary>защита на уровне строк</primary></indexterm>

  <indexterm zone="ddl-rowsecurity"><primary>политика</primary></indexterm>

  <para>В дополнение к стандартной <link linkend="ddl-priv">системе прав</link> SQL, управляемой командой <xref linkend="sql-grant"/>, на уровне таблиц можно определить <firstterm>политики защиты строк</firstterm>, ограничивающие для пользователей наборы строк, которые могут быть возвращены обычными запросами или добавлены, изменены и удалены командами, изменяющими данные. Это называется также <firstterm>защитой на уровне строк</firstterm> (RLS, Row-Level Security). По умолчанию таблицы не имеют политик, так что если система прав SQL разрешает пользователю доступ к таблице, все строки в ней одинаково доступны для чтения или изменения.</para>

  <para>Когда для таблицы включается защита строк (с помощью команды <link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</link>), все обычные запросы к таблице на выборку или модификацию строк должны разрешаться политикой защиты строк. (Однако на владельца таблицы такие политики обычно не действуют.) Если политика для таблицы не определена, применяется политика запрета по умолчанию, так что никакие строки в этой таблице нельзя увидеть или модифицировать. На операции с таблицей в целом, такие как <command>TRUNCATE</command> и <literal>REFERENCES</literal>, защита строк не распространяется.</para>

  <para>Политики защиты строк могут применяться к определённым командам и/или ролям. Политику можно определить как применяемую к командам <literal>ALL</literal> (всем), либо <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal> и <literal>DELETE</literal>. Кроме того, политику можно связать с несколькими ролями, при этом действуют обычные правила членства и наследования.</para>

  <para>Чтобы определить, какие строки будут видимыми или могут изменяться в таблице, для политики задаётся выражение, возвращающее логический результат. Это выражение будет вычисляться для каждой строки перед другими условиями или функциями, поступающими из запроса пользователя. (Единственным исключением из этого правила являются <literal>герметичные</literal> функции, которые гарантированно не допускают утечки информации; оптимизатор может решить выполнить эти функции до проверок защиты строк.) Строки, для которых это выражение возвращает не <literal>true</literal>, обрабатываться не будут. Чтобы независимо управлять набором строк, которые можно видеть, и набором строк, которые можно модифицировать, в политике можно задать отдельные выражения. Выражения политик обрабатываются в составе запроса с правами исполняющего его пользователя, но для обращения к данным, недоступным этому пользователю, в этих выражениях могут применяться функции, определяющие контекст безопасности.</para>

  <para>Суперпользователи и роли с атрибутом <literal>BYPASSRLS</literal> всегда обращаются к таблице, минуя систему защиты строк. На владельца таблицы защита строк тоже не действует, хотя он может включить её для себя принудительно, выполнив команду <link linkend="sql-altertable">ALTER TABLE ... FORCE ROW LEVEL SECURITY</link>.</para>

  <para>Неотъемлемое право включать или отключать защиту строк, а также определять политики для таблицы, имеет только её владелец.</para>

  <para>Для создания политик предназначена команда <xref linkend="sql-createpolicy"/>, для изменения — <xref linkend="sql-alterpolicy"/>, а для удаления — <xref linkend="sql-droppolicy"/>. Чтобы включить или отключить защиту строк для определённой таблицы, воспользуйтесь командой <xref linkend="sql-altertable"/>.</para>

  <para>Каждой политике назначается имя, при этом для одной таблицы можно определить несколько политик. Так как политики привязаны к таблицам, каждая политика для таблицы должна иметь уникальное имя. В разных таблицах политики могут иметь одинаковые имена.</para>

  <para>Когда к определённому запросу применяются несколько политик, они объединяются логическим сложением, так что строка будет доступна, если это разрешит какая-либо политика. Это подобно тому, как некоторая роль получает права всех ролей, в которые она включена.</para>

  <para>В качестве простого примера, создать политику для отношения <literal>account</literal>, позволяющую только членам роли <literal>managers</literal> обращаться к строкам отношения и при этом только к своим, можно так:</para>

<programlisting>CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);</programlisting>

  <para>Если роль не задана, либо задано специальное имя пользователя <literal>PUBLIC</literal>, политика применяется ко всем пользователям в данной системе. Чтобы все пользователи могли обратиться к собственной строке в таблице <literal>users</literal>, можно применить простую политику:</para>

<programlisting>CREATE POLICY user_policy ON users
    USING (user_name = current_user);</programlisting>

  <para>Чтобы определить для строк, добавляемых в таблицу, отдельную политику, отличную от политики, ограничивающей видимые строки, можно применить предложение <literal>WITH CHECK</literal>. Следующая политика позволит всем пользователям видеть все строки в таблице <literal>users</literal>, но изменять только свою собственную:</para>

<programlisting>CREATE POLICY user_policy ON users
    USING (true)
    WITH CHECK (user_name = current_user);</programlisting>

  <para>Защиту строк можно отключить так же командой <command>ALTER TABLE</command>. При отключении защиты, политики, определённые для таблицы, не удаляются, а просто игнорируются. В результате в таблице будут видны и могут модифицироваться все строки, с учётом ограничений стандартной системы прав SQL.</para>

  <para>Ниже показан развёрнутый пример того, как этот механизм защиты можно применять в производственной среде. Таблица <literal>passwd</literal> имитирует файл паролей в Unix:</para>

<programlisting>-- Простой пример на базе файла passwd
CREATE TABLE passwd (
  user_name              text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- Администратор
CREATE ROLE bob;    -- Обычный пользователь
CREATE ROLE alice;  -- Обычный пользователь

-- Наполнение таблицы
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- Необходимо включить для этой таблицы защиту на уровне строк
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- Создание политик
-- Администратор может видеть и добавлять любые строки
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- Обычные пользователи могут видеть все строки
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- Обычные пользователи могут изменять собственные данные, но
-- не могут задать произвольную оболочку входа
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- Администраторы получают все обычные права
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- Пользователям разрешается чтение только общедоступных столбцов
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- Пользователям разрешается изменение определённых столбцов
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;</programlisting>

  <para>Как и любые средства защиты, важно проверить политики, и убедиться в том, что они работают ожидаемым образом. Применительно к предыдущему примеру, эти команды показывают, что система разрешений работает корректно.</para>

<programlisting>-- Администратор может видеть все строки и поля
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- Проверим, что может делать Алиса
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
-- Алиса может изменить своё имя (поле real_name), но не имя кого-либо другого
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
-- Алиса может изменить собственный пароль; попытки поменять другие пароли RLS просто игнорирует
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1</programlisting>

  <para>На проверки ссылочной целостности, например, на ограничения уникальности и внешние ключи, защита строк никогда не распространяется, чтобы не нарушалась целостность данных. Поэтому организацию и политики защиты на уровне строк необходимо тщательно прорабатывать, чтобы не возникли <quote>скрытые каналы</quote> утечки информации через эти проверки.</para>

  <para>В некоторых случаях важно, чтобы защита на уровне строк, наоборот, не действовала. Например, резервное копирование может оказаться провальным, если механизм защиты на уровне строк молча не даст скопировать какие-либо строки. В таком случае вы можете установить для параметра конфигурации <xref linkend="guc-row-security"/> значение <literal>off</literal>. Это само по себе не отключит защиту строк; при этом просто будет выдана ошибка, если результаты запроса отфильтруются политикой, с тем чтобы можно было изучить причину ошибки и устранить её.</para>

  <para>В приведённых выше примерах выражения политики учитывали только текущие значения в запрашиваемой или изменяемой строке. Это самый простой и наиболее эффективный по скорости вариант; по возможности реализацию защиты строк следует проектировать именно так. Если же для принятия решения о доступе необходимо обращаться к другим строкам или другим таблицам, это можно осуществить, применяя в выражениях политик вложенные <command>SELECT</command> или функции, содержащие <command>SELECT</command>. Однако учтите, что при такой реализации возможны условия гонки, что чревато утечкой информации, если не принять меры предосторожности. Например, рассмотрим следующую конструкцию таблиц:</para>

<programlisting>-- определение групп привилегий
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- alice является администратором
GRANT SELECT ON groups TO public;

-- определение уровней привилегий для пользователей
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- таблица, содержащая защищаемую информацию
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- строка должна быть доступна для чтения/изменения пользователям с group_id,
-- большим или равным group_id данной строки
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-- мы защищаем таблицу с информацией, полагаясь только на RLS
GRANT ALL ON information TO public;</programlisting>

  <para>Теперь предположим, что Алиса (роль <literal>alice</literal>) желает записать <quote>слегка секретную</quote> информацию, но при этом не хочет давать <literal>mallory</literal> доступ к ней. Она делает следующее:</para>

<programlisting>BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;</programlisting>

  <para>На первый взгляд всё нормально; <literal>mallory</literal> ни при каких условиях не должна увидеть строку <quote>secret from mallory</quote>. Однако здесь возможно условие гонки. Если Мэллори (роль <literal>mallory</literal>) параллельно выполняет, скажем: <programlisting>SELECT * FROM information WHERE group_id = 2 FOR UPDATE;</programlisting> и её транзакция в режиме <literal>READ COMMITTED</literal>, она сможет увидеть <quote>secret from mallory</quote>. Это произойдёт, если её транзакция дойдёт до строки <structname>information</structname> сразу после того, как эту строку изменит Алиса (роль <literal>alice</literal>). Она заблокируется, ожидая фиксирования транзакции Алисы, а затем прочитает изменённое содержимое строки благодаря предложению <literal>FOR UPDATE</literal>. Однако при этом изменённое содержимое <structname>users</structname> <emphasis>не</emphasis> будет прочитано неявным запросом <command>SELECT</command>, так как этот вложенный <command>SELECT</command> выполняется без указания <literal>FOR UPDATE</literal>; вместо этого строка <structname>users</structname> читается из снимка, полученного в начале запроса. Таким образом, выражение политики проверяет старое значение уровня привилегий пользователя <literal>mallory</literal> и позволяет ей видеть изменённую строку.</para>

  <para>Обойти эту проблему можно несколькими способами. Первое простое решение заключается в использовании <literal>SELECT ... FOR SHARE</literal> во вложенных запросах <command>SELECT</command> в политиках защиты строк. Однако для этого потребуется давать затронутым пользователям право <literal>UPDATE</literal> в целевой таблице (здесь <structname>users</structname>), что может быть нежелательно. (Хотя можно применить ещё одну политику защиты строк, чтобы они не могли практически воспользоваться этим правилом; либо поместить вложенный <command>SELECT</command> в функцию, определяющую контекст безопасности.) Кроме этого, активное использование блокировок строк в целевой таблице может повлечь проблемы с производительностью, особенно при частых изменениях. Другое решение, практичное, если целевая таблица изменяется нечасто, заключается в исключительной блокировке целевой таблицы при изменении, чтобы никакие параллельные транзакции не видели старые значения строк. Либо можно просто дождаться завершения всех параллельных транзакций после изменения в целевой таблице, прежде чем вносить изменения, рассчитанные на новые условия безопасности.</para>

  <para>За дополнительными подробностями обратитесь к <xref remap="3" linkend="sql-createpolicy"/> и <xref remap="3" linkend="sql-altertable"/>.</para>

 </sect1>

 <sect1 id="ddl-schemas">
  <title>Схемы</title>

  <indexterm zone="ddl-schemas"><primary>схема</primary></indexterm>

  <para>Кластер баз данных <productname>&productname;</productname> содержит один или несколько именованных экземпляров баз. На уровне кластера создаются пользователи и группы, но данные могут относиться только к базам данных. При этом в рамках одного подключения к серверу можно обращаться к данным только одной базы данных, указанной при установлении соединения.</para>

  <note>
   <para>Пользователи кластера не обязательно будут иметь доступ ко всем базам данным этого кластера. То, что пользователи создаются на уровне кластера, означает только, что в нём не может быть двух пользователей <literal>joe</literal> в разных базах данных, хотя система позволяет ограничить доступ <literal>joe</literal> только некоторыми базами данных.</para>
  </note>

  <para>База данных содержит одну или несколько именованных <firstterm>схем</firstterm>, которые в свою очередь содержат таблицы. Схемы также содержат именованные объекты других видов, включая типы данных, функции и операторы. Одно и то же имя объекта можно свободно использовать в разных схемах, например и <literal>schema1</literal>, и <literal>myschema</literal> могут содержать таблицы с именем <literal>mytable</literal>. В отличие от баз данных, схемы не ограничивают доступ к данным: пользователи могут обращаться к объектам в любой схеме текущей базы данных, если им назначены соответствующие права.</para>

  <para>Есть несколько возможных объяснений, для чего стоит применять схемы: <itemizedlist>
    <listitem>
     <para>Чтобы одну базу данных могли использовать несколько пользователей, независимо друг от друга.</para>
    </listitem>

    <listitem>
     <para>Чтобы объединить объекты базы данных в логические группы для облегчения управления ими.</para>
    </listitem>

    <listitem>
     <para>Чтобы в одной базе сосуществовали разные приложения, и при этом не возникало конфликтов имён.</para>
    </listitem>
   </itemizedlist> Схемы в некоторым смысле подобны каталогам в операционной системе, но они не могут быть вложенными.</para>

  <sect2 id="ddl-schemas-create">
   <title>Создание схемы</title>

   <indexterm zone="ddl-schemas-create"><primary>схема</primary> <secondary>создание</secondary></indexterm>

   <para>Для создания схемы используется команда <xref linkend="sql-createschema"/>. При этом вы определяете имя схемы по своему выбору, например так: <programlisting>CREATE SCHEMA myschema;</programlisting></para>

   <indexterm><primary>полное имя</primary></indexterm>

   <indexterm><primary>имя</primary> <secondary>полное</secondary></indexterm>

   <para>Чтобы создать объекты в схеме или обратиться к ним, указывайте <firstterm>полное имя</firstterm>, состоящее из имён схемы и объекта, разделённых точкой: <synopsis>
<replaceable>схема</replaceable><literal>.</literal><replaceable>таблица</replaceable>
</synopsis> Этот синтаксис работает везде, где ожидается имя таблицы, включая команды модификации таблицы и команды обработки данных, обсуждаемые в следующих главах. (Для краткости мы будем говорить только о таблицах, но всё это распространяется и на другие типы именованных объектов, например, типы и функции.)</para>

   <para>Есть ещё более общий синтаксис <synopsis>
<replaceable>база_данных</replaceable><literal>.</literal><replaceable>схема</replaceable><literal>.</literal><replaceable>таблица</replaceable>
</synopsis>но в настоящее время он поддерживается только для формального соответствия стандарту SQL. Если вы указываете базу данных, это может быть только база данных, к которой вы подключены.</para>

   <para>Таким образом, создать таблицу в новой схеме можно так: <programlisting>CREATE TABLE myschema.mytable (
 ...
);</programlisting></para>

   <indexterm><primary>схема</primary> <secondary>удаление</secondary></indexterm>

   <para>Чтобы удалить пустую схему (не содержащую объектов), выполните: <programlisting>DROP SCHEMA myschema;</programlisting> Удалить схему со всеми содержащимися в ней объектами можно так: <programlisting>DROP SCHEMA myschema CASCADE;</programlisting> Стоящий за этим общий механизм описан в <xref remap="6" linkend="ddl-depend"/>.</para>

   <para>Часто бывает нужно создать схему, владельцем которой будет другой пользователь (это один из способов ограничения пользователей пространствами имён). Сделать это можно так: <programlisting>CREATE SCHEMA <replaceable>имя_схемы</replaceable> AUTHORIZATION <replaceable>имя_пользователя</replaceable>;</programlisting> Вы даже можете опустить имя схемы, в этом случае именем схемы станет имя пользователя. Как это можно применять, описано в <xref remap="6" linkend="ddl-schemas-patterns"/>.</para>

   <para>Схемы с именами, начинающимися с <literal>pg_</literal>, являются системными; пользователям не разрешено использовать такие имена.</para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>Схема public</title>

   <indexterm zone="ddl-schemas-public"><primary>схема</primary> <secondary>public</secondary></indexterm>

   <para>До этого мы создавали таблицы, не указывая никакие имена схем. По умолчанию такие таблицы (и другие объекты) автоматически помещаются в схему <quote>public</quote>. Она содержится во всех создаваемых базах данных. Таким образом, команда: <programlisting>CREATE TABLE products ( ... );</programlisting> эквивалентна: <programlisting>CREATE TABLE public.products ( ... );</programlisting></para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>Путь поиска схемы</title>

   <indexterm><primary>путь поиска</primary></indexterm>

   <indexterm><primary>неполное имя</primary></indexterm>

   <indexterm><primary>имя</primary> <secondary>неполное</secondary></indexterm>

   <para>Везде писать полные имена утомительно, и часто всё равно лучше не привязывать приложения к конкретной схеме. Поэтому к таблицам обычно обращаются по <firstterm>неполному имени</firstterm>, состоящему просто из имени таблицы. Система определяет, какая именно таблица подразумевается, используя <firstterm>путь поиска</firstterm>, который представляет собой список просматриваемых схем. Подразумеваемой таблицей считается первая подходящая таблица, найденная в схемах пути. Если подходящая таблица не найдена, возникает ошибка, даже если таблица с таким именем есть в других схемах базы данных.</para>

   <indexterm><primary>схема</primary> <secondary>текущая</secondary></indexterm>

   <para>Первая схема в пути поиска называется текущей. Эта схема будет использоваться не только при поиске, но и при создании объектов &mdash; она будет включать таблицы, созданные командой <command>CREATE TABLE</command> без указания схемы.</para>

   <indexterm><primary>параметр конфигурации <varname>search_path</varname></primary></indexterm>

   <para>Чтобы узнать текущий тип поиска, выполните следующую команду: <programlisting>SHOW search_path;</programlisting> В конфигурации по умолчанию она возвращает: <screen>
 search_path
--------------
 "$user", public
</screen> Первый элемент ссылается на схему с именем текущего пользователя. Если такой схемы не существует, ссылка на неё игнорируется. Второй элемент ссылается на схему public, которую мы уже видели.</para>

   <para>Первая существующая схема в пути поиска также считается схемой по умолчанию для новых объектов. Именно поэтому по умолчанию объекты создаются в схеме public. При указании неполной ссылки на объект в любом контексте (при модификации таблиц, изменении данных или в запросах) система просматривает путь поиска, пока не найдёт соответствующий объект. Таким образом, в конфигурации по умолчанию неполные имена могут относиться только к объектам в схеме public.</para>

   <para>Чтобы добавить в путь нашу новую схему, мы выполняем: <programlisting>SET search_path TO myschema,public;</programlisting> (Мы опускаем компонент <literal>$user</literal>, так как здесь в нём нет необходимости.) Теперь мы можем обращаться к таблице без указания схемы: <programlisting>DROP TABLE mytable;</programlisting> И так как <literal>myschema</literal> &mdash; первый элемент в пути, новые объекты будут по умолчанию создаваться в этой схеме.</para>

   <para>Мы можем также написать: <programlisting>SET search_path TO myschema;</programlisting> Тогда мы больше не сможем обращаться к схеме public, не написав полное имя объекта. Единственное, что отличает схему public от других, это то, что она существует по умолчанию, хотя её так же можно удалить.</para>

   <para>В <xref remap="6" linkend="functions-info"/> вы узнаете, как ещё можно манипулировать путём поиска схем.</para>

   <para>Как и для имён таблиц, путь поиска аналогично работает для имён типов данных, имён функций и имён операторов. Имена типов данных и функций можно записать в полном виде так же, как и имена таблиц. Если же вам нужно использовать в выражении полное имя оператора, для этого есть специальный способ &mdash; вы должны написать: <synopsis>
<literal>OPERATOR(</literal><replaceable>схема</replaceable><literal>.</literal><replaceable>оператор</replaceable><literal>)</literal>
</synopsis> Такая запись необходима для избежания синтаксической неоднозначности. Пример такого выражения: <programlisting>SELECT 3 OPERATOR(pg_catalog.+) 4;</programlisting> На практике пользователи часто полагаются на путь поиска, чтобы не приходилось писать такие замысловатые конструкции.</para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>Схемы и права</title>

   <indexterm zone="ddl-schemas-priv"><primary>права</primary> <secondary sortas="схемы">для схем</secondary></indexterm>

   <para>По умолчанию пользователь не может обращаться к объектам в чужих схемах. Чтобы изменить это, владелец схемы должен дать пользователю право <literal>USAGE</literal> для данной схемы. Чтобы пользователи могли использовать объекты схемы, может понадобиться назначить дополнительные права на уровне объектов.</para>

   <para>Пользователю также можно разрешить создавать объекты в не принадлежащей ему схеме. Для этого ему нужно дать право <literal>CREATE</literal> в требуемой схеме. Заметьте, что по умолчанию все имеют права <literal>CREATE</literal> и <literal>USAGE</literal> в схеме <literal>public</literal>. Благодаря этому все пользователи могут подключаться к заданной базе данных и создавать объекты в её схеме <literal>public</literal>. Если вас это не устраивает, вы можете отозвать это право: <programlisting>REVOKE CREATE ON SCHEMA public FROM PUBLIC;</programlisting> (Первое слово <quote>public</quote> обозначает схему, а второе <quote>public</quote> подразумевает <quote>все пользователи</quote>. В первом случае это идентификатор, а во втором &mdash; ключевое слово, поэтому оно написано в разном регистре; вспомните рекомендации из <xref remap="2" linkend="sql-syntax-identifiers"/>.)</para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>Схема системного каталога</title>

   <indexterm zone="ddl-schemas-catalog"><primary>системный каталог</primary> <secondary>схема</secondary></indexterm>

   <para>В дополнение к схеме <literal>public</literal> и схемам, создаваемым пользователями, любая база данных содержит схему <literal>pg_catalog</literal>, в которой находятся системные таблицы и все встроенные типы данных, функции и операторы. <literal>pg_catalog</literal> фактически всегда является частью пути поиска. Если даже эта схема не добавлена в путь явно, она неявно просматривается <emphasis>до</emphasis> всех схем, указанных в пути. Так обеспечивается доступность встроенных имён при любых условиях. Однако вы можете явным образом поместить <literal>pg_catalog</literal> в конец пути поиска, если вам нужно, чтобы пользовательские имена переопределяли встроенные.</para>

   <para>Так как имена системных таблиц начинаются с <literal>pg_</literal>, такие имена лучше не использовать во избежание конфликта имён, возможного при появлении в будущем системной таблицы с тем же именем, что и ваша. (С путём поиска по умолчанию неполная ссылка будет воспринята как обращение к системной таблице.) Системные таблицы будут и дальше содержать в имени приставку <literal>pg_</literal>, так что они не будут конфликтовать с неполными именами пользовательских таблиц, если пользователи со своей стороны не будут использовать приставку <literal>pg_</literal>.</para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>Шаблоны использования</title>

   <para>Схемам можно найти множество применений. Вот лишь некоторые шаблоны их использования, рекомендуемые и легко реализуемые в конфигурации по умолчанию: <itemizedlist>
     <listitem>
      <para>Если вы явно не создаёте какие-либо схемы, все пользователи будут неявно обращаться к схеме public. Таким образом система ведёт себя так, как если бы схем не было вообще. Эта конфигурация в основном рекомендуется, когда в базе данных есть всего один или несколько сотрудничающих пользователей. Она также позволяет легко мигрировать из среды, где схемы не поддерживаются.</para>
     </listitem>

     <listitem>
      <para>Вы можете создать отдельные схемы для каждого пользователя, назвав их именами пользователей. Вспомните, путь поиска по умолчанию начинается с <literal>$user</literal>, что интерпретируется как имя пользователя. Таким образом, если у пользователя будет своя схема, по умолчанию он будет обращаться к ней.</para>

      <para>Если вы реализуете этот подход, вы, возможно, также захотите запретить доступ к схеме public (или даже удалить её), чтобы пользователи не выходили за рамки своих схем.</para>
     </listitem>

     <listitem>
      <para>В отдельные схемы также можно устанавливать совместно используемые приложения (таблицы, которые нужны всем, дополнительные функции и т. д.). Не забудьте дать другим пользователям права для доступа к этим схемам. Тогда пользователи смогут обращаться к этим дополнительным объектам по полному имени или при желании добавят эти схемы в свои пути поиска.</para>
     </listitem>
    </itemizedlist></para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>Переносимость</title>

   <para>Стандарт SQL не поддерживает обращение в одной схеме к разным объектам, принадлежащим разным пользователям. Более того, в ряде реализаций СУБД нельзя создавать схемы с именем, отличным от имени владельца. На практике, в СУБД, реализующих только базовую поддержку схем согласно стандарту, концепции пользователя и схемы очень близки. Таким образом, многие пользователи полагают, что полное имя на самом деле образуется как <literal><replaceable>имя_пользователя</replaceable>.<replaceable>имя_таблицы</replaceable></literal>. И именно так будет вести себя <productname>&productname;</productname>, если вы создадите схемы для каждого пользователя.</para>

   <para>В стандарте SQL нет и понятия схемы <literal>public</literal>. Для максимального соответствия стандарту использовать схему <literal>public</literal> не следует (и возможно, лучше даже удалить её).</para>

   <para>Конечно, есть СУБД, в которых вообще не реализованы схемы или пространства имён поддерживают (возможно, с ограничениями) обращения к другим базам данных. Если вам потребуется работать с этими системами, максимальной переносимости вы достигнете, вообще не используя схемы.</para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
  <title>Наследование</title>

  <indexterm><primary>наследование</primary></indexterm>

  <indexterm><primary>таблица</primary> <secondary>наследование</secondary></indexterm>

  <para><productname>&productname;</productname> реализует наследование таблиц, что может быть полезно для проектировщиков баз данных. (Стандарт SQL:1999 и более поздние версии определяют возможность наследования типов, но это во многом отличается от того, что описано здесь.)</para>

  <para>Давайте начнём со следующего примера: предположим, что мы создаём модель данных для городов. В каждом штате есть множество городов, но лишь одна столица. Мы хотим иметь возможность быстро получать город-столицу для любого штата. Это можно сделать, создав две таблицы: одну для столиц штатов, а другую для городов, не являющихся столицами. Однако, что делать, если нам нужно получить информацию о любом городе, будь то столица штата или нет? В решении этой проблемы может помочь наследование. Мы определим таблицу <structname>capitals</structname> как наследника <structname>cities</structname>: <programlisting>CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -- в футах
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);</programlisting> В этом случае таблица <structname>capitals</structname> <firstterm>наследует</firstterm> все столбцы своей родительской таблицы, <structname>cities</structname>. Столицы штатов также имеют дополнительный столбец <structfield>state</structfield>, в котором будет указан штат.</para>

  <para>В <productname>&productname;</productname> таблица может наследоваться от нуля или нескольких других таблиц, а запросы могут выбирать все строки родительской таблицы или все строки родительской и всех дочерних таблиц. По умолчанию принят последний вариант. Например, следующий запрос найдёт названия всех городов, включая столицы штатов, расположенных выше 500 футов: <programlisting>SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;</programlisting> Для данных из введения (см. <xref remap="4" linkend="tutorial-sql-intro"/>) он выдаст: <programlisting>   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845</programlisting></para>

  <para>А следующий запрос находит все города, которые не являются столицами штатов, но также находятся на высоте выше 500 футов: <programlisting>SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953</programlisting></para>

  <para>Здесь ключевое слово <literal>ONLY</literal> указывает, что запрос должен применяться только к таблице <structname>cities</structname>, но не к таблицам, расположенным ниже <structname>cities</structname> в иерархии наследования. Многие операторы, которые мы уже обсудили, &mdash; <command>SELECT</command>, <command>UPDATE</command> и <command>DELETE</command> &mdash; поддерживают ключевое слово <literal>ONLY</literal>.</para>

  <para>Вы также можете добавить после имени таблицы <literal>*</literal>, чтобы обрабатывались и все дочерние таблицы: <programlisting>SELECT name, altitude
    FROM cities*
    WHERE altitude &gt; 500;</programlisting> Указывать <literal>*</literal> не обязательно, так как теперь это поведение подразумевается по умолчанию (если только вы не измените параметр конфигурации <xref linkend="guc-sql-inheritance"/>). Однако такая запись может быть полезна тем, что подчеркнёт использование дополнительных таблиц.</para>

  <para>В некоторых ситуациях бывает необходимо узнать, из какой таблицы выбрана конкретная строка. Для этого вы можете воспользоваться системным столбцом <structfield>tableoid</structfield>, присутствующим в каждой таблице: <programlisting>SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;</programlisting> этот запрос выдаст: <programlisting> tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845</programlisting> (Если вы попытаетесь выполнить его у себя, скорее всего вы получите другие значения OID.) Собственно имена таблиц вы можете получить, обратившись к <structname>pg_class</structname>: <programlisting>SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;</programlisting> в результате вы получите: <programlisting> relname  |   name    | altitude
----------+-----------+----------
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845</programlisting></para>

  <para>Тот же эффект можно получить другим способом, используя псевдотип <type>regclass</type>; при этом OID таблицы выводится в символьном виде: <programlisting>SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;</programlisting></para>

  <para>Механизм наследования не способен автоматически распределять данные команд <command>INSERT</command> или <command>COPY</command> по таблицам в иерархии наследования. Поэтому в нашем примере этот оператор <command>INSERT</command> не выполнится: <programlisting>INSERT INTO cities (name, population, altitude, state)
VALUES ('Albany', NULL, NULL, 'NY');</programlisting> Мы могли надеяться на то, что данные каким-то образом попадут в таблицу <structname>capitals</structname>, но этого не происходит: <command>INSERT</command> всегда вставляет данные непосредственно в указанную таблицу. В некоторых случаях добавляемые данные можно перенаправлять, используя правила (см. <xref remap="4" linkend="rules"/>). Однако в нашем случае это не поможет, так как таблица <structname>cities</structname> не содержит столбца <structfield>state</structfield> и команда будет отвергнута до применения правила.</para>

  <para>Дочерние таблицы автоматически наследуют от родительской таблицы ограничения-проверки и ограничения NOT NULL (если только для них не задано явно <literal>NO INHERIT</literal>). Все остальные ограничения (уникальности, первичный ключ и внешние ключи) не наследуются.</para>

  <para>Таблица может наследоваться от нескольких родительских таблиц, в этом случае она будет объединять в себе все столбцы этих таблиц, а также столбцы, описанные непосредственно в её определении. Если в определениях родительских и дочерней таблиц встретятся столбцы с одним именем, эти столбцы будут <quote>объединены</quote>, так что в дочерней таблице окажется только один столбец. Чтобы такое объединение было возможно, столбцы должны иметь одинаковый тип данных, в противном случае произойдёт ошибка. Наследуемые ограничения-проверки и ограничения NOT NULL объединяются подобным образом. Так, например, объединяемый столбец получит свойство NOT NULL, если какое-либо из порождающих его определений имеет свойство NOT NULL. Ограничения-проверки объединяются, если они имеют одинаковые имена; но если их условия различаются, происходит ошибка.</para>

  <para>Отношение наследования между таблицами обычно устанавливается при создании дочерней таблицы с использованием предложения <literal>INHERITS</literal> оператора <xref linkend="sql-createtable"/>. Другой способ добавить такое отношение для таблицы, определённой подходящим образом &mdash; использовать <literal>INHERIT</literal> с оператором <xref linkend="sql-altertable"/>. Для этого будущая дочерняя таблица должна уже включать те же столбцы (с совпадающими именами и типами), что и родительская таблица. Также она должна включать аналогичные ограничения-проверки (с теми же именами и выражениями). Удалить отношение наследования можно с помощью указания <literal>NO INHERIT</literal> оператора <command>ALTER TABLE</command>. Динамическое добавление и удаление отношений наследования может быть полезно при реализации секционирования таблиц (см. <xref remap="4" linkend="ddl-partitioning"/>).</para>

  <para>Для создания таблицы, которая затем может стать наследником другой, удобно воспользоваться предложением <literal>LIKE</literal> оператора <command>CREATE TABLE</command>. Такая команда создаст новую таблицу с теми же столбцами, что имеются в исходной. Если в исходной таблицы определены ограничения <literal>CHECK</literal>, для создания полностью совместимой таблицы их тоже нужно скопировать, и это можно сделать, добавив к предложению <literal>LIKE</literal> параметр <literal>INCLUDING CONSTRAINTS</literal>.</para>

  <para>Родительскую таблицу нельзя удалить, пока существуют унаследованные от неё. При этом в дочерних таблицах нельзя удалять или модифицировать столбцы или ограничения-проверки, унаследованные от родительских таблиц. Если вы хотите удалить таблицу вместе со всеми её потомками, это легко сделать, добавив в команду удаления родительской таблицы параметр <literal>CASCADE</literal> (см. <xref remap="4" linkend="ddl-depend"/>).</para>

  <para>При изменениях определений и ограничений столбцов команда <xref linkend="sql-altertable"/> распространяет эти изменения вниз в иерархии наследования. Однако удалить столбцы, унаследованные дочерними таблицами, можно только с помощью параметра <literal>CASCADE</literal>. При создании отношений наследования команда <command>ALTER TABLE</command> следует тем же правилам объединения дублирующихся столбцов, что и <command>CREATE TABLE</command>.</para>

  <para>В запросах с наследуемыми таблицами проверка прав доступа выполняется только в родительской таблице. Так, например, наличие разрешения <literal>UPDATE</literal> для таблицы <structname>cities</structname> подразумевает право на изменение строк также в таблице <structname>capitals</structname>, когда к ним происходит обращение через таблицу <structname>cities</structname>. Это сохраняет видимость того, что эти данные (также) находятся в родительской таблице. Но изменить таблицу <structname>capitals</structname> напрямую без дополнительного разрешения нельзя. Подобным образом, политики безопасности на уровне строк (см. <xref remap="4" linkend="ddl-rowsecurity"/>) для родительской таблицы применяются к строкам, получаемым из дочерних таблиц при выполнении запроса с наследованием. Политики же дочерних таблиц, если они определены, действуют только когда такие таблицы явно задействуются в запросе; в этом случае все политики, связанные с родительскими таблицами, игнорируются.</para>

  <para>Сторонние таблицы (см. <xref remap="4" linkend="ddl-foreign-data"/>) могут также входить в иерархию наследования как родительские или дочерние таблицы, так же, как и обычные. Если в иерархию наследования входит сторонняя таблица, все операции, не поддерживаемые ей, не будут поддерживаться иерархией в целом.</para>

 <sect2 id="ddl-inherit-caveats">
  <title>Ограничения</title>

  <para>Заметьте, что не все SQL-команды могут работать с иерархиями наследования. Команды, выполняющие выборку данных, изменение данных или модификацию схемы (например <literal>SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, большинство вариантов <literal>ALTER TABLE</literal>, но не <literal>INSERT</literal> и <literal>ALTER TABLE ... RENAME</literal>), обычно по умолчанию обрабатывают данные дочерних таблиц и могут исключать их, если поддерживают указание <literal>ONLY</literal>. Команды для обслуживания и настройки базы данных (например <literal>REINDEX</literal> и <literal>VACUUM</literal>) обычно работают только с отдельными физическими таблицами и не поддерживают рекурсивную обработку отношений наследования. Соответствующее поведение каждой команды описано в её справке (<xref linkend="sql-commands"/>).</para>

  <para>Возможности наследования серьёзно ограничены тем, что индексы (включая ограничения уникальности) и ограничения внешних ключей относятся только к отдельным таблицам, но не к их потомкам. Это касается обеих сторон ограничений внешних ключей. Таким образом, применительно к нашему примеру: <itemizedlist>
    <listitem>
     <para>Если мы объявим <structname>cities</structname>.<structfield>name</structfield> с ограничением <literal>UNIQUE</literal> или <literal>PRIMARY KEY</literal>, это не помешает добавить в таблицу <structname>capitals</structname> строки с названиями городов, уже существующими в таблице <structname>cities</structname>. И эти дублирующиеся строки по умолчанию будут выводиться в результате запросов к <structname>cities</structname>. На деле таблица <structname>capitals</structname> по умолчанию вообще не будет содержать ограничение уникальности, так что в ней могут оказаться несколько строк с одним названием. Хотя вы можете добавить в <structname>capitals</structname> соответствующее ограничение, но это не предотвратит дублирование при объединении с <structname>cities</structname>.</para>
    </listitem>

    <listitem>
     <para>Подобным образом, если мы укажем, что <structname>cities</structname>.<structfield>name</structfield> ссылается (<literal>REFERENCES</literal>) на какую-то другую таблицу, это ограничение не будет автоматически распространено на <structname>capitals</structname>. В этом случае решением может стать явное добавление такого же ограничения <literal>REFERENCES</literal> в таблицу <structname>capitals</structname>.</para>
    </listitem>

    <listitem>
     <para>Если вы сделаете, чтобы столбец другой таблицы ссылался на <literal>cities(name)</literal>, в этом столбце можно будет указывать только названия городов, но не столиц. В этом случае хорошего решения нет.</para>
    </listitem>
   </itemizedlist> Возможно, в будущем эти недостатки будут исправлены, но в настоящее время вам следует тщательно взвесить все за и против, прежде чем использовать наследование в своих приложениях.</para>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>Секционирование</title>

   <indexterm><primary>секционирование</primary></indexterm>

   <indexterm><primary>таблица</primary> <secondary>секционирование</secondary></indexterm>

   <para><productname>&productname;</productname> поддерживает простое секционирование таблиц. В этом разделе описывается, как и почему бывает полезно применять секционирование при проектировании баз данных.</para>

   <sect2 id="ddl-partitioning-overview">
     <title>Обзор</title>

   <para>Секционированием данных называется разбиение одной большой логической таблицы на несколько небольших физических секций. Секционирование может принести следующую пользу: <itemizedlist>
    <listitem>
     <para>В определённых ситуациях оно кардинально увеличивает быстродействие, особенно когда большой процент часто запрашиваемых строк таблицы относится к одному или небольшому числу секций. Секционирование может сыграть роль ведущих столбцов в индексах, что позволит уменьшить размер индекса и увеличит вероятность нахождения наиболее востребованных частей индексов в памяти.</para>
    </listitem>

    <listitem>
     <para>Когда в выборке или изменении данных задействована большая часть одной секции, последовательное сканирование этой секции может выполняться гораздо быстрее, чем случайный доступ по индексу к данным, разбросанным по всей таблице.</para>
    </listitem>

    <listitem>
     <para>Массовую загрузку и удаление данных можно осуществлять, добавляя и удаляя секции, если это было предусмотрено при проектировании секций. Команды <command>ALTER TABLE NO INHERIT</command> и <command>DROP TABLE</command> работают гораздо быстрее, чем массовая загрузка. Эти команды также полностью исключают накладные расходы, связанные с выполнением операции <command>VACUUM</command> после команды <command>DELETE</command>.</para>
    </listitem>

    <listitem>
     <para>Редко используемые данные можно перенести на более дешёвые и медленные носители.</para>
    </listitem>
   </itemizedlist> Всё это обычно полезно только для очень больших таблиц. Какие именно таблицы выиграют от секционирования, зависит от конкретного приложения, хотя, как правило, это следует применять для таблиц, размер которых превышает объём ОЗУ сервера.</para>

   <para>В настоящее время <productname>&productname;</productname> реализует секционирование таблиц через механизм наследования. Каждая секция одной таблицы должна создаваться как её дочерняя таблица. Сама же родительская таблица обычно остаётся пустой; она существует только для того, чтобы представлять единый набор данных. Прежде чем приступить к изучению секционирования, вам следует познакомиться с наследованием (см. <xref remap="4" linkend="ddl-inherit"/>).</para>

   <para>В <productname>&productname;</productname> можно реализовать следующие типы секционирования: <variablelist>
     <varlistentry>
      <term>Секционирование по диапазонам</term>

      <listitem>
       <para>Таблица секционируется по <quote>диапазонам</quote>, определённым по ключевому столбцу или набору столбцов, и не пересекающимся друг с другом. Например, можно секционировать данные по диапазонам дат или по диапазонам идентификаторов определённых бизнес-объектов.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Секционирование по списку</term>

      <listitem>
       <para>Таблица секционируется с помощью списка, явно указывающего, какие значения ключа должны относиться к каждой секции.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
   </sect2>

   <sect2 id="ddl-partitioning-implementation">
     <title>Реализация секционирования</title>

    <para>Чтобы создать секционированную таблицу, выполните следующее: <orderedlist spacing="compact">
      <listitem>
       <para>Создайте <quote>главную</quote> таблицу, от которой будут унаследованы все секции.</para>
       <para>Эта таблица не будет содержать данных. Не определяйте для неё никаких ограничений, если только вы не намерены затем явно продублировать их во всех секциях. Также не имеет смысла определять для неё какие-либо индексы или ограничения уникальности.</para>
      </listitem>

      <listitem>
       <para>Создайте несколько <quote>дочерних</quote> таблиц, унаследовав их все от главной. Обычно в таких таблицах не будет никаких дополнительных столбцов, кроме унаследованных.</para>

       <para>Далее мы будем называть эти дочерние таблицы секциями, хотя по сути они ничем не отличаются от обычных таблиц <productname>&productname;</productname> (и, возможно, сторонних таблиц).</para>
      </listitem>

      <listitem>
       <para>Добавьте в таблицы-секции ограничения, определяющие допустимые значения ключей для каждой секции.</para>

       <para>Типичные примеры таких ограничений: <programlisting>CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )</programlisting> Убедитесь в том, что ограничения не пересекаются, то есть никакие значения ключа не относятся сразу к нескольким секциям. Например, часто допускают такую ошибку в определении диапазонов: <programlisting>CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )</programlisting> Это не будет работать, так как неясно, к какой секции должно относиться значение 200.</para>

       <para>Заметьте, что никаких синтаксических отличий между секционированием по диапазонам и по списку значений нет; эти типы выделены только для понимания.</para>
      </listitem>

      <listitem>
       <para>Для каждой секции создайте индекс по ключевому столбцу(ам), а также любые другие индексы по своему усмотрению. (Индекс по ключу, строго говоря, не необходим, но в большинстве случаев он будет полезен. Если вы хотите, чтобы значения ключа были уникальны, вам следует также создать ограничения уникальности или первичного ключа для каждой секции.)</para>
      </listitem>

      <listitem>
       <para>Дополнительно вы можете определить триггер или правило для перенаправления данных, добавляемых в главную таблицу, в соответствующую секцию.</para>
      </listitem>

      <listitem>
       <para>Убедитесь в том, что параметр конфигурации <xref linkend="guc-constraint-exclusion"/> не выключен в <filename>postgresql.conf</filename>. Иначе запросы не будут оптимизироваться должным образом.</para>
      </listitem>

     </orderedlist></para>

    <para>Например, предположим, что мы создаём базу данных для большой компании, торгующей мороженым. Компания учитывает максимальную температуру и продажи мороженого каждый день в разрезе регионов. По сути нам нужна следующая таблица: <programlisting>CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);</programlisting> Мы знаем, что большинство запросов будут работать только с данными за последнюю неделю, месяц или квартал, так как в основном эта таблица нужна для формирования текущих отчётов для руководства. Чтобы сократить объём хранящихся старых данных, мы решили оставлять данные только за 3 последних года. Ненужные данные мы будем удалять в начале каждого месяца.</para>

    <para>При таких условиях мы можем применить секционирование для удовлетворения всех наших потребностей. Настроить секционирование согласно приведённой выше последовательности действий можно следующим образом:</para>

    <para>
     <orderedlist spacing="compact">
      <listitem>
       <para>Главная таблица, названная <structname>measurement</structname>, будет объявлена в точности как показано выше.</para>
      </listitem>

      <listitem>
       <para>Затем мы создаём отдельные секции для каждого нужного нам месяца: <programlisting>CREATE TABLE measurement_y2006m02 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 ( ) INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 ( ) INHERITS (measurement);</programlisting> Все эти секции являются полностью самостоятельными таблицами, но они наследуют свои определения от таблицы <structname>measurement</structname>.</para>

       <para>Это решает одну из наших проблем: удаление старых данных. Каждый месяц нам нужно будет просто выполнять <command>DROP TABLE</command> для самой старой дочерней таблицы и создавать новую дочернюю таблицу для данных нового месяца.</para>
      </listitem>

      <listitem>
       <para>Мы должны определить непересекающиеся ограничения таблиц. Таким образом, скрипт создания таблиц должен не просто создавать секции, но ещё и задавать ограничения: <programlisting>CREATE TABLE measurement_y2006m02 (
  CHECK (logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01')
) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 (
  CHECK (logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01')
) INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 (
  CHECK (logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01')
) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 (
  CHECK (logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01')
) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 (
  CHECK (logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01')
) INHERITS (measurement);</programlisting></para>
      </listitem>

      <listitem>
       <para>Мы, вероятно, также захотим добавить индексы по столбцам ключа: <programlisting>CREATE INDEX measurement_y2006m02_logdate
  ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate
  ON measurement_y2006m03 (logdate);
...
CREATE INDEX measurement_y2007m11_logdate
  ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate
  ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate
  ON measurement_y2008m01 (logdate);</programlisting> На этом с индексами мы пока остановимся.</para>
      </listitem>

      <listitem>
       <para>Мы хотим, чтобы наше приложение могло сказать <literal>INSERT INTO measurement ...</literal> и данные оказались в соответствующей секции. Мы можем добиться этого, добавив подходящую триггерную функцию в главную таблицу. Если данные всегда будут добавляться только в последнюю секцию, нам будет достаточно очень простой функции: <programlisting>CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;</programlisting> Теперь мы создаём триггер, вызывающий эту функцию: <programlisting>CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();</programlisting> Затем мы должны будем каждый месяц переопределять триггерную функцию, чтобы она всегда указывала на текущую секцию. Однако определение триггера обновлять не потребуется.</para>

       <para>Но мы можем также сделать, чтобы сервер автоматически находил секцию, в которую нужно направить добавляемую строку. Для этого нам потребуется более сложная триггерная функция: <programlisting>CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION
  'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;</programlisting> Определение триггера остаётся прежним. Заметьте, что все условия <literal>IF</literal> должны в точности отражать ограничения <literal>CHECK</literal> соответствующих секций.</para>

       <para>Хотя эта функция сложнее, чем вариант с одним текущим месяцем, её не придётся так часто модифицировать, так как ветви условий можно добавить заранее.</para>

       <note>
        <para>На практике будет лучше сначала проверять условие для последней секции, если строки чаще добавляются в эту секцию. Для простоты же мы расположили проверки триггера в том же порядке, как и в других фрагментах кода для этого примера.</para>
       </note>
      </listitem>
     </orderedlist>
    </para>

    <para>Как уже можно понять, для реализации сложной схемы разбиения может потребоваться DDL-код значительного объёма. В данном примере нам потребуется создавать секцию каждый месяц, так что было бы разумно написать скрипт, который бы формировал требуемый код DDL автоматически.</para>

   </sect2>

   <sect2 id="ddl-partitioning-managing-partitions">
   <title>Управление секциями</title>

   <para>Обычно набор секций, образованный изначально при создании таблиц, не предполагается сохранять неизменным. Чаще наоборот, планируется удалять старые секции данных и периодически добавлять новые. Одно из наиболее важных преимуществ секционирования состоит именно в том, что оно позволяет практически моментально выполнять трудоёмкие операции, изменяя структуру секций, а не физически перемещая большие объёмы данных.</para>

   <para>Самый лёгкий способ удалить старые данные &mdash; это просто удалить секцию, ставшую ненужной: <programlisting>DROP TABLE measurement_y2006m02;</programlisting> Так можно удалить миллионы записей гораздо быстрее, чем сервер будет удалять их по одной.</para>

   <para>Ещё один часто более предпочтительный вариант &mdash; убрать секцию из главной таблицы, но сохранить возможность обращаться к ней как к самостоятельной таблице: <programlisting>ALTER TABLE measurement_y2006m02 NO INHERIT measurement;</programlisting> При этом можно будет продолжать работать с данными, пока таблица не будет удалена. Например, в этом состоянии очень кстати будет сделать резервную копию данных, используя <command>COPY</command>, <application>pg_dump</application> или подобные средства. Возможно, эти данные также можно будет агрегировать, перевести в компактный формат, выполнить другую обработку или построить отчёты.</para>

   <para>Аналогичным образом можно добавлять новую секцию с данными. Мы можем создать пустую секцию в главной таблице так же, как мы создавали секции в исходном состоянии до этого: <programlisting>CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);</programlisting> А иногда удобнее создать новую таблицу вне структуры секций и сделать её полноценной секцией позже. При таком подходе данные можно будет загрузить, проверить и преобразовать до того, как они появятся в секционированной таблице: <programlisting>CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-- возможна дополнительная подготовка данных
ALTER TABLE measurement_y2008m02 INHERIT measurement;</programlisting></para>
   </sect2>

   <sect2 id="ddl-partitioning-constraint-exclusion">
   <title>Секционирование и исключение по ограничению</title>

   <indexterm><primary>исключение по ограничению</primary></indexterm>

   <para><firstterm>Исключение по ограничению</firstterm> &mdash; это приём оптимизации запросов, который ускоряет работу с секционированными таблицами, определёнными по вышеописанной схеме. Например: <programlisting>SET constraint_exclusion = on;
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';</programlisting> Без исключения по ограничению для данного запроса пришлось бы просканировать все секции таблицы <structname>measurement</structname>. Если же исключение по ограничению включено, планировщик рассмотрит ограничение каждой секции с целью определить, что данная секция не может содержать строки, удовлетворяющие условию запроса <literal>WHERE</literal>. Если планировщик придёт к такому выводу, он исключит эту секцию из плана запроса.</para>

   <para>Чтобы увидеть, как меняется план при изменении параметра <varname>constraint_exclusion</varname>, вы можете воспользоваться командой <command>EXPLAIN</command>. Типичный неоптимизированный план для такой конфигурации таблицы будет выглядеть так: <programlisting>SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM measurement
  WHERE logdate &gt;= DATE '2008-01-01';

                              QUERY PLAN
---------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m02 measurement
                      (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03 measurement
                      (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m12 measurement
                      (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement
                      (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)</programlisting> В некоторых или всех секциях может применяться не полное последовательное сканирование, а сканирование по индексу, но основная идея примера в том, что для удовлетворения запроса не нужно сканировать старые секции. И когда мы включаем исключение по ограничению, мы получаем значительно более эффективный план, дающий тот же результат: <programlisting>SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM measurement
  WHERE logdate &gt;= DATE '2008-01-01';

                              QUERY PLAN
--------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement
                      (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)</programlisting></para>

   <para>Заметьте, что механизм исключения по ограничению учитывает только ограничения <literal>CHECK</literal>, но не наличие индексов. Поэтому определять индексы для столбцов ключа не обязательно. Нужно ли создавать индекс для данной секции, зависит от того, какая часть секции будет обрабатываться при выполнении большинства запросов. Если это небольшая часть, индекс может быть полезен, в противном случае он не нужен.</para>

   <para>По умолчанию параметр <xref linkend="guc-constraint-exclusion"/> имеет значение не <literal>on</literal> и не <literal>off</literal>, а промежуточное (и рекомендуемое) значение <literal>partition</literal>, при котором этот приём будет применяться только к запросам, где предположительно будут задействованы секционированные таблицы. Значение <literal>on</literal> обязывает планировщик просматривать ограничения <literal>CHECK</literal> во всех запросах, даже в самых простых, где исключение по ограничению не будет иметь смысла.</para>

   </sect2>

   <sect2 id="ddl-partitioning-alternatives">
   <title>Альтернативные варианты секционирования</title>

    <para>Другой способ перенаправления добавляемых строк в соответствующую секцию можно реализовать, определив для главной таблицы не триггер, а правила. Например: <programlisting>CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);</programlisting> С правилами связано гораздо больше накладных расходов, чем с триггером, но они относятся к запросу в целом, а не к каждой строке. Поэтому этот способ может быть более выигрышным при массовом добавлении данных. Однако в большинстве случаев триггеры будут работать быстрее.</para>

    <para>Учтите, что команда <command>COPY</command> игнорирует правила. Если вы хотите вставить данные с помощью <command>COPY</command>, вам придётся копировать их сразу в нужную секцию, а не в главную таблицу. С другой стороны, <command>COPY</command> не отменяет триггеры, так что с триггерами вы сможете использовать её обычным образом.</para>

    <para>Ещё один недостаток подхода с правилами связан с невозможностью выдать ошибку, если добавляемая строка не подпадает ни под одно из правил; в этом случае данные просто попадут в главную таблицу.</para>

    <para>Секционирование можно также реализовать с помощью представления с <literal>UNION ALL</literal> вместо наследования. Например:<programlisting>CREATE VIEW measurement AS
          SELECT * FROM measurement_y2006m02
UNION ALL SELECT * FROM measurement_y2006m03
...
UNION ALL SELECT * FROM measurement_y2007m11
UNION ALL SELECT * FROM measurement_y2007m12
UNION ALL SELECT * FROM measurement_y2008m01;</programlisting> Однако для изменения набора секций в этом случае придётся не только добавлять или удалять секции, но и пересоздавать представление. На практике этот метод не имеет значительных преимуществ по сравнению с наследованием.</para>

   </sect2>

   <sect2 id="ddl-partitioning-caveats">
   <title>Ограничения</title>

   <para>С секционированными таблицами связаны следующие ограничения: <itemizedlist>
    <listitem>
     <para>Система не может проверить автоматически, являются ли все ограничения <literal>CHECK</literal> взаимно исключающими. Поэтому безопаснее будет написать и отладить код для формирования секций и создания и/или изменения связанных объектов, чем делать это вручную.</para>
    </listitem>

    <listitem>
     <para>Показанные здесь схемы подразумевают, что ключевой столбец(ы) секции в строке никогда не меняется, или меняется не настолько, чтобы строку потребовалось перенести в другую секцию. Если же попытаться выполнить такой оператор <command>UPDATE</command>, произойдёт ошибка из-за нарушения ограничения <literal>CHECK</literal>. Если вам нужно обработать и такие случаи, вы можете установить подходящие триггеры на обновление в таблицы-секции, но это ещё больше усложнит управление всей конструкцией.</para>
    </listitem>

    <listitem>
     <para>Если вы выполняете команды <command>VACUUM</command> или <command>ANALYZE</command> вручную, не забывайте, что их нужно запускать для каждой секции в отдельности. Команда <programlisting>ANALYZE measurement;</programlisting> обработает только главную таблицу.</para>
    </listitem>

    <listitem>
     <para>Операторы <command>INSERT</command> с предложениями <literal>ON CONFLICT</literal> скорее всего не будут работать ожидаемым образом, так как действие <literal>ON CONFLICT</literal> предпринимается только в случае нарушений уникальности в указанном целевом отношении, а не его дочерних отношениях.</para>
    </listitem>

   </itemizedlist></para>

   <para>Применяя исключения по ограничению, необходимо учитывать следующее: <itemizedlist>
    <listitem>
     <para>Исключение по ограничению работает только когда предложение <literal>WHERE</literal> в запросе содержит константы (или получаемые извне параметры). Например, сравнение с функцией переменной природы, такой как <function>CURRENT_TIMESTAMP</function>, нельзя оптимизировать, так как планировщик не знает, в какую секцию попадёт значение функции во время выполнения.</para>
    </listitem>

    <listitem>
     <para>Ограничения секций должны быть простыми, иначе планировщик не сможет вычислить, какие секции не нужно обрабатывать. Для секционирования по списку используйте простые условия на равенства, а для секционирования по диапазонам — простые проверки диапазонов, подобные показанным в примерах. Рекомендуется создавать ограничения секций, содержащие только такие сравнения секционирующих столбцов с константами, в которых используются операторы, поддерживающие B-деревья.</para>
    </listitem>

    <listitem>
     <para>При анализе для исключения по ограничению исследуются все ограничения всех секций главной таблицы, поэтому при большом количестве секций время планирования запросов может значительно увеличиться. Описанные выше подходы работают хорошо, пока количество секций не превышает примерно ста, но не пытайтесь применять их с тысячами секций.</para>
    </listitem>

   </itemizedlist></para>
  </sect2>
 </sect1>

 <sect1 id="ddl-foreign-data">
  <title>Сторонние данные</title>

   <indexterm><primary>сторонние данные</primary></indexterm>
   <indexterm><primary>сторонняя таблица</primary></indexterm>
   <indexterm><primary>сопоставление пользователей</primary></indexterm>

   <para><productname>&productname;</productname> частично реализует спецификацию SQL/MED, позволяя вам обращаться к данным, находящимся снаружи, используя обычные SQL-запросы. Такие данные называются <firstterm>сторонними</firstterm>.</para>

   <para>Сторонние данные доступны в <productname>PostgreSQL</productname> через <firstterm>обёртку сторонних данных</firstterm>. Обёртка сторонних данных &mdash; это библиотека, взаимодействующая с внешним источником данных и скрывающая в себе внутренние особенности подключения и получения данных. Несколько готовых обёрток предоставляются в виде модулей <filename>contrib</filename> ; см. <xref remap="4" linkend="contrib"/>. Также вы можете найти другие обёртки, выпускаемые как дополнительные продукты. Если ни одна из существующих обёрток вас не устраивает, вы можете написать свою собственную (см. <xref remap="4" linkend="fdwhandler"/>).</para>

   <para>Чтобы обратиться к сторонним данным, вы должны создать объект <firstterm>сторонний сервер</firstterm>, в котором настраивается подключение к внешнему источнику данных, определяются параметры соответствующей обёртки сторонних данных. Затем вы должны создать одну или несколько <firstterm>сторонних таблиц</firstterm>, определив тем самым структуру внешних данных. Сторонние таблицы можно использовать в запросах так же, как и обычные, но их данные не хранятся на сервере &productname;. При каждом запросе <productname>&productname;</productname> обращается к обёртке сторонних данных, которая, в свою очередь, получает данные из внешнего источника или передаёт их ему (в случае команд INSERT или UPDATE).</para>

   <para>При обращении к внешним данным удалённый источник может потребовать аутентификации клиента. Соответствующие учётные данные можно предоставить с помощью <firstterm>сопоставлений пользователей</firstterm>, позволяющих определить в частности имена и пароли, в зависимости от текущей роли пользователя <productname>&productname;</productname>.</para>

   <para>Дополнительную информацию вы найдёте в <xref remap="6" linkend="sql-createforeigndatawrapper"/>, <xref remap="6" linkend="sql-createserver"/>, <xref remap="6" linkend="sql-createusermapping"/>, <xref remap="6" linkend="sql-createforeigntable"/> и <xref remap="6" linkend="sql-importforeignschema"/>.</para>
 </sect1>

 <sect1 id="ddl-others">
  <title>Другие объекты баз данных</title>

  <para>Таблицы &mdash; центральные объекты в структуре реляционной базы данных, так как они содержат ваши данные. Но это не единственные объекты, которые могут в ней существовать. Помимо них вы можете создавать и использовать объекты и других типов, призванные сделать управление данными эффективнее и удобнее. Они не обсуждаются в этой главе, но мы просто перечислим некоторые из них, чтобы вы знали об их существовании:</para>

  <itemizedlist>
   <listitem>
    <para>Представления</para>
   </listitem>

   <listitem>
    <para>Функции и операторы</para>
   </listitem>

   <listitem>
    <para>Типы данных и домены</para>
   </listitem>

   <listitem>
    <para>Триггеры и правила перезаписи</para>
   </listitem>
  </itemizedlist>

  <para>Подробнее соответствующие темы освещаются в <xref remap="6" linkend="server-programming"/>.</para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>Отслеживание зависимостей</title>

  <indexterm zone="ddl-depend"><primary>CASCADE</primary> <secondary sortas="DROP">с DROP</secondary></indexterm>

  <indexterm zone="ddl-depend"><primary>RESTRICT</primary> <secondary sortas="DROP">с DROP</secondary></indexterm>

  <para>Когда вы создаёте сложные структуры баз данных, включающие множество таблиц с внешними ключами, представлениями, триггерами, функциями и т. п., вы неявно создаёте сеть зависимостей между объектами. Например, таблица с ограничением внешнего ключа зависит от таблицы, на которую она ссылается.</para>

  <para>Для сохранения целостности структуры всей базы данных, <productname>&productname;</productname> не позволяет удалять объекты, от которых зависят другие. Например, попытка удалить таблицу products (мы рассматривали её в <xref remap="6" linkend="ddl-constraints-fk"/>), от которой зависит таблица orders, приведёт к ошибке примерно такого содержания: <screen>
DROP TABLE products;

ОШИБКА:  удалить объект "таблица products" нельзя, так как от него зависят другие
ПОДРОБНОСТИ:  ограничение orders_product_no_fkey в отношении "таблица orders" зависит от объекта "таблица products"
ПОДСКАЗКА:  Для удаления зависимых объектов используйте DROP ... CASCADE.
</screen> Сообщение об ошибке даёт полезную подсказку: если вы не хотите заниматься ликвидацией зависимостей по отдельности, можно выполнить: <screen>
DROP TABLE products CASCADE;
</screen> и все зависимые объекты, а также объекты, зависящие от них, будут удалены рекурсивно. В этом случае таблица orders останется, а удалено будет только её ограничение внешнего ключа. Удаление не распространится на другие объекты, так как ни один объект не зависит от этого ограничения. (Если вы хотите проверить, что произойдёт при выполнении <command>DROP ... CASCADE</command>, запустите <command>DROP</command> без <literal>CASCADE</literal> и прочитайте <literal>ПОДРОБНОСТИ</literal> (DETAIL).)</para>

  <para>Почти все команды <command>DROP</command> в <productname>&productname;</productname> поддерживают указание <literal>CASCADE</literal>. Конечно, вид возможных зависимостей зависит от типа объекта. Вы также можете написать <literal>RESTRICT</literal> вместо <literal>CASCADE</literal>, чтобы включить поведение по умолчанию, когда объект можно удалить, только если от него не зависят никакие другие.</para>

  <note>
   <para>Стандарт SQL требует явного указания <literal>RESTRICT</literal> или <literal>CASCADE</literal> в команде <command>DROP</command>. Но это требование на самом деле не выполняется ни в одной СУБД, при этом одни системы по умолчанию подразумевают <literal>RESTRICT</literal>, а другие — <literal>CASCADE</literal>.</para>
  </note>

  <para>Если в команде <command>DROP</command> перечисляются несколько объектов, <literal>CASCADE</literal> требуется указывать, только когда есть зависимости вне заданной группы. Например, в команде <literal>DROP TABLE tab1, tab2</literal> при наличии внешнего ключа, ссылающегося на <literal>tab1</literal> из <literal>tab2</literal>, можно не указывать <literal>CASCADE</literal>, чтобы она выполнилась успешно.</para>

  <para>Для пользовательских функций <productname>&productname;</productname> отслеживает зависимости, связанные с внешне видимыми свойствами функции, такими как типы аргументов и результата, но <emphasis>не</emphasis> зависимости, которые могут быть выявлены только при анализе тела функции. В качестве примера рассмотрите следующий сценарий: <programlisting>CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;</programlisting> (Описание функций языка SQL можно найти в <xref remap="6" linkend="xfunc-sql"/>.) <productname>&productname;</productname> будет понимать, что функция <function>get_color_note</function> зависит от типа <type>rainbow</type>: при удалении типа будет принудительно удалена функция, так как тип её аргумента оказывается неопределённым. Но <productname>&productname;</productname> не будет учитывать зависимость <function>get_color_note</function> от таблицы <structname>my_colors</structname> и не удалит функцию при удалении таблицы. Но у этого подхода есть не только минус, но и плюс. В случае отсутствия таблицы эта функция останется рабочей в некотором смысле: хотя при попытке выполнить её возникнет ошибка, но при создании новой таблицы с тем же именем функция снова будет работать.</para>
 </sect1>

</chapter>
