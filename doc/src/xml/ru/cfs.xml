<!-- doc/src/xml/cfs.xml -->

<chapter id="cfs">
 <title>Сжатая файловая система</title>

 <para>В этой главе рассматривается сжатие и шифрование на уровне страниц в СУБД <productname>&productname;</productname>.</para>

 <sect1 id="cfs-overview">
  <title>Когда сжатие/шифрование баз данных может быть полезным?</title>
    
  <para>В базах данных обычно хранятся большие объёмы текста и повторяющейся информации. Поэтому сжатие для большинства баз данных может быть довольно эффективным и позволяет сократить объём хранимых данных в 3..5 раз. &productname; производит сжатие данных TOAST, но небольшие текстовые поля, умещающиеся в странице, сжатию не подвергаются. Однако сжатие может быть полезно не только для страниц в куче, но и для индексов по текстовым ключам или для индексов с большим количеством повторяющихся значений.</para>

  <para>&productname; обращается к данным на диске через пул буферов, в котором остаются наиболее востребованные буферы. Интерфейс между менеджером буфером и файловой системой является наиболее подходящим местом для выполнения сжатия. Буферы хранятся на диске в сжатой форме для уменьшения объёма данных на диске и сокращения объёма считываемых данных. А так как пул буферов в памяти содержит несжатые буферы, обращаться к данным в них можно также быстро, как и без сжатия. Поскольку современные серверы имеют достаточно большой объём ОЗУ, обычно в памяти может кешироваться существенная часть базы данных, при обращении к которой не потребуется платить за сжатие.</para>

  <para>Помимо очевидного плюса, заключающегося в экономии места, сжатие может также увеличить быстродействие системы. Это объясняется двумя причинами:</para>

  <variablelist>
   <varlistentry>
    <term>Сокращение объёма дискового ввода/вывода</term>
    <listitem>
     <para>Сжатие помогает уменьшить объём данных, который приходится записывать или считывать с диска. Коэффициент сжатия 3 обычно означает, что читать придётся в 3 раза меньше данных, или что то же количество записей можно прочитать в три раза быстрее.</para>
    </listitem>
   </varlistentry>
  
   <varlistentry>
    <term>Улучшение кучности</term>
    <listitem>
     <para>Когда модифицированные буферы сбрасываются из пула на диск, они записываются в произвольные области диска. Реализованный в &productname; алгоритм замены кеша принимает решение о вымещении буфера из пула в зависимости только от частоты обращений к нему и игнорирует его расположение на диске. Поэтому два последовательно записываемых на диск буфера могут располагаться в совершенно разных областях диска. Для жёстких дисков время позиционирования может быть довольно большим — до 10 мс, а значит за секунду возможно выполнить лишь около 100 операций произвольной записи. А скорость последовательной записи может достигать 100 МБ/с и более, то есть около 10000 буферов в секунду (в 100 раз быстрее). Для SSD разрыв между скоростью последовательной и случайной записи меньше, но последовательная запись всё же производится эффективнее. Как это связано со сжатием данных? Размер буфера в &productname; фиксированный (по умолчанию 8 КБ), а размер сжатого буфера зависит от содержимого буфера. Поэтому изменённый буфер не всегда сможет уместиться в своё старое расположение на диске. Вот почему мы не можем обращаться к страницам непосредственно по адресу. Вместо этого мы должны ввести отображение адресов для сопоставления логического адреса страницы с его физическим расположением на диске. Этот дополнительный уровень адресации, определённо, добавляет издержки. Но в большинстве случаев это отображение умещается в памяти, так что поиск страницы заключается просто в обращении к элементу массива. Однако добавление этого отображения даёт и положительный эффект: теперь мы можем записывать изменённые страницы последовательно, просто корректируя их записи в карте отображения. &productname; прилагает большие усилия, чтобы избежать «лавины записи», когда место в пуле буферов заканчивается, а дополнительное сжатие помогает значительно сократить нагрузку на диск.</para>
    </listitem>
   </varlistentry>
  </variablelist>
  
  <para>Ещё одной полезной функцией, которую можно сочетать со сжатием, является шифрование базы данных. Шифрование позволяет защитить базу данных от несанкционированного доступа (если кто-то похитит ваш ноутбук или жёсткий диск либо сделает его копию, он не сможет извлечь информацию из вашей базы данных, если она зашифрована). В &productname; представлен дополнительный модуль pgcrypto, который даёт возможность шифровать избранные типы/столбцы, но безопаснее и удобнее может быть шифровать все данные в базе. Шифрование можно совместить со сжатием. Данные будут храниться на диске в зашифрованном виде и расшифруются при загрузке страницы в пул буферов. При этом важно, чтобы сжатие выполнялось до шифрования, иначе при шифровании вся избыточность в данных будет скрыта, и коэффициент сжатия будет около 1.</para>

  <para>Почему мы решили реализовать сжатие/шифрование в &productname;, вместо того, чтобы использовать соответствующие возможности нижележащих файловых систем? Во-первых, не так много файловых систем, которые поддерживают сжатие и шифрование во всех операционных системах. И даже если бы такие файловые системы существовали, не всегда возможно/удобно внедрять такую файловую систему только для того, чтобы сжать/защитить вашу базу данных. Во-вторых, сжатие на уровне базы данных может осуществляться гораздо эффективнее, так как здесь мы знаем размер страниц базы данных и можем сжимать данные лучше.</para>

 </sect1>
    
 <sect1 id="cfs-implementation">
  <title>Как сжатие/шифрование интегрируется в &productname;</title>
    
  <para>Для увеличения эффективности дискового ввода/вывода &productname; обращается к файлам через менеджер буферов, который способен закреплять в памяти наиболее часто используемые страницы. Каждая страница имеет фиксированный размер (по умолчанию 8 КБ). Но если мы сжимаем страницу, её размер будет зависеть от её содержимого. Поэтому изменённая страница может занимать больше (или меньше) места, чем исходная. А следовательно, мы не всегда можем заменить содержимое страницы на диске. Вместо этого мы должны найти для неё новое место и как-то высвободить старое. К решению этой проблемы есть два основных подхода:</para>

  <variablelist>
   <varlistentry>
    <term>Выделение места</term>
    <listitem>
     <para>Мы должны реализовать собственный механизм выделения места в файле. Обычно для уменьшения дефрагментации место выделяется блоками фиксированного размера. Это означает, что мы выделяем место некоторыми фиксированными порциями. Например, если размер сжатой страницы 932 байта, мы выделим для неё в файле 1024 байта.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Сборка мусора</term>
    <listitem>
     <para>Мы можем всегда выделять место для страниц в конце файла и периодически делать файл компактнее (дефрагментировать его), перемещая все использованные страницы в начало файла. Такую процедуру сборки мусора можно производить в фоновом режиме. Как уже объяснялось в предыдущем разделе, при последовательной записи на диск сбрасываемых страниц может значительно возрасти скорость и общая производительность. Вот почему мы использовали этот подход в CFS.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>Поскольку расположение страницы не фиксированное и страница может перемещаться, мы больше не можем обращаться к странице по её адресу и должны использовать дополнительный уровень адресации, чтобы перейти от логического адреса страницы к её физическому расположению на диске. Это осуществляется с помощью файлов отображения. В большинстве случаев такое отображение будет умещаться в памяти (размер отображения в 1000 раз меньше размера файла данных) и трансляция адресов практически никак не отражается на времени обращения к странице. Но у нас возникает необходимость обслуживать эти дополнительные файлы: сбрасывать их на диск во время контрольных точек, удалять при удалении таблицы, включать в резервную копию и так далее...</para>

  <para>&productname; хранит отношение в наборе файлов, ограничивая размер каждого 2 гигабайтами. CFS создаёт для каждого файла отдельную карту отображения страниц и производит сборку мусора в нескольких фоновых процессах. Число этих рабочих процессов и условия простоя в их работе может настраиваться администратором баз данных. Эти рабочие процессы разделяют свою работу по хешу дескриптора файла (inode), так что конфликт между ними исключён. Обрабатывается каждый файл независимо. Эти файлы могут блокироваться в момент сборки мусора, но всё отношение при этом не блокируется. Для сохранения целостности данных сборщик мусора создаёт копии исходного файла с данными и файла отображения, а когда данные полностью сохраняются на диске, новая версия файла данных атомарно переименовывается и получает исходное имя. Затем новая карта отображения копируется в файл, отображённый в память, и предыдущий файл отображения удаляется. Производя восстановление после сбоя, мы сначала проверяем, нет ли на диске резервной копии файла данных. Если такой файл существует, это означает, что исходный файл ещё не заменился и мы можем безопасно удалить копию. Если же такого файла нет, мы проверяем наличие копии файла отображения. Если эта копия находится, значит дефрагментация не была завершена из-за сбоя, и мы можем продолжить эту операцию, скопировав отображение из копии.</para>
    
  <para>CFS можно собрать с поддержкой разных библиотек сжатия: &productname; lz, zlib, lz4, snappy, lzfse... Но этот выбор нужно сделать во время сборки: динамическая смена алгоритма сжатия не поддерживается. CFS сохраняет информацию об используемом алгоритме сжатия в табличном пространстве и выдаёт ошибку, если &productname; собран с другой библиотекой.</para>
    
  <para>Шифрование выполняется по алгоритму RC4. Ключ шифрования получается из переменной окружения <varname>PG_CIPHER_KEY</varname>. Заметьте, что отношения системного каталога, как и дополнительные слои отношений, не шифруются.</para>

 </sect1>
    
 <sect1 id="cfs-usage">
  <title>Использование сжатия/шифрования</title>
    
  <para>Сжатие можно включить для отдельных табличных пространств. При этом системные отношения не сжимаются в любом случае. В настоящее время изменить характеристику сжатия табличного пространства невозможно — то есть нельзя сжать существующее табличное пространство или наоборот, сделать сжатое пространство несжатым.</para>

  <para>Поэтому, чтобы использовать сжатие/шифрование, необходимо создать табличное пространство с параметром <varname>compression=true</varname>. Вы можете сделать это табличное пространство пространством по умолчанию — в этом случае все таблицы будут неявно создаваться в нём:</para>

  <programlisting>    postgres=# create tablespace zfs location '/var/data/cfs' with (compression=true);
    postgres=# set default_tablespace=zfs;
  </programlisting>
  
  <para>Шифрование на данный момент поддерживается только со сжатием: использовать шифрование без сжатия невозможно. Чтобы включить шифрование, нужно задать для параметра <varname>cfs_encryption</varname> значение true и задать ключ шифрования в переменной окружения <varname>PG_CIPHER_KEY</varname>.</para>
    
  <para>Вы можете настроить поведение CFS, используя параметры конфигурации сжатия данных. За подробностями обратитесь к <xref remap="3" linkend="runtime-config-cfs"/>.</para>

    <para>По умолчанию CFS использует для сборки мусора один рабочий процесс. Сборщик мусора проходит по каталогу табличного пространства, находит в нём файлы отображений и проверяет в них процент мусора. Если отношение неиспользуемого объёма к общему превышает значение <varname>cfs_gc_threshold</varname>, этот файл дефрагментируется. На время дефрагментации файл блокируется, в результате чего ни к какой его части нельзя обратиться. По завершении фрагментации сборщик мусора ждёт <varname>cfs_gc_delay</varname> миллисекунд и продолжает проход по каталогу. Завершив проход, он ждёт дополнительно <varname>cfs_gc_period</varname> миллисекунд и начинает новый проход. Если для CFS настроено несколько процессов сборки мусора, они разделяют свою работу по хешу дескриптора файла (inode).</para>

    <para>Также возможно запустить сборку мусора вручную, воспользовавшись функцией <varname>cfs_start_gc(n_workers)</varname>. Эта функция возвращает число рабочих процессов, которые были фактически запущены. Заметьте, что если параметр <varname>cfs_gc_workers</varname> отличен от нуля, сборка мусора выполняется в фоне и функция <varname>cfs_start_gc</varname> ничего не делает, а просто возвращает 0.</para>

    <para>Эффект от сжатия таблицы можно оценить предварительно, воспользовавшись функцией <varname>cfs_estimate(relation)</varname>. Эта функция считывает первые десять блоков отношения, пытается сжать их и возвращает средний коэффициент сжатия. Так, если она возвращает значение 7.8, это означает, что сжатая таблица будет занимать почти в 8 раз меньше места, чем исходная.</para>

     <para>Функция <varname>cfs_compression_ratio(relation)</varname> позволяет проверить, насколько точной была оценка, выданная функцией <varname>cfs_estimate(relation)</varname>. Она возвращает фактический коэффициент сжатия для всех сегментов сжатого отношения. Коэффициент сжатия рассчитывается как результат деления общей суммы виртуальных размеров всех сегментов отношения (числа блоков, умноженного на 8 Кбайт) на сумму физических размеров его файлов сегментов.</para>
 
     <para>Как было сказано ранее, CFS всегда добавляет изменённые строки в конец сжатого файла. Поэтому физический размер файла может быть больше объёма полезных данных в нём. Другими словами, файл CFS становится фрагментированным и поэтому сборщик мусора CFS периодически проводит в нём дефрагментацию. Функции <varname>cfs_fragmentation(relation)</varname> возвращают средний коэффициент фрагментации файлов отношения, который вычисляется как результат деления суммы физических размеров файлов минус используемый объём в этих файлах на сумму физических размеров данных файлов.</para>
 
     <para>Дефрагментировать отдельное отношение можно с помощью функции <varname>cfs_gc_relation(relation)</varname>. Эта функция может использоваться, только если неактивны рабочие процессы сборки мусора (<varname>cfs_gc_workers</varname> равняется нулю). Она возвращает число дефрагментированных сегментов отношения. Если отношение с таким OID не находится или оно не сжато, либо активен другой процесс, возвращается 0.</para>
       
     <para>Для наблюдения за активностью, связанной со сборкой мусора, предлагаются следующие функции: <varname>cfs_gc_activity_scanned_files</varname> (возвращает число файлов, просканированных при сборке мусора), <varname>cfs_gc_activity_processed_files</varname> (возвращает число файлов, сжатых при сборке мусора), <varname>cfs_gc_activity_processed_pages</varname> (возвращает число страниц, перемещённых сборщиком мусора в процессе дефрагментации файлов) и <varname>cfs_gc_activity_processed_bytes</varname> (возвращает общий объём перемещённых страниц). Все эти функции подсчитывают значения с момента запуска системы.</para>
 
 </sect1>
</chapter>
