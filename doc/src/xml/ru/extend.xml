<!-- doc/src/xml/extend.xml -->

 <chapter id="extend">
  <title>Расширение <acronym>SQL</acronym></title>

  <indexterm zone="extend"><primary>расширение SQL</primary></indexterm>

  <para>В следующих разделах мы обсудим, как в <productname>&productname;</productname> можно расширять язык запросов SQL, добавляя собственные: <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>функции (начиная с <xref remap="2" linkend="xfunc"/>)</para>
    </listitem>
    <listitem>
     <para>агрегатные функции (начиная с <xref remap="2" linkend="xaggr"/>)</para>
    </listitem>
    <listitem>
     <para>типы данных (начиная с <xref remap="2" linkend="xtypes"/>)</para>
    </listitem>
    <listitem>
     <para>операторы (начиная с <xref remap="2" linkend="xoper"/>)</para>
    </listitem>
    <listitem>
     <para>классы операторов для индексов (начиная с <xref remap="2" linkend="xindex"/>)</para>
    </listitem>
    <listitem>
     <para>пакеты связанных объектов (начиная с <xref remap="2" linkend="extend-extensions"/>)</para>
    </listitem>
   </itemizedlist></para>

  <sect1 id="extend-how">
   <title>Как реализована расширяемость</title>

   <para><productname>&productname;</productname> является расширяемым благодаря тому, что его работа управляется каталогами. Если вы знакомы с традиционными реляционными системами баз данных, вы знаете, что они хранят информацию о базах, таблицах, столбцах и т. д., в структурах, которые обычно называются системными каталогами. (В некоторых системах они называются словарями данных.) Эти каталоги представляются пользователю в виде таблиц, подобных любым другим, но <acronym>СУБД</acronym> ведёт в них свои внутренние записи. Ключевое отличие <productname>&productname;</productname> от обычных реляционных СУБД состоит в том, что <productname>&productname;</productname> хранит в этих каталогах намного больше информации: информацию не только о таблицах и столбцах, но также о типах данных, функциях, методах доступа и т. д. Эти таблицы могут быть изменены пользователями, а так как <productname>&productname;</productname> в своих действиях руководствуется этими таблицами, это означает, что пользователи могут расширять <productname>&productname;</productname>. Обычные же СУБД можно расширять, только модифицируя жёстко запрограммированные процедуры в исходном коде или загружая модули, специально разработанные производителем <acronym>СУБД</acronym>.</para>

   <para>Кроме того, сервер <productname>&productname;</productname> может динамически загружать в свой процесс код, написанный пользователем. То есть, пользователь может подключить файл с объектным кодом (например, разделяемую библиотеку), который реализует новый тип или функцию, а <productname>&productname;</productname> загрузит его по мере надобности. Код, написанный на <acronym>SQL</acronym>, добавляется на сервер ещё проще. Эта способность менять своё поведение <quote>на лету</quote> делает <productname>&productname;</productname> исключительно подходящим для быстрого прототипирования новых приложений и структур хранения.</para>
  </sect1>

  <sect1 id="extend-type-system">
   <title>Система типов <productname>&productname;</productname></title>

   <indexterm zone="extend-type-system"><primary>базовый тип</primary></indexterm>

   <indexterm zone="extend-type-system"><primary>тип данных</primary> <secondary>базовый</secondary></indexterm>

   <indexterm zone="extend-type-system"><primary>составной тип</primary></indexterm>

   <indexterm zone="extend-type-system"><primary>тип данных</primary> <secondary>составной</secondary></indexterm>

   <para>Типы данных <productname>&productname;</productname> делятся на базовые, составные, доменные и псевдотипы.</para>

   <sect2>
    <title>Базовые типы</title>

    <para>Базовые типы — это типы вроде <type>int4</type>, которые реализуются ниже уровня языка <acronym>SQL</acronym> (обычно на низкоуровневом языке, например, C). В общих чертах они соответствуют так называемым абстрактным типам данных. <productname>&productname;</productname> может работать с такими типами только через функции, предоставленные пользователем, и понимать их поведение только в той степени, в какой его опишет пользователь. Базовые типы подразделяются на скалярные типы и массивы. Для каждого скалярного типа автоматически создаётся тип массива, который может содержать множество значений этого скалярного типа переменного размера.</para>
   </sect2>

   <sect2>
    <title>Составные типы</title>

    <para>Составные типы, или типы строк, образуются при создании любой таблицы. С помощью команды <xref linkend="sql-createtype"/> также можно определить <quote>независимый</quote> составной тип, не связанный с таблицей. Составной тип представляет собой просто список типов с определёнными именами полей. Значением составного типа является строка таблицы или запись из значений полей. Пользователь может обращаться к этим полям из запросов <acronym>SQL</acronym>. За дополнительными сведениями о составных типах обратитесь к <xref remap="3" linkend="rowtypes"/>.</para>
   </sect2>

   <sect2 id="extend-type-system-domains">
    <title>Домены</title>

    <para>Домен основывается на определённом базовом типе и во многих аспектах взаимозаменяем с ним. Однако домен может иметь дополнительные ограничения, уменьшающие множество допустимых значений относительно нижележащего базового типа.</para>

    <para>Доменные типы можно создавать, используя <acronym>SQL</acronym>-команду <xref linkend="sql-createdomain"/>. Их создание и применение в этой главе не рассматривается.</para>
   </sect2>

   <sect2>
    <title>Псевдотипы</title>

    <para>Для специальных целей существует также несколько <quote>псевдотипов</quote>. Псевдотипы не могут применяться в столбцах таблицы или атрибутах составных типов, но их можно использовать в объявлениях аргументов и результатов функций. Это даёт возможность выделить в системе типов специальные классы функций. Все существующие псевдотипы перечислены в <xref remap="6" linkend="datatype-pseudotypes-table"/>.</para>
   </sect2>

   <sect2 id="extend-types-polymorphic">
    <title>Полиморфные типы</title>

   <indexterm zone="extend-types-polymorphic"><primary>полиморфный тип</primary></indexterm>

   <indexterm zone="extend-types-polymorphic"><primary>полиморфная функция</primary></indexterm>

   <indexterm zone="extend-types-polymorphic"><primary>тип</primary> <secondary>полиморфный</secondary></indexterm>

   <indexterm zone="extend-types-polymorphic"><primary>функция</primary> <secondary>полиморфная</secondary></indexterm>

    <para>Особый интерес представляют пять псевдотипов: <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type> и <type>anyrange</type>, которые называются <firstterm>полиморфными типами</firstterm>. Функция, в объявлении которой используются эти типы, называется <firstterm>полиморфной</firstterm>. Полиморфная функция может работать со множеством различных типов данных; конкретный тип определяется в зависимости от значения, переданного при вызове.</para>

    <para>Полиморфные аргументы и результаты связываются друг с другом и сводятся к определённому типу данных при разборе запроса, вызывающего полиморфную функцию. В каждой позиции (в аргументах или возвращаемом значении), объявленной как <type>anyelement</type>, может передаваться любой фактический тип данных, но в каждом конкретном вызове все эти фактические типы должны быть <emphasis>одинаковыми</emphasis>. Аналогичным образом, в каждой позиции, объявленной как <type>anyarray</type>, может передаваться любой тип данных массива, но все фактические типы массивов должны совпадать. Так же и во всех позициях, объявленных как <type>anyrange</type>, должен передаваться одинаковый тип-диапазон. Более того, если некоторые позиции объявлены как <type>anyarray</type>, а другие как <type>anyelement</type>, то фактическим типом в позициях <type>anyarray</type> должен быть массив, элементы которого имеют тот же тип, что и значения в позициях <type>anyelement</type>. Подобным образом, если одни позиции объявлены как <type>anyrange</type>, а другие как <type>anyelement</type>, фактическим типом в позициях <type>anyrange</type> должен быть диапазон, подтип которого совпадает с типом, передаваемым в позициях <type>anyelement</type>. Псевдотип <type>anynonarray</type> обрабатывается так же, как <type>anyelement</type>, но с дополнительным ограничением — фактический тип не должен быть типом массива. Псевдотип <type>anyenum</type> тоже обрабатывается как <type>anyelement</type>, но его фактические типы ограничиваются перечислениями.</para>

    <para>Таким образом, когда с полиморфным типом объявлено несколько аргументов, в итоге допускаются только определённые комбинации фактических типов. Например, функция, объявленная как <literal>equal(anyelement, anyelement)</literal>, примет в аргументах любые два значения, но только если их типы данных совпадают.</para>

    <para>Когда с полиморфным типом объявлено возвращаемое значение функции, так же полиморфным должен быть минимум один аргумент, и фактический тип результата при конкретном вызове определится по типу фактически переданного аргумента. Например, если бы отсутствовал механизм обращения к элементам массива, его можно было бы реализовать, создав функцию <literal>subscript(anyarray, integer) returns anyelement</literal>. С таким объявлением первым фактическим аргументом должен быть массив, и из него будет выведен правильный тип результата при разборе запроса. В качестве другого примера можно привести функцию <literal>f(anyarray) returns anyenum</literal>, которая будет принимать только массивы перечислений.</para>

    <para>Заметьте, что <type>anynonarray</type> и <type>anyenum</type> представляют не отдельные типы переменных; это те же типы, что и <type>anyelement</type>, но с дополнительными ограничениями. Например, объявление функции <literal>f(anyelement, anyenum)</literal> равнозначно объявлению <literal>f(anyenum, anyenum)</literal>: оба фактических аргумента должны быть одинаковыми типами-перечислениями.</para>

    <para>Функции с переменным числом аргументом (описанные в <xref remap="6" linkend="xfunc-sql-variadic-functions"/>) тоже могут быть полиморфными: для этого их последний параметр описывается как <literal>VARIADIC</literal> <type>anyarray</type>. Для целей сопоставления аргументов и определения фактического типа результата такая функция представляется так же, как если бы в ней явно объявлялось нужное число параметров <type>anynonarray</type>.</para>
   </sect2>
  </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;


  <sect1 id="extend-extensions">
   <title>Упаковывание связанных объектов в расширение</title>

   <indexterm zone="extend-extensions"><primary>расширение</primary></indexterm>

   <para>Полезное расширение <productname>&productname;</productname> обычно включает несколько объектов SQL; например, с появлением нового типа данных могут потребоваться новые функции, новые операторы и новые классы операторов. Все эти объекты удобно собрать в один пакет, с тем чтобы упростить управление базой данных. В <productname>&productname;</productname> такие пакеты называются <firstterm>расширениями</firstterm>. Чтобы определить расширение, вам понадобится как минимум <firstterm>файл скрипта</firstterm> с командами <acronym>SQL</acronym>, создающими объекты расширения, и <firstterm>управляющий файл</firstterm>, в котором определяются несколько базовых свойств самого расширения. Если расширение написано на C, в него обычно также включается файл разделяемой библиотеки, содержащий скомпилированный код. Обеспечив наличие этих файлов, загрузить их в базу данных можно простой командой <xref linkend="sql-createextension"/>.</para>

   <para>Основное преимущество расширений по сравнению с обычным <acronym>SQL</acronym>-скриптом, загружающим множество <quote>разрозненных</quote> объектов в базу данных, состоит в том, что <productname>&productname;</productname> будет понимать, что объекты расширения связаны вместе. Вы можете удалить все объекты одной командой <xref linkend="sql-dropextension"/> (разрабатывать отдельный скрипт <quote>uninstall</quote> не требуется). Ещё полезнее то, что утилита <application>pg_dump</application> знает, что не нужно выгружать отдельные объекты, составляющие расширение &mdash; вместо этого она просто включит в архивный файл команду <command>CREATE EXTENSION</command>. Это кардинально упрощает миграцию на новую версию расширения, которая может содержать новые или другие объекты по сравнению с предыдущей версией. Заметьте, однако, что при загрузке такого архива в базу данных обязательно наличие скрипта, управляющего файла и других файлов расширения.</para>

   <para><productname>&productname;</productname> не позволит удалить отдельный объект, содержащийся в расширении, кроме как при удалении всего расширения. Также имейте в виду, что вы можете изменить определение объекта, относящегося к расширению (например, командой <command>CREATE OR REPLACE FUNCTION</command> для функции), но изменённое определение не будет выгружено утилитой <application>pg_dump</application>. Такие изменения обычно разумны, только если они параллельно отражаются в файле скрипта расширения. (Для таблиц, содержащих конфигурационные данные, предусмотрены специальные средства; см. <xref remap="4" linkend="extend-extensions-config-tables"/>.) В производственной среде обычно лучше создавать скрипт обновления расширения, который будет изменять относящиеся к расширению объекты.</para>

   <para>Скрипт расширения может устанавливать права доступа для объектов, являющихся частью расширения, выполняя команды <command>GRANT</command> и <command>REVOKE</command>. Окончательный набор прав для каждого объекта (если они заданы) будет сохранён в системном каталоге <link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link>. При использовании <application>pg_dump</application> в выгружаемый скрипт будет выведена команда <command>CREATE EXTENSION</command> с последующими операторами <command>GRANT</command> и <command>REVOKE</command>, которые установят права, имевшие место в момент выгрузки.</para>

   <para><productname>&productname;</productname> в настоящее время не поддерживает скрипты расширений, выполняющие операторы <command>CREATE POLICY</command> или <command>SECURITY LABEL</command>. Ожидается, что такие команды будут выполняться после того, как расширение будет создано. Выгружая данные, <application>pg_dump</application> будет также включать в вывод все политики RLS и метки безопасности.</para>

   <para>Механизм расширений также предоставляет средства для поддержки дополнительных скриптов, призванных изменять определение объектов SQL, содержащихся в расширении. Например, если версия расширения 1.1, по сравнению с версией 1.0, добавляет одну функцию и изменяет тело другой функции, автор расширения может предоставить <firstterm>скрипт обновления</firstterm>, который произведёт именно эти два изменения. Затем, воспользовавшись командой <command>ALTER EXTENSION UPDATE</command>, можно будет применить эти изменения и отследить, какая версия расширения фактически установлена в заданной базе данных.</para>

   <para>Типы SQL-объектов, которые могут быть членами расширения, перечислены в описании <xref linkend="sql-alterextension"/>. Не могут быть его членами, в частности, объекты уровня кластера, такие как базы данных, роли и табличные пространства, так как расширение существует только в рамках одной базы данных. (Скрипту расширения не запрещается создавать такие объекты, но если он сделает это, они не будут считаться частью расширения.) Также заметьте, что несмотря на то, что таблица может быть членом расширения, её подчинённые объекты, такие как индексы, непосредственными членами расширения считаться не будут. Ещё один важный момент — схемы могут принадлежать расширениям, но не наоборот; поэтому расширение имеет неполное имя и не существует <quote>внутри</quote> какой-либо схемы. Однако объекты-члены расширения, будут относиться к схемам, если это уместно для их типов. Сами расширения могут иметь, а могут не иметь основания владеть схемами, к которым относятся объекты-члены расширения.</para>

   <sect2>
    <title>Файлы расширений</title>

   <indexterm><primary>управляющий файл</primary></indexterm>

    <para>Команда <xref linkend="sql-createextension"/> задействует управляющий файл расширения, который должен называться по имени расширения, с суффиксом <literal>.control</literal>, и должен быть помещён в каталог сервера <literal>SHAREDIR/extension</literal>. Должен быть также ещё минимум один <acronym>SQL</acronym>-скрипт, с именем, соответствующим шаблону <literal><replaceable>расширение</replaceable>--<replaceable>версия</replaceable>.sql</literal> (например, <literal>foo--1.0.sql</literal> для версии <literal>1.0</literal> расширения <literal>foo</literal>). По умолчанию скрипт(ы) также помещается в каталог <literal>SHAREDIR/extension</literal>; но в управляющем файле можно задать и другой каталог.</para>

    <para>Формат управляющего файла расширения не отличается от формата <filename>postgresql.conf</filename>, а именно представляет собой список присвоений <replaceable>имя_параметра</replaceable> <literal>=</literal> <replaceable>значение</replaceable>, по одному в строке. В нём также допускаются пустые строки и комментарии, начинающиеся с <literal>#</literal>. Все значения, отличные от единственного слова или числа, в нём должны заключаться в кавычки.</para>

    <para>В управляющем файле могут устанавливаться следующие параметры:</para>

    <variablelist>
     <varlistentry>
      <term><varname>directory</varname> (<type>string</type>)</term>
      <listitem>
       <para>Каталог, содержащий <acronym>SQL</acronym>-скрипт(ы) расширения. Если только не задан абсолютный путь, это имя рассматривается относительно каталога сервера <literal>SHAREDIR</literal>. По умолчанию подразумевается указание <literal>directory = 'extension'</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>default_version</varname> (<type>string</type>)</term>
      <listitem>
       <para>Версия расширения по умолчанию (та, которая будет установлена, если в <command>CREATE EXTENSION</command> не будет указана никакая версия). Хотя этот параметр можно опустить, это приведёт к ошибке в <command>CREATE EXTENSION</command> без явного указания <literal>VERSION</literal>, что вряд ли будет желаемым поведением.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>comment</varname> (<type>string</type>)</term>
      <listitem>
       <para>Комментарий (произвольная строка) к расширению. Комментарий применяется при изначальном создании расширения, но не при обновлениях расширения (так как при этом мог бы заменяться комментарий, заданный пользователем). Комментарий расширения также можно задать посредством команды <xref linkend="sql-comment"/> в файле скрипта.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>encoding</varname> (<type>string</type>)</term>
      <listitem>
       <para>Кодировка символов, используемая в файлах скриптов. Её следует указать, если эти файлы содержат символы не из набора ASCII. По умолчанию предполагается, что эти файлы содержат текст в кодировке базы данных.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>module_pathname</varname> (<type>string</type>)</term>
      <listitem>
       <para>Значение этого параметра будет подставляться вместо каждого вхождения <literal>MODULE_PATHNAME</literal> в скриптах. Если этот параметр не задан, подстановка не производится. Обычно для этого параметра устанавливается значение <literal>$libdir/<replaceable>имя_разделяемой_библиотеки</replaceable></literal>, а затем в командах <command>CREATE FUNCTION</command> для функций на языке C указывается <literal>MODULE_PATHNAME</literal>, чтобы в скриптах не приходилось жёстко задавать имя разделяемой библиотеки.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>requires</varname> (<type>string</type>)</term>
      <listitem>
       <para>Список имён расширений, от которых зависит данное, например, <literal>requires = 'foo, bar'</literal>. Эти расширения должны быть уже установлены, прежде чем можно будет установить данное.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>superuser</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>Если этот параметр имеет значение <literal>true</literal> (по умолчанию), только суперпользователи смогут создать это расширение или обновить его до новой версии. Если он равен <literal>false</literal>, для этого будет достаточно прав, необходимых для выполнения команд в установочном скрипте или скрипте обновления.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>relocatable</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>Расширение является <firstterm>перемещаемым</firstterm>, если относящиеся к нему объекты после создания расширения можно переместить в другую схему. По умолчанию подразумевается <literal>false</literal>, то есть расширение не считается перемещаемым. Подробнее об этом рассказывается в <xref remap="6" linkend="extend-extensions-relocation"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>schema</varname> (<type>string</type>)</term>
      <listitem>
       <para>Этот параметр может задаваться только для неперемещаемых расширений. Если он задан, расширение можно будет загрузить только в указанную схему и не в какую другую. Подробнее об этом рассказывается ниже. Параметр <varname>schema</varname> учитывается только при изначальном создании расширения, но не при его обновлении. Подробнее об этом рассказывается в <xref remap="6" linkend="extend-extensions-relocation"/>.</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>Помимо главного управляющего файла <literal><replaceable>расширение</replaceable>.control</literal>, расширение может включать дополнительные управляющие файлы с именами вида <literal><replaceable>расширение</replaceable>--<replaceable>версия</replaceable>.control</literal>. Если они присутствуют, они должны находиться в том же каталоге, что и основной скрипт. Дополнительные управляющие файлы имеют тот же формат, что и основной. Любые параметры, заданные в дополнительном управляющем файле, переопределяют параметры основного файла, когда выполняется установка этой версии расширения или обновление до неё. Однако параметры <varname>directory</varname> и <varname>default_version</varname> в дополнительных управляющих файлах задать нельзя.</para>

    <para><acronym>SQL</acronym>-скрипты расширений могут содержать любые команды SQL, за исключением команд управления транзакциями (<command>BEGIN</command>, <command>COMMIT</command> и т. д.) и команд, которые не могут выполняться внутри блока транзакции (например, <command>VACUUM</command>). Это объясняется тем, что эти скрипты неявно выполняются в блоке транзакции.</para>

    <para><acronym>SQL</acronym>-скрипты расширений также могут содержать строки, начинающиеся с <literal>\echo</literal>, и они будут игнорироваться (восприниматься как комментарии) механизмом расширений. Это часто используется для вывода ошибки в случае, если этот скрипт выполняется в <application>psql</application>, а не загружается командой <command>CREATE EXTENSION</command> (см. пример скрипта в <xref remap="6" linkend="extend-extensions-example"/>). Если такое выполнение не предотвратить, пользователи могут случайно загрузить содержимое расширения как <quote>разрозненные</quote> объекты, а не как собственно расширение, и получить состояние, которое довольно сложно исправить.</para>

    <para>Тогда как файлы скриптов могут содержать любые символы, допустимые в указанной кодировке, управляющие файлы могут содержать только ASCII-символы, так как указать кодировку этих файлов в <productname>&productname;</productname> нет никакой возможности. На практике это представляет проблему, только если вы хотите использовать символы не из набора ASCII в комментарии расширения. В таких случаях рекомендуется не использовать параметр <varname>comment</varname> в управляющем файле, а вместо этого задать комментарий командой <command>COMMENT ON EXTENSION</command> в файле скрипта.</para>

   </sect2>

   <sect2 id="extend-extensions-relocation">
    <title>Перемещаемость расширений</title>

    <para>У пользователей часто возникает желание загрузить объекты, содержащиеся в расширении, в схему, отличную от той, что выбрал автор расширения. Насколько это поддерживает расширение, описывается одним из трёх уровней:</para>

    <itemizedlist>
     <listitem>
      <para>Полностью перемещаемое расширение может быть перемещено в другую схему в любое время, даже после того, как оно загружено в базу данных. Это осуществляется командой <command>ALTER EXTENSION SET SCHEMA</command>, которая автоматически переименовывает все объекты-члены расширения, перенося их в новую схему. Обычно это возможно, только если в расширении нет никаких внутренних предположений о том, в какой схеме находятся все его объекты. Кроме того, все объекты расширения должны находиться в одной исходной схеме (за исключением объектов, не принадлежащих схемам, как например, процедурные языки). Чтобы пометить расширение как полностью перемещаемое, установите <literal>relocatable = true</literal> в его управляющем файле.</para>
     </listitem>

     <listitem>
      <para>Расширение может быть перемещаемым в момент установки, но не после. Обычно это имеет место, когда скрипту расширения необходимо явно ссылаться на целевую схему, например, устанавливая свойства <literal>search_path</literal> для функций SQL. Для такого расширения нужно задать <literal>relocatable = false</literal> в его управляющем файле и обращаться к целевой схеме в скрипте по псевдоимени <literal>@extschema@</literal>. Все вхождения этого псевдоимени будут заменены именем выбранной целевой схемы перед выполнением скрипта. Пользователь может выбрать целевую схему в указании <literal>SCHEMA</literal> команды <command>CREATE EXTENSION</command>.</para>
     </listitem>

     <listitem>
      <para>Если расширение вовсе не поддерживает перемещение, установите в его управляющем файле <literal>relocatable = false</literal>, и также задайте в параметре <literal>schema</literal> имя предполагаемой целевой схемы. Это предотвратит использование указания <literal>SCHEMA</literal> команды <command>CREATE EXTENSION</command>, если только оно задаёт не то же имя, что определёно в управляющем файле. Этот выбор обычно необходим, если в расширении делаются внутренние предположения об именах схемы, которые нельзя свести к использованию псевдоимени <literal>@extschema@</literal>. Механизм подстановки <literal>@extschema@</literal> будет работать и в этом случае, хотя польза от него будет ограниченной, так как имя схемы определяется управляющим файлом.</para>
     </listitem>
    </itemizedlist>

    <para>В любом случае, при выполнении файла скрипта параметр <xref linkend="guc-search-path"/> изначально будет указывать на целевую схему; то есть, <command>CREATE EXTENSION</command> делает то же, что и: <programlisting>SET LOCAL search_path TO @extschema@;</programlisting> Это позволяет направить объекты, создаваемые скриптом, в целевую схему. Скрипт может изменить <varname>search_path</varname>, если пожелает, но обычно это нежелательно. Параметр <varname>search_path</varname> восстанавливает предыдущее значение по завершении <command>CREATE EXTENSION</command>.</para>

    <para>Целевая схема определяется параметром <varname>schema</varname> (если он задан) в управляющем файле, либо указанием <literal>SCHEMA</literal> команды <command>CREATE EXTENSION</command> (если оно присутствует), а в противном случае выбирается текущая схема для создания объектов по умолчанию (первая указанная в параметре <varname>search_path</varname> вызывающего). Когда используется параметр управляющего файла <varname>schema</varname>, целевая схема будет создана, если она ещё не существует, но в двух других случаях она должна уже существовать.</para>

    <para>Если в параметре <varname>requires</varname> в файле управления указаны какие-либо расширения, необходимые для данного, их целевые схемы добавляются к начальному значению <varname>search_path</varname>. Благодаря этому, их объекты видны для скрипта нового расширения.</para>

    <para>Хотя неперемещаемое расширение может содержать объекты, распределяемые по нескольким схемам, обычно желательно поместить все объекты, предназначенные для внешнего использования, в одну схему, назначенную целевой схемой расширения. Такой порядок будет хорошо согласовываться со значением <varname>search_path</varname> по умолчанию в процессе создания зависимых расширений.</para>
   </sect2>

   <sect2 id="extend-extensions-config-tables">
    <title>Конфигурационные таблицы расширений</title>

    <para>Некоторые расширения включают конфигурационные таблицы, содержащие данные, которые могут быть добавлены или изменены пользователем после установки расширения. Обычно, если таблица является частью расширения, ни определение таблицы, ни её содержимое не будет выгружаться утилитой <application>pg_dump</application>. Но это поведение нежелательно для конфигурационных таблиц — изменения, внесённые в них пользователем, должны выгружаться; в противном случае расширение будет вести себя по-другому, когда будет загружено вновь.</para>

   <indexterm><primary>pg_extension_config_dump</primary></indexterm>

    <para>Чтобы решить эту проблему, скрипт расширения может пометить созданную им таблицу или последовательность как конфигурационное отношение, в результате чего <application>pg_dump</application> включит в выгружаемые данные содержимое (но не определение) этой таблицы или последовательности. Для этого нужно вызвать функцию <function>pg_extension_config_dump(regclass, text)</function> после создания таблицы или последовательности, например так: <programlisting>CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');</programlisting> Так можно пометить любое число таблиц или последовательностей, в том числе последовательности, связанные со столбцами <type>serial</type> или <type>bigserial</type>.</para>

    <para>Когда второй аргумент <function>pg_extension_config_dump</function> — пустая строка, <application>pg_dump</application> выгружает всё содержимое таблицы. Обычно это правильно, только если после создания скриптом расширения эта таблица изначально пуста. Если же в таблице оказывается смесь начальных данных и данных, добавленных пользователем, во втором аргументе <function>pg_extension_config_dump</function> передаётся условие <literal>WHERE</literal>, которое отфильтровывает данные, подлежащие выгрузке. Например, имея таблицу, созданную таким образом: <programlisting>CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');</programlisting> можно сделать так, чтобы поле <structfield>standard_entry</structfield> содержало true только для строк, создаваемых скриптом расширения.</para>

    <para>Для последовательностей второй аргумент функции <function>pg_extension_config_dump</function> не имеет значения.</para>

    <para>В более сложных ситуациях, когда пользователи могут модифицировать и изначально существовавшие строки, можно создать триггеры для конфигурационной таблицы, которые корректно пометят изменённые строки.</para>

    <para>Условие фильтра, связанное с конфигурационной таблицей, можно изменить, повторно вызвав <function>pg_extension_config_dump</function>. (Обычно это находит применение в скрипте обновления расширения.) Единственный способ обозначить, что некоторая таблица более не является конфигурационной — разорвать её связь с расширением командой <command>ALTER EXTENSION ... DROP TABLE</command>.</para>

    <para>Заметьте, что отношения внешних ключей между таблицами определяют порядок, в котором эти таблицы будет выгружать pg_dump. В частности, pg_dump попытается выгрузить сначала основную таблицу, а затем подчинённую. Так как отношения внешних ключей устанавливаются во время выполнения CREATE EXTENSION (до загрузки данных в таблицы), циклические зависимости не поддерживаются. Когда образуются циклические зависимости, данные, тем не менее, будут выгружены, но полученный архив нельзя будет восстановить обычным образом, потребуется вмешательство пользователя.</para>

    <para>Последовательности, связанные со столбцами <type>serial</type> или <type>bigserial</type>, не обязательно помечать непосредственно, чтобы их состояние было сохранено. Для этой цели достаточно пометить только их родительское отношение.</para>
   </sect2>

   <sect2>
    <title>Обновление расширений</title>

    <para>Один из плюсов механизма расширений заключается в том, что он предоставляет удобные способы управления обновлениями SQL-команд, определяющих объекты расширения. В частности, каждой выпускаемой версии установочного скрипта расширения назначается имя или номер версии. Кроме того, если вы хотите, чтобы пользователи могли динамически обновлять одну версию расширения до другой, вы должны предоставить <firstterm>скрипты обновления</firstterm>, которые внесут необходимые изменения для перехода от старой версии к новой. Скриптам обновлений назначаются имена, соответствующие шаблону <literal><replaceable>расширение</replaceable>--<replaceable>старая_версия</replaceable>--<replaceable>новая_версия</replaceable>.sql</literal> (например, <literal>foo--1.0--1.1.sql</literal> будет содержать команды, меняющие версию <literal>1.0</literal> расширения <literal>foo</literal> на версию <literal>1.1</literal>).</para>

    <para>С условием, что имеется подходящий скрипт расширения, команда <command>ALTER EXTENSION UPDATE</command> обновит установленное расширение до указанной новой версии. Скрипт обновления запускается в том же окружении, которое организует команда <command>CREATE EXTENSION</command> для установочных скриптов: в частности, <varname>search_path</varname> устанавливается таким же образом, а любые новые объекты, созданные скриптом, автоматически добавляются в расширение.</para>

    <para>Если у расширения есть дополнительные управляющие файлы, для скрипта обновления применяются те параметры, которые связаны с целевой (новой) версией скрипта.</para>

    <para>Механизм обновления может использоваться для решения важной особой задачи: преобразование <quote>разрозненной</quote> коллекции объектов в расширение. До того как механизм расширений появился в <productname>PostgreSQL</productname> (в версии 9.1), многие писали модули разрешений, которые просто создавали множество неупакованных объектов. Но если у нас уже есть база данных с такими объектами, как их можно преобразовать в правильно упакованное расширение? Один из вариантов — удалить их и затем выполнить простую команду <command>CREATE EXTENSION</command>, но это нежелательно, если у объектов есть зависимости (например, если в таблицах есть столбцы типа данных, созданного расширением). Чтобы исправить эту ситуацию, можно создать пустое расширение, затем с помощью команды <command>ALTER EXTENSION ADD</command> добавить в него каждый существующий объект, и наконец, создать все новые объекты, которые есть в текущей версии расширения, но отсутствуют в неупакованном варианте. <command>CREATE EXTENSION</command> поддерживает этот сценарий предложением <literal>FROM</literal> <replaceable class="parameter">старая_версия</replaceable>, с которым она не будет запускать обычный установочный скрипт для целевой версии, а запустит вместо этого скрипт обновления с именем <literal><replaceable>расширение</replaceable>--<replaceable>старая_версия</replaceable>--<replaceable>новая_версия</replaceable>.sql</literal>. В качестве имени <replaceable class="parameter">старая_версия</replaceable> автор расширения может выбрать любое фиктивное имя, но обычно задаётся <literal>unpackaged</literal>. Если у вас несколько предыдущих версий, которые нужно привести к стилю расширения, выберите разные фиктивные имена версий, чтобы различить их.</para>

    <para><command>ALTER EXTENSION</command> также может выполнять последовательности скриптов обновления для получения запрошенной версии. Например, если имеются только скрипты <literal>foo--1.0--1.1.sql</literal> и <literal>foo--1.1--2.0.sql</literal>, <command>ALTER EXTENSION</command> будет применять их по порядку, если при установленной версии <literal>1.0</literal> запрошено обновлении до версии <literal>2.0</literal>.</para>

    <para><productname>&productname;</productname> не делает никаких предположений о свойствах имён версий: например, он не знает, следует ли версия <literal>1.1</literal> за <literal>1.0</literal>. Он просто сопоставляет имена имеющихся версий и следует пути, который требует применить как можно меньше скриптов обновлений. (Именем версии на самом деле может быть любая строка, которая не содержит <literal>--</literal> и при этом не начинается и не заканчивается символом <literal>-</literal>.)</para>

    <para>Иногда бывают полезны скрипты <quote>понижения версии</quote>, например, <literal>foo--1.1--1.0.sql</literal>, которые позволяют откатить изменения, связанные с версией <literal>1.1</literal>. Если вы применяете их, учтите, что есть вероятность неожиданного выполнения такого скрипта, если он окажется в кратчайшем пути. Рискованная ситуация возникает при наличии скрипта обновления по <quote>короткому пути</quote>, который перепрыгивает через несколько версий, и скрипта понижения версии до начальной точки первого скрипта. В результате может получиться так, что понижение версии с последующим обновлением по короткому пути окажется на несколько шагов короче, чем последовательное повышение версии. Если скрипт понижения версии удаляет какие-либо незаменимые объекты, это может привести к нежелательным результатам.</para>

    <para>Чтобы убедиться, что при обновлении не будет выбран нежелательный путь, воспользуйтесь этой командой: <programlisting>SELECT * FROM pg_extension_update_paths('<replaceable>имя_расширения</replaceable>');</programlisting> Она показывает каждую пару различных известных имён версий для указанного расширения, вместе с последовательностью обновления, которая будет выбрана для перехода от одной версии к другой, либо <literal>NULL</literal>, если путь обновления не находится. Путь выводится в текстовом виде с разделителями <literal>--</literal>. Если вы предпочитаете формат массива, вы можете применить <literal>regexp_split_to_array(path,'--')</literal>.</para>
   </sect2>

   <sect2 id="extend-extensions-example">
    <title>Пример расширения</title>

    <para>Здесь представлен полный пример расширения, в котором средствами исключительно <acronym>SQL</acronym> реализуется составной тип с двумя элементами, который может сохранить в своих слотах значения любого типа, названные <quote>k</quote> и <quote>v</quote>. Для хранения все значения переводятся в текстовый формат (если они имеют другой формат).</para>

    <para>Файл скрипта <filename>pair--1.0.sql</filename> выглядит так: <programlisting><![CDATA[
-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);
]]>
</programlisting></para>

    <para>Управляющий файл <filename>pair.control</filename> выглядит так: <programlisting># pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = true</programlisting></para>

    <para>Хотя вам вряд ли понадобится сборочный файл, только для того, чтобы установить эти два файла в нужный каталог, вы можете использовать <filename>Makefile</filename> следующего содержания: <programlisting>EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</programlisting> Этот Makefile опирается на инфраструктуру <acronym>PGXS</acronym>, которая описывается в <xref remap="6" linkend="extend-pgxs"/>. С ним команда <literal>make install</literal> установит управляющий файл и скрипт в правильный каталог, который определит <application>pg_config</application>.</para>

    <para>Когда эти файлы будут установлены, выполните команду <xref linkend="sql-createextension"/>, чтобы загрузить объекты в определённую базу данных.</para>
   </sect2>
  </sect1>

  <sect1 id="extend-pgxs">
   <title>Инфраструктура сборки расширений</title>

   <indexterm zone="extend-pgxs"><primary>pgxs</primary></indexterm>

   <para>Если вы задумываетесь о распространении ваших модулей расширения <productname>&productname;</productname>, знайте, что организовать для них портируемую систему сборки может быть довольно сложно. Поэтому инсталляция <productname>&productname;</productname> включает инфраструктуру сборки расширений, названную <acronym>PGXS</acronym>, так что несложные модули расширений можно собрать просто в среде установленного сервера. <acronym>PGXS</acronym> предназначена в первую очередь для расширений, написанных на C, хотя её можно применять и для расширения на чистом SQL. Заметьте, что <acronym>PGXS</acronym> не претендует на роль универсальной инфраструктуры сборки, способной собрать любой программный объект, взаимодействующий с <productname>&productname;</productname>; она просто автоматизирует общие правила для сборки простых модулей расширения сервера. Для более сложных пакетов вам придётся разработать собственную систему сборки.</para>

   <para>Чтобы использовать инфраструктуру <acronym>PGXS</acronym> для вашего расширения, вы должны написать простой сборочный файл. В нём вы должны установить нужные переменные и подключить глобальный сборочный файл <acronym>PGXS</acronym>. Следующий пример собирает модуль расширения с именем <literal>isbn_issn</literal>, который включает разделяемую библиотеку, написанную на C, управляющий файл расширения, SQL-скрипт и текстовый файл документации: <programlisting>MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
DOCS = README.isbn_issn

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</programlisting> Последние три строки всегда должны быть такими. Выше в файле вы определяете переменные или добавляете собственные правила для <application>make</application>.</para>

   <para>Установите одну из этих трёх переменных, чтобы указать, что будет собрано: <variablelist>
     <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
       <para>список объектов разделяемых библиотек, которые должны быть собраны из исходных файлов с одной основой (суффиксы библиотек в этом списке не указываются)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
       <para>разделяемая библиотека, которая должна быть собрана из нескольких исходных файлов (объектные файлы перечисляются в <varname>OBJS</varname>)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
       <para>исполняемая программа, которая должна быть собрана (объектные файлы перечисляются в <varname>OBJS</varname>)</para>
      </listitem>
     </varlistentry>
    </variablelist> Также можно установить следующие переменные: <variablelist>
     <varlistentry>
      <term><varname>EXTENSION</varname></term>
      <listitem>
       <para>имена расширений(я); для каждого имени вы должны предоставить файл <literal><replaceable>расширение</replaceable>.control</literal>, который будет установлен в <literal><replaceable>префикс</replaceable>/share/extension</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULEDIR</varname></term>
      <listitem>
       <para>подкаталог в каталоге <literal><replaceable>префикс</replaceable>/share</literal>, в который должны устанавливаться файлы DATA и DOCS (если не задан, подразумевается <literal>extension</literal>, если установлена переменная <varname>EXTENSION</varname>, или <literal>contrib</literal> в противном случае)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
       <para>произвольные файлы, которые должны быть установлены в <literal><replaceable>префикс</replaceable>/share/$MODULEDIR</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
       <para>произвольные файлы, которые должны быть сначала собраны, а затем установлены в <literal><replaceable>префикс</replaceable>/share/$MODULEDIR</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_TSEARCH</varname></term>
      <listitem>
       <para>произвольные файлы, которые должны быть установлены в <literal><replaceable>префикс</replaceable>/share/tsearch_data</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
       <para>произвольные файлы, которые должны быть установлены в <literal><replaceable>префикс</replaceable>/doc/$MODULEDIR</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
       <para>скрипты (не двоичные файлы), которые должны быть установлены в <literal><replaceable>префикс</replaceable>/bin</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
       <para>скрипты (не двоичные файлы), которые должны быть сначала собраны, а затем установлены в <literal><replaceable>префикс</replaceable>/bin</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
       <para>список тестов регрессий (без суффикса), см. ниже</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS_OPTS</varname></term>
      <listitem>
       <para>дополнительные параметры, передаваемые <application>pg_regress</application></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
       <para>дополнительные файлы, которые должны быть удалены при <literal>make clean</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
       <para>флаги, добавляемые в <varname>CPPFLAGS</varname></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
       <para>будет добавлено в строку компоновки <varname>PROGRAM</varname></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
       <para>будет добавлено в строку компоновки <varname>MODULE_big</varname></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CONFIG</varname></term>
      <listitem>
       <para>путь к программе <application>pg_config</application> в инсталляции <productname>&productname;</productname>, с которой будет выполняться сборка (обычно указывается просто <literal>pg_config</literal>, и используется первый экземпляр, найденный по пути в <varname>PATH</varname>)</para>
      </listitem>
     </varlistentry>
    </variablelist></para>

   <para>Поместите этот сборочный файл под именем <literal>Makefile</literal> в каталог, где находится ваше расширение. После этого выполните <literal>make</literal>, чтобы скомпилировать, а затем <literal>make install</literal>, чтобы установить ваш модуль. По умолчанию расширение компилируется и устанавливается для той инсталляции <productname>&productname;</productname>, которая соответствует экземпляру <command>pg_config</command>, найденному первым при поиске по пути в <varname>PATH</varname>. Чтобы использовать другую инсталляцию, вы можете задать в <varname>PG_CONFIG</varname> путь к её экземпляру <command>pg_config</command> либо внутри сборочного файла, либо в командном файле <literal>make</literal>.</para>

   <para>Вы также можете запустить <literal>make</literal> в каталоге вне каталога исходного дерева вашего расширения, если хотите отделить каталог сборки. Эта процедура называется сборкой с <indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm> и выполняется так: <programlisting>mkdir build_dir
cd build_dir
make -f /path/to/extension/source/tree/Makefile
make -f /path/to/extension/source/tree/Makefile install</programlisting></para>

   <para>Также вы можете подготовить каталог для сборки с VPATH таким же образом, как это делается в коде ядра сервера. Как один из вариантов, для этого можно воспользоваться скриптом ядра <filename>config/prep_buildtree</filename>. Затем вы сможете выполнить сборку, установив переменную <varname>VPATH</varname> для <literal>make</literal> таким образом: <programlisting>make VPATH=/path/to/extension/source/tree
make VPATH=/path/to/extension/source/tree install</programlisting> Эта процедура поддерживает самые разные расположения каталогов.</para>

   <para>Скрипты, перечисленные в переменной <varname>REGRESS</varname>, используются для тестирования регрессии в вашем модуле, и вызвать их можно командой <literal>make installcheck</literal> после <literal>make install</literal>. Для проведения тестов необходим работающий сервер <productname>&productname;</productname>. Файлы скриптов, перечисленные в <varname>REGRESS</varname>, должны размещаться в подкаталоге <literal>sql/</literal> каталога расширения. Эти файлы должны иметь расширение <literal>.sql</literal>, но указывать его в списке <varname>REGRESS</varname> в сборочном файле не нужно. Для каждого теста также должен создаваться файл с ожидаемым выводом в подкаталоге <literal>expected/</literal>, с тем же базовым именем и расширением <literal>.out</literal>. Команда <literal>make installcheck</literal> выполнит каждый тест в <application>psql</application> и сравнит полученный вывод с ожидаемым. Все выявленные различия будут записаны в файл <literal>regression.diffs</literal> в формате команды <command>diff -c</command>. Заметьте, что при попытке запустить тест без файла ожидаемого вывода этот тест будет отмечен как <quote>проблемный</quote>, поэтому убедитесь, что все такие файлы присутствуют.</para>

   <tip>
    <para>Проще всего для этого создать пустые файлы ожидаемого вывода, а затем выполнить тест (при этом конечно будут выявлены несоответствия). Изучите полученные файлы результатов, сохранённые в каталоге <literal>results/</literal>, и, если они соответствуют вашим ожиданиям от теста, скопируйте их в <literal>expected/</literal>.</para>

   </tip>
  </sect1>

 </chapter>
