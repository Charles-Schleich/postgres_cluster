<!-- doc/src/xml/user-manag.xml -->

<chapter id="user-manag">
 <title>Роли базы данных</title>

 <para><productname>&productname;</productname> использует концепцию ролей (<firstterm>roles</firstterm>) для управления разрешениями на доступ к базе данных. Роль можно рассматривать как пользователя базы данных или как группу пользователей, в зависимости от того, как роль настроена. Роли могут владеть объектами базы данных (например, таблицами и функциями) и выдавать другим ролям разрешения на доступ к этим объектам, управляя тем, кто имеет доступ и к каким объектам. Кроме того, можно предоставить одной роли <firstterm>членство</firstterm> в другой роли, таким образом одна роль может использовать привилегии других ролей.</para>

 <para>Концепция ролей включает в себя концепцию пользователей (<quote>users</quote>) и групп (<quote>groups</quote>). До версии 8.1 в <productname>PostgreSQL</productname> пользователи и группы были отдельными сущностями, но теперь есть только роли. Любая роль может использоваться в качестве пользователя, группы, и того и другого.</para>

 <para>В этой главе описывается как создавать и управлять ролями. Дополнительную информацию о привилегиях для ролей на различные объекты базы данных можно найти в <xref remap="6" linkend="ddl-priv"/>.</para>

 <sect1 id="database-roles">
  <title>Роли базы данных</title>

  <indexterm zone="database-roles"><primary>роль</primary></indexterm>

  <indexterm zone="database-roles"><primary>пользователь</primary></indexterm>

  <indexterm><primary>CREATE ROLE</primary></indexterm>

  <indexterm><primary>DROP ROLE</primary></indexterm>

  <para>Роли базы данных концептуально полностью отличаются от пользователей операционной системы. На практике поддержание соответствия между ними может быть удобным, но не является обязательным. Роли базы данных являются глобальными для всей установки кластера базы данных (не для отдельной базы данных). Для создания роли используется команда SQL <xref linkend="sql-createrole"/>: <synopsis>
CREATE ROLE <replaceable>имя</replaceable>;
</synopsis> Здесь <replaceable>имя</replaceable> соответствует правилам именования идентификаторов SQL: либо обычное, без специальных символов, либо в двойных кавычках. (На практике, к команде обычно добавляются другие указания, такие как <literal>LOGIN</literal>. Подробнее об этом ниже.) Для удаления роли используется команда <xref linkend="sql-droprole"/>: <synopsis>
DROP ROLE <replaceable>имя</replaceable>;
</synopsis></para>

  <indexterm><primary>createuser</primary></indexterm>

  <indexterm><primary>dropuser</primary></indexterm>

  <para>Для удобства поставляются программы <xref linkend="app-createuser"/> и <xref linkend="app-dropuser"/>, которые являются обёртками для этих команд SQL и вызываются из командной строки оболочки ОС: <synopsis>
createuser <replaceable>имя</replaceable>
dropuser <replaceable>имя</replaceable>
</synopsis></para>

  <para>Для получения списка существующих ролей, рассмотрите <structname>pg_roles</structname> системного каталога, например: <synopsis>
SELECT rolname FROM pg_roles;
</synopsis> Метакоманда <literal>\du</literal> программы <xref linkend="app-psql"/> также полезна для получения списка существующих ролей.</para>

  <para>Для начальной настройки кластера базы данных, система сразу после инициализации всегда содержит одну предопределённую роль. Эта роль является суперпользователем (<quote>superuser</quote>) и по умолчанию (если не изменено при запуске <command>initdb</command>) имеет такое же имя, как и пользователь операционной системы, инициализирующий кластер баз данных. Обычно эта роль называется <literal>postgres</literal>. Для создания других ролей, вначале нужно подключиться с этой ролью.</para>

  <para>Каждое подключение к серверу базы данных выполняется под именем конкретной роли и эта роль определяет начальные привилегии доступа для команд выполняемых в этом соединении. Имя роли для конкретного подключения к базе данных указывается клиентской программой характерным для неё способом, таким образом инициируя запрос на подключение. Например, программа <command>psql</command> для указания роли использует аргумент командной строки <option>-U</option>. Многие приложения предполагают, что по умолчанию нужно использовать имя пользователя операционной системы (включая <command>createuser</command> и <command>psql</command>). Поэтому часто бывает удобным поддерживать соответствие между именами ролей и именами пользователей операционной системы.</para>

  <para>Список доступных для подключения ролей, который могут использовать клиенты, определяется конфигурацией аутентификации, как описывалось в <xref remap="6" linkend="client-authentication"/>. (Поэтому, клиент не ограничен только ролью, соответствующей имени пользователя операционной системы, также как и имя для входа может не соответствовать реальному имени.) Так как роль определяет набор доступных привилегий, очень важно тщательно настраивать привилегии в многопользовательской среде.</para>
 </sect1>

 <sect1 id="role-attributes">
  <title>Атрибуты ролей</title>

   <para>Роль базы данных может иметь атрибуты, определяющие её полномочия и взаимодействие с системой аутентификации клиентов. <variablelist>
     <varlistentry>
      <term>Право подключения<indexterm><primary>право подключения</primary></indexterm></term>
      <listitem>
       <para>Только роли с атрибутом <literal>LOGIN</literal> могут использоваться для начального подключения к базе данных. Роль с атрибутом <literal>LOGIN</literal> можно рассматривать как пользователя базы данных. Для создания роли такой роли можно использовать любой из вариантов: <programlisting>CREATE ROLE <replaceable>имя</replaceable> LOGIN;
CREATE USER <replaceable>имя</replaceable>;</programlisting> (Команда <command>CREATE USER</command> эквивалентна <command>CREATE ROLE</command> за исключением того, что <command>CREATE USER</command> по умолчанию предполагает атрибут <literal>LOGIN</literal>, в то время как <command>CREATE ROLE</command> нет.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Статус суперпользователя<indexterm><primary>суперпользователь</primary></indexterm></term>
      <listitem>
       <para>Суперпользователь базы данных обходит все проверки прав доступа, за исключением права на вход в систему. Это опасная привилегия и она не должна использоваться небрежно. Лучше всего выполнять большую часть работы не как суперпользователь. Для создания нового суперпользователя используется <literal>CREATE ROLE <replaceable>имя</replaceable> SUPERUSER</literal>. Это нужно выполнить из под роли, которая также является суперпользователем.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Создание базы данных<indexterm><primary>баз данных</primary> <secondary>право для создания</secondary></indexterm></term>
      <listitem>
       <para>Роль должна явно иметь разрешение на создание базы данных (за исключением суперпользователей, которые пропускают все проверки). Для создания такой роли используется <literal>CREATE ROLE <replaceable>имя</replaceable> CREATEDB</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Создание роли<indexterm><primary>ролей</primary> <secondary>право для создания</secondary></indexterm></term>
      <listitem>
       <para>Роль должна явно иметь разрешение на создание других ролей (за исключением суперпользователей, которые пропускают все проверки). Для создания такой роли используется <literal>CREATE ROLE <replaceable>имя</replaceable> CREATEROLE</literal>. Роль с привилегией <literal>CREATEROLE</literal> может также изменять и удалять другие роли, а также выдавать и отзывать членство в ролях. Однако, для создания, изменения, удаления суперпользовательских ролей, а также изменения в них членства, требуется иметь статус суперпользователя; привилегии <literal>CREATEROLE</literal> в таких случаях недостаточно.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Запуск репликации<indexterm><primary>роль</primary> <secondary>право для запуска репликации</secondary></indexterm></term>
      <listitem>
       <para>Роль должна иметь явное разрешение на запуск потоковой репликации (за исключением суперпользователей, которые пропускают все проверки). Роль, используемая для потоковой репликации, также должна иметь атрибут <literal>LOGIN</literal>. Для создания такой роли используется <literal>CREATE ROLE <replaceable>имя</replaceable> REPLICATION LOGIN</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Пароль<indexterm><primary>пароль</primary></indexterm></term>
      <listitem>
       <para>Пароль имеет значение, если метод аутентификации клиентов требует, чтобы пользователи предоставляли пароль к базе данных. Пароли используются методами аутентификации <option>password</option>, <option>md5</option> и <option>scram</option>. Заметьте, что пароли базы данных существует отдельно от паролей операционной системы. Задаются пароли при создании роли с помощью команд <literal>CREATE ROLE <replaceable>имя</replaceable> PASSWORD '<replaceable>строка</replaceable>'</literal> или <literal>CREATE ROLE <replaceable>имя</replaceable> PASSWORD ('<replaceable>строка</replaceable>' USING '<replaceable>метод</replaceable>')</literal>.</para>
      </listitem>
     </varlistentry>
    </variablelist> Атрибуты ролей могут быть изменены после создания командой <command>ALTER ROLE</command>.<indexterm><primary>ALTER ROLE</primary></indexterm> Более детальная информация в справке по командам <xref linkend="sql-createrole"/> и <xref linkend="sql-alterrole"/>.</para>

  <tip>
   <para>Рекомендуется создать роль с привилегиями <literal>CREATEDB</literal> и <literal>CREATEROLE</literal>, но не суперпользователя и в последующем использовать её для управления базами данных и ролями. Такой подход позволит избежать опасностей, связанных с использованием полномочий суперпользователя для задач, которые их не требуют.</para>
  </tip>

  <para>На уровне ролей можно устанавливать многие конфигурационные параметры времени выполнения, описанные в <xref remap="6" linkend="runtime-config"/>. Например, если по некоторым причинам всякий раз при подключении к базе данных требуется отключить использование индексов (подсказка: плохая идея) можно выполнить: <programlisting>ALTER ROLE myname SET enable_indexscan TO off;</programlisting> Установленное значение параметра будет сохранено (но не будет применено сразу). Для последующих подключений с этой ролью это будет выглядеть как выполнение команды <literal>SET enable_indexscan TO off</literal> перед началом сессии. Но это только значение по умолчанию, в течение сессии эту установку можно изменить. Для удаления установок на уровне ролей для параметров конфигурации используется <literal>ALTER ROLE <replaceable>rolename</replaceable> RESET <replaceable>varname</replaceable></literal>. Обратите внимание, что установка параметров конфигурации на уровне роли без привилегии <literal>LOGIN</literal> лишено смысла, т. к. они никогда не будут применены,</para>
 </sect1>

 <sect1 id="role-membership">
  <title>Членство в роли</title>

  <indexterm zone="role-membership"><primary>роль</primary> <secondary>членство</secondary></indexterm>

  <para>Часто бывает удобным сгруппировать пользователей для упрощения администрирования привилегий: привилегии выдаются или отзываются на всю группу. В <productname>&productname;</productname> для этого создаётся роль, которая представляет группу, а затем членство (<firstterm>membership</firstterm>) в этой группе выдаётся ролям индивидуальных пользователей.</para>

  <para>Для настройки групповой роли, сначала нужно создать саму роль:<synopsis>
CREATE ROLE <replaceable>имя</replaceable>;
</synopsis> Обычно групповая роль не имеет атрибута <literal>LOGIN</literal>, хотя при желании его можно установить.</para>

  <para>После того как групповая роль создана, в неё можно добавлять или удалять членов, используя команды <xref linkend="sql-grant"/> и <xref linkend="sql-revoke"/>:<synopsis>
GRANT <replaceable>group_role</replaceable> TO <replaceable>role1</replaceable>, ... ;
REVOKE <replaceable>group_role</replaceable> FROM <replaceable>role1</replaceable>, ... ;
</synopsis> Можно выдавать членство в групповой роли другим групповым ролям (потому что в действительности нет никаких различий между групповыми и не групповыми ролями). База данных не позволит замкнуть предоставление членства по кругу. Также, не допускается выдача членства в роли для <literal>PUBLIC</literal>.</para>

  <para>Члены групповой роли могут использовать её привилегии двумя способами. Во-первых, каждый член группы может явно выполнить <xref linkend="sql-set-role"/>, чтобы временно <quote>стать</quote> групповой ролью. В этом состоянии, сессия базы данных использует полномочия групповой роли, вместо оригинальной роли, под которой был выполнен вход в систему. При этом для всех создаваемых объектов базы данных владельцем считается групповая, а не оригинальная роль. Во-вторых, роли, имеющие атрибут <literal>INHERIT</literal>, автоматически используют привилегии всех ролей, членами которых они являются, в том числе и унаследованными этими ролями привилегиями. Например: <programlisting>CREATE ROLE joe LOGIN INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;</programlisting> После подключения с ролью <literal>joe</literal>, сессия базы данных будет использовать полномочия выданные напрямую <literal>joe</literal> и привилегии выданные <literal>admin</literal>, так как <literal>joe</literal> "наследует" привилегии <literal>admin</literal>. Однако привилегии выданные <literal>wheel</literal> не будут доступны, потому что, хотя <literal>joe</literal> неявно и является членом <literal>wheel</literal>, это членство получено через роль <literal>admin</literal>, которая имеет атрибут <literal>NOINHERIT</literal>. После выполнения команды: <programlisting>SET ROLE admin;</programlisting> сессия будет использовать только привилегии выданные <literal>admin</literal>, привилегии выданные <literal>joe</literal> не будут доступны. После выполнения команды: <programlisting>SET ROLE wheel;</programlisting> сессия будет использовать только привилегии выданные <literal>wheel</literal>, привилегии <literal>joe</literal> и <literal>admin</literal> не будут доступны. Начальный набор привилегий можно вернуть любой из команд: <programlisting>SET ROLE joe;
SET ROLE NONE;
RESET ROLE;</programlisting></para>

  <note>
   <para>Команда <command>SET ROLE</command> в любой момент разрешает выбрать любую роль, прямым или косвенным членом которой является оригинальная роль, под которой был выполнен вход в систему. Поэтому, в примере выше, не обязательно сначала становиться <literal>admin</literal>, перед тем как стать <literal>wheel</literal>.</para>
  </note>

  <note>
   <para>В стандарте SQL есть чёткое различие между пользователями и ролями. При этом пользователи не наследуют автоматически привилегии, а роли наследуют автоматически. Такое поведение может быть получено в <productname>&productname;</productname>, если для ролей, используемых как роли в стандарте SQL, устанавливать атрибут <literal>INHERIT</literal>, а для ролей, используемых как пользователи в стандарте SQL, устанавливать атрибут <literal>NOINHERIT</literal>. Однако, в <productname>&productname;</productname> все роли по умолчанию имеют атрибут <literal>INHERIT</literal>. Это сделано для обратной совместимости с версиями предшествующими 8.1, в которых пользователи всегда могли использовать привилегии групп, членами которых они являются.</para>
  </note>

  <para>Атрибуты роли <literal>LOGIN</literal>, <literal>SUPERUSER</literal>, <literal>CREATEDB</literal> и <literal>CREATEROLE</literal> можно рассматривать как особые привилегии, но они никогда не наследуются, как обычные привилегии на объекты базы данных. Необходимо через <command>SET ROLE</command> установить роль, имеющую один из этих атрибутов, чтобы им воспользоваться. Продолжая предыдущий пример, можно установить атрибуты <literal>CREATEDB</literal> и <literal>CREATEROLE</literal> для роли <literal>admin</literal>. Затем при входе с ролью <literal>joe</literal>, получить доступ к этим привилегиям будет возможно только после выполнения <command>SET ROLE admin</command>.</para>

  <para>
  </para>

  <para>Для удаления групповой роли используется <xref linkend="sql-droprole"/>: <synopsis>
DROP ROLE <replaceable>имя</replaceable>;
</synopsis> Любое членство в групповой роли будет автоматически отозвано (в остальном на членов этой роли это никак не повлияет).</para>
 </sect1>

 <sect1 id="role-removal">
  <title>Удаление ролей</title>

  <para>Так как роли могут владеть объектами баз данных и иметь права доступа к объектам других, удаление роли не сводится к немедленному действию <xref linkend="sql-droprole"/>. Сначала должны быть удалены и переданы другим владельцами все объекты, принадлежащие роли; также должны быть отозваны все права, данные роли.</para>

  <para>Владение объектами можно передавать в индивидуальном порядке, применяя команду <command>ALTER</command>, например: <programlisting>ALTER TABLE bobs_table OWNER TO alice;</programlisting> Кроме того, для переназначения какой-либо другой роли владения сразу всеми объектами, принадлежащих удаляемой роли, можно применить команду <xref linkend="sql-reassign-owned"/>. Так как <command>REASSIGN OWNED</command> не может обращаться к объектам в других базах данных, её необходимо выполнить в каждой базе, которая содержит объекты, принадлежащие этой роли. (Заметьте, что первая такая команда <command>REASSIGN OWNED</command> изменит владельца для всех разделяемых между базами объектов, то есть для баз данных или табличных пространств, принадлежащих удаляемой роли.)</para>

  <para>После того, как все ценные объекты будут переданы новым владельцам, все оставшиеся объекты, принадлежащие удаляемой роли, могут быть удалены с помощью команды <xref linkend="sql-drop-owned"/>. И эта команда не может обращаться к объектам в других базах данных, так что её нужно запускать в каждой базе, которая содержит объекты, принадлежащие роли. Также заметьте, что <command>DROP OWNED</command> не удаляет табличные пространства или базы данных целиком, так что это необходимо сделать вручную, если роли принадлежат базы или табличные пространства, не переданные новым владельцам.</para>

  <para><command>DROP OWNED</command> также удаляет все права, которые даны целевой роли для объектов, не принадлежащих ей. Так как <command>REASSIGN OWNED</command> такие объекты не затрагивает, обычно необходимо запустить и <command>REASSIGN OWNED</command>, и <command>DROP OWNED</command> (в этом порядке!), чтобы полностью ликвидировать зависимости удаляемой роли.</para>

  <para>С учётом этого, общий рецепт удаления роли, которая владела объектами, вкратце таков:</para>
<programlisting>REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
-- повторить предыдущие команды для каждой базы в кластере
DROP ROLE doomed_role;</programlisting>

  <para>Когда не все объекты нужно передать одному новому владельцу, лучше сначала вручную отработать исключения, а в завершение выполнить показанные выше действия.</para>

  <para>При попытке выполнить <command>DROP ROLE</command> для роли, у которой сохраняются зависимые объекты, будут выданы сообщения, говорящие, какие объекты нужно передать другому владельцу или удалить.</para>
 </sect1>

 <sect1 id="default-roles">
  <title>Предопределённые роли</title>

  <indexterm zone="default-roles"><primary>роль</primary></indexterm>

  <para>В <productname>&productname;</productname> имеется набор предопределённых ролей, которые дают доступ к некоторым часто востребованным, но не общедоступным функциям и данным. Администраторы могут назначать (GRANT) эти роли пользователям и/или ролям в своей среде, таким образом открывая этим пользователям доступ к указанной функциональности и информации.</para>

  <para>Имеющиеся предопределённые роли описаны в <xref remap="6" linkend="default-roles-table"/>. Заметьте, что конкретные разрешения для каждой из предопределённых ролей в будущем могут изменяться по мере добавления дополнительной функциональности. Администраторы должны следить за этими изменениями, просматривая замечания к выпускам.</para>

   <table tocentry="1" id="default-roles-table">
    <title>Предопределённые роли</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Роль</entry>
       <entry>Разрешаемый доступ</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>pg_signal_backend</entry>
       <entry>Передавать сигналы другим обслуживающим процессам (например, отменять запрос, завершать процесс).</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Администраторы могут давать пользователям доступ к этим ролям, используя команду GRANT: <programlisting>GRANT pg_signal_backend TO admin_user;</programlisting></para>

 </sect1>

 <sect1 id="perm-functions">
  <title>Безопасность функций и триггеров</title>

  <para>Функции и триггеры дают возможность пользователям добавить на сервер программный код, который другие пользователи могут непреднамеренно выполнить. Таким образом, оба механизма позволяют относительно легко атаковать других пользователей, внедряя <quote>троянских коней</quote>. Единственной реальной защитой может быть жёсткое ограничение круга лиц, имеющих право создавать функции.</para>

  <para>Функции выполняются внутри серверного процесса с полномочиями пользователя операционной системы, запускающего сервер базы данных. Если используемый для функций язык программирования разрешает неконтролируемый доступ к памяти, то это даёт возможность изменить внутренние структуры данных сервера. Таким образом, помимо всего прочего, такие функции могут обойти ограничения доступа к системе. Языки программирования, допускающие такой доступ, считаются <quote>недоверенными</quote> и создавать функции на этих языках <productname>&productname;</productname> разрешает только суперпользователям.</para>
 </sect1>

</chapter>
