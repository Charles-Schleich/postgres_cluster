<!-- doc/src/xml/replication-origins.xml -->
<chapter id="replication-origins">
 <title>Отслеживание прогресса репликации</title>

 <indexterm zone="replication-origins"><primary>Отслеживание прогресса репликации</primary></indexterm>
 <indexterm zone="replication-origins"><primary>Источники репликации</primary></indexterm>

 <para>Инфраструктура источников репликации введена для упрощения реализации решений логической репликации на основе <link linkend="logicaldecoding">логического декодирования</link>. Она помогает решить две распространённых проблемы: <itemizedlist>
   <listitem>
    <para>Как надёжно отслеживать прогресс репликации</para>
   </listitem>
   <listitem>
    <para>Как менять поведение репликации в зависимости от источника строки; например, для предотвращения циклов при двунаправленной репликации</para>
   </listitem>
  </itemizedlist></para>

 <para>Источники репликации имеют только два свойства: имя и OID. Имя, по которому к источнику следует обращаться из разных систем, задаётся значением типа <type>text</type> в произвольной форме. Его следует выбирать так, чтобы конфликты между источниками репликации, созданными различными средствами репликации были маловероятны; например, добавлять в начало обозначение средства репликации. OID используется только для того, чтобы не приходилось хранить длинное имя там, где требуется минимизировать объём. Он не может разделяться между разными системами.</para>

 <para>Источник репликации можно создать функцией <link linkend="pg-replication-origin-create"><function>pg_replication_origin_create()</function></link>; удалить функцией <link linkend="pg-replication-origin-drop"><function>pg_replication_origin_drop()</function></link>; и увидеть в системном каталоге <link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link>.</para>

 <para>Одной из нетривиальных задач при организации репликации является надёжное отслеживание прогресса воспроизведения. Например, когда применяющий изменения процесс (или весь кластер) умирает, нужно иметь возможность понять, какие данные были переданы успешно. Наивные решения этой проблемы, такие как изменение строки в некоторой таблице для каждой воспроизведённой транзакции, чреваты дополнительной нагрузкой во время выполнения и замусориванием базы данных.</para>

 <para>С использованием инфраструктуры источников репликации сеанс может быть помечен как воспроизводящий изменения с удалённого узла (с помощью функции <link linkend="pg-replication-origin-session-setup"><function>pg_replication_origin_session_setup()</function></link>). В дополнение к этому для каждой транзакции из источника можно задать <acronym>LSN</acronym> и время фиксации, вызвав <link linkend="pg-replication-origin-xact-setup"><function>pg_replication_origin_xact_setup()</function></link>. Если сделать всё это, прогресс репликации можно будет отслеживать надёжным образом. Прогресс воспроизведения для всех источников репликации можно увидеть в представлении <link linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link>. Прогресс отдельного источника, например, при возобновлении репликации, можно получить для любого источника, воспользовавшись функцией <link linkend="pg-replication-origin-progress"><function>pg_replication_origin_progress()</function></link>, или для источника, настроенного в текущем сеансе, с помощью <link linkend="pg-replication-origin-session-progress"><function>pg_replication_origin_session_progress()</function></link>.</para>

 <para>В топологиях репликации более сложных, чем простая репликация с одной системы в другую, возможна ещё одна проблема — повторная репликация уже воспроизведённых строк, что может приводить к зацикливанию и снижению эффективности. В качестве механизма выявления и предотвращения повторной репликации так же могут оказаться полезны источники репликации. Если воспользоваться функциями, упомянутыми в предыдущем абзаце, во все поступающие в сеансе транзакции и изменения, передаваемые обработчикам модулей вывода (см. <xref remap="4" linkend="logicaldecoding-output-plugin"/>), добавляется пометка источника репликации для текущего сеанса. Это позволяет обрабатывать их в модуле вывода по-разному, например, игнорировать все строки, кроме имеющих локальное происхождение. Кроме того, обработчик вызова <link linkend="logicaldecoding-output-plugin-filter-origin"><function>filter_by_origin_cb</function></link> позволяет отфильтровать поток изменений логического декодирования в зависимости от источника. Фильтрация через этот обработчик не так гибка, как проверка записей внутри модуля вывода, но зато гораздо эффективнее.</para>
</chapter>
