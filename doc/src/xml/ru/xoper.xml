<!-- doc/src/xml/xoper.xml -->

 <sect1 id="xoper">
  <title>Пользовательские операторы</title>

  <indexterm zone="xoper"><primary>оператор</primary> <secondary>пользовательский</secondary></indexterm>

  <para>Любой оператор представляет собой <quote>синтаксический сахар</quote> для вызова нижележащей функции, выполняющей реальную работу; поэтому прежде чем вы сможете создать оператор, необходимо создать нижележащую функцию. Однако оператор — <emphasis>не исключительно</emphasis> синтаксический сахар, так как он несёт и дополнительную информацию, помогающую планировщику запросов оптимизировать запросы с этим оператором. Рассмотрению этой дополнительной информации будет посвящён следующий раздел.</para>

  <para><productname>&productname;</productname> поддерживает левые унарные, правые унарные и бинарные операторы. Операторы могут быть перегружены;<indexterm><primary>перегрузка</primary> <secondary>операторов</secondary></indexterm> то есть одно имя оператора могут иметь различные операторы с разным количеством и типами операндов. Когда выполняется запрос, система определяет, какой оператор вызвать, по количеству и типам предоставленных операндов.</para>

  <para>В следующем примере создаётся оператор сложения двух комплексных чисел. Предполагается, что мы уже создали определение типа <type>complex</type> (см. <xref remap="4" linkend="xtypes"/>). Сначала нам нужна функция, собственно выполняющая операцию, а затем мы сможем определить оператор: <programlisting>CREATE FUNCTION complex_add(complex, complex)
    RETURNS complex
    AS '<replaceable>имя_файла</replaceable>', 'complex_add'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR + (
    leftarg = complex,
    rightarg = complex,
    procedure = complex_add,
    commutator = +
);</programlisting></para>

  <para>Теперь мы можем выполнить такой запрос: <screen>
SELECT (a + b) AS c FROM test_complex;

        c
-----------------
 (5.2,6.05)
 (133.42,144.95)
</screen></para>

  <para>Мы продемонстрировали создание бинарного оператора. Чтобы создать унарный оператор, просто опустите <literal>leftarg</literal> (для левого унарного) или <literal>rightarg</literal> (для правого унарного). Обязательными в <command>CREATE OPERATOR</command> являются только предложение <literal>procedure</literal> и объявления аргументов. Предложение <literal>commutator</literal>, добавленное в данном примере, представляет необязательную подсказку для оптимизатора запросов. Подробнее о <literal>commutator</literal> и других подсказках для оптимизатора рассказывается в следующем разделе.</para>
 </sect1>

  <sect1 id="xoper-optimization">
   <title>Информация для оптимизации операторов</title>

   <para>Определение оператора в <productname>&productname;</productname> может включать различные дополнительные предложения, которые сообщают системе полезные сведения о поведении оператора. Старайтесь задавать эти предложения при возможности, так как они могут значительно ускорить выполнение запросов, использующих данный оператор. Но если вы задаёте их, убедитесь, что они корректны! Неправильное применение предложений оптимизации может привести к замедлению запросов, неочевидным ошибочным результатам и другим неприятностям. Если вы не уверены в правильности предложения оптимизации, лучше вовсе не использовать его; единственным последствием будет то, что запросы будут работать медленнее, чем могли бы.</para>

   <para>В будущих версиях <productname>&productname;</productname> могут быть добавлены и другие предложения. Здесь описываются те, что поддерживаются версией &version;.</para>

   <sect2>
    <title><literal>COMMUTATOR</literal></title>

    <para>Предложение <literal>COMMUTATOR</literal>, если представлено, задаёт оператор, коммутирующий для определяемого. Оператор A является коммутирующим для оператора B, если (x A y) равняется (y B x) для всех возможных значений x, y. Заметьте, что B также будет коммутирующим для A. Например, операторы <literal>&lt;</literal> и <literal>&gt;</literal> для конкретного типа данных обычно являются коммутирующими друг для друга, а оператор <literal>+</literal> — коммутирующий для себя. Но традиционный оператор <literal>-</literal> коммутирующего не имеет.</para>

    <para>Тип левого операнда оператора должен совпадать с типом правого операнда коммутирующего для него оператора, и наоборот. Поэтому имя коммутирующего оператора — это всё, что <productname>&productname;</productname> должен знать, чтобы найти коммутатор, и всё, что нужно указать в предложении <literal>COMMUTATOR</literal>.</para>

    <para>Информация о коммутирующих операторах крайне важна для операторов, которые будут применяться в индексах и условиях соединения, так как, используя её, оптимизатор запросов может <quote>переворачивать</quote> такие выражения и получать формы, необходимые для разных типов планов. Например, рассмотрим запрос с предложением WHERE <literal>tab1.x = tab2.y</literal>, где <literal>tab1.x</literal> и <literal>tab2.y</literal> имеют пользовательский тип, и предположим, что у нас есть индекс по столбцу <literal>tab2.y</literal>. Оптимизатор сможет задействовать сканирование по индексу, только если ему удастся перевернуть выражение <literal>tab2.y = tab1.x</literal>, так как механизм сканирования по индексу ожидает, что индексируемый столбец находится слева от оператора. <productname>&productname;</productname> сам по себе <emphasis>не</emphasis> будет полагать, что такое преобразование возможно &mdash; это должен определить создатель оператора <literal>=</literal>, добавив информацию о коммутирующем операторе.</para>

    <para>Когда вы определяете оператор, коммутирующий сам для себя, вы делаете именно это. Если же вы определяете пару коммутирующих операторов, возникает небольшое затруднение: как оператор, определяемый первым, может ссылаться на другой, ещё не определённый? Есть два решения этой проблемы: <itemizedlist>
      <listitem>
       <para>Во-первых, можно опустить предложение <literal>COMMUTATOR</literal> для первого оператора, который вы определяете, а затем добавить его в определении второго. Так как <productname>&productname;</productname> знает, что коммутирующие операторы связаны парами, встречая второе определение, он автоматически возвращается к первому и добавляет в него недостающее предложение <literal>COMMUTATOR</literal>.</para>
      </listitem>

      <listitem>
       <para>Во-вторых, можно добавить предложение <literal>COMMUTATOR</literal> в оба определения. Когда <productname>&productname;</productname> обрабатывает первое определение и видит, что <literal>COMMUTATOR</literal> ссылается на несуществующий оператор, в системном каталоге создаётся фиктивная запись для этого оператора. В этой фиктивной записи актуальны будут только имя оператора, типы левого и правого операндов, а также тип результата, так как это всё, что <productname>&productname;</productname> может определить в этот момент. Запись первого оператора будет связана с этой фиктивной записью. Затем, когда вы определите второй оператор, система внесёт в эту фиктивную запись дополнительную информацию из второго определения. Если вы попытаетесь применить фиктивный оператор, прежде чем он будет полностью определён, вы просто получите сообщение об ошибке.</para>
      </listitem>
     </itemizedlist></para>
   </sect2>

   <sect2>
    <title><literal>NEGATOR</literal></title>

    <para>Предложение <literal>NEGATOR</literal>, если присутствует, задаёт оператор, обратный к определяемому. Оператор A является обратным к оператору B, если они оба возвращают булевский результат и (x A y) равняется NOT (x B y) для всех возможных x, y. Заметьте, что B так же является обратным к A. Например, операторы <literal>&lt;</literal> и <literal>&gt;=</literal> составляют пару обратных друг к другу для большинства типов данных. Никакой оператор не может быть обратным к себе же.</para>

   <para>В отличие от коммутирующих операторов, два унарных оператора вполне могут быть обратными к друг другу; это будет означать, что (A x) равняется NOT (B x) для всех x (и для правых унарных операторов аналогично).</para>

   <para>У оператора, обратного данному, типы левого и/или правого операнда должны соответствовать типам данного оператора, так же как и с предложением <literal>COMMUTATOR</literal>; отличие только в том, что имя оператора задаётся в предложении <literal>NEGATOR</literal>.</para>

   <para>Указание обратного оператора очень полезно для оптимизатора запросов, так как это позволяет упростить выражение вида <literal>NOT (x = y)</literal> до <literal>x &lt;&gt; y</literal>. Такие выражения не так редки, как может показаться, так как операции <literal>NOT</literal> могут добавляться автоматически в результате реорганизаций выражений.</para>

   <para>Пару обратных операторов можно определить теми же способами, что были описаны ранее для пары коммутирующих.</para>

  </sect2>

  <sect2>
   <title><literal>RESTRICT</literal></title>

   <para>Предложение <literal>RESTRICT</literal>, если представлено, определяет функцию оценки избирательности ограничения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения <literal>RESTRICT</literal> имеют смысл только для бинарных операторов, возвращающих <type>boolean</type>. Идея оценки избирательности ограничения заключается в том, чтобы определить, какой процент строк в таблице будет удовлетворять условию <literal>WHERE</literal> вида: <programlisting>column OP constant</programlisting> для текущего оператора и определённого значения константы. Это помогает оптимизатору примерно определить, сколько строк будет исключено предложениями <literal>WHERE</literal> такого вида. (ВЫ спросите, а что если константа находится слева? Ну, собственно для таких случаев и задаётся <literal>COMMUTATOR</literal>...)</para>

   <para>Разработка новых функций оценки избирательности ограничения выходит за рамки данной главы, но обычно можно использовать один из стандартных системных оценщиков для большинства дополнительных операторов. Стандартные оценщики ограничений следующие: <simplelist>
     <member><function>eqsel</function> для <literal>=</literal></member>
     <member><function>neqsel</function> для <literal>&lt;&gt;</literal></member>
     <member><function>scalarltsel</function> для <literal>&lt;</literal> или <literal>&lt;=</literal></member>
     <member><function>scalargtsel</function> для <literal>&gt;</literal> или <literal>&gt;=</literal></member>
   </simplelist> Может показаться немного странным, что выбраны именно эти категории, но если подумать, это имеет смысл. Оператор <literal>=</literal> обычно оставляет только небольшой процент строк в таблице, а <literal>&lt;&gt;</literal> отбрасывает то же количество. Оператор <literal>&lt;</literal> оставляет процент, зависящий от того, в какой диапазон значений определённого столбца таблицы попадает заданная константа (информация об этих диапазонах собирается командой <command>ANALYZE</command> и предоставляется оценщику избирательности). Оператор <literal>&lt;=</literal> оставляет чуть больший процент, чем <literal>&lt;</literal>, при сравнении с той же константой, но они настолько близки, что различать их не имеет смысла, так как это не даст лучшего результата, чем просто угадывание. Подобные замечания применимы и к операторам <literal>&gt;</literal> и <literal>&gt;=</literal>.</para>

   <para>Часто вы можете обойтись функциями <function>eqsel</function> и <function>neqsel</function> для операторов с очень высокой или низкой избирательностью, даже если это не операторы собственно равенства или неравенства. Например, геометрические операторы приблизительного равенства используют <function>eqsel</function> в предположении, что соответствующие (равные) элементы будут составлять только небольшой процент от всех записей таблицы.</para>

   <para>Функции <function>scalarltsel</function> и <function>scalargtsel</function> можно использовать для сравнений с типами данных, которые могут быть каким-либо осмысленным образом преобразованы в числовые скалярные значения для сравнения диапазонов. Если возможно, добавьте свой тип данных в число тех, что понимает функция <function>convert_to_scalar()</function> в <filename>src/backend/utils/adt/selfuncs.c</filename>. (Когда-нибудь эта функция должна быть заменена специализированными функциями, которые будут устанавливаться для конкретных типов в определённом столбце системного каталога <classname>pg_type</classname>; но сейчас это не так.) Если вы этого не сделаете, всё будет работать, но оценки оптимизатора будут не так хороши, как могли бы быть.</para>

   <para>Для геометрических операторов разработаны дополнительные функции оценки избирательности в <filename>src/backend/utils/adt/geo_selfuncs.c</filename>: <function>areasel</function>, <function>positionsel</function> и <function>contsel</function>. На момент написания документации это просто заглушки, но вы, тем не менее, вполне можете использовать (или ещё лучше, доработать) их.</para>
   </sect2>

   <sect2>
    <title><literal>JOIN</literal></title>

    <para>Предложение <literal>JOIN</literal>, если представлено, определяет функцию оценки избирательности соединения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения <literal>JOIN</literal> имеют смысл только для бинарных операторов, возвращающих <type>boolean</type>. Идея оценки избирательности соединения заключается в том, чтобы угадать, какой процент строк в паре таблиц будет удовлетворять условию <literal>WHERE</literal> следующего вида: <programlisting>table1.column1 OP table2.column2</programlisting> для текущего оператора. Как и <literal>RESTRICT</literal>, это предложение очень помогает оптимизатору, позволяя ему выяснить, какой из возможных вариантов соединения скорее всего окажется выгоднее.</para>

    <para>Как и ранее, в этой главе мы не будем пытаться рассказать, как написать функцию оценивания избирательности соединения, а просто отметим, что вы можете использовать один из подходящих стандартных оценщиков: <simplelist>
      <member><function>eqjoinsel</function> для <literal>=</literal></member>
      <member><function>neqjoinsel</function> для <literal>&lt;&gt;</literal></member>
      <member><function>scalarltjoinsel</function> для <literal>&lt;</literal> или <literal>&lt;=</literal></member>
      <member><function>scalargtjoinsel</function> для <literal>&gt;</literal> или <literal>&gt;=</literal></member>
      <member><function>areajoinsel</function> для сравнений областей в плоскости</member>
      <member><function>positionjoinsel</function> для сравнения положений в плоскости</member>
      <member><function>contjoinsel</function> для проверки на включение в плоскости</member>
     </simplelist></para>
   </sect2>

   <sect2>
    <title><literal>HASHES</literal></title>

    <para>Предложение <literal>HASHES</literal>, если присутствует, говорит системе, что для соединений с применением этого оператора допустимо использовать метод соединения по хешу. <literal>HASHES</literal> имеет смысл только для бинарного оператора, который возвращает <literal>boolean</literal>, и на практике этот оператор должен выражать равенство значений некоторого типа данных или пары типов данных.</para>

    <para>Соединение по хешу базируется на том предположении, что оператор соединения возвращает истину только для таких пар значений слева и справа, для которых получается одинаковый хеш. Если два значения оказываются в разных ячейках хеша, операция соединения никогда не будет сравнивать их, неявно подразумевая, что результат оператора соединения в этом случае должен быть ложным. Поэтому не имеет никакого смысла указывать <literal>HASHES</literal> для операторов, которые не представляют какую-любо форму равенства. В большинстве случаев практический смысл в поддержке хеширования есть только для операторов, принимающих один тип данных с обеих сторон. Однако иногда возможно разработать хеш-функции, совместимые сразу с несколькими типами данных; то есть, функции, которые будут выдавать одинаковые хеш-коды для <quote>равных</quote> значений, несмотря на то, что эти значения будут представлены по-разному. Например, довольно легко функции с такой особенностью реализуются для хеширования целых чисел различного размера.</para>

    <para>Чтобы оператор соединения имел характеристику <literal>HASHES</literal>, он должен входить в семейство операторов индексирования по хешу. Это требование откладывается, когда оператор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать. Но при попытке использовать такой оператор для соединения по хешу, возникнет ошибка во время выполнения, если такого семейства не окажется. Системе необходимо знать семейство операторов, чтобы найти функции для хеширования типа(ов) входных данных оператора. Конечно, вы должны также определить подходящие функции хеширования, прежде чем сможете создать семейство операторов.</para>

    <para>При подготовке функции хеширования обязательно позаботьтесь о том, чтобы она всегда выдавала нужный результат, вне зависимости от особенностей машинной архитектуры. Например, если ваш тип данных представлен в структуре, в которой есть незначащие дополняющие биты, нельзя просто передать всю структуру функции <function>hash_any</function>. (Это возможно, только если все ваши операторы и функции гарантированно очищают незначащие биты, что является рекомендуемой стратегией.) В качестве другого примера можно привести типы с плавающей точкой в стандарте <acronym>IEEE</acronym>, в которых отрицательный ноль и положительный ноль — различные значения (отличаются на уровне битов), но при сравнении они считаются равными. Если значение с плавающей точкой может содержать отрицательный ноль, требуются дополнительные действия, чтобы для него выдавался тот же хеш, что и для положительного нуля.</para>

    <para>Оператор соединения по хешу должен иметь коммутирующий (это может быть тот же оператор, если у него два операнда одного типа, либо связанный оператор равенства, в противном случае), относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использования оператора возможны ошибки планировщика. Также желательно (хотя это строго не требуется), чтобы в семействе операторов хеширования, поддерживающем несколько типов данных, определялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оптимизации.</para>

    <note>
    <para>Функция, реализующая оператор соединения по хешу, должна быть постоянной (IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), система никогда не будет применять этот оператор для соединения по хешу.</para>
    </note>

    <note>
    <para>Если оператор соединения по хешу реализуется строгой функцией (STRICT), эта функция также должна быть полной: то есть она должна возвращать true или false, но не NULL, для любых двух аргументов, отличных от NULL. Если это правило не соблюдается, оптимизация операций <literal>IN</literal> с хешем может приводить к неверным результатам. (В частности, выражение <literal>IN</literal> может вернуть false, когда правильным ответом, согласно стандарту, должен быть NULL, либо выдать ошибку с сообщением о том, что оно не готов к результату NULL.)</para>
    </note>

   </sect2>

   <sect2>
    <title><literal>MERGES</literal></title>

    <para>Предложение <literal>MERGES</literal>, если присутствует, говорит системе, что для соединений с применением этого оператора допустимо использовать метод соединения слиянием. <literal>MERGES</literal> имеет смысл только для бинарного оператора, который возвращает <literal>boolean</literal>, и на практике этот оператор должен выражать равенство значений некоторого типа данных или пары типов данных.</para>

    <para>Идея объединения слиянием заключается в упорядочивании таблиц слева и справа и затем параллельном сканировании их. Поэтому оба типа данных должны поддерживать сортировку в полном объёме, а оператор соединения должен давать положительный результат только для пар значений, оказавшихся в <quote>одном месте</quote> при определённом порядке сортировки. На практике это означает, что оператор соединения должен работать как проверка на равенство. Но при этом возможно объединить слиянием два различных типа данных, если они совместимы логически. Например, оператор проверки равенства <type>smallint</type> и <type>integer</type> может применяться для соединений слиянием; понадобятся только операторы сортировки, приводящие оба типа данных в логически совместимые последовательности.</para>

    <para>Чтобы оператор соединения имел характеристику <literal>MERGES</literal>, он должен являться членом семейства операторов индекса <literal>btree</literal>, реализующим равенство. Это требование откладывается, когда оператор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать. Но этот оператор не будет фактически применяться для соединений слиянием, пока не будет найдено соответствующее семейство операторов. Таким образом, флаг <literal>MERGES</literal> только подсказывает планировщику, что стоит обратиться к соответствующему семейству.</para>

    <para>Оператор соединения слиянием должен иметь коммутирующий (это может быть тот же оператор, если у него два операнда одного типа, либо связанный оператор равенства, в противном случае), относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использования оператора возможны ошибки планировщика. Также желательно (хотя это строго не требуется), чтобы в семействе операторов <literal>btree</literal>, поддерживающем несколько типов данных, определялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оптимизации.</para>

    <note>
    <para>Функция, реализующая оператор соединения слиянием, должна быть постоянной (IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), система никогда не будет применять этот оператор для соединения слиянием.</para>
    </note>
   </sect2>
  </sect1>
