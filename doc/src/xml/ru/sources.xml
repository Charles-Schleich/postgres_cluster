<!-- doc/src/xml/sources.xml -->

 <chapter id="source">
  <title>Соглашения по оформлению кода &productname;</title>

  <sect1 id="source-format">
   <title>Форматирование</title>

   <para>Исходный код форматируется с отступом на 4 позиции, с сохранением табуляции (т. е. символы табуляции не разворачиваются в пробелы). Для каждого логического уровня отступа добавляется одна табуляция.</para>

   <para>Правила оформления (расположения скобок и т. д.) следуют соглашениям BSD. В частности, фигурные скобки для управляемых ими блоков <literal>if</literal>, <literal>while</literal>, <literal>switch</literal> и т. д. размещаются в отдельных строках.</para>

   <para>Ограничьте размеры строк, чтобы код можно было читать в окне шириной 80 символов. (Это не значит, что никогда нельзя заходить за 80 символов. Например, не стоит разбивать длинную строку сообщения в произвольных местах, просто чтобы код умещался в 80 символов, так как это в результате скорее всего не сделает код более читабельным.)</para>

   <para>Не используйте комментарии в стиле C++ (комментарии <literal>//</literal>). Строгие компиляторы ANSI C их не принимают. По этой же причине не используйте расширения C++, например, не объявляйте новые переменные в середине блока.</para>

   <para>Предпочитаемый стиль многострочных блоков выглядит так: <programlisting>/*
 * текст комментария начинается здесь
 * и продолжается здесь
 */</programlisting> Заметьте, что блоки комментариев, начинающиеся с первого символа, будут сохраняться утилитой <application>pgindent</application> как есть, но содержимое блоков комментариев с отступами будет переразбито по строкам как обычный текст. Если вы хотите сохранить разрывы строк в блоке с отступом, добавьте минусы следующим образом: <programlisting>    /*----------
     * текст комментария начинается здесь
     * и продолжается здесь
     *----------
     */</programlisting></para>

   <para>Хотя предлагаемые правки кода не обязательно должны следовать этим правилам форматирования, лучше их придерживаться. Ваш код будет пропущен через <application>pgindent</application> перед следующим выпуском, поэтому нет смысла наводить в нём красоту по другим правилам. Для правок есть хорошее правило: <quote>оформляйте новый код так же, как выглядит существующий код вокруг</quote>.</para>

   <para>В каталоге <filename>src/tools</filename> содержатся примеры файлов настройки, которые можно использовать с редакторами <productname>emacs</productname>, <productname>xemacs</productname> или <productname>vim</productname> для упрощения задачи форматирования кода в соответствии с описанными соглашениями.</para>

   <para>Чтобы табуляция показывалась должным образом в средствах просмотра текста <application>more</application> и <application>less</application>, их можно вызвать так: <programlisting>more -x4
less -x4</programlisting></para>
  </sect1>

  <sect1 id="error-message-reporting">
   <title>Вывод сообщений об ошибках в коде сервера</title>

   <indexterm><primary>ereport</primary></indexterm>
   <indexterm><primary>elog</primary></indexterm>

   <para>Сообщения об ошибках, предупреждения и обычные сообщения, выдаваемые в коде сервера должны создаваться функцией <function>ereport</function> или родственной её предшественницей <function>elog</function>. Использование этой функции достаточно сложно и требует дополнительного объяснения.</para>

   <para>У каждого сообщения есть два обязательных элемента: уровень важности (от <literal>DEBUG</literal> до <literal>PANIC</literal>) и основной текст сообщения. В дополнение к ним есть необязательные элементы, из которых часто используется код идентификатора ошибки, соответствующий определению SQLSTATE в спецификации SQL. Функция <function>ereport</function> сама по себе является просто оболочкой, которая существует в основном для синтаксического удобства, чтобы выдача сообщения выглядела как вызов функции в коде C. Единственный параметр, который принимает непосредственно функция <function>ereport</function>, это уровень важности. Основной текст и любые дополнительные элементы сообщения генерируются в результате вызова вспомогательных функций, таких как <function>errmsg</function>, в вызове <function>ereport</function>.</para>

   <para>Типичный вызов <function>ereport</function> выглядит примерно так: <programlisting>ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));</programlisting> В нём задаётся уровень важности <literal>ERROR</literal> (заурядная ошибка). В вызове <function>errcode</function> указывается код ошибки SQLSTATE по макросу, определённому в <filename>src/include/utils/errcodes.h</filename>. Вызов <function>errmsg</function> даёт текст основного сообщения. Обратите внимание на дополнительный набор скобок, окружающих вызовы вспомогательных функций &mdash; они загромождают код, но требуются синтаксисом.</para>

   <para>Более сложный пример: <programlisting>ereport(ERROR,
        (errcode(ERRCODE_AMBIGUOUS_FUNCTION),
         errmsg("function %s is not unique",
                func_signature_string(funcname, nargs,
                                      NIL, actual_arg_types)),
         errhint("Unable to choose a best candidate function. "
                 "You might need to add explicit typecasts.")));</programlisting> В нём демонстрируется использование кодов форматирования для включения значений времени выполнения в текст сообщения. Также в нём добавляется дополнительное сообщение <quote>подсказки</quote>.</para>

   <para>При уровне важности <literal>ERROR</literal> или более высоком, <function>ereport</function> прерывает выполнение пользовательской функции и не возвращает управление в вызывающий код. Если уровень важности ниже <literal>ERROR</literal>, <function>ereport</function> завершается обычным способом.</para>

   <para>Для <function>ereport</function> предлагаются следующие вспомогательные функции: <itemizedlist>
   <listitem>
    <para><function>errcode(sqlerrcode)</function> задаёт код идентификатора ошибки SQLSTATE для данной ошибки. Если эта функция не вызывается, подразумевается идентификатор ошибки <literal>ERRCODE_INTERNAL_ERROR</literal> при уровне важности <literal>ERROR</literal> или выше, либо <literal>ERRCODE_WARNING</literal> при уровне важности <literal>WARNING</literal>, иначе (при уровне <literal>NOTICE</literal> или ниже) — <literal>ERRCODE_SUCCESSFUL_COMPLETION</literal>. Хотя эти значения по умолчанию довольно разумны, всегда стоит подумать, насколько они уместны, прежде чем опустить вызов <function>errcode()</function>.</para>
   </listitem>
   <listitem>
    <para><function>errmsg(const char *msg, ...)</function> задаёт основной текст сообщения об ошибке и, возможно, значения времени выполнения, которые будут в него включаться. Эти включения записываются кодами формата в стиле <function>sprintf</function>. В дополнение к стандартным кодам формата, принимаемым функцией <function>sprintf</function>, можно использовать код формата <literal>%m</literal>, который вставит сообщение об ошибке, возвращённое строкой <function>strerror</function> для текущего значения <literal>errno</literal>. <footnote>
      <para>То есть значение, которое было текущим, когда была вызвана <function>ereport</function>; изменения <literal>errno</literal> во вспомогательных функциях выдачи сообщений на него не повлияют. Это будет не так, если вы запишете <literal>strerror(errno)</literal> явно в списке параметров <function>errmsg</function>; поэтому делать так не нужно.</para>
     </footnote> Для <literal>%m</literal> не требуется соответствующая запись в списке параметров <function>errmsg</function>. Заметьте, что эта строка будет пропущена через <function>gettext</function>, то есть может быть локализована, до обработки кодов формата.</para>
   </listitem>
   <listitem>
    <para><function>errmsg_internal(const char *msg, ...)</function> действует как <function>errmsg</function>, но её строка сообщения не будет переводиться и включаться в словарь сообщений для интернационализации. Это следует использовать для случаев, которые <quote>не происходят никогда</quote>, так что тратить силы на их перевод не стоит.</para>
   </listitem>
   <listitem>
    <para><function>errmsg_plural(const char *fmt_singular, const char *fmt_plural, unsigned long n, ...)</function> действует подобно <function>errmsg</function>, но поддерживает различные формы сообщения с множественными числами. Параметр <replaceable>fmt_singular</replaceable> задаёт строку формата на английском для единственного числа, <replaceable>fmt_plural</replaceable> — формат для множественного числа, <replaceable>n</replaceable> задаёт целое число, определяющее, какая именно форма множественного числа требуется, а остальные аргументы форматируются согласно выбранной строке формата. За дополнительными сведениями обратитесь к <xref remap="3" linkend="nls-guidelines"/>.</para>
   </listitem>
   <listitem>
    <para><function>errdetail(const char *msg, ...)</function> задаёт дополнительное <quote>подробное</quote> сообщение; оно должно использоваться, когда есть дополнительная информация, которую неуместно включать в основное сообщение. Строка сообщения обрабатывается так же, как и для <function>errmsg</function>.</para>
   </listitem>
   <listitem>
    <para><function>errdetail_internal(const char *msg, ...)</function> действует как <function>errdetail</function>, но её строка сообщения не будет переводиться и включаться в словарь сообщений для интернационализации. Это следует использовать для подробных сообщений, на перевод которых не стоит тратить силы, например, когда это техническая информация, непонятная большинству пользователей.</para>
   </listitem>
   <listitem>
    <para><function>errdetail_plural(const char *fmt_singular, const char *fmt_plural, unsigned long n, ...)</function> действует подобно <function>errdetail</function>, но поддерживает различные формы сообщения с множественными числами. За дополнительными сведениями обратитесь к <xref remap="3" linkend="nls-guidelines"/>.</para>
   </listitem>
   <listitem>
    <para><function>errdetail_log(const char *msg, ...)</function> подобна <function>errdetail</function>, но выводимая строка попадает только в журнал сервера, и никогда не передаётся клиенту. Если используется и <function>errdetail</function> (или один из её эквивалентов), и <function>errdetail_log</function>, тогда одна строка передаётся клиенту, а другая отправляется в журнал. Это полезно для вывода подробных сообщений, имеющих конфиденциальный характер или большой размер, так что передавать их клиенту нежелательно.</para>
   </listitem>
   <listitem>
    <para><function>errdetail_log_plural(const char *fmt_singular, const char *fmt_plural, unsigned long n, ...)</function> действует подобно <function>errdetail_log</function>, но поддерживает различные формы сообщения с множественными числами. За дополнительными сведениями обратитесь к <xref remap="3" linkend="nls-guidelines"/>.</para>
   </listitem>
   <listitem>
    <para><function>errhint(const char *msg, ...)</function> передаёт дополнительное сообщение <quote>подсказки</quote>; это позволяет предложить решение проблемы, а не просто сообщить факты, связанные с ней. Строка сообщения обрабатывается так же, как и для <function>errmsg</function>.</para>
   </listitem>
   <listitem>
    <para><function>errcontext(const char *msg, ...)</function> обычно не вызывается непосредственно с места вызова <function>ereport</function>, а используется в функциях обратного вызова <literal>error_context_stack</literal> и выдаёт информацию о контексте, в котором произошла ошибка, например, о текущем положении в функции PL. Строка сообщения обрабатывается так же, как и для <function>errmsg</function>. В отличие от других вспомогательных функций, внутри вызова <function>ereport</function> её можно вызывать неоднократно; добавляемые таким образом последовательные сообщения складываются через символы перевода строк.</para>
   </listitem>
   <listitem>
    <para><function>errposition(int cursorpos)</function> задаёт положение ошибки в тексте запроса. В настоящее время это полезно только для ошибок, выявляемых на этапах лексического и синтаксического анализа запроса.</para>
   </listitem>
   <listitem>
    <para><function>errtable(Relation rel)</function> определяет отношение, имя и схема которого должны быть включены во вспомогательные поля сообщения об ошибке.</para>
   </listitem>
   <listitem>
    <para><function>errtablecol(Relation rel, int attnum)</function> определяет столбец, имя которого, вместе с именем таблицы и схемы, должно быть включено во вспомогательные поля сообщения об ошибке.</para>
   </listitem>
   <listitem>
    <para><function>errtableconstraint(Relation rel, const char *conname)</function> задаёт имя ограничения таблицы, которое вместе с именем таблицы и схемы должно быть включено во вспомогательные поля сообщения об ошибке. В данном контексте индекс считается ограничением, независимо от того, имеется ли для него запись в <structname>pg_constraint</structname>. Заметьте, что при этом в качестве <literal>rel</literal> нужно передавать нижележащее отношение, а не сам индекс.</para>
   </listitem>
   <listitem>
    <para><function>errdatatype(Oid datatypeOid)</function> задаёт тип данных, имя которого, вместе с именем схемы, должно включаться во вспомогательные поля сообщения об ошибке.</para>
   </listitem>
   <listitem>
    <para><function>errdomainconstraint(Oid datatypeOid, const char *conname)</function> задаёт имя ограничения домена, которое вместе с именем домена и схемы должно включаться во вспомогательные поля сообщения об ошибке.</para>
   </listitem>
   <listitem>
    <para><function>errcode_for_file_access()</function> — вспомогательная функция, выбирающая подходящий идентификатор SQLSTATE при сбое в системном вызове, в котором происходит обращение к файловой системе. Какой код ошибки генерировать, она определяет по сохранённому значению <literal>errno</literal>. Обычно это используется в сочетании с <literal>%m</literal> в основном сообщении об ошибке.</para>
   </listitem>
   <listitem>
    <para><function>errcode_for_socket_access()</function> — вспомогательная функция, выбирающая подходящий идентификатор SQLSTATE при сбое в системном вызове, в котором происходит обращение к сокетам.</para>
   </listitem>
   <listitem>
    <para><function>errhidestmt(bool hide_stmt)</function> может быть вызвана для подавления вывода поля <literal>ОПЕРАТОР:</literal> (<literal>STATEMENT:</literal>) в журнал сервера. Обычно это уместно, когда само сообщение включает текст текущего оператора.</para>
   </listitem>
   <listitem>
    <para><function>errhidecontext(bool hide_ctx)</function> может быть вызвана для подавления вывода поля <literal>КОНТЕКСТ:</literal> (<literal>CONTEXT:</literal>) в журнал сервера. Это следует использовать только для подробных отладочных сообщений, в которых одна и та же информация о контексте, выводимая в журнал, будет только чрезмерно замусоривать его.</para>
   </listitem>
  </itemizedlist></para>

   <note>
    <para>В вызове <function>ereport</function> следует использовать максимум одну из функций <function>errtable</function>, <function>errtablecol</function>, <function>errtableconstraint</function>, <function>errdatatype</function> или <function>errdomainconstraint</function>. Данные функции существуют для того, чтобы приложения могли извлечь имя объекта базы данных, связанного с условием ошибки, так, чтобы для этого им не требовалось разбирать текст ошибки, возможно локализованный. Эти функции должны использоваться в случае ошибок, для которых может быть желательной автоматическая обработка. Для версии <productname>PostgreSQL</productname> 9.3 этот подход распространяется полностью только на ошибки класса SQLSTATE 23 (нарушение целостности ограничения), но в будущем область его применения может быть расширена.</para>
   </note>

   <para>Существует также более старая, но тем не менее активно используемая функция <function>elog</function>. Вызов <function>elog</function>: <programlisting>elog(level, "format string", ...);</programlisting> полностью равнозначен вызову: <programlisting>ereport(level, (errmsg_internal("format string", ...)));</programlisting> Заметьте, что код ошибки SQLSTATE всегда определяется неявно, а строка сообщения не подлежит переводу. Таким образом, <function>elog</function> следует использовать только для внутренних ошибок и отладки на низком уровне. Любое сообщение, которое может представлять интерес для обычных пользователей, должно проходить через <function>ereport</function>. Тем не менее, в системе есть достаточно много внутренних проверок для случаев, <quote>которые не должны происходить</quote>, и в них по-прежнему широко используется <function>elog</function>; для таких сообщений эта функция предпочитается из-за простоты записи.</para>

   <para>Советы по написанию хороших сообщений об ошибках можно найти в <xref remap="6" linkend="error-style-guide"/>.</para>
  </sect1>

  <sect1 id="error-style-guide">
   <title>Руководство по стилю сообщений об ошибках</title>

   <para>Это руководство по стилю предлагается в надежде обеспечить единообразный и понятный пользователю стиль для всех сообщений, которые выдаёт <productname>&productname;</productname>.</para>

  <simplesect>
   <title>Что и куда выводить</title>

   <para>Основное сообщение должно быть кратким, фактологическим и, по возможности, не говорить о тонкостях реализации, например, не упоминать конкретные имена функций. Под <quote>кратким</quote> понимается <quote>должно умещаться в одной строке при обычных условиях</quote>. Дополнительное подробное сообщение добавляется, когда краткого сообщения недостаточно, или вы считаете, что нужно упомянуть какие-то внутренние детали, например, конкретный системный вызов, в котором произошла ошибка. И основное, и подробное сообщения должны сообщать исключительно факты. Чтобы предложить решение проблемы, особенно, если это решение может быть применимо не всегда, передайте его в сообщении-подсказке.</para>

   <para>Например, вместо: <programlisting>IpcMemoryCreate: ошибка в shmget(ключ=%d, размер=%u, 0%o): %m
(плюс длинное дополнение, по сути представляющее собой подсказку)</programlisting> следует записать: <programlisting>Основное:    не удалось создать сегмент разделяемой памяти: %m
Подробное:   Ошибка в системном вызове shmget(key=%d, size=%u, 0%o).
Подсказка:   дополнительный текст</programlisting></para>

   <para>Объяснение: когда основное сообщение достаточно краткое, клиенты могут выделить для него место на экране в предположении, что одной строки будет достаточно. Подробное сообщение и подсказка могут выводиться в режиме дополнительных сведений или, возможно, в разворачивающемся окне &laquo;ошибка-подробности&raquo;. Кроме того, подробности и подсказки обычно не записываются в журнал сервера для сокращения его объёма. Детали реализации лучше опускать, так как пользователи не должны в них разбираться.</para>

  </simplesect>

  <simplesect>
   <title>Форматирование</title>

   <para>Не полагайтесь на какое-либо определённое форматирование в тексте сообщений. Следует ожидать, что в клиентском интерфейсе и в журнале сервера длинные строки будут переноситься в зависимости от ситуации. В длинных сообщениях можно обозначить предполагаемые места разрыва абзацев символами новой строки (\n). Завершать сообщение этим символом не нужно. Также не используйте табуляции или другие символы форматирования. (При выводе контекста ошибок автоматически добавляются символы перевода строки для разделения уровней контекста, например, вызовов функций.)</para>

   <para>Объяснение: сообщение не обязательно будет выводиться в интерфейсе терминального типа. В графических интерфейсах или браузерах эти инструкции форматирования в лучшем случае игнорируются.</para>

  </simplesect>

  <simplesect>
   <title>Символы кавычек</title>

   <para>В тексте на английском языке везде, где это уместно, следует использовать двойные кавычки. В тексте на других языках следует единообразно использовать тот тип кавычек, который принят для печати вывода других программ.</para>

   <para>Объяснение: выбор двойных кавычек вместо апострофов несколько своевольный, но ему сейчас отдаётся предпочтение. Некоторые разработчики предлагали выбирать тип кавычек в зависимости от типа объекта, следуя соглашениям SQL (а именно, строки заключать в апострофы, а идентификаторы в кавычки). Но это внутренняя техническая особенность языка, о которой многие пользователи даже не догадываются; кроме того, это нельзя распространить на другие типы сущностей в кавычках, не всегда можно перевести на другие языки и к тому же довольно бессмысленно.</para>

  </simplesect>

  <simplesect>
   <title>Использование кавычек</title>

   <para>Всегда используйте кавычки для заключения имён файлов, задаваемых пользователем идентификаторов и других переменных, которые могут содержать слова. Не заключайте в кавычки переменные, которые никогда не будут содержать слова (например, имена операторов).</para>

   <para>В коде сервера есть функции, которые при необходимости сами заключают выводимый результат в кавычки (например, <function>format_type_be()</function>). Дополнительные кавычки вокруг результата таких функций добавлять не следует.</para>

   <para>Объяснение: у объектов могут быть имена, создающие двусмысленность, когда они появляются в сообщении. Всегда одинаково обозначайте, где начинается и где заканчивается встроенное имя. Но не загромождайте сообщения ненужными или повторными знаками кавычек.</para>

  </simplesect>

  <simplesect>
   <title>Грамматика и пунктуация</title>

   <para>Правила для основного сообщения и дополнительного сообщения/подсказки различаются:</para>

   <para>Основное сообщение об ошибке: не делайте первую букву заглавной. Не завершайте сообщение точкой. Даже не думайте о том, чтобы завершить сообщение восклицательным знаком!</para>

   <para>Подробное сообщение и подсказка: пишите полные предложения и завершайте каждое точкой. Начинайте первое слово предложения с большой буквы. Добавляйте два пробела после точки, если за одним предложением следует другое (для английского текста; может не подходить для других языков).</para>

   <para>Строка с контекстом ошибки: не делайте первую букву заглавной и не завершайте строку точкой. Строки контекста обычно не должны быть полными предложениями.</para>

   <para>Объяснение: при отсутствии знаков пунктуации клиентским приложениям проще вставить сообщение в самые разные грамматические контексты. Часто основные сообщения всё равно не являются грамматически полными предложениями. (Если сообщение настолько длинное, что занимает не одно предложение, его следует поделить на основную и дополнительную часть.) Однако подробные сообщения и подсказки по определению длиннее и могут содержать несколько предложений. Единообразия ради, они должны следовать стилю полного предложения, даже если предложение всего одно.</para>

  </simplesect>

  <simplesect>
   <title>Верхний регистр или нижний регистр</title>

   <para>Пишите сообщение в нижнем регистре, включая первую букву основного сообщения об ошибке. Используйте верхний регистр для команд SQL и ключевых слов, если они выводятся в сообщении.</para>

   <para>Объяснение: так проще сделать, чтобы всё выглядело единообразно, так как некоторые сообщения могут быть полными предложениями, а другие нет.</para>

  </simplesect>

  <simplesect>
   <title>Избегайте пассивного залога</title>

   <para>Используйте активный залог. Когда есть действующий субъект, формулируйте полные предложения (<quote>A не удалось сделать B</quote>). Используйте телеграфный стиль без субъекта, если субъект — сама программа; не пишите <quote>я</quote> от имени программы.</para>

   <para>Объяснение: программа — не человек. Не создавайте впечатление, что это не так.</para>

  </simplesect>

  <simplesect>
   <title>Настоящее или прошедшее время</title>

   <para>Используйте прошедшее время, если попытка сделать что-то не удалась, но может быть успешной в следующий раз (возможно, после устранения некоторой проблемы). Используйте настоящее время, если ошибка, определённо, постоянная.</para>

   <para>Есть нетривиальное смысловое различие между предложениями вида: <programlisting>не удалось открыть файл "%s": %m</programlisting> и: <programlisting>нельзя открыть файл "%s"</programlisting> Первое означает, что попытка открыть файл не удалась. Сообщение должно сообщать причину, например, <quote>переполнение диска</quote> или <quote>файл не существует</quote>. Прошедшее время уместно, потому что в следующий раз диск может быть не переполнен или запрошенный файл будет найден.</para>

   <para>Вторая форма показывает, что функциональность открытия файла с заданным именем полностью отсутствует в программе, либо это невозможно в принципе. Настоящее время в этом случае уместно, так как это условие будет сохраняться неопределённое время.</para>

   <para>Объяснение: конечно, средний пользователь не сможет сделать глубокие выводы, проанализировав синтаксическое время, но если язык даёт нам возможность такого выражения, мы должны использовать это корректно.</para>

  </simplesect>

  <simplesect>
   <title>Тип объекта</title>

   <para>Цитируя имя объекта, указывайте также его тип.</para>

   <para>Объяснение: иначе никто не поймёт, к чему относится <quote>foo.bar.baz</quote>.</para>

  </simplesect>

  <simplesect>
   <title>Скобки</title>

   <para>Квадратные скобки должны использоваться только (1) в описаниях команд и обозначать необязательные аргументы, либо (2) для обозначения индекса массива.</para>

   <para>Объяснение: все другие варианты их использования не являются общепринятыми и будут вводить в заблуждение.</para>

  </simplesect>

  <simplesect>
   <title>Сборка сообщений об ошибках</title>

   <para>Когда сообщение включает текст, сгенерированный в другом месте, внедряйте его следующим образом: <programlisting>не удалось открыть файл %s: %m</programlisting></para>

   <para>Объяснение: довольно сложно учесть все возможные варианты ошибок, которые будут вставляться в предложение, чтобы оно при этом оставалось складным, поэтому требуется какая-то пунктуация. Было предложение заключать включаемый текст в скобки, но это не вполне естественно, если этот текст содержит наиболее важную часть сообщения, что часто имеет место.</para>

  </simplesect>

  <simplesect>
   <title>Причины ошибок</title>

   <para>Сообщения должны всегда сообщать о причине произошедшей ошибки. Например: <programlisting>ПЛОХО:  не удалось открыть файл %s
ЛУЧШЕ:  не удалось открыть файл %s (ошибка ввода/вывода)</programlisting> Если причина неизвестна, лучше исправить код.</para>

  </simplesect>

  <simplesect>
   <title>Имена функций</title>

   <para>Не включайте в текст ошибки имя функции, в которой возникла ошибка. У нас есть другие механизмы, позволяющие узнать его, когда требуется, а для большинства пользователей это бесполезная информация. Если текст ошибки оказывается бессвязным без имени функции, перефразируйте его. <programlisting>ПЛОХО:  pg_atoi: ошибка в "z": не удалось разобрать "z"
ЛУЧШЕ:  неверное значение для целого числа: "z"</programlisting></para>

   <para>Избегайте упоминания имён вызываемых функций; вместо этого скажите, что пытается делать код: <programlisting>ПЛОХО:  ошибка в open(): %m
ЛУЧШЕ:  не удалось открыть файл %s: %m</programlisting> Если это действительно кажется необходимым, упомяните системный вызов в подробном сообщении. (В некоторых случаях в подробном сообщении стоит показать фактические значения, передаваемые системному вызову.)</para>

   <para>Объяснение: пользователи не знают, что делают все эти функции.</para>

  </simplesect>

  <simplesect>
   <title>Скользкие слова, которых следует избегать</title>

  <formalpara>
    <title>Unable (Неспособен)</title>
   <para><quote>Unable</quote> — это почти пассивный залог. Лучше использовать <quote>cannot</quote> (нельзя) или <quote>could not</quote> (не удалось), в зависимости от ситуации.</para>
  </formalpara>

  <formalpara>
    <title>Bad (Плохое)</title>
   <para>Сообщения об ошибках типа <quote>bad result</quote> (плохой результат) трудно воспринять осмысленно. Лучше написать, почему результат <quote>плохой</quote>, например, <quote>invalid format</quote> (неверный формат).</para>
  </formalpara>

  <formalpara>
    <title>Illegal (Нелегальное)</title>
   <para><quote>Illegal</quote> (нелегально) — то, что нарушает закон, всё остальное можно называть <quote>invalid</quote> (неверным). Опять же лучше сказать, почему что-то неверное.</para>
  </formalpara>

  <formalpara>
    <title>Unknown (Неизвестное)</title>
   <para>Постарайтесь исключить <quote>unknown</quote> (неизвестное). Взгляните на сообщение: <quote>error: unknown response</quote> (ошибка: неизвестный ответ). Если вы не знаете, что за ответ получен, как вы поняли, что он ошибочный? Вместо этого часто лучше сказать <quote>unrecognized</quote> (нераспознанный). Также обязательно добавьте значение, которое не было воспринято. <programlisting>ПЛОХО:  неизвестный тип узла
ЛУЧШЕ:  нераспознанный тип узла: 42</programlisting></para>
  </formalpara>

  <formalpara>
    <title>&laquo;Не найдено&raquo; или &laquo;не существует&raquo;</title>
   <para>Если программа выполняет поиск ресурса, используя нетривиальный алгоритм (например, поиск по пути), и этот алгоритм не срабатывает, лучше честно сказать, что программа не смогла <quote>найти</quote> ресурс. С другой стороны, если ожидаемое расположение ресурса точно известно, но программа не может обратиться к нему, скажите, что этот ресурс не <quote>существует</quote>. Формулировка с глаголом <quote>найти</quote> в данном случае звучит слабо и затрудняет понимание.</para>
  </formalpara>

  <formalpara>
    <title>Разрешено, могу или возможно</title>
   <para><quote>May</quote> (разрешено) подразумевает разрешение (например, &laquo;Вам разрешено воспользоваться моими граблями.&raquo;) и этому практически нет применения в документации или сообщениях об ошибках. <quote>Can</quote> (могу) подразумевает способность (например, &laquo;Я могу поднять это бревно.&raquo;), а <quote>might</quote> (возможно) подразумевает возможность (например, &laquo;Сегодня возможен дождь.&raquo;). Использование подходящего слова проясняет значение и облегчает перевод.</para>
  </formalpara>

  <formalpara>
    <title>Сокращения</title>
   <para>Избегайте сокращений, например <quote>can't</quote>; вместо это напишите <quote>cannot</quote>.</para>
  </formalpara>

  </simplesect>

  <simplesect>
   <title>Правильное написание</title>

   <para>Пишите слова полностью. Например, избегайте (в английском): <itemizedlist>
   <listitem>
    <para>spec</para>
   </listitem>
   <listitem>
    <para>stats</para>
   </listitem>
   <listitem>
    <para>parens</para>
   </listitem>
   <listitem>
    <para>auth</para>
   </listitem>
   <listitem>
    <para>xact</para>
   </listitem>
  </itemizedlist></para>

   <para>Объяснение: так сообщения будут единообразными.</para>

  </simplesect>

  <simplesect>
   <title>Локализация</title>

   <para>Помните, что текст сообщений должен переводиться на другие языки. Следуйте советам, приведённым в <xref remap="6" linkend="nls-guidelines"/>, чтобы излишне не усложнять жизнь переводчикам.</para>
  </simplesect>

  </sect1>

  <sect1 id="source-conventions">
   <title>Различные соглашения по оформлению кода</title>

   <simplesect>
    <title>Стандарт C</title>
    <para>Код в <productname>&productname;</productname> должен использовать только те возможности языка, что описаны в стандарте C89. Это означает, что код postgres должен успешно компилироваться компилятором, поддерживающим C89, возможно, за исключением нескольких платформозависимых мест. Возможности более поздних ревизий стандарта C или специфические особенности компилятора могут использоваться, только если предусмотрен и вариант компиляции без них.</para>
    <para>Например, в настоящее время используются конструкции <literal>static inline</literal> и <literal>_StaticAssert()</literal>, хотя они относятся к более новым ревизиям стандарта C. Но если они недоступны, мы соответственно переходим к определению функций без inline, и к использованию альтернативы, которая совместима с C89 и выполняет те же проверки, но выдаёт довольно непонятные сообщения.</para>
   </simplesect>

   <simplesect>
    <title>Внедрённые функции и макросы, подобные функциям</title>
    <para>Допускается использование и макросов с аргументами, и функций <literal>static inline</literal>. Последний вариант предпочтительнее, если возникает риск множественного вычисления выражений в макросе, как например в случае с <programlisting>#define Max(x, y)       ((x) &gt; (y) ? (x) : (y))</programlisting> или когда макрос может быть слишком объёмным. В других случаях использовать макросы — единственный, или как минимум более простой вариант. Например, может быть полезна возможность передавать макросу выражения различных типов.</para>
    <para>Когда определение внедрённой функции обращается к символам (переменным, функциям), доступным только в серверном коде, такая функция не должна быть видна при включении в клиентский код. <programlisting>#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */</programlisting> В этом примере вызывается функция <literal>CurrentMemoryContext</literal>, существующая только на стороне сервера, и поэтому функция скрыта директивой <literal>#ifndef FRONTEND</literal>. Это правило введено, потому что некоторые компиляторы генерируют указатели на символы, фигурирующие во внедрённых функциях, даже когда эти функции не используются.</para>
   </simplesect>

   <simplesect>
    <title>Написание обработчиков сигналов</title>
    <para>Чтобы код мог выполняться внутри обработчика сигналов, его нужно написать очень аккуратно. Фундаментальная сложность состоит в том, что обработчик сигнала может прервать код в любой момент, если он не отключён. Если код внутри обработчика сигнала использует то же состояние, что и внешний основной код, это может привести к хаосу. В качестве примера представьте, что произойдёт, если обработчик сигнала попытается получить ту же блокировку, которой уже владеет прерванный код.</para>
    <para>Если не предпринимать специальных мер, код в обработчиках сигналов может вызывать только безопасные с точки зрения асинхронных сигналов функции (как это определяется в POSIX) и обращаться к переменным типа <literal>volatile sig_atomic_t</literal>. Также безопасными для обработчиков сигналов считаются несколько функций в <command>postgres</command>, в том числе, что важно, <function>SetLatch()</function>.</para>
    <para>В большинстве случаев обработчики событий должны только сообщить о поступлении сигнала и пробудить код снаружи обработчика, используя защёлку. Например, обработчик может быть таким: <programlisting>static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}</programlisting> Переменная <varname>errno</varname> сохраняется и восстанавливается, так как её может изменить <function>SetLatch()</function>. Если этого не сделать, прерванный код, считывая <varname>errno</varname>, мог бы получить некорректное значение.</para>
   </simplesect>

  </sect1>
 </chapter>
