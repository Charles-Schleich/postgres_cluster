<!-- doc/src/xml/array.xml -->

<sect1 id="arrays">
 <title>Массивы</title>

 <indexterm><primary>массив</primary></indexterm>

 <para><productname>&productname;</productname> позволяет определять столбцы таблицы как многомерные массивы переменной длины. Элементами массивов могут быть любые встроенные или определённые пользователями типы, перечисления или составные типы. Массивы доменов в данный момент не поддерживаются.</para>

 <sect2 id="arrays-declaration">
  <title>Объявления типов массивов</title>

  <indexterm><primary>массив</primary> <secondary>объявление</secondary></indexterm>

 <para>Чтобы проиллюстрировать использовать массивов, мы создадим такую таблицу: <programlisting>CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);</programlisting> Как показано, для объявления типа массива к названию типа элементов добавляются квадратные скобки (<literal>[]</literal>). Показанная выше команда создаст таблицу <structname>sal_emp</structname> со столбцами типов <type>text</type> (<structfield>name</structfield>), одномерный массив с элементами <type>integer</type> (<structfield>pay_by_quarter</structfield>), представляющий квартальную зарплату работников, и двухмерный массив с элементами <type>text</type> (<structfield>schedule</structfield>), представляющий недельный график работника.</para>

 <para>Команда <command>CREATE TABLE</command> позволяет также указать точный размер массивов, например так: <programlisting>CREATE TABLE tictactoe (
    squares   integer[3][3]
);</programlisting> Однако текущая реализация игнорирует все указанные размеры, т. е. фактически размер массива остаётся неопределённым.</para>

 <para>Текущая реализация также не ограничивает число размерностей. Все элементы массивов считаются одного типа, вне зависимости от его размера и числа размерностей. Поэтому явно указывать число элементов или размерностей в команде <command>CREATE TABLE</command> имеет смысл только для документирования, на механизм работы с массивом это не влияет.</para>

 <para>Для объявления одномерных массивов можно применять альтернативную запись с ключевым словом <literal>ARRAY</literal>, соответствующую стандарту SQL. Столбец <structfield>pay_by_quarter</structfield> можно было бы определить так: <programlisting>    pay_by_quarter  integer ARRAY[4],</programlisting> Или без указания размера массива: <programlisting>    pay_by_quarter  integer ARRAY,</programlisting> Заметьте, что и в этом случае <productname>&productname;</productname> не накладывает ограничения на фактический размер массива.</para>
 </sect2>

 <sect2 id="arrays-input">
  <title>Ввод значения массива</title>

  <indexterm><primary>массив</primary> <secondary>константа</secondary></indexterm>

  <para>Чтобы записать значение массива в виде буквальной константы, заключите значения элементов в фигурные скобки и разделите их запятыми. (Если вам знаком C, вы найдёте, что это похоже на синтаксис инициализации структур в C.) Вы можете заключить значение любого элемента в двойные кавычки, а если он содержит запятые или фигурные скобки, это обязательно нужно сделать. (Подробнее это описано ниже.) Таким образом, общий формат константы массива выглядит так: <synopsis>
'{ <replaceable>значение1</replaceable> <replaceable>разделитель</replaceable> <replaceable>значение2</replaceable> <replaceable>разделитель</replaceable> ... }'
</synopsis> где <replaceable>разделитель</replaceable> &mdash; символ, указанный в качестве разделителя в соответствующей записи в таблице <literal>pg_type</literal>. Для стандартных типов данных, существующих в дистрибутиве <productname>&productname;</productname>, разделителем является запятая (<literal>,</literal>), за исключением лишь типа <type>box</type>, в котором разделитель &mdash;точка с запятой (<literal>;</literal>). Каждое <replaceable>значение</replaceable> здесь &mdash; это либо константа типа элемента массива, либо вложенный массив. Например, константа массива может быть такой: <programlisting>'{{1,2,3},{4,5,6},{7,8,9}}'</programlisting> Эта константа определяет двухмерный массив 3x3, состоящий из трёх вложенных массивов целых чисел.</para>

  <para>Чтобы присвоить элементу массива значение NULL, достаточно просто написать <literal>NULL</literal> (регистр символов при этом не имеет значения). Если же требуется добавить в массив строку, содержащую <quote>NULL</quote>, это слово нужно заключить в двойные кавычки.</para>

  <para>(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай констант, описанных в <xref remap="6" linkend="sql-syntax-constants-generic"/>. Константа изначально воспринимается как строка и передаётся процедуре преобразования вводимого массива. При этом может потребоваться явно указать целевой тип.)</para>

  <para>Теперь мы можем показать несколько операторов <command>INSERT</command>: <programlisting>INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"training", "presentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');</programlisting></para>

 <para>Результат двух предыдущих команд: <programlisting>SELECT * FROM sal_emp;
name |     pay_by_quarter      |                schedule
-----+-------------------------+--------------------------------------
Bill |{10000,10000,10000,10000}|{{meeting,lunch},{training,presentation}}
Carol|{20000,25000,25000,25000}|{{breakfast,consulting},{meeting,lunch}}
(2 rows)</programlisting></para>

 <para>В многомерных массивов число элементов в каждой размерности должно быть одинаковым; в противном случае возникает ошибка. Например: <programlisting>INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"meeting"}}');
ОШИБКА:  для многомерных массивов должны задаваться выражения
  с соответствующими размерностями</programlisting></para>

 <para>Также можно использовать синтаксис конструктора <literal>ARRAY</literal>: <programlisting>INSERT INTO sal_emp
    VALUES ('Bill',
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);

INSERT INTO sal_emp
    VALUES ('Carol',
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);</programlisting> Заметьте, что элементы массива здесь &mdash; это простые SQL-константы или выражения; и поэтому, например строки будут заключаться в одинарные апострофы, а не в двойные, как в буквальной константе массива. Более подробно конструктор <literal>ARRAY</literal> обсуждается в <xref remap="6" linkend="sql-syntax-array-constructors"/>.</para>
 </sect2>

 <sect2 id="arrays-accessing">
  <title>Обращение к массивам</title>

  <indexterm><primary>массив</primary> <secondary>обращение</secondary></indexterm>

 <para>Добавив данные в таблицу, мы можем перейти к выборкам. Сначала мы покажем, как получить один элемент массива. Этот запрос получает имена сотрудников, зарплата которых изменилась во втором квартале: <programlisting>SELECT name FROM sal_emp WHERE pay_by_quarter[1] &lt;&gt; pay_by_quarter[2];

 name
-------
 Carol
(1 row)</programlisting> Индексы элементов массива записываются в квадратных скобках. По умолчанию в <productname>&productname;</productname> действует соглашение о нумерации элементов массива с 1, то есть в массиве из <replaceable>n</replaceable> элементов первым считается <literal>array[1]</literal>, а последним &mdash; <literal>array[<replaceable>n</replaceable>]</literal>.</para>

 <para>Этот запрос выдаёт зарплату всех сотрудников в третьем квартале: <programlisting>SELECT pay_by_quarter[3] FROM sal_emp;

 pay_by_quarter
----------------
          10000
          25000
(2 rows)</programlisting></para>

 <para>Мы также можем получать обычные прямоугольные срезы массива, то есть подмассивы. Срез массива обозначается как <literal><replaceable>нижняя-граница</replaceable>:<replaceable>верхняя-граница</replaceable></literal> для одной или нескольких размерностей. Например, этот запрос получает первые пункты в графике Билла в первые два дня недели: <programlisting>SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)</programlisting> Если одна из размерностей записана в виде среза, то есть содержит двоеточие, тогда срез распространяется на все размерности. Если при этом для размерности указывается только одно число (без двоеточия), в срез войдут элемент от 1 до заданного номера. Например, в этом примере <literal>[2]</literal> будет равнозначно <literal>[1:2]</literal>: <programlisting>SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';

                 schedule
-------------------------------------------
 {{meeting,lunch},{training,presentation}}
(1 row)</programlisting> Во избежание путаницы с обращением к одному элементу, срезы лучше всегда записывать явно для всех измерений, например <literal>[1:2][1:1]</literal> вместо <literal>[2][1:1]</literal>.</para>

 <para>Значения <replaceable>нижняя-граница</replaceable> и/или <replaceable>верхняя-граница</replaceable> в указании среза можно опустить; опущенная граница заменяется нижним или верхним пределом индексов массива. Например: <programlisting>SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{lunch},{presentation}}
(1 row)

SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)</programlisting></para>

 <para>Выражение обращения к элементу массива возвратит NULL, если сам массив или одно из выражений индексов элемента равны NULL. Значение NULL также возвращается, если индекс выходит за границы массива (это не считается ошибкой). Например, если <literal>schedule</literal> в настоящее время имеет размерности <literal>[1:3][1:2]</literal>, результатом обращения к <literal>schedule[3][3]</literal> будет NULL. Подобным образом, при обращении к элементу массива с неправильным числом индексов возвращается NULL, а не ошибка.</para>

 <para>Аналогично, NULL возвращается при обращении к срезу массива, если сам массив или одно из выражений, определяющих индексы элементов, равны NULL. Однако, в других случаях, например, когда границы среза выходят за рамки массива, возвращается не NULL, а пустой массив (с размерностью 0). (Так сложилось исторически, что в этом срезы отличаются от обращений к обычным элементам.) Если запрошенный срез пересекает границы массива, тогда возвращается не NULL, а срез, сокращённый до области пересечения.</para>

 <para>Текущие размеры значения массива можно получить с помощью функции <function>array_dims</function>: <programlisting>SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';

 array_dims
------------
 [1:2][1:2]
(1 row)</programlisting> <function>array_dims</function> выдаёт результат типа <type>text</type>, что удобно скорее для людей, чем для программ. Размеры массива также можно получить с помощью функций <function>array_upper</function> и <function>array_lower</function>, которые возвращают соответственно верхнюю и нижнюю границу для указанной размерности: <programlisting>SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_upper
-------------
           2
(1 row)</programlisting> <function>array_length</function> возвращает число элементов в указанной размерности массива: <programlisting>SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_length
--------------
            2
(1 row)</programlisting> <function>cardinality</function> возвращает общее число элементов массива по всем измерениям. Фактически это число строк, которое вернёт функция <function>unnest</function>: <programlisting>SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';

 cardinality
-------------
           4
(1 row)</programlisting></para>
 </sect2>

 <sect2 id="arrays-modifying">
  <title>Изменение массивов</title>

  <indexterm><primary>массив</primary> <secondary>изменение</secondary></indexterm>

 <para>Значение массива можно заменить полностью так: <programlisting>UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'
    WHERE name = 'Carol';</programlisting> или используя синтаксис <literal>ARRAY</literal>: <programlisting>UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
    WHERE name = 'Carol';</programlisting> Также можно изменить один элемент массива: <programlisting>UPDATE sal_emp SET pay_by_quarter[4] = 15000
    WHERE name = 'Bill';</programlisting> или срез: <programlisting>UPDATE sal_emp SET pay_by_quarter[1:2] = '{27000,27000}'
    WHERE name = 'Carol';</programlisting> При этом в указании среза может быть опущена <replaceable>нижняя-граница</replaceable> и/или <replaceable>верхняя-граница</replaceable>, но только для массива, отличного от NULL, и имеющего ненулевую размерность (иначе неизвестно, какие граничные значения должны подставляться вместо опущенных).</para>

 <para>Сохранённый массив можно расширить, определив значения ранее отсутствовавших в нём элементов. При этом все элементы, располагающиеся между существовавшими ранее и новыми, принимают значения NULL. Например, если массив <literal>myarray</literal> содержит 4 элемента, после присвоения значения элементу <literal>myarray[6]</literal> его длина будет равна 6, а <literal>myarray[5]</literal> будет содержать NULL. В настоящее время подобное расширение поддерживается только для одномерных, но не многомерных массивов.</para>

 <para>Определяя элементы по индексам, можно создавать массивы, в которых нумерация элементов может начинаться не с 1. Например, можно присвоить значение выражению <literal>myarray[-2:7]</literal> и таким образом создать массив, в котором будут элементы с индексами от -2 до 7.</para>

 <para>Значения массива также можно сконструировать с помощью оператора конкатенации, <literal>||</literal>: <programlisting>SELECT ARRAY[1,2] || ARRAY[3,4];
 ?column?
-----------
 {1,2,3,4}
(1 row)

SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
      ?column?
---------------------
 {{5,6},{1,2},{3,4}}
(1 row)</programlisting></para>

 <para>Оператор конкатенации позволяет вставить один элемент в начало или в конец одномерного массива. Он также может принять два <replaceable>N</replaceable>-мерных массива или массивы размерностей <replaceable>N</replaceable> и <replaceable>N+1</replaceable>.</para>

 <para>Когда в начало или конец одномерного массива вставляется один элемент, в образованном в результате массиве будет та же нижняя граница, что и в массиве-операнде. Например: <programlisting>SELECT array_dims(1 || '[0:1]={2,3}'::int[]);
 array_dims
------------
 [0:2]
(1 row)

SELECT array_dims(ARRAY[1,2] || 3);
 array_dims
------------
 [1:3]
(1 row)</programlisting></para>

 <para>Когда складываются два массива одинаковых размерностей, в результате сохраняется нижняя граница внешней размерности левого операнда. Выходной массив включает все элементы левого операнда, после которых добавляются все элементы правого. Например: <programlisting>SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
 array_dims
------------
 [1:5]
(1 row)

SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
 array_dims
------------
 [1:5][1:2]
(1 row)</programlisting></para>

 <para>Когда к массиву размерности <replaceable>N+1</replaceable> спереди или сзади добавляется <replaceable>N</replaceable>-мерный массив, он вставляется аналогично тому, как в массив вставляется элемент (это было описано выше). Любой <replaceable>N</replaceable>-мерный массив по сути является элементом во внешней размерности массива, имеющего размерность <replaceable>N+1</replaceable>. Например: <programlisting>SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
 array_dims
------------
 [1:3][1:2]
(1 row)</programlisting></para>

 <para>Массив также можно сконструировать с помощью функций <function>array_prepend</function>, <function>array_append</function> и <function>array_cat</function>. Первые две функции поддерживают только одномерные массивы, а <function>array_cat</function> поддерживает и многомерные. Несколько примеров: <programlisting>SELECT array_prepend(1, ARRAY[2,3]);
 array_prepend
---------------
 {1,2,3}
(1 row)

SELECT array_append(ARRAY[1,2], 3);
 array_append
--------------
 {1,2,3}
(1 row)

SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
 array_cat
-----------
 {1,2,3,4}
(1 row)

SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
      array_cat
---------------------
 {{1,2},{3,4},{5,6}}
(1 row)

SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
      array_cat
---------------------
 {{5,6},{1,2},{3,4}}</programlisting></para>

 <para>В простых случаях описанный выше оператор конкатенации предпочтительнее непосредственного вызова этих функций. Однако, так как оператор конкатенации перегружен для решения всех трёх задач, возможны ситуации, когда лучше применить одну из этих функций во избежание неоднозначности. Например, рассмотрите: <programlisting>SELECT ARRAY[1, 2] || '{3, 4}';  -- нетипизированная строка воспринимается как массив
 ?column?
-----------
 {1,2,3,4}

SELECT ARRAY[1, 2] || '7';                 -- как и эта
ERROR:  malformed array literal: "7"

SELECT ARRAY[1, 2] || NULL;                -- как и буквальный NULL
 ?column?
----------
 {1,2}
(1 row)

SELECT array_append(ARRAY[1, 2], NULL);    -- это могло иметься в виду на самом деле
 array_append
--------------
 {1,2,NULL}</programlisting> В показанных примерах анализатор запроса видит целочисленный массив с одной стороны оператора конкатенации и константу неопределённого типа с другой. Согласно своим правилам разрешения типа констант, он полагает, что она имеет тот же тип, что и другой операнд &mdash; в данном случае, целочисленный массив. Поэтому предполагается, что оператор конкатенации здесь представляет функцию <function>array_cat</function>, а не <function>array_append</function>. Если это решение оказывается неверным, его можно скорректировать, приведя константу к типу элемента массива; однако может быть лучше явно использовать функцию <function>array_append</function>.</para>
 </sect2>

 <sect2 id="arrays-searching">
  <title>Поиск значений в массивах</title>

  <indexterm><primary>массив</primary> <secondary>поиск</secondary></indexterm>

 <para>Чтобы найти значение в массиве, необходимо проверить все его элементы. Это можно сделать вручную, если вы знаете размер массива. Например: <programlisting>SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR
                            pay_by_quarter[2] = 10000 OR
                            pay_by_quarter[3] = 10000 OR
                            pay_by_quarter[4] = 10000;</programlisting> Однако с большим массивами этот метод становится утомительным, и к тому же он не работает, когда размер массива неизвестен. Альтернативный подход описан в <xref remap="6" linkend="functions-comparisons"/>. Показанный выше запрос можно было переписать так: <programlisting>SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);</programlisting> А так можно найти в таблице строки, в которых массивы содержат только значения, равные 10000: <programlisting>SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);</programlisting></para>

 <para>Кроме того, для обращения к элементам массива можно использовать функцию <function>generate_subscripts</function>. Например так: <programlisting>SELECT * FROM
   (SELECT pay_by_quarter,
           generate_subscripts(pay_by_quarter, 1) AS s
      FROM sal_emp) AS foo
 WHERE pay_by_quarter[s] = 10000;</programlisting> Эта функция описана в <xref remap="6" linkend="functions-srf-subscripts"/>.</para>

 <para>Также искать в массиве значения можно, используя оператор <literal>&amp;&amp;</literal>, который проверяет, перекрывается ли левый операнд с правым. Например: <programlisting>SELECT * FROM sal_emp WHERE pay_by_quarter &amp;&amp; ARRAY[10000];</programlisting> Этот и другие операторы для работы с массивами описаны в <xref remap="6" linkend="functions-array"/>. Он может быть ускорен с помощью подходящего индекса, как описано в <xref remap="6" linkend="indexes-types"/>.</para>

 <para>Вы также можете искать определённые значения в массиве, используя функции <function>array_position</function> и <function>array_positions</function>. Первая функция возвращает позицию первого вхождения значения в массив, а вторая — массив позиций всех его вхождений. Например: <programlisting>SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
 array_positions
-----------------
 2

SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1);
 array_positions
-----------------
 {1,4,8}</programlisting></para>

 <tip>
  <para>Массивы &mdash; это не множества; необходимость поиска определённых элементов в массиве может быть признаком неудачно сконструированной базы данных. Возможно, вместо массива лучше использовать отдельную таблицу, строки которой будут содержать данные элементов массива. Это может быть лучше и для поиска, и для работы с большим количеством элементов.</para>
 </tip>
 </sect2>

 <sect2 id="arrays-io">
  <title>Синтаксис вводимых и выводимых значений массива</title>

  <indexterm><primary>массив</primary> <secondary>ввод/вывод</secondary></indexterm>

  <para>Внешнее текстовое представление значения массива состоит из записи элементов, интерпретируемых по правилам ввода/вывода для типа элемента массива, и оформления структуры массива. Оформление состоит из фигурных скобок (<literal>{</literal> и <literal>}</literal>), окружающих значение массива, и знаков-разделителей между его элементами. В качестве знака-разделителя обычно используется запятая (<literal>,</literal>), но это может быть и другой символ; он определяется параметром <literal>typdelim</literal> для типа элемента массива. Для стандартных типов данных, существующих в дистрибутиве <productname>&productname;</productname>, разделителем является запятая (<literal>,</literal>), за исключением лишь типа <type>box</type>, в котором разделитель &mdash; точка с запятой (<literal>;</literal>). В многомерном массиве у каждой размерности (ряд, плоскость, куб и т. д.) есть свой уровень фигурных скобок, а соседние значения в фигурных скобках на одном уровне должны отделяться разделителями.</para>

  <para>Функция вывода массива заключает значение элемента в кавычки, если это пустая строка или оно содержит фигурные скобки, знаки-разделители, кавычки, обратную косую черту, пробельный символ или это текст <literal>NULL</literal>. Кавычки и обратная косая черта, включённые в такие значения, преобразуются в спецпоследовательность с обратной косой чертой. Для числовых типов данных можно рассчитывать на то, что значения никогда не будут выводиться в кавычках, но для текстовых типов следует быть готовым к тому, что выводимое значение массива может содержать кавычки.</para>

  <para>По умолчанию нижняя граница всех размерностей массива равна одному. Чтобы представить массивы с другими нижними границами, перед содержимым массива можно указать диапазоны индексов. Такое оформление массива будет содержать квадратные скобки (<literal>[]</literal>) вокруг нижней и верхней границ каждой размерности с двоеточием (<literal>:</literal>) между ними. За таким указанием размерности следует знак равно (<literal>=</literal>). Например: <programlisting>SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
 FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;

 e1 | e2
----+----
  1 |  6
(1 row)</programlisting> Процедура вывода массива включает в результат явное указание размерностей, только если нижняя граница в одной или нескольких размерностях отличается от 1.</para>

  <para>Если в качестве значения элемента задаётся <literal>NULL</literal> (в любом регистре), этот элемент считается равным непосредственно NULL. Если же оно включает кавычки или обратную косую черту, элементу присваивается текстовая строка <quote>NULL</quote>. Кроме того, для обратной совместимости с версиями <productname>PostgreSQL</productname> до 8.2, параметр конфигурации <xref linkend="guc-array-nulls"/> можно выключить (присвоив ему <literal>off</literal>), чтобы строки <literal>NULL</literal> не воспринимались как значения NULL.</para>

  <para>Как было показано ранее, записывая значение массива, любой его элемент можно заключить в кавычки. Это <emphasis>нужно</emphasis> делать, если при разборе значения массива без кавычек возможна неоднозначность. Например, в кавычки необходимо заключать элементы, содержащие фигурные скобки, запятую (или разделитель, определённый для данного типа), кавычки, обратную косую черту, а также пробельные символы в начале или конце строки. Пустые строки и строки, содержащие одно слово <literal>NULL</literal>, также нужно заключать в кавычки. Чтобы включить кавычки или обратную косую черту в значение, заключённое в кавычки, используйте спецпоследовательности с обратной косой чертой. С другой стороны, чтобы обойтись без кавычек, такими спецпоследовательностями можно защитить все символы в данных, которые могут быть восприняты как часть синтаксиса массива.</para>

  <para>Перед открывающей и после закрывающей скобки можно добавлять пробельные символы. Пробелы также могут окружать каждую отдельную строку значения. Во всех случаях такие пробельные символы игнорируются. Однако все пробелы в строках, заключённых в кавычки, или окружённые не пробельными символами, напротив, учитываются.</para>

 <note>
  <para>Помните, что написанная SQL-команда прежде всего интерпретируется как текстовая строка, а затем как массив. Вследствие этого число символов обратной косой черты удваивается. Например, чтобы ввести в массив значения типа <type>text</type> с обратной косой чертой и кавычками, команду нужно будет записать так: <programlisting>INSERT ... VALUES (E'{"\\\\","\\""}');</programlisting> Сначала обработчик спецпоследовательностей удаляет один уровень обратной косой черты, так что анализатор значения массива получает на вход <literal>{"\\","\""}</literal>. В свою очередь, он передаёт эти строки процедуре ввода значения типа <type>text</type>, где они преобразуются в <literal>\</literal> и <literal>"</literal> соответственно. (Если бы мы работали с типом данных, процедура ввода которого также интерпретирует обратную косую черту особым образом, например <type>bytea</type>, нам могло бы понадобиться уже восемь таких символов, чтобы сохранить этот символ в элементе массива.) Во избежание такого дублирования спецсимволов строки можно заключать в доллары (см. <xref remap="4" linkend="sql-syntax-dollar-quoting"/>).</para>
 </note>

 <tip>
  <para>Записывать значения массивов в командах SQL часто бывает удобнее с помощью конструктора <literal>ARRAY</literal> (см. <xref remap="4" linkend="sql-syntax-array-constructors"/>). В <literal>ARRAY</literal> отдельные значения элементов записываются так же, как если бы они не были членами массива.</para>
 </tip>
 </sect2>

</sect1>
