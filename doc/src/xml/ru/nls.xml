<!-- doc/src/xml/nls.xml -->

<chapter id="nls">
 <title>Языковая поддержка</title>

 <sect1 id="nls-translator">
  <title>Переводчику</title>

  <para>Программы <productname>&productname;</productname> (серверные и клиентские) могут выдавать сообщения на предпочитаемом вами языке &mdash; если эти сообщения были переведены. Создание и поддержка переведённых наборов сообщений предполагает помощь со стороны людей, которые хорошо говорят на своём языке и хотят сотрудничать с <productname>&productname;</productname>. Для этого совершенно не обязательно быть программистом. В данном разделе объясняется, как можно помочь.</para>

  <sect2>
   <title>Требования</title>

   <para>Мы не будем оценивать ваши языковые навыки &mdash; данный раздел посвящён средствам программного обеспечения. Теоретически, требуется лишь текстовый редактор. Но, скорее всего, вы захотите проверить свои переведённые сообщения. Когда вы выполняете <command>configure</command>, обязательно используйте параметр <option>--enable-nls</option>. Это также проверит библиотеку <application>libintl</application> и программу <filename>msgfmt</filename>, которые понадобятся всем пользователям в любом случае. Чтобы проверить свою работу, следуйте соответствующим разделам инструкций по установке.</para>

   <para>Если вы захотите выполнить перевод или слияние каталога сообщений (описано ниже), вам понадобятся, соответственно, программы <filename>xgettext</filename> и <filename>msgmerge</filename> в GNU-совместимой реализации. Позднее, мы постараемся сделать так, что если вы будете использовать дистрибутив исходников, вам не понадобится <filename>xgettext</filename>. (При работе с Git, вам всё же это будет необходимо). В настоящее время рекомендуется <application>GNU Gettext 0.10.36</application> или более поздняя версия.</para>

   <para>К вашей реализации gettext должна прилагаться документация. Некоторая её часть, возможно, будет продублирована ниже, но более подробную информацию следует искать там.</para>
  </sect2>

  <sect2>
   <title>Основные понятия</title>

   <para>Пары оригинальных (английских) сообщений и их (предположительно) переведённых эквивалентов хранятся в <firstterm>каталогах сообщений</firstterm>, по одному для каждой программы (хотя связанные программы могут иметь общий каталог) и для каждого языка перевода. Существует два формата, поддерживающих каталоги сообщений: Первый — <quote>PO</quote> (Portable Object, переносимый объект), который является простым текстовым файлом с особым синтаксисом, редактируемый переводчиками. Второй — <quote>MO</quote> (Machine Object, машинный объект), который является двоичным файлом, генерируемым из соответствующего файла PO, и используется при выполнении интернационализированной программы. Переводчики не работают с файлами MO; фактически с ними едва ли кто-то работает напрямую.</para>

   <para>Файл каталога сообщений, как можно было предположить, имеет расширение <filename>.po</filename> или <filename>.mo</filename>. Базовым именем является либо имя сопровождаемой им программы, либо язык, для которого создан файл, в зависимости от ситуации. Это создаёт некоторую путаницу. Например, <filename>psql.po</filename> (файл PO для psql) или <filename>fr.mo</filename> (файл MO на французском).</para>

   <para>Здесь проиллюстрирован формат файлов PO: <programlisting># comment

msgid "original string"
msgstr "translated string"

msgid "more original"
msgstr "another translated"
"string can be broken up like this"

...</programlisting> Строки msgid извлекаются из исходного кода программы (что необязательно, но это наиболее распространённый способ). Строки msgstr изначально пусты, и переводчик заполняет их переводами. Строки могут содержать экранирующие спецсимволы в стиле С и занимать несколько строк, как в приведённом примере. (Следующая строка должна начинаться с начала строки.)</para>

   <para>Символ # обозначает начало комментария. Если сразу за символом # следует пробел, то этим комментарием управляет переводчик. Комментарии также могут быть автоматическими, у которых сразу за # следует символ, отличный от пробела. Они управляются различными инструментами, которые работают с файлами PO и предназначены для переводчиков. <programlisting>#. automatic comment
#: filename.c:1023
#, flags, flags</programlisting> Комментарии в стиле #. извлекаются из исходного файла, где используется сообщение. Возможно, программист вставил информацию для переводчика, например, о предполагаемом выравнивании. Комментарий #: указывает точное место (места), где сообщение используется в исходном коде. Переводчику не нужно смотреть на исходный код программы, но он может это сделать, если сомневается в точности перевода. Комментарии #, содержат флаги, которые некоторым образом описывают сообщение. В настоящее время существует два флага: <literal>fuzzy</literal> устанавливается, если сообщение, возможно, стало неактуально по причине изменений в исходном коде программы. Переводчик может проверить это и, возможно, удалить флаг fuzzy. Заметьте, что fuzzy сообщения недоступны конечному пользователю. Другой флаг это <literal>c-format</literal>, который указывает, что сообщение является шаблоном формата в стиле <function>printf</function>. Это означает, что перевод также должен быть строкой формата с таким же количеством и типом "заполнителей". Существуют средства, которые распознают и проверяют флаги c-format.</para>
  </sect2>

  <sect2>
   <title>Создание и управление каталогами сообщений</title>

   <para>Итак, как же создать <quote>blank</quote> каталог сообщений? Во-первых, зайдите в каталог, содержащий программу, сообщения которой необходимо перевести. Если имеется файл <filename>nls.mk</filename>, данная программа подготовлена к переводу.</para>

   <para>Если уже есть некоторые <filename>.po</filename> файлы, то кто-то уже занимался переводом. Файлы получают имя <filename><replaceable>language</replaceable>.po</filename>, где <replaceable>language</replaceable> это <ulink url="http://www.loc.gov/standards/iso639-2/php/English_list.php"> двухбуквенный языковой код ISO 639-1 (в нижнем регистре)</ulink>, например, <filename>fr.po</filename> для французского. Если требуется больше одного перевода на какой-либо язык, файлы могут также быть названы <filename><replaceable>language</replaceable>_<replaceable>region</replaceable>.po</filename>, где <replaceable>region</replaceable> это <ulink url="http://www.iso.org/iso/country_names_and_code_elements"> двухбуквенный код страны ISO 3166-1 (в верхнем регистре)</ulink>, например, <filename>pt_BR.po</filename> для португальского в Бразилии. Если найден необходимый язык, можно просто начать работать над этим файлом.</para>

   <para>Если необходимо начать новый перевод, сначала выполните команду: <programlisting>make init-po</programlisting> В результате будет создан файл <filename><replaceable>progname</replaceable>.pot</filename>. (<filename>.pot</filename>, чтобы отличать его от файлов PO, находящихся <quote>в эксплуатации</quote>. <literal>T</literal> означает <quote>шаблон</quote>.) Скопируйте данный файл в <filename><replaceable>language</replaceable>.po</filename> и редактируйте его. Чтобы сообщить о том, что новый язык доступен, также редактируйте файл <filename>nls.mk</filename> и добавляйте языковой код (или код языка и страны) к строке, которая выглядит следующим образом: <programlisting>AVAIL_LANGUAGES := de fr</programlisting> (Конечно, и другие языки могут появиться.)</para>

   <para>По мере развития базовой программы или библиотеки, сообщения могут быть изменены или добавлены программистами. В этом случае нет необходимости начинать с нуля. Вместо этого выполните команду: <programlisting>make update-po</programlisting> что создаст новый пустой файл каталога сообщений (файл с расширением pot, с которого вы начали) и объединит его с существующими файлами PO. Если алгоритм слияния не распознаёт конкретное сообщение, он ставит пометку <quote>fuzzy</quote>, как говорилось выше. Новый файл PO сохраняется с расширением <filename>.po.new</filename>.</para>
  </sect2>

  <sect2>
   <title>Редактирование файлов PO</title>

   <para>Файлы PO можно редактировать при помощи обычного текстового редактора. Переводчику нужно лишь вставить перевод между кавычками после директивы msgstr, добавить комментарии и изменить флаг fuzzy. Существует также режим PO для Emacs, который представляется довольно полезным.</para>

   <para>Файлы PO не обязательно должны быть полностью заполнены. Программа автоматически вернётся к использованию исходной строки, если перевод недоступен (или отсутствует). Вы вполне можете предлагать для включения в исходный код неполный перевод; это даст возможность другим продолжить работу над ним. Однако после слияния рекомендуется в первую очередь удалить ненужные неточные соответствия. Помните, что неточные соответствия в итоге не будут использоваться, они могут лишь подсказывать, каким мог бы быть перевод похожей строки.</para>

   <para>Ниже описаны моменты, которые следует учитывать при редактировании переводов: <itemizedlist>
     <listitem>
      <para>Если оригинал заканчивается переводом строки, важно, чтобы это было отражено и в переводе. То же относится к табуляции, и т. п.</para>
     </listitem>

     <listitem>
      <para>Если оригиналом является строка форматирования <function>printf</function>, то перевод должен иметь такой же вид. Перевод также должен иметь те же спецификаторы формата в том же порядке. Иногда правила языка таковы, что это невозможно или как минимум нелепо. В таком случае можно модифицировать спецификаторы формата подобным образом: <programlisting>msgstr "Die Datei %2$s hat %1$u Zeichen."</programlisting> Тогда первый заполнитель просто использует второй аргумент из списка.<literal><replaceable>digits</replaceable>$</literal> должен стоять сразу за % до любых других модификаторов формата. (Эта возможность действительно существует в семействе функций <function>printf</function>. Вы, возможно, не слышали о ней раньше, потому что она мало используется где-либо кроме интернационализации сообщений.)</para>
     </listitem>

     <listitem>
      <para>Если исходная строка содержит лингвистическую ошибку, сообщите об этом (или исправьте самостоятельно в исходном коде программы) и переведите правильно. Верная строка может быть добавлена, когда исходный программный код будет обновлен. Если исходная строка содержит фактическую ошибку, сообщите об этом (или исправьте самостоятельно) и не переводите её. Вместо этого, можно отметить строку, оставив комментарий в файле PO.</para>
     </listitem>

     <listitem>
      <para>Сохраняйте стиль и тон исходной строки. В частности, сообщения, не являющиеся предложениями (<literal>cannot open file %s</literal>), вероятно, не следует начинать с заглавной буквы (если в вашем языке есть разделение на регистры) или заканчивать точкой (если в вашем языке используются знаки препинания). Дополнительно см. <xref remap="4" linkend="error-style-guide"/>.</para>
     </listitem>

     <listitem>
      <para>Если вы не знаете, что означает какое-либо сообщение, или если оно допускает двоякое толкование, обратитесь за помощью через список рассылки разработчиков. По всей вероятности, англоговорящие пользователи могут также его не понять или найти двусмысленным, поэтому лучше исправить это сообщение.</para>
     </listitem>

    </itemizedlist></para>
  </sect2>

 </sect1>


 <sect1 id="nls-programmer">
  <title>Программисту</title>

  <sect2 id="nls-mechanics">
   <title>Механизмы</title>

  <para>Данный раздел описывает как добавить языковую поддержку в программе или библиотеке, которая является частью дистрибутива <productname>&productname;</productname>. В настоящий момент это относится только к программам на языке С.</para>

  <procedure>
   <title>Добавление языковой поддержки для программы</title>

   <step>
    <para>Вставьте этот код в начало программы: <programlisting>#ifdef ENABLE_NLS
#include &lt;locale.h&gt;
#endif

...

#ifdef ENABLE_NLS
setlocale(LC_ALL, "");
bindtextdomain("<replaceable>progname</replaceable>", LOCALEDIR);
textdomain("<replaceable>progname</replaceable>");
#endif</programlisting> (<replaceable>progname</replaceable> фактически может быть выбрана произвольно.)</para>
   </step>

   <step>
    <para>Везде, где сообщение нуждается в переводе, необходимо вставить вызов <function>gettext()</function>. Например: <programlisting>fprintf(stderr, "panic level %d\n", lvl);</programlisting> нужно заменить на: <programlisting>fprintf(stderr, gettext("panic level %d\n"), lvl);</programlisting> (<symbol>gettext</symbol> определяется как холостая команда, если NLS поддержка не настроена.)</para>

    <para>Это часто приводит к немалой путанице. Один из распространённых подходов в этом случае: <programlisting>#define _(x) gettext(x)</programlisting> Ещё одно решение допустимо, если программа часто выполняет обмен данными через одну или несколько функций, таких как <function>ereport()</function> в серверном процессе. Тогда вы выполняете внутренний вызов функции <function>gettext</function> для каждой входящей строки.</para>
   </step>

   <step>
    <para>Добавьте файл <filename>nls.mk</filename> в каталог с исходными кодами программы. Данный файл будет считаться сборочным файлом (makefile). В нём необходимо выполнить присвоение значений для следующих переменных: <variablelist>
      <varlistentry>
       <term><varname>CATALOG_NAME</varname></term>

       <listitem>
        <para>Имя программы, которое указано в вызове <function>textdomain()</function>.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>AVAIL_LANGUAGES</varname></term>

       <listitem>
        <para>Список выполненных переводов (изначально пустой).</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>GETTEXT_FILES</varname></term>

       <listitem>
        <para>Список файлов, которые содержат подлежащие переводу строки, т. е. помеченные <function>gettext</function> или альтернативным решением. В итоге, в него будут включены почти все исходные файлы программы. Если список станет слишком длинным, можно первый <quote>file</quote> сделать <literal>+</literal> а второе слово — файлом, который содержит по одному имени файла на строку.</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>GETTEXT_TRIGGERS</varname></term>

       <listitem>
        <para>Утилитам, которые генерируют каталоги сообщений для работы переводчиков, должно быть известно, какие вызовы функции содержат строки, подлежащие переводу. По умолчанию распознаются только вызовы <function>gettext()</function>. Если вы использовали <function>_</function> или другие идентификаторы, необходимо перечислить их здесь. Если подлежащая переводу строка не является первым аргументом, необходимо, чтобы элемент имел форму <literal>func:2</literal> (для второго аргумента). Если функция поддерживает сообщения в форме множественного числа, элемент должен выглядеть следующим образом <literal>func:1,2</literal> (идентификация аргументов в виде сообщений в форме единственного и множественного числа).</para>
       </listitem>
      </varlistentry>
     </variablelist></para>
   </step>

  </procedure>

  <para>Система сборки автоматически соберёт и установит каталоги сообщений.</para>
  </sect2>

  <sect2 id="nls-guidelines">
   <title>Рекомендации по написанию сообщений</title>

  <para>Ниже описаны некоторые рекомендации по написанию сообщений, которые легко перевести. <itemizedlist>
    <listitem>
     <para>Не составляйте предложения во время выполнения. Например: <programlisting>printf("Files were %s.\n", flag ? "copied" : "removed");</programlisting> Порядок слов в предложении может отличаться в других языках. Также, даже если вы не забываете вызывать <function>gettext()</function> для каждого фрагмента, возможно, что по отдельности они не будут переведены хорошо. Лучше продублировать небольшую часть кода, чтобы каждое сообщение было переведено как единое целое. Лишь цифры, имена файлов и подобные текущие переменные следует вставлять в текст сообщения во время выполнения.</para>
    </listitem>

    <listitem>
     <para>По тем же причинам следующий подход не будет работать: <programlisting>printf("copied %d file%s", n, n!=1 ? "s" : "");</programlisting> так как это подразумевает, как формируется форма множественного числа. Если вы думаете, что сможете решить это таким способом: <programlisting>if (n==1)
    printf("copied 1 file");
else
    printf("copied %d files", n):</programlisting> возможно, вы будете разочарованы. В некоторых языках существует более двух форм, и они образуются по особым правилам. Обычно лучше сформулировать сообщение, которое позволит полностью избежать этой проблемы, например: <programlisting>printf("number of copied files: %d", n);</programlisting></para>

     <para>Если вы действительно хотите формировать правильно составленные сообщения в форме множественного числа, есть способ этого добиться, но это несколько неудобно. При генерировании первичного или детализированного сообщения об ошибке в <function>ereport()</function>, можно написать так: <programlisting>errmsg_plural("copied %d file",
              "copied %d files",
              n,
              n)</programlisting> Первым аргументом является строка формата, соответствующая форме единственного числа в английском языке, вторым аргументом — строка формата, соответствующая форме множественного числа в английском языке, и третьим аргументом — управляющее целочисленное значение, которое определяет, какую форму (единственного или множественного числа) использовать. Последующие аргументы форматируются на основе строки формата, как обычно. (Как правило, значение аргумента для управления формой множественного числа будет также одним из значений, подлежащих форматированию, поэтому оно должно быть записано дважды.) В английском языке важно лишь, является ли значение <replaceable>n</replaceable> единицей или нет, но в других языках может быть много различных форм множественного числа. Переводчик рассматривает две английские формы как группу и имеет возможность задать несколько вариантов замены строк, при этом подходящий вариант выбирается исходя из текущего значения <replaceable>n</replaceable>.</para>

     <para>Если вам нужно составить сообщение в форме множественного числа, которое не используется непосредственно при выводе сообщений в <function>errmsg</function> или <function>errdetail</function>, вы должны воспользоваться базовой функцией <function>ngettext</function>. См. документацию по gettext.</para>
    </listitem>

    <listitem>
     <para>Если вы хотите передать какую-либо информацию переводчику, например о том, насколько сообщение соотносится с другими выходными данными, перед строкой должен появиться комментарий, который начинается с <literal>translator</literal>, например: <programlisting>/* translator: This message is not what it seems to be. */</programlisting> Эти комментарии копируются в файлы каталога сообщений, чтобы переводчик мог их видеть.</para>
    </listitem>
   </itemizedlist></para>
  </sect2>
 </sect1>

</chapter>
