<!-- doc/src/xml/plhandler.xml -->

 <chapter id="plhandler">
   <title>Написание обработчика процедурного языка</title>

   <indexterm zone="plhandler"><primary>процедурный язык</primary> <secondary>обработчик</secondary></indexterm>

   <para>Все функции, написанные на языке, вызываемом не через текущий интерфейс <quote>версии 1</quote> для компилируемых языков (а именно, это функции на процедурных языках, функции, написанные на SQL, и функции, использующие интерфейс компилируемых языков версии 0) выполняются через <firstterm>обработчик вызова</firstterm> для заданного языка. Задача такого обработчика вызова — выполнить функцию должным образом, например, интерпретируя для этого её исходный текст. В этой главе в общих чертах рассказывается, как можно написать обработчик нового процедурного языка.</para>

   <para>Обработчик вызова процедурного языка — это <quote>обычная </quote> функция, которая разрабатывается на компилируемом языке, таком как C, вызывается через интерфейс версии 1, и регистрируется в <productname>&productname;</productname> как не принимающая аргументы и возвращающая тип <type>language_handler</type>. Этот специальный псевдотип помечает функцию как обработчик вызова и препятствует её вызову непосредственно из команд SQL. Более подробно соглашение о вызовах и динамическая загрузка кода на C описывается в <xref remap="6" linkend="xfunc-c"/>.</para>

   <para>Обработчик вызова вызывается так же, как и любая другая функция: он получает указатель на переменную <type>struct</type> <structname>FunctionCallInfoData</structname>, содержащую значения аргументов и информацию о вызываемой функции, и должен вернуть результат типа <type>Datum</type> (и, возможно, установить признак <structfield>isnull</structfield> в структуре <structname>FunctionCallInfoData</structname>, если нужно вернуть результат SQL NULL). Отличие обработчика вызова от обычной вызываемой функцией состоит в том, что поле <structfield>flinfo-&gt;fn_oid</structfield> структуры <structname>FunctionCallInfoData</structname> для него будет содержать OID вызываемой функции, а не самого обработчика. По этому OID обработчик вызова должен понять, какую функцию вызывать. Кроме того, список передаваемых аргументов для него формируется в соответствии с объявлением целевой функции, а не обработчика вызова.</para>

   <para>Обработчик вызова сам должен выбрать запись функции из системного каталога <classname>pg_proc</classname> и проанализировать типы аргументов и результата вызываемой функции. Содержимое предложения <literal>AS</literal> команды <command>CREATE FUNCTION</command> для этой функции будет находиться в столбце <literal>prosrc</literal> строки в <classname>pg_proc</classname>. Обычно это исходный текст на процедурном языке, но в принципе это может быть и что-то другое, например, путь к файлу или иные данные, говорящие обработчику вызова, что именно делать.</para>

   <para>Часто функция многократно вызывается в одном SQL-операторе. Чтобы в таких случаях избежать повторных обращений за информацией о вызываемой функции, обработчик вызова может воспользоваться полем <structfield>flinfo-&gt;fn_extra</structfield>. Изначально оно содержит <symbol>NULL</symbol>, но обработчик вызова может поместить в него указатель на требуемую информацию. При последующих вызовах, если поле <structfield>flinfo-&gt;fn_extra</structfield> будет отлично от <symbol>NULL</symbol>, им можно воспользоваться и пропустить шаг получения этой информации. Обработчик вызова должен позаботиться о том, чтобы указатель в <structfield>flinfo-&gt;fn_extra</structfield> указывал на блок памяти, который не будет освобождён раньше, чем завершится запрос (именно столько может существовать структура <structname>FmgrInfo</structname>). В качестве одного из вариантов, этого можно добиться, разместив дополнительные данные в контексте памяти, заданном в <structfield>flinfo-&gt;fn_mcxt</structfield>; срок жизни таких данных обычно совпадает со сроком жизни самой структуры <structname>FmgrInfo</structname>. С другой стороны, обработчик может выбрать и более долгоживущий контекст памяти с тем, чтобы кешировать определения функций и между запросами.</para>

   <para>Когда функция на процедурном языке вызывается как триггер, ей не передаются аргументы обычным способом; вместо этого поле <structfield>context</structfield> в <structname>FunctionCallInfoData</structname> указывает на структуру <structname>TriggerData</structname>, тогда как при обычном вызове функции оно содержит <symbol>NULL</symbol>. Обработчик языка, в свою очередь, должен каким-либо образом предоставить эту информацию функциям на этом процедурном языке.</para>

   <para>Шаблон обработчика процедурного языка, написанный на C, выглядит так: <programlisting>#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Вызывается как триггерная процедура
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;

        retval = ...
    }
    else
    {
        /*
         * Вызывается как функция
         */

        retval = ...
    }

    return retval;
}</programlisting> Чтобы завершить код обработчика, нужно добавить лишь несколько тысяч строк вместо многоточий.</para>

   <para>Скомпилировав функцию-обработчик языка в загружаемый модуль (см. <xref remap="4" linkend="dfunc"/>), этот язык (plsample) можно зарегистрировать следующими командами: <programlisting>CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<replaceable>имя_файла</replaceable>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;</programlisting></para>

   <para>Хотя обработчика вызова достаточно для создания простейшего процедурного языка, есть ещё две функции, которые можно реализовать дополнительно, чтобы пользоваться языком было удобнее: функция <firstterm>проверки</firstterm> и <firstterm>обработчик внедрённого кода</firstterm>. Функцию проверки можно реализовать, чтобы производить проверку синтаксиса языка во время <xref linkend="sql-createfunction"/>. Если же реализован обработчик внедрённого кода, этот язык будет поддерживать выполнение анонимных блоков кода командой <xref linkend="sql-do"/>.</para>

   <para>Если для процедурного языка предоставляется функция проверки, она должна быть объявлена как функция, принимающая один параметр типа <type>oid</type>. Результат функции проверки игнорируется, так что она обычно объявляется как возвращающая тип <type>void</type>. Эта функция будет вызываться в конце выполнения команды <command>CREATE FUNCTION</command>, создающей или изменяющей функцию, написанную на процедурном языке. Переданный ей OID указывает на строку в <classname>pg_proc</classname> для этой функции. Функция проверки должна выбрать эту строку обычным образом и произвести все необходимые проверки. Прежде всего нужно вызвать <function>CheckFunctionValidatorAccess()</function>, чтобы отличить явные вызовы этой функции от происходящих при выполнении команды <command>CREATE FUNCTION</command>. Затем обычно проверяется, например, что типы аргументов и результата функции поддерживаются языком и что тело функции синтаксически правильно для данного языка. Если функция проверки заключает, что всё в порядке, она должна просто завершиться. Если же она обнаруживает ошибку, она должна сообщить о ней через обычный механизм <function>ereport()</function>. Выданная таким образом ошибка приведёт к откату транзакции, так что определение некорректной функции зафиксировано не будет.</para>

   <para>Функции проверки обычно должны учитывать параметр <xref linkend="guc-check-function-bodies"/>: если он отключён, то дорогостоящие или зависящие от контекста проверки содержимого функции выполнять не следует. Если язык подразумевает выполнение кода в процессе компиляции, проверяющая функция должна избегать проверок, которые влекут за собой такое выполнение. В частности, указанный параметр отключает утилита <application>pg_dump</application>, чтобы она могла загружать функции на процедурных языках, не заботясь о побочных эффектах или зависимостях содержимого функций от других объектов базы. (Вследствие этого требования, обработчик языка не должен полагать, что функция прошла полную проверку. Смысл существования функции проверки не в том, чтобы убрать эти проверки из обработчика вызова, а в том, чтобы немедленно уведомить пользователя об очевидных ошибках при выполнении <command>CREATE FUNCTION</command>.) Хотя выбор, что именно должно проверяться, по большому счёту остаётся за функцией проверки, заметьте, что основной код <command>CREATE FUNCTION</command> выполняет присваивания <literal>SET</literal>, связанные с функцией, только когда <varname>check_function_bodies</varname> включён. Таким образом, проверки, результаты которых могут зависеть от параметров GUC, определённо должны опускаться, когда <varname>check_function_bodies</varname> отключён, во избежание ложных ошибок при восстановлении базы из копии.</para>

   <para>Если для процедурного языка предоставляется обработчик встроенного кода, он должен объявляться в виде функции, принимающей один параметр типа <type>internal</type>. Результат такого обработчика игнорируется, поэтому обычно он объявляется как возвращающий тип <type>void</type>. Обработчик встроенного кода будет вызываться при выполнении оператора <command>DO</command> с данным процедурным языком. В качестве параметра ему на самом деле передаётся указатель на структуру <structname>InlineCodeBlock</structname>, содержащую информацию о параметрах <command>DO</command>, в частности, текст выполняемого анонимного блока внедрённого кода.</para>

   <para>Все подобные объявления функций, а также саму команду <command>CREATE LANGUAGE</command>, рекомендуется упаковывать в <firstterm>расширение</firstterm> так, чтобы для установки языка было достаточно простой команды <command>CREATE EXTENSION</command>. За информацией о разработке расширений обратитесь к <xref remap="3" linkend="extend-extensions"/>.</para>

   <para>Реализация процедурных языков, включённых в стандартный дистрибутив, может послужить хорошим примером при написании собственных обработчиков языков. Её вы можете найти в подкаталоге <filename>src/pl</filename> дерева исходного кода. Некоторые полезные детали также можно узнать на странице справки <xref linkend="sql-createlanguage"/>.</para>

 </chapter>
