<!-- doc/src/xml/maintenance.xml -->

<chapter id="maintenance">
 <title>Регламентные задачи обслуживания базы данных</title>

 <indexterm zone="maintenance"><primary>обслуживание</primary></indexterm>

 <indexterm zone="maintenance"><primary>регламентное обслуживание</primary></indexterm>

  <para>Как и в любой СУБД, в <productname>&productname;</productname> для достижения оптимальной производительности нужно регулярно выполнять определённые процедуры. Задачи, которые рассматриваются в этой главе, являются <emphasis>обязательными</emphasis>, но они по природе своей повторяющиеся и легко поддаются автоматизации с использованием стандартных средств, таких как задания <application>cron</application> или <application>Планировщика задач</application> в Windows. Создание соответствующих заданий и контроль над их успешным выполнением входят в обязанности администратора базы данных.</para>

  <para>Одной из очевидных задач обслуживания СУБД является регулярное создание резервных копий данных. При отсутствии свежей резервной копии у вас не будет шанса восстановить систему после катастрофы (сбой диска, пожар, удаление важной таблицы по ошибке и т. д.). Механизмы резервного копирования и восстановления в <productname>&productname;</productname> детально рассматриваются в <xref remap="6" linkend="backup"/>.</para>

  <para>Другое важное направление обслуживания СУБД — периодическая <quote>очистка</quote> базы данных. Эта операция рассматривается в <xref remap="6" linkend="routine-vacuuming"/>. С ней тесно связано обновление статистики, которая будет использоваться планировщиком запросов; оно рассматривается в <xref remap="6" linkend="vacuum-for-statistics"/>.</para>

  <para>Ещё одной задачей, требующей периодического выполнения, является управление файлами журнала. Она рассматривается в <xref remap="6" linkend="logfile-maintenance"/>.</para>

  <para>Для контроля состояния базы данных и для отслеживания нестандартных ситуаций можно использовать <ulink url="http://bucardo.org/wiki/Check_postgres"><application>check_postgres</application></ulink>. Скрипт <application>check_postgres</application> можно интегрировать с Nagios и MRTG, однако он может работать и самостоятельно.</para>

  <para>По сравнению с некоторыми другими СУБД <productname>&productname;</productname> неприхотлив в обслуживании. Тем не менее, должное внимание к вышеперечисленным задачам будет значительно способствовать комфортной и производительной работе с СУБД.</para>

 <sect1 id="routine-vacuuming">
  <title>Регламентная очистка</title>

  <indexterm zone="routine-vacuuming"><primary>очистка</primary></indexterm>

  <para>Базы данных <productname>&productname;</productname> требуют периодического проведения процедуры обслуживания, которая называется <firstterm>очисткой</firstterm>. Во многих случаях очистку достаточно выполнять с помощью <firstterm>демона автоочистки</firstterm>, который описан в <xref remap="6" linkend="autovacuum"/>. Возможно, в вашей ситуации для получения оптимальных результатов потребуется настроить описанные там же параметры автоочистки. Некоторые администраторы СУБД могут дополнить или заменить действие этого демона командами <command>VACUUM</command> (обычно они выполняются по расписанию в заданиях <application>cron</application> или <application>Планировщика задач</application>). Чтобы правильно организовать очистку вручную, необходимо понимать темы, которые будут рассмотрены в следующих подразделах. Администраторы, которые полагаются на автоочистку, возможно, всё же захотят просмотреть этот материал, чтобы лучше понимать и настраивать эту процедуру.</para>

  <sect2 id="vacuum-basics">
   <title>Основные принципы очистки</title>

   <para>Команды <xref linkend="sql-vacuum"/> в <productname>&productname;</productname> должны обрабатывать каждую таблицу по следующим причинам: <orderedlist>
     <listitem>
      <simpara>Для высвобождения или повторного использования дискового пространства, занятого изменёнными или удалёнными строками.</simpara>
     </listitem>

     <listitem>
      <simpara>Для обновления статистики по данным, используемой планировщиком запросов <productname>&productname;</productname>.</simpara>
     </listitem>

     <listitem>
      <simpara>Для обновления карты видимости, которая ускоряет <link linkend="indexes-index-only-scans">сканирование только индекса</link>.</simpara>
     </listitem>

     <listitem>
      <simpara>Для сжатия <literal>pg_clog</literal> и <literal>pg_multixact</literal>.</simpara>
     </listitem>
    </orderedlist> Разные причины диктуют выполнение действий <command>VACUUM</command> с разной частотой и в разном объёме, как рассматривается в следующих подразделах.</para>

   <para>Существует два варианта <command>VACUUM</command>: обычный <command>VACUUM</command> и <command>VACUUM FULL</command>. Команда <command>VACUUM FULL</command> может высвободить больше дискового пространства, однако работает медленнее. Кроме того, обычная команда <command>VACUUM</command> может выполняться параллельно с использованием производственной базы данных. (При этом такие команды как <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</command> будут выполняться нормально, хотя нельзя будет изменить определение таблицы командами типа <command>ALTER TABLE</command>.) Команда <command>VACUUM FULL</command> требует исключительной блокировки обрабатываемой таблицы и поэтому не может выполняться параллельно с другими операциями с этой таблицей. По этой причине администраторы, как правило, должны стараться использовать обычную команду <command>VACUUM</command> и избегать <command>VACUUM FULL</command>.</para>

   <para>Команда <command>VACUUM</command> порождает существенный объём трафика ввода/вывода, который может стать причиной низкой производительности в других активных сеансах. Это влияние фоновой очистки можно регулировать, настраивая параметры конфигурации (см. <xref remap="4" linkend="runtime-config-resource-vacuum-cost"/>).</para>
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
   <title>Высвобождение дискового пространства</title>

   <indexterm zone="vacuum-for-space-recovery"><primary>дисковое пространство</primary></indexterm>

   <para>В <productname>&productname;</productname> команды <command>UPDATE</command> или <command>DELETE</command> не вызывают немедленного удаления старой версии изменяемых строк. Этот подход необходим для реализации эффективного многоверсионного управления конкурентным доступом (<acronym>MVCC</acronym>, см. <xref remap="4" linkend="mvcc"/>): версия строки не должна удаляться до тех пор, пока она остаётся потенциально видимой для других транзакций. Однако в конце концов устаревшая или удалённая версия строки оказывается не нужна ни одной из транзакций. После этого занимаемое ей место должно быть освобождено и может быть отдано новым строкам, во избежание неограниченного роста потребности в дисковом пространстве. Это происходит при выполнении команды <command>VACUUM</command>.</para>

   <para>Обычная форма <command>VACUUM</command> удаляет неиспользуемые версии строк в таблицах и индексах и помечает пространство свободным для дальнейшего использования. Однако это дисковое пространство не возвращается операционной системе, кроме особого случая, когда полностью освобождаются одна или несколько страниц в конце таблицы и можно легко получить исключительную блокировку таблицы. Команда <command>VACUUM FULL</command>, напротив, кардинально сжимает таблицы, записывая абсолютно новую версию файла таблицы без неиспользуемого пространства. Это минимизирует размер таблицы, однако может занять много времени. Кроме того, для этого требуется больше места на диске для записи новой копии таблицы до завершения операции.</para>

   <para>Обычно цель регулярной очистки — выполнять простую очистку (<command>VACUUM</command>) достаточно часто, чтобы не возникала необходимость в <command>VACUUM FULL</command>. Демон автоочистки пытается работать в этом режиме, и на самом деле он сам никогда не выполняет <command>VACUUM FULL</command>. Основная идея такого подхода не в том, чтобы минимизировать размер таблиц, а в том, чтобы поддерживать использование дискового пространства на стабильном уровне: каждая таблица занимает объём, равный её минимальному размеру, плюс объём, который был занят между процедурами очистки. Хотя с помощью <command>VACUUM FULL</command> можно сжать таблицу до минимума и возвратить дисковое пространство операционной системе, большого смысла в этом нет, если в будущем таблица так же вырастет снова. Следовательно, для активно изменяемых таблиц лучше с умеренной частотой выполнять <command>VACUUM</command>, чем очень редко выполнять <command>VACUUM FULL</command>.</para>

   <para>Некоторые администраторы предпочитают планировать очистку БД самостоятельно, например, проводя все работы ночью в период низкой загрузки. Однако очистка только по фиксированному расписанию плоха тем, что при резком скачке интенсивности изменений таблица может разрастить настолько, что для высвобождения пространства действительно понадобится выполнить <command>VACUUM FULL</command>. Использование демона автоочистки снимает эту проблему, поскольку он планирует очистку динамически, отслеживая интенсивность изменений. Полностью отключать этот демон может иметь смысл, только если вы имеете дело с предельно предсказуемой загрузкой. Возможен и компромиссный вариант — настроить параметры демона автоочистки так, чтобы он реагировал только на необычайно высокую интенсивность изменений и мог удержать ситуацию под контролем, в то время как команды <command>VACUUM</command>, запускаемые по расписанию, будут выполнять основную работу в периоды нормальной загрузки.</para>

   <para>Если же автоочистка не применяется, обычно планируется выполнение <command>VACUUM</command> для всей базы данных раз в сутки в период низкой активности, и в случае необходимости оно дополняется более частой очисткой интенсивно изменяемых таблиц. (В некоторых ситуациях, когда изменения производятся крайне интенсивно, самые востребованные таблицы могут очищаться раз в несколько минут.) Если в вашем кластере несколько баз данных, не забывайте выполнять <command>VACUUM</command> для каждой из них; при этом может быть полезна программа <xref linkend="app-vacuumdb"/>.</para>

   <tip>
   <para>Результат обычного <command>VACUUM</command> может быть неудовлетворительным, когда вследствие массового изменения или удаления строк в таблице оказывается много мёртвых версий строк. Если у вас есть такая таблица и вам нужно освободить лишнее пространство, которое она занимает, используйте команду <command>VACUUM FULL</command> или, в качестве альтернативы, <xref linkend="sql-cluster"/> или один из вариантов <xref linkend="sql-altertable"/>, выполняющий перезапись таблицы. Эти команды записывают абсолютно новую копию таблицы и строят для неё индексы. Все эти варианты требуют исключительной блокировки. Заметьте, что они также на время требуют дополнительного пространства на диске в объёме, приблизительно равном размеру таблицы, поскольку старые копии таблицы и индексов нельзя удалить до завершения создания новых копий.</para>
   </tip>

   <tip>
   <para>Если у вас есть таблица, всё содержимое которой периодически удаляется, рассмотрите возможность использования <xref linkend="sql-truncate"/> вместо <command>DELETE</command> с последующей командой <command>VACUUM</command>. <command>TRUNCATE</command> немедленно удаляет всё содержимое таблицы, не требуя последующей очистки (<command>VACUUM</command> или <command>VACUUM FULL</command>) для высвобождения неиспользуемого дискового пространства. Недостатком такого подхода является нарушение строгой семантики MVCC.</para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>Обновление статистики планировщика</title>

   <indexterm zone="vacuum-for-statistics"><primary>статистика</primary> <secondary>планировщика</secondary></indexterm>

   <indexterm zone="vacuum-for-statistics"><primary>ANALYZE</primary></indexterm>

   <para>Планировщик запросов в <productname>&productname;</productname>, выбирая эффективные планы запросов, полагается на статистическую информацию о содержимом таблиц. Эта статистика собирается командой <xref linkend="sql-analyze"/>, которая может вызываться сама по себе или как дополнительное действие команды <command>VACUUM</command>. Статистика должна быть достаточно точной, так как в противном случае неудачно выбранные планы запросов могут снизить производительность базы данных.</para>

   <para>Демон автоочистки, если он включён, будет автоматически выполнять <command>ANALYZE</command> после существенных изменений содержимого таблицы. Однако администраторы могут предпочесть выполнение <command>ANALYZE</command> вручную, в частности, если известно, что производимые в таблице изменения не повлияют на статистику по <quote>интересным</quote> столбцам. Демон же планирует выполнение <command>ANALYZE</command> в зависимости только от количества вставленных или изменённых строк; он не знает, приведут ли они к значимым изменениям статистики.</para>

   <para>Как и процедура очистки для высвобождения пространства, частое обновление статистики полезнее для интенсивно изменяемых таблиц, нежели для тех таблиц, которые изменяются редко. Однако даже в случае часто изменяемой таблицы обновление статистики может не требоваться, если статистическое распределение данных меняется слабо. Как правило, достаточно оценить, насколько меняются максимальное и минимальное значения в столбцах таблицы. Например, максимальное значение в столбце <type>timestamp</type>, хранящем время изменения строки, будет постоянно увеличиваться по мере добавления и изменения строк; для такого столбца может потребоваться более частое обновление статистики, чем, к примеру, для столбца, содержащего адреса страниц (URL), которые запрашивались с сайта. Столбец с URL-адресами может меняться столь же часто, однако статистическое распределение его значений, вероятно, будет изменяться относительно медленно.</para>

   <para>Команду <command>ANALYZE</command> можно выполнять для отдельных таблиц и даже просто для отдельных столбцов таблицы, поэтому, если того требует приложение, одни статистические данные можно обновлять чаще, чем другие. Однако на практике обычно лучше просто анализировать всю базу данных, поскольку это быстрая операция, так как <command>ANALYZE</command> читает не каждую отдельную строку, а статистически случайную выборку строк таблицы.</para>

   <tip>
    <para>Хотя индивидуальная настройка частоты <command>ANALYZE</command> для отдельных столбцов может быть не очень полезной, смысл может иметь настройка детализации статистики, собираемой командой <command>ANALYZE</command>. Для столбцов, которые часто используются в предложениях <literal>WHERE</literal>, и имеют очень неравномерное распределение данных, может потребоваться более детальная, по сравнению с другими столбцами, гистограмма данных. В таких случаях можно воспользоваться командой <command>ALTER TABLE SET STATISTICS</command> или изменить значение по умолчанию параметра уровня БД <xref linkend="guc-default-statistics-target"/>.</para>

    <para>Кроме того, по умолчанию информация об избирательности функций ограничена. Однако если вы создаёте индекс по выражению с вызовом функции, об этой функции будет собрана полезная статистическая информация, которая может значительно улучшить планы запросов, в которых используется данный индекс.</para>
   </tip>

   <tip>
    <para>Демон автоочистки не выполняет команды <command>ANALYZE</command> для сторонних таблиц, поскольку он не знает, как часто это следует делать. Если для получения качественных планов вашим запросам необходима статистика по сторонним таблицам, будет хорошей идеей дополнительно запускать <command>ANALYZE</command> для них по подходящему расписанию.</para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-visibility-map">
   <title>Обновление карты видимости</title>

   <para>Процедура очистки поддерживает <link linkend="storage-vm">карты видимости</link> для каждой таблицы, позволяющие определить, в каких страницах есть только записи, заведомо видимые для всех активных транзакций (и всех будущих транзакций, пока страница не будет изменена). Это имеет два применения. Во-первых, сам процесс очистки может пропускать такие страницы при следующем запуске, поскольку на этих страницах вычищать нечего.</para>

   <para>Во-вторых, с такими картами <productname>&productname;</productname> может выдавать результаты некоторых запросов, используя только индекс, не обращаясь к данным таблицы. Так как индексы <productname>&productname;</productname> не содержат информацию о видимости записей, при обычном сканировании по индексу необходимо извлечь соответствующую запись из таблицы и проверить её видимость для текущей транзакции. Поэтому при <link linkend="indexes-index-only-scans"><firstterm>сканировании только индекса</firstterm></link>, наоборот, сначала проверяется карта видимости. Если известно, что все записи на странице видимы, то выборку из таблицы можно пропустить. Это наиболее полезно с большими наборах данных, когда благодаря карте видимости можно оптимизировать чтение с диска. Карта видимости значительно меньше таблицы, поэтому она легко помещается в кеш, даже когда объём самих страниц очень велик.</para>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>Принудительное сжатие <literal>pg_clog</literal> и <literal>pg_multixact</literal></title>

   <indexterm zone="vacuum-for-wraparound"><primary>идентификатор транзакции</primary> <secondary>зацикливание</secondary></indexterm>

    <indexterm><primary>зацикливание</primary> <secondary>идентификаторов транзакций</secondary></indexterm>

   <para>В <productname>&productname;</productname> семантика транзакций <link linkend="mvcc-intro">MVCC</link> зависит от возможности сравнения номеров идентификаторов транзакций (<acronym>XID</acronym>): версия строки, у которой XID добавившей её транзакции больше, чем XID текущей транзакции, относится <quote>к будущему</quote> и не должна быть видна в текущей транзакции. В старых версиях идентификаторы транзакций имели ограниченный размер (32 бита), так что кластер, работающий долгое время (более 4 миллиардов транзакций) мог столкнуться с <firstterm>зацикливанием идентификаторов транзакций</firstterm>: счётчик XID прокручивается до нуля, и внезапно транзакции, которые относились к прошлому, оказываются в будущем &mdash; их результаты становятся невидимыми и это означает потерю данных.</para>

   <para>В <productname>Postgres Pro Enterprise</productname> 9.6 были введены 64-битные идентификаторы транзакций, которые не подвержены зацикливанию и для их сравнения не требуется арифметика по модулю 2<superscript>32</superscript>. Заголовок каждого кортежа содержит два идентификатора транзакций, поэтому увеличение их размера повлекло бы большие издержки. Поэтому идентификаторы внутри страницы остались 32-битными, а в заголовок каждой страницы добавлено смещение, которое называется <firstterm>эпохой</firstterm> и добавляется к идентификаторам внутри страницы, чтобы их можно было сравнивать.</para>

   <para>Когда новый идентификатор транзакции не подходит для существующей страницы, согласно её <firstterm>эпохи</firstterm>, эта <firstterm>эпоха</firstterm> смещается. При необходимости эта одна страница также может замораживаться. Оба этих действия выполняются «на лету». Зацикливание на уровне страниц оказывается возможным, только если кто-то будет удерживать снимок, в котором накопилось больше 4 миллиардов транзакций.</para>

   <para>Периодическое выполнение очистки решает эту проблему, потому что процедура <command>VACUUM</command> помечает строки как <emphasis>замороженные</emphasis>, указывая, что они были вставлены транзакцией, зафиксированной достаточно давно, так что эффект добавляющей транзакции с точки зрения MVCC определённо будет виден во всех текущих и будущих транзакциях. Для этого <productname>&productname;</productname> резервирует особый идентификатор, <literal>FrozenTransactionId</literal>, который всегда считается старее любого обычного XID. Замороженные версии строк обрабатываются так, как если бы их вставила транзакция с XID <literal>FrozenTransactionId</literal>, то есть они относятся <quote>к прошлому</quote> для всех обычных транзакций.</para>

   <para>Операция замораживания данных командой <command>VACUUM</command> для предотвращения зацикливания идентификаторов более не требуется, однако эта операция по-прежнему нужна для сжатия <literal>pg_clog</literal> и <literal>pg_multixact</literal>. По историческим причинам операция автоочистки для сжатия <literal>pg_clog</literal> and <literal>pg_multixact</literal> сохранила название «автоочистка для предотвращения зацикливания».</para>

   <note>
    <para>В версиях <productname>PostgreSQL</productname> до 9.4 замораживание было реализовано как замена XID добавления строки специальным идентификатором <literal>FrozenTransactionId</literal>, который можно было увидеть в системной колонке <structname>xmin</structname> данной строки. В новых версиях просто устанавливается битовый флаг, а исходный <structname>xmin</structname> строки сохраняется для возможного расследования в будущем. Однако строки с <structname>xmin</structname>, равным <literal>FrozenTransactionId</literal> (2), можно по-прежнему встретить в базах данных, обновлённых (с применением <application>pg_upgrade</application>) с версий до 9.4.</para>
    <para>Также системные каталоги могут содержать строки со значением <structname>xmin</structname>, равным <literal>BootstrapTransactionId</literal> (1), показывающим, что они были вставлены на первом этапе <application>initdb</application>. Как и <literal>FrozenTransactionId</literal>, этот специальный XID считается более старым, чем любой обычный XID.</para>
   </note>

   <para>Параметр <xref linkend="guc-vacuum-freeze-min-age"/> определяет, насколько старым должен стать XID, чтобы строки с таким XID были заморожены. Увеличение его значения помогает избежать ненужной работы, если строки, которые могли бы быть заморожены в ближайшее время, будут изменены ещё раз, а уменьшение приводит к увеличению количества транзакций, которые могут выполниться, прежде чем потребуется очередная очистка таблицы.</para>

   <para><command>VACUUM</command> определяет, какие страницы таблицы нужно сканировать, анализируя <link linkend="storage-vm">карту видимости</link>. Обычно при этой операции пропускаются страницы, в которых нет мёртвых версий строк, даже если в них могут быть версии строк со старыми XID. Таким образом, обычная команда <command>VACUUM</command> не будет всегда замораживать все версии строк, имеющиеся в таблице. Периодически <command>VACUUM</command> будет также производить <firstterm>агрессивную очистку</firstterm>, пропуская только те страницы, которые не содержат ни мёртвых строк, ни незамороженных значений XID или MXID. Когда <command>VACUUM</command> будет делать это, зависит от параметра <xref linkend="guc-vacuum-freeze-table-age"/>: полностью видимые, но не полностью замороженные страницы будут сканироваться, если число транзакций, прошедших со времени последнего такого сканирования, оказывается больше чем <varname>vacuum_freeze_table_age</varname> минус <varname>vacuum_freeze_min_age</varname>. Если <varname>vacuum_freeze_table_age</varname> равно 0, <command>VACUUM</command> будет применять эту более агрессивную стратегию при каждом сканировании.</para>

   <para>Для любой таблицы, которая может содержать значения XID старше, чем возраст, указанный в конфигурационном параметре <xref linkend="guc-autovacuum-freeze-max-age"/>, вызывается автоочистка. (Это случается, даже если автоочистка отключена.)</para>

   <para>Это означает, что если очистка таблицы не вызывается другим способом, то автоочистка для неё будет вызываться приблизительно через каждые <varname>autovacuum_freeze_max_age</varname> минус <varname>vacuum_freeze_min_age</varname> транзакций. Для таблиц, очищаемых регулярно для высвобождения пространства, это неактуально. В то же время статичные таблицы (включая таблицы, в которых данные вставляются, но не изменяются и не удаляются) не нуждаются в очистке для высвобождения пространства, поэтому для очень больших статичных таблиц имеет смысл увеличить интервал между вынужденными запусками автоочистки. Очевидно, это можно сделать, либо увеличив <varname>autovacuum_freeze_max_age</varname>, либо уменьшив <varname>vacuum_freeze_min_age</varname>.</para>

   <para>Фактический максимум для <varname>vacuum_freeze_table_age</varname> составляет 0.95 * <varname>autovacuum_freeze_max_age</varname>; большее значение будет ограничено этим пределом. Значение, превышающее <varname>autovacuum_freeze_max_age</varname>, не имело бы смысла, поскольку по достижении этого значения в любом случае вызывалась бы автоочистка для сжатия <literal>pg_clog</literal> и <literal>pg_multixact</literal>, а коэффициент 0.95 оставляет немного времени для того, чтобы запустить <command>VACUUM</command> вручную до того, как это произойдёт. Как правило, установленное значение <command>vacuum_freeze_table_age</command> должно быть несколько меньше <varname>autovacuum_freeze_max_age</varname>, чтобы оставленный промежуток был достаточен для выполнения в этом окне <command>VACUUM</command> по расписанию или автоочистки, управляемой обычной активностью операций удаления и изменения. Если это значение будет слишком близким к максимуму, автоочистка для сжатия <literal>pg_clog</literal> и <literal>pg_multixact</literal> будет выполняться, даже если таблица только что была очищена для высвобождения пространства, в то же время при небольшом значении будет чаще производиться агрессивная очистка.</para>

   <para>Единственный минус увеличения <varname>autovacuum_freeze_max_age</varname> (и <varname>vacuum_freeze_table_age</varname> с ним) заключается в том, что подкаталог <filename>pg_clog</filename> в кластере базы данных будет занимать больше места, поскольку в нём нужно будет хранить статус фиксации всех транзакций вплоть до горизонта <varname>autovacuum_freeze_max_age</varname>. Для статуса фиксации используется по два бита на транзакцию, поэтому если в <varname>autovacuum_freeze_max_age</varname> установлено максимально допустимое значение в два миллиарда, то размер <filename>pg_clog</filename> может составить примерно половину гигабайта. Если по сравнению с объёмом вашей базы данных этот объём незначителен, тогда рекомендуется установить для <varname>autovacuum_freeze_max_age</varname> максимально допустимое значение. В противном случае, установите значение этого параметра в зависимости от объёма, который вы готовы выделить для <filename>pg_clog</filename>. (Значению по умолчанию, 200 миллионам транзакций, соответствует приблизительно 50 Мб в <filename>pg_clog</filename>.)</para>

   <para>Уменьшение значения <varname>vacuum_freeze_min_age</varname>, с другой стороны, чревато тем, что команда <command>VACUUM</command> может выполнять бесполезную работу: замораживание версии строки — пустая трата времени, если эта строка будет вскоре изменена (и в результате получит новый XID). Поэтому значение этого параметра должно быть достаточно большим для того, чтобы строки не замораживались, пока их последующее изменение не станет маловероятным.</para>

   <para>Для отслеживания возраста самых старых значений XID в базе данных команда <command>VACUUM</command> сохраняет статистику по XID в системных таблицах <structname>pg_class</structname> и <structname>pg_database</structname>. В частности, столбец <structfield>relfrozenxid</structfield> в записи для определённой таблицы в <structname>pg_class</structname> содержит граничное значение XID, с которым в последний раз выполнялась агрессивная очистка (<command>VACUUM</command>) этой таблицы. Все строки, добавленные транзакциями с более ранними XID, гарантированно будут заморожены. Аналогично столбец <structfield>datfrozenxid</structfield> в записи для базы данных в <structname>pg_database</structname> представляет нижнюю границу обычных значений XID, встречающихся в этой базе &mdash; он просто хранит минимальное из всех значений <structfield>relfrozenxid</structfield> для таблиц этой базы. Эту информацию удобно получать с помощью таких запросов: <programlisting>SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;</programlisting> Столбец <literal>age</literal> показывает количество транзакций от граничного значения XID до XID текущей транзакции.</para>

   <para>Обычно <command>VACUUM</command> сканирует только те страницы, которые изменялись после последней очистки, однако <structfield>relfrozenxid</structfield> может увеличиться только при сканировании всех страниц таблицы, включая те, что могут содержать незамороженные XID. Это происходит когда возраст <structfield>relfrozenxid</structfield> достигает <varname>vacuum_freeze_table_age</varname> транзакций, когда <command>VACUUM</command> вызывается с указанием <literal>FREEZE</literal>, или когда оказывается, что очистку для удаления мёртвых версий строк нужно провести во всех ещё не замороженных страницах. Когда <command>VACUUM</command> сканирует в таблице каждую ещё не полностью замороженную страницу, значение <literal>age(relfrozenxid)</literal> в результате должно стать немного больше, чем установленное значение <varname>vacuum_freeze_min_age</varname> (больше на число транзакций, начатых с момента запуска <command>VACUUM</command>). Если по достижении <varname>autovacuum_freeze_max_age</varname> для таблицы ни разу не будет выполнена операция <structfield>relfrozenxid</structfield>, в скором времени для неё будет принудительно запущена автоочистка.</para>

   <sect3 id="vacuum-for-multixact-wraparound">
    <title>Сжатие <literal>pg_multixact</literal></title>

    <indexterm><primary>MultiXactId</primary></indexterm>

    <indexterm><primary>зацикливание</primary> <secondary>идентификаторов мультитранзакций</secondary></indexterm>

    <para><firstterm>Идентификаторы мультитранзакций</firstterm> используются для поддержки блокировки строк несколькими транзакциями одновременно. Поскольку в заголовке строки есть только ограниченное пространство для хранения информации о блокировках, в нём указывается <quote>идентификатор множественной транзакции</quote>, или идентификатор мультитранзакции для краткости, когда строку блокируют одновременно несколько транзакций. Информация о том, какие именно идентификаторы транзакций относятся к определённой мультитранзакции, хранится отдельно в подкаталоге <filename>pg_multixact</filename>, а в поле <structfield>xmax</structfield> в заголовке строки сохраняется только идентификатор мультитранзакции. Как и идентификаторы транзакций, идентификаторы мультитранзакций исполнены в виде 64-битного счётчика со смещением относительно эпохи, что требует аккуратного управления их возрастом и очисткой хранилища. Существует отдельная область, в которой содержится список членов каждой мультитранзакции, где счётчики также 64-битные.</para>

    <para>Когда <command>VACUUM</command> сканирует какую-либо часть таблицы, каждый идентификатор мультитранзакции старее чем <xref linkend="guc-vacuum-multixact-freeze-min-age"/> заменяется другим значением, которое может быть нулевым, идентификатором одиночной транзакции или новым идентификатором мультитранзакции. Для каждой таблицы в <structname>pg_class</structname>.<structfield>relminmxid</structfield> хранится самый старый возможный идентификатор мультитранзакции, всё ещё задействованный в какой-либо строке этой таблицы. Если это значение оказывается старее <xref linkend="guc-vacuum-multixact-freeze-table-age"/>, выполняется агрессивная очистка. Как рассказывалось в предыдущем разделе, при агрессивной очистке будут пропускаться только те страницы, которые считаются полностью замороженными. Узнать возраст <structname>pg_class</structname>.<structfield>relminmxid</structfield> можно с помощью функции <function>mxid_age()</function>.</para>

    <para>Благодаря агрессивным операциям <command>VACUUM</command>, вне зависимости от их причины, это значение для таблицы будет увеличиваться. В конце концов, по мере сканирования всех таблиц во всех базах данных и увеличения их старейших значений мультитранзакций, информация о старых мультитранзакциях может быть удалена с диска.</para>

    <para>Агрессивное сканирование таблицы с целью очистки будет происходить для любой таблицы, возраст мультитранзакций которой больше, чем <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>.</para>
   </sect3>
  </sect2>

  <sect2 id="autovacuum">
   <title>Демон автоочистки</title>

   <indexterm><primary>автоочистка</primary> <secondary>общая информация</secondary></indexterm>
   <para>В <productname>&productname;</productname> имеется не обязательная, но настоятельно рекомендуемая к использованию функция, называемая <firstterm>автоочисткой</firstterm>, предназначение которой — автоматизировать выполнение команд <command>VACUUM</command> и <command>ANALYZE </command>. Когда автоочистка включена, она проверяет, в каких таблицах было вставлено, изменено или удалено много строк. При этих проверках используются средства сбора статистики; поэтому автоочистка будет работать, только если параметр <xref linkend="guc-track-counts"/> имеет значение <literal>true</literal>. В конфигурации по умолчанию автоочистка включена и соответствующие параметры имеют подходящие значения.</para>

   <para><quote>Демон автоочистки</quote> на самом деле состоит из нескольких процессов. Существует постоянный фоновый процесс, называемый <firstterm>процессом запуска автоочистки</firstterm>, который отвечает за запуск <firstterm>рабочих процессов автоочистки</firstterm> для всех баз данных. Этот контролирующий процесс распределяет работу по времени, стараясь запускать рабочий процесс для каждой базы данных каждые <xref linkend="guc-autovacuum-naptime"/> секунд. (Следовательно, если всего имеется <replaceable>N</replaceable> баз данных, новый рабочий процесс будет запускаться каждые <varname>autovacuum_naptime</varname>/<replaceable>N</replaceable> секунд.) Одновременно могут выполняться до <xref linkend="guc-autovacuum-max-workers"/> рабочих процессов. Если число баз данных, требующих обработки, превышает <varname>autovacuum_max_workers</varname>, обработка следующей базы начинается сразу по завершении первого рабочего процесса. Каждый рабочий процесс проверяет все таблицы в своей базе данных и в случае необходимости выполняет <command>VACUUM</command> и/или <command>ANALYZE</command>. Для отслеживания действий рабочих процессов можно установить параметр <xref linkend="guc-log-autovacuum-min-duration"/>.</para>

   <para>Если в течение короткого промежутка времени потребность в очистке возникает для нескольких больших таблиц, все рабочие процессы автоочистки могут продолжительное время заниматься очисткой только этих таблиц. В результате другие таблицы и базы данных будут ожидать очистки, пока не появится свободный рабочий процесс. Число рабочих процессов для одной базы не ограничивается, при этом каждый процесс старается не повторять работу, только что выполненную другими. Заметьте, что в ограничениях <xref linkend="guc-max-connections"/> или <xref linkend="guc-superuser-reserved-connections"/> число выполняющихся рабочих процессов не учитывается.</para>

   <para>Для таблиц с <structfield>relfrozenxid</structfield>, устаревшим более чем на <xref linkend="guc-autovacuum-freeze-max-age"/> транзакций, очистка выполняется всегда (это также применимо к таблицам, для которых максимальный порог заморозки был изменён через параметры хранения; см. ниже). В противном случае, очистка таблицы производится, если количество кортежей, устаревших с момента последнего выполнения <command>VACUUM</command>, превышает <quote>пороговое значение очистки</quote>. Пороговое значение очистки определяется как: <programlisting>порог очистки = базовый порог очистки + коэффициент доли для очистки * количество кортежей</programlisting> где базовый порог очистки — значение <xref linkend="guc-autovacuum-vacuum-threshold"/>, коэффициент доли — <xref linkend="guc-autovacuum-vacuum-scale-factor"/>, а количество кортежей — <structname>pg_class</structname>.<structfield>reltuples</structfield>. Количество устаревших кортежей получается от сборщика статистики; оно представляет собой приблизительное число, обновляемое после каждой операции <command>UPDATE</command> и <command>DELETE</command>. (Точность не гарантируется, потому что при большой нагрузке часть информации может быть утеряна.) Если значение <structfield>relfrozenxid</structfield> для таблицы старее <varname>vacuum_freeze_table_age</varname> транзакций, производится агрессивная очистка с целью заморозить старые версии строк и увеличить значение <structfield>relfrozenxid</structfield>; в противном случае сканируются только страницы, изменённые после последней очистки.</para>

   <para>Для выполнения сбора статистики используется аналогичное условие: пороговое значение, определяемое как: <programlisting>порог анализа = базовый порог анализа + коэффициент доли для анализа * количество кортежей</programlisting> сравнивается с общим количеством кортежей добавленных, изменённых или удалённых после последнего выполнения <command>ANALYZE</command>.</para>

   <para>Автоочистка не обрабатывает временные таблицы. Поэтому очистку и сбор статистики в них нужно производить с помощью SQL-команд в обычном сеансе.</para>

   <para>Используемые по умолчанию пороговые значения и коэффициенты берутся из <filename>postgresql.conf</filename>, однако их (и многие другие параметры, управляющие автоочисткой) можно переопределить для каждой таблицы; за подробностями обратитесь к <xref remap="3" linkend="sql-createtable-storage-parameters" endterm="sql-createtable-storage-parameters-title"/>. Если какие-либо значения определены через параметры хранения таблицы, при обработке этой таблицы действуют они, а в противном случае — глобальные параметры. За более подробной информацией о глобальных параметрах обратитесь к <xref remap="3" linkend="runtime-config-autovacuum"/>.</para>

   <para>Когда выполняются несколько рабочих процессов, параметры задержки автоочистки по стоимости (см. <xref remap="4" linkend="runtime-config-resource-vacuum-cost"/>) <quote>распределяются</quote> между всеми этими процессами, так что общее воздействие на систему остаётся неизменным, независимо от их числа. Однако этот алгоритм распределения нагрузки не учитывает процессы, обрабатывающие таблицы с индивидуальными значениями параметров хранения <literal>autovacuum_vacuum_cost_delay</literal> и <literal>autovacuum_vacuum_cost_limit</literal>.</para>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>Регулярная переиндексация</title>

  <indexterm zone="routine-reindex"><primary>переиндексация</primary></indexterm>

  <para>В некоторых ситуациях стоит периодически перестраивать индексы, выполняя команду <xref linkend="sql-reindex"/> или последовательность отдельных шагов по восстановлению индексов.</para>

  <para>Страницы индексов на основе B-деревьев, которые стали абсолютно пустыми, могут быть использованы повторно. Однако возможность неэффективного использования пространства всё же остаётся: если со страницы были удалены почти все, но не все ключи индекса, страница всё равно остаётся занятой. Следовательно, шаблон использования, при котором со временем удаляются многие, но не все ключи в каждом диапазоне, приведёт к неэффективному расходованию пространства. В таких случаях рекомендуется периодически проводить переиндексацию.</para>

  <para>Возможность потери пространства в индексах на основе не B-деревьев глубоко не исследовалась. Поэтому имеет смысл периодически отслеживать физический размер индекса, когда применяется индекс такого типа.</para>

  <para>Кроме того, с B-деревьями доступ по недавно построенному индексу осуществляется немного быстрее, нежели доступ по индексу, который неоднократно изменялся, поскольку в недавно построенном индексе страницы, близкие логически, обычно расположены так же близко и физически. (Это соображение неприменимо к индексам, которые основаны не на B-деревьях.) Поэтому периодически проводить переиндексацию стоит хотя бы для того, чтобы увеличить скорость доступа.</para>

  <para>Команду <xref linkend="sql-reindex"/> можно безопасно и просто применять во всех случаях. Но так как она требует исключительной блокировки таблицы, часто предпочтительнее перестраивать индекс в несколько этапов, включающих создание и замену индекса. Типы индексов, которые поддерживает <xref linkend="sql-createindex"/> с указанием <literal>CONCURRENTLY</literal>, можно построить именно так. Если это удаётся и получен рабочий индекс, изначальный индекс можно заменить им, выполнив <xref linkend="sql-alterindex"/> и <xref linkend="sql-dropindex"/>. Когда индекс используется для обеспечения уникальности или других ограничений, может потребоваться команда <xref linkend="sql-altertable"/>, чтобы поменять существующее ограничение на то, что обеспечивает новый индекс. Обстоятельно продумайте эту многоходовую процедуру, прежде чем выполнять её, так как не все индексы можно перестроить таким образом, и предусмотрите обработку ошибок.</para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>Обслуживание журнала</title>

  <indexterm zone="logfile-maintenance"><primary>журнал сервера</primary> <secondary>обслуживание файла журнала</secondary></indexterm>

  <para>Журнал сервера базы данных желательно сохранять где-либо, а не просто сбрасывать его в <filename>/dev/null</filename>. Этот журнал бесценен при диагностике проблем. Однако он может быть очень объёмным (особенно при высоких уровнях отладки), так что хранить его неограниченно долго вы вряд ли захотите. Поэтому необходимо организовать <emphasis>ротацию</emphasis> журнальных файлов так, чтобы новые файлы создавались, а старые удалялись через разумный промежуток времени.</para>

  <para>Если просто направить <systemitem>stderr</systemitem> команды <command>postgres</command> в файл, вы получите в нём журнал сообщений, но очистить этот файл можно будет, только если остановить и перезапустить сервер. Это может быть допустимо при использовании <productname>&productname;</productname> в среде разработки, но вряд ли такой вариант будет приемлемым в производственной среде.</para>

  <para>Лучшим подходом будет перенаправление вывода сервера <systemitem>stderr</systemitem> в какую-либо программу ротации журнальных файлов. Существует и встроенное средство ротации журнальных файлов, которое можно использовать, установив для параметра <varname>logging_collector</varname> значение <literal>true</literal> в <filename>postgresql.conf</filename>. Параметры, управляющие этой программой, описаны в <xref remap="6" linkend="runtime-config-logging-where"/>. Этот подход также можно использовать для получения содержимого журнала в формате <acronym>CSV</acronym> (значения, разделённые запятыми).</para>

  <para>Вы также можете использовать внешнюю программу для ротации журнальных файлов, если уже применяете такое приложение для других серверных приложений. Например, утилиту <application>rotatelogs</application>, включённую в дистрибутив <productname>Apache</productname>, можно использовать и с <productname>&productname;</productname>. Для этого просто направьте вывод <systemitem>stderr</systemitem> сервера в желаемую программу. Если вы запускаете сервер, используя <command>pg_ctl</command>, то <systemitem>stderr</systemitem> уже будет перенаправлен в <systemitem>stdout</systemitem>, так что будет достаточно просто применить конвейер, например: <programlisting>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</programlisting></para>

  <para>Ещё одно решение промышленного уровня заключается в передаче журнала в <application>syslog</application>, чтобы ротацией файлов занималась уже служба <application>syslog</application>. Для этого присвойте параметру конфигурации <varname>log_destination</varname> значение <literal>syslog</literal> (для вывода журнала только в <application>syslog</application>) в <filename>postgresql.conf</filename>. Затем вы сможете посылать сигнал <literal>SIGHUP</literal> службе <application>syslog</application>, когда захотите принудительно начать запись нового журнального файла. Если вы хотите автоматизировать ротацию журнальных файлов, программу <application>logrotate</application> можно настроить и для работы с журнальными файлами, которые формирует <application>syslog</application>.</para>

  <para>Однако во многих системах, а особенно c большими сообщениями, <application>syslog</application> работает не очень надёжно; он может обрезать или терять сообщения как раз тогда, когда они вам нужны. Кроме того, в <productname>Linux</productname>, <application>syslog</application>&gt; сбрасывает каждое сообщение на диск, от чего страдает производительность. (Для отключения этой синхронной записи можно добавить <quote><literal>-</literal></quote> перед именем файла в файле конфигурации <application>syslog</application>.)</para>

  <para>Обратите внимание, что все описанные выше решения обеспечивают создание новых журнальных файлов через задаваемые промежутки времени, но не удаление старых, ставших бесполезными файлов журналов. Возможно, вы захотите создать задание для периодического удаления старых файлов. Кроме того, вы можете настроить программу ротации файлов так, чтобы старые файлы журналов циклически перезаписывались.</para>

  <para>Также вам может быть полезен <ulink url="http://dalibo.github.io/pgbadger/"><productname>pgBadger</productname></ulink> — инструмент для сложного анализа файлов журнала. Кроме того, <ulink url="http://bucardo.org/wiki/Check_postgres"><productname>check_postgres</productname></ulink> может посылать уведомления в Nagios, когда в журнале появляются важные сообщения, а также при обнаружении других нестандартных ситуаций.</para>
 </sect1>
</chapter>
