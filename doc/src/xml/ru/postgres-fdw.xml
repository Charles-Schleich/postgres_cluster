<!-- doc/src/xml/postgres-fdw.xml -->

<sect1 id="postgres-fdw" xreflabel="postgres_fdw">
 <title>postgres_fdw</title>

 <indexterm zone="postgres-fdw"><primary>postgres_fdw</primary></indexterm>

 <para>Модуль <filename>postgres_fdw</filename> предоставляет обёртку сторонних данных <literal>postgres_fdw</literal>, используя которую можно обращаться к данным, находящимся на внешних серверах <productname>&productname;</productname>.</para>

 <para>Функциональность этого модуля во многом пересекается с функциональностью старого модуля <xref linkend="dblink"/>. Однако <filename>postgres_fdw</filename> предоставляет более прозрачный и стандартизированный синтаксис для обращения к удалённым таблицам и во многих случаях даёт лучшую производительность.</para>

 <para>Чтобы подготовиться к обращению к удалённым данным через <filename>postgres_fdw</filename>: <orderedlist spacing="compact">
   <listitem>
    <para>Установите расширение <filename>postgres_fdw</filename> с помощью команды <xref linkend="sql-createextension"/>.</para>
   </listitem>
   <listitem>
    <para>Создайте объект стороннего сервера, используя <xref linkend="sql-createserver"/>, который будет представлять удалённую базу данных, к которой вы хотите подключаться. Укажите свойства подключения, кроме <literal>user</literal> и <literal>password</literal>, в параметрах объекта сервера.</para>
   </listitem>
   <listitem>
    <para>Создайте сопоставление пользователей, используя <xref linkend="sql-createusermapping"/>, для каждого пользователя базы, которому нужен доступ к удалённому серверу. Укажите имя и пароль удалённого пользователя в параметрах <literal>user</literal> и <literal>password</literal> сопоставления.</para>
   </listitem>
   <listitem>
    <para>Создайте стороннюю таблицу, используя <xref linkend="sql-createforeigntable"/> или <xref linkend="sql-importforeignschema"/>, для каждой удалённой таблицы, к которой вы хотите обращаться. Столбцы сторонней таблицы должны соответствовать столбцам целевой удалённой таблицы. Однако вы можете использовать локально имена таблиц и/или столбцов, отличные от удалённых, если укажете корректные удалённые имена в параметрах объекта сторонней таблицы.</para>
   </listitem>
  </orderedlist></para>

 <para>После этого для обращения к данным, хранящимся в нижележащей удалённой таблице, вам нужно только выполнять <command>SELECT</command>. Вы также можете изменять данные в удалённой таблице, выполняя <command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</command>. (Разумеется, удалённый пользователь, указанный в сопоставлении, должен иметь необходимые права для этого.)</para>

 <para>Заметьте, что в настоящее время в <filename>postgres_fdw</filename> не поддерживаются операторы <command>INSERT</command> с предложением <literal>ON CONFLICT DO UPDATE</literal>. Однако предложение <literal>ON CONFLICT DO NOTHING</literal> поддерживается, при отсутствии указания для выбора уникального индекса.</para>

 <para>Обычно рекомендуется объявлять столбцы сторонней таблицы точно с теми же типами данных и правилами сортировки, если они применимы, как у целевых столбцов удалённой таблицы. Хотя <filename>postgres_fdw</filename> в настоящее время довольно лоялен к преобразованиям типов данных при необходимости, но когда типы или правила сортировки не совпадают, возможны неожиданные семантические аномалии, вследствие того, что удалённый сервер будет обрабатывать предложения <literal>WHERE</literal> не совсем так, как локальный сервер.</para>

 <para>Заметьте, что сторонняя таблица может быть объявлена с меньшим количеством или с другим порядком столбцов, чем в нижележащей удалённой таблице. Сопоставление столбцов удалённой таблицы осуществляется по имени, а не по позиции.</para>

 <sect2>
  <title>Параметры обёртки для postgres_fdw</title>

  <sect3>
   <title>Параметры подключения</title>

   <para>Для стороннего сервера, настраиваемого с использованием обёртки сторонних данных <filename>postgres_fdw</filename>, можно задать те же параметры, что принимает <application>libpq</application> в строках подключения, как описано в <xref remap="6" linkend="libpq-paramkeywords"/>, за исключением следующих недопустимых параметров: <itemizedlist spacing="compact">
     <listitem>
      <para><literal>user</literal> и <literal>password</literal> (их следует задавать в сопоставлениях пользователей)</para>
     </listitem>
     <listitem>
      <para><literal>client_encoding</literal> (автоматически принимается равной локальной кодировке сервера)</para>
     </listitem>
     <listitem>
      <para><literal>fallback_application_name</literal> (всегда <literal>postgres_fdw</literal>)</para>
     </listitem>
    </itemizedlist></para>

   <para>Подключаться к сторонним серверам без аутентификации по паролю могут только суперпользователи, поэтому в сопоставлениях для обычных пользователей всегда нужно задавать пароль (<literal>password</literal>).</para>
  </sect3>

  <sect3>
   <title>Параметры имени объекта</title>

   <para>Эти параметры позволяют управлять тем, как на удалённый сервер <productname>&productname;</productname> будут передаваться имена, фигурирующие в операторах SQL. Данные параметры нужны, когда сторонняя таблица создаётся с именами, отличными от имён удалённой таблицы.</para>

   <variablelist>

    <varlistentry>
     <term><literal>schema_name</literal></term>
     <listitem>
      <para>Этот параметр, который может задаваться для сторонней таблицы, указывает имя схемы для обращения к этой таблице на удалённом сервере. Если данный параметр опускается, применяется схема сторонней таблицы.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>table_name</literal></term>
     <listitem>
      <para>Этот параметр, который может задаваться для сторонней таблицы, указывает имя таблицы для обращения к этой таблице на удалённом сервере. Если данный параметр опускается, применяется имя сторонней таблицы.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>column_name</literal></term>
     <listitem>
      <para>Этот параметр, который может задаваться для столбца сторонней таблицы, указывает имя столбца для обращения к этому столбцу на удалённом сервере. Если данный параметр опускается, применяется исходное имя столбца.</para>
     </listitem>
    </varlistentry>

   </variablelist>

  </sect3>

  <sect3>
   <title>Параметры оценки стоимости</title>

   <para>Модуль <filename>postgres_fdw</filename> получает удалённые данные, выполняя запросы на удалённых серверах, поэтому в идеале ожидаемая стоимость сканирования сторонней таблицы должна равняться стоимости выполнения на удалённом сервере плюс издержки сетевого взаимодействия. Самый надёжный способ получить такие оценки — узнать стоимость у удалённого сервера и добавить некоторую надбавку &mdash; но для простых запросов может быть невыгодно передавать дополнительный запрос, только чтобы получить оценку стоимости. Поэтому <filename>postgres_fdw</filename> предоставляет следующие параметры, позволяющие управлять вычислением оценки стоимости:</para>

   <variablelist>

    <varlistentry>
     <term><literal>use_remote_estimate</literal></term>
     <listitem>
      <para>Этот параметр, который может задаваться для сторонней таблицы или для стороннего сервера, определяет, будет ли <filename>postgres_fdw</filename> выполнять удалённо команды <command>EXPLAIN</command> для получения оценок стоимости. Параметр, заданный для сторонней таблицы, переопределяет параметр сервера, но только для данной таблицы. Значение по умолчанию — <literal>false</literal> (выкл.).</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>fdw_startup_cost</literal></term>
     <listitem>
      <para>Этот параметр, который может задаваться для стороннего сервера, устанавливает числовое значение, добавляемое к оценке стоимости запуска для любого сканирования сторонней таблицы на этом сервере. Он выражает дополнительные издержки на установление подключения, разбор и планирование запроса на удалённой стороне и т. д. Значение по умолчанию — <literal>100</literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>fdw_tuple_cost</literal></term>
     <listitem>
      <para>Этот параметр, который может задаваться для стороннего сервера, устанавливает числовое значение, выражающее дополнительную цену чтения одного кортежа из сторонней таблицы на этом сервере. Это число можно увеличить или уменьшить, отражая меньшую или большую фактическую скорость сетевого взаимодействия с удалённым сервером. Значение по умолчанию — <literal>0.01</literal>.</para>
     </listitem>
    </varlistentry>

   </variablelist>

   <para>Когда поведение <literal>use_remote_estimate</literal> включено, <filename>postgres_fdw</filename> получает количество строк и оценку стоимости с удалённого сервера, а затем добавляет к оценке стоимости <literal>fdw_startup_cost</literal> и <literal>fdw_tuple_cost</literal>. Когда поведение <literal>use_remote_estimate</literal> отключено, <filename>postgres_fdw</filename> рассчитывает число строк и оценку стоимости локально, а затем так же добавляет к этой оценке <literal>fdw_startup_cost</literal> и <literal>fdw_tuple_cost</literal>. Локальная оценка может быть точной только при условии наличия локальной копии статистики удалённых таблиц. Обновить эту статистику для сторонней таблицы можно с помощью команды <xref linkend="sql-analyze"/>; при этом удалённая таблица будет просканирована, и по её содержимому будут вычислена и сохранена статистика как для локальной таблицы. Локальное хранение статистики может быть полезно для сокращения издержек планирования для удалённой таблицы &mdash; но если удалённая таблица меняется часто, локальная статистика будет быстро устаревать.</para>

  </sect3>

  <sect3>
   <title>Параметры удалённого выполнения</title>

   <para>По умолчанию ограничения <literal>WHERE</literal>, содержащие встроенные операторы и функции, обрабатываются на удалённом сервере, а ограничения, содержащие вызовы не встроенных функций, проверяются локально после получения строк. Если же расширенные функции доступны на удалённом сервере и можно рассчитывать, что они дадут те же результаты, что и локально, производительность можно увеличить, передавая и такие предложения <literal>WHERE</literal> для удалённого выполнения. Этим поведением позволяет управлять следующий параметр:</para>

   <variablelist>

    <varlistentry>
     <term><literal>extensions</literal></term>
     <listitem>
      <para>В этом параметре задаётся список имён расширений <productname>&productname;</productname> через запятую, которые установлены и имеют совместимые версии и на локальном, и на удалённом сервере. Относящиеся к перечисленным расширениям и при этом постоянные (immutable) функции и операторы могут передаваться на выполнение удалённому серверу. Этот параметр можно задать только для стороннего сервера, но не для таблицы.</para>

      <para>При использовании параметра <literal>extensions</literal> <emphasis>пользователь сам отвечает</emphasis> за то, чтобы перечисленные расширения существовали и их поведение было одинаковым на локальном и удалённом сервере. В противном случае удалённые запросы могут выдавать ошибки или неожиданные результаты.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>fetch_size</literal></term>
     <listitem>
      <para>Этот параметр определяет, сколько строк должна получать <filename>postgres_fdw</filename> в одной операции выборки. Его можно задать для сторонней таблицы или стороннего сервера. Значение по умолчанию — <literal>100</literal> строк.</para>
     </listitem>
    </varlistentry>

   </variablelist>

  </sect3>

  <sect3>
   <title>Параметры изменения данных</title>

   <para>По умолчанию все сторонние таблицы, доступные через <filename>postgres_fdw</filename>, считаются допускающими изменения. Это можно переопределить с помощью следующего параметра:</para>

   <variablelist>

    <varlistentry>
     <term><literal>updatable</literal></term>
     <listitem>
      <para>Этот параметр определяет, будет ли <filename>postgres_fdw</filename> допускать изменения в сторонних таблицах посредством команд <command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</command>. Его можно задать для сторонней таблицы или для стороннего сервера. Параметр, определённый на уровне таблицы, переопределяет параметр уровня сервера. Значение по умолчанию — <literal>true</literal> (изменения разрешены).</para>

      <para>Конечно, если удалённая таблица на самом деле не допускает изменения, всё равно произойдёт ошибка. Использование этого параметра прежде всего позволяет выдать ошибку локально, не обращаясь к удалённому серверу. Заметьте, однако, что представление <literal>information_schema</literal> будет показывать, что определённая сторонняя таблица <filename>postgres_fdw</filename> является изменяемой (или нет), согласно значению данного параметра, не проверяя это на удалённом сервере.</para>
     </listitem>
    </varlistentry>

   </variablelist>
  </sect3>

  <sect3>
   <title>Параметры импорта</title>

   <para>Обёртка <filename>postgres_fdw</filename> позволяет импортировать определения сторонних таблиц с применением команды <xref linkend="sql-importforeignschema"/>. Эта команда создаёт на локальном сервере определения сторонних таблиц, соответствующие таблицам или представлениям, существующим на удалённом сервере. Если импортируемые удалённые таблицы содержат столбцы пользовательских типов данных, на локальном сервере должны быть совместимые типы с теми же именами.</para>

   <para>Поведение процедуры импорта можно настроить следующими параметрами (задаваемыми в команде <command>IMPORT FOREIGN SCHEMA</command>):</para>

   <variablelist>
    <varlistentry>
     <term><literal>import_collate</literal></term>
     <listitem>
      <para>Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с внешнего сервера, включаться характеристики столбцов <literal>COLLATE</literal>. По умолчанию они включаются. Вам может потребоваться отключить его, если на удалённом сервере набор имён правил сортировки отличается от локального, что скорее всего будет иметь место, если серверы работают в разных операционных системах.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>import_default</literal></term>
     <listitem>
      <para>Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с внешнего сервера, включаться заданные для столбцов выражения <literal>DEFAULT</literal>. По умолчанию они не включаются. Если вы включите этот параметр, остерегайтесь выражений по умолчанию, которые могут вычисляться на локальном сервере не так, как на удалённом; например, частый источник проблем — <function>nextval()</function>. Если в импортируемом выражении используются функции или операторы, несуществующие локально, команда <command>IMPORT</command> в целом выдаст сбой.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>import_not_null</literal></term>
     <listitem>
      <para>Этот параметр устанавливает, будут ли в определения сторонних таблиц, импортируемых с внешнего сервера, включаться ограничения столбцов <literal>NOT NULL</literal>. По умолчанию они включаются.</para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>Заметьте, что никакие другие ограничения, кроме <literal>NOT NULL</literal>, из удалённых таблиц импортироваться не будут. Хотя <productname>&productname;</productname> поддерживает ограничения <literal>CHECK</literal> для сторонних таблиц, никаких средств для автоматического импорта их нет из-за риска различного вычисления выражения ограничения на локальном и удалённом серверах. Любая такая несогласованность в поведении ограничений <literal>CHECK</literal> могла бы привести к сложно выявляемым ошибкам в оптимизации запросов. Поэтому, если вы хотите импортировать ограничения <literal>CHECK</literal>, вы должны сделать это вручную и должны внимательно проверить семантику каждого. Более подробно интерпретация ограничений <literal>CHECK</literal> для сторонних таблиц описана в <xref remap="6" linkend="sql-createforeigntable"/>.</para>
  </sect3>
 </sect2>

 <sect2>
  <title>Управление соединением</title>

  <para>Модуль <filename>postgres_fdw</filename> устанавливает соединение со сторонним сервером при первом запросе, в котором участвует сторонняя таблица, связанная со сторонним сервером. Это соединение сохраняется и повторно используется для последующих запросов в том же сеансе. Однако, если для обращения к стороннему серверу задействуются разные пользователи (сопоставления пользователей), отдельное соединение устанавливается для каждого сопоставления пользователей.</para>
 </sect2>

 <sect2>
  <title>Управление транзакциями</title>

  <para>В процессе выполнения запроса, в котором участвуют какие-либо удалённые таблицы на стороннем сервере, <filename>postgres_fdw</filename> открывает транзакцию на удалённом сервере, если такая транзакция ещё не была открыта для текущей локальной транзакции. Эта удалённая транзакция фиксируется или прерывается, когда фиксируется или прерывается локальная транзакция. Подобным образом реализуется и управление точками сохранения.</para>

  <para>Для удалённой транзакции выбирается режим изоляции <literal>SERIALIZABLE</literal>, когда локальная транзакция открыта в режиме <literal>SERIALIZABLE</literal>; в противном случае применяется режим <literal>REPEATABLE READ</literal>. Этот выбор гарантирует, что если запрос сканирует несколько таблиц на удалённом сервере, он будет получать согласованные данные одного снимка для всех сканирований. Как следствие, последовательные запросы в одной транзакции будут видеть одни данные удалённого сервера, даже если на нём параллельно происходят изменения, вызванные другими действиями. Это поведение ожидаемо для локальной транзакции в режимах <literal>SERIALIZABLE</literal> и <literal>REPEATABLE READ</literal>, но для локальной транзакции в режиме <literal>READ COMMITTED</literal> оно может быть неожиданным. В будущих выпусках <productname>&productname;</productname> эти правила могут быть изменены.</para>
 </sect2>

 <sect2>
  <title>Оптимизация удалённых запросов</title>

  <para>Обёртка <filename>postgres_fdw</filename> пытается оптимизировать удалённые запросы, уменьшая объём обмена данными со сторонними серверами. Для этого она может передавать на выполнение удалённому серверу предложения <literal>WHERE</literal> и не получать столбцы таблицы, не требующиеся для текущего запроса. Чтобы уменьшить риск некорректного выполнения запросов, предложения <literal>WHERE</literal> передаются удалённому серверу, только если в них используются типы данных, операторы и функции, встроенные в ядро или относящиеся к расширениям, перечисленным в параметре <literal>extensions</literal>. Операторы и функции в таких предложениях также должны быть постоянными (<literal>IMMUTABLE</literal>). Для запросов <command>UPDATE</command> или <command>DELETE</command> обёртка <filename>postgres_fdw</filename> пытается оптимизировать выполнение, передавая весь запрос на удалённый сервер, если в запросе нет предложения <literal>WHERE</literal>, которое нельзя было бы передать, не выполняется локальное соединение, в целевой таблице отсутствуют локальные триггеры <literal>BEFORE</literal>/<literal>AFTER</literal> уровня строки и в родительских представлениях нет ограничения <literal>CHECK OPTION</literal>. Кроме того, в запросах <command>UPDATE</command> выражения, присваиваемые целевым столбцам, должны задействовать только встроенные типы данных и постоянные (<literal>IMMUTABLE</literal>) операторы и функции, чтобы уменьшить риск неверного выполнения запроса.</para>

  <para>Когда обёртка <filename>postgres_fdw</filename> обнаруживает соединение сторонних таблиц на одном стороннем сервере, она передаёт всё соединение этому серверу, если только по какой-то причине не решит, что будет эффективнее выбирать строки из каждой таблицы по отдельности, или сопоставляемые при обращении к таблицам пользователи оказываются разными. При передаче предложений <literal>JOIN</literal> принимаются те же меры предосторожности, что были описаны выше для предложений <literal>WHERE</literal>.</para>

  <para>Запрос, фактически отправляемый удалённому серверу для выполнения, можно изучить с помощью команды <command>EXPLAIN VERBOSE</command>.</para>
 </sect2>

 <sect2>
  <title>Окружение удалённого выполнения запросов</title>

  <para>В удалённых сеансах, установленных обёрткой <filename>postgres_fdw</filename>, в параметре <xref linkend="guc-search-path"/> задаётся только <literal>pg_catalog</literal>, так что без указания схемы видны только встроенные объекты. Это не проблема для запросов, которые генерирует сама <filename>postgres_fdw</filename>, так как она всегда добавляет такие указания. Однако это может быть опасно для функций, которые выполняются на удалённом сервере при срабатывании триггеров или правил для удалённых таблиц. Например, если удалённая таблица на самом деле представляет собой представление, любые функции, используемые в этом представлении, будут выполняться с таким ограниченным путём поиска. Поэтому рекомендуется в таких функциях дополнять схемой все имена либо добавлять параметры <literal>SET search_path</literal> (см. <xref remap="4" linkend="sql-createfunction"/>) в определения таких функций, чтобы установить ожидаемый ими путь поиска в окружении.</para>

  <para>Обёртка <filename>postgres_fdw</filename> подобным образом устанавливает для удалённого сеанса значения параметров <xref linkend="guc-timezone"/>, <xref linkend="guc-datestyle"/>, <xref linkend="guc-intervalstyle"/> и <xref linkend="guc-extra-float-digits"/>. С ними проблемы менее вероятны, чем с <varname>search_path</varname>, но если они возникнут, их можно урегулировать, установив нужные параметры с помощью <literal>SET</literal>.</para>

  <para>Это поведение <emphasis>не</emphasis> рекомендуется переопределять, устанавливая значения этих параметров на уровне сеанса; это скорее всего приведёт к поломке <filename>postgres_fdw</filename>.</para>
 </sect2>

 <sect2>
  <title>Совместимость с разными версиями</title>

  <para>Модуль <filename>postgres_fdw</filename> может применяться с удалёнными серверами версий, начиная с <productname>PostgreSQL</productname> 8.3. Способность только чтения данных доступна, начиная с 8.1. Однако, при этом есть ограничение, вызванное тем, что <filename>postgres_fdw</filename> полагает, что постоянные встроенные функции и операторы могут безопасно передаваться на удалённый сервер для выполнения, если они фигурируют в предложении <literal>WHERE</literal> для сторонней таблицы. Таким образом, встроенная функция, добавленная в более новой версии, чем на удалённом сервере, может быть отправлена на выполнение, что в результате приведёт к ошибке <quote>функция не существует</quote> или подобной. Отказы такого типа можно предотвратить, переписав запрос, например, поместив ссылку на стороннюю таблицу во вложенный <literal>SELECT</literal> с <literal>OFFSET 0</literal> в качестве защиты от оптимизации, и применив проблематичную функцию или оператор снаружи этого вложенного <literal>SELECT</literal>.</para>
 </sect2>

 <sect2>
  <title>Примеры</title>

  <para>Ниже приведёт пример создания сторонней таблицы с применением <literal>postgres_fdw</literal>. Сначала установите расширение:</para>

<programlisting>CREATE EXTENSION postgres_fdw;</programlisting>

  <para>Затем создайте сторонний сервер с помощью команды <xref linkend="sql-createserver"/>. В данном примере мы хотим подключиться к серверу <productname>&productname;</productname>, работающему по адресу <literal>192.83.123.89</literal>, порт <literal>5432</literal>. База данных, к которой устанавливается подключение, на удалённом сервере называется <literal>foreign_db</literal>: <programlisting>CREATE SERVER foreign_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');</programlisting></para>

  <para>Для определения роли, которая будет задействована на удалённом сервере, с помощью <xref linkend="sql-createusermapping"/> задаётся сопоставление пользователей: <programlisting>CREATE USER MAPPING FOR local_user
        SERVER foreign_server
        OPTIONS (user 'foreign_user', password 'password');</programlisting></para>

  <para>Теперь можно создать стороннюю таблицу, применив команду <xref linkend="sql-createforeigntable"/>. В этом примере мы хотим обратиться к таблице <structname>some_schema.some_table</structname> на удалённом сервере. Локальным именем этой таблицы будет <structname>foreign_table</structname>: <programlisting>CREATE FOREIGN TABLE foreign_table (
        id integer NOT NULL,
        data text
)
        SERVER foreign_server
        OPTIONS (schema_name 'some_schema', table_name 'some_table');</programlisting> Важно, чтобы типы данных и другие свойства столбцов, объявленных в <command>CREATE FOREIGN TABLE</command>, соответствовали фактической удалённой таблице. Также должны соответствовать имена столбцов, если только вы не добавите параметры <literal>column_name</literal> для отдельных столбцов, задающие их реальные имена в удалённой таблице. Во многих случаях использовать <xref linkend="sql-importforeignschema"/> предпочтительнее, чем конструировать определения сторонних таблиц вручную.</para>
 </sect2>

 <sect2>
  <title>Автор</title>
  <para>Шигеру Ханада <email>shigeru.hanada@gmail.com</email></para>
 </sect2>

</sect1>
