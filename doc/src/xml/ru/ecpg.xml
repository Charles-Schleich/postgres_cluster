<!-- doc/src/xml/ecpg.xml -->

<chapter id="ecpg">
 <title><application>ECPG</application> — встраиваемый <acronym>SQL</acronym> в C</title>

 <indexterm zone="ecpg"><primary>встраиваемый SQL</primary> <secondary>в C</secondary></indexterm>
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

 <para>В этой главе описывается встраиваемый <acronym>SQL</acronym> для <productname>&productname;</productname>. Авторы этой разработки: Линус Толке (<email>linus@epact.se</email>) и Михаэль Мескес (<email>meskes@postgresql.org</email>). Изначально этот проект предназначался для <acronym>C</acronym>. Сейчас он также работает с <acronym>C++</acronym>, но пока не распознаёт все конструкции <acronym>C++</acronym>.</para>

 <para>Эта документация не абсолютно полная, но так как этот интерфейс стандартизирован, дополнительные сведения можно почерпнуть во многих ресурсах, посвящённых SQL.</para>

 <sect1 id="ecpg-concept">
  <title>Концепция</title>

  <para>Программа со встраиваемым SQL состоит из кода, написанного на обычном языке программирования, в данном случае, С, дополненного командами SQL в специально обозначенных секциях. Чтобы собрать программу, её исходный код (<filename>*.pgc</filename>) сначала нужно пропустить через препроцессор встраиваемого SQL, который превратит её в обычную программу на C (<filename>*.c</filename>), которую затем сможет обработать компилятор C. (Подробнее компиляция и компоновка описывается в <xref remap="6" linkend="ecpg-process"/>). Преобразованные приложения ECPG вызывают функции в библиотеке libpq через библиотеку встраиваемого SQL (ecpglib) и взаимодействуют с сервером &productname; по обычному клиент-серверному протоколу.</para>

  <para>Встраиваемый <acronym>SQL</acronym> имеет ряд преимуществ по сравнению с другими методами вызова команд <acronym>SQL</acronym> из кода C. Во-первых, этот механизм берёт на себя заботу о передаче информации через переменные в программе на <acronym>C</acronym>. Во-вторых, код SQL в программе проверяется на синтаксическую правильность во время сборки. В-третьих, встраиваемый <acronym>SQL</acronym> в C описан стандартом <acronym>SQL</acronym> и поддерживается многими другими СУБД <acronym>SQL</acronym>. Реализация в <productname>&productname;</productname> разработана так, чтобы максимально соответствовать этому стандарту, поэтому обычно достаточно легко портировать в <productname>&productname;</productname> программы с встраиваемым <acronym>SQL</acronym>, написанные для других СУБД.</para>

  <para>Как уже сказано, программы, написанные для интерфейса встраиваемого <acronym>SQL</acronym>, представляют собой обычные программы на C с добавленным специальным кодом, который выполняет действия, связанные с базой данных. Этот специальный код всегда имеет следующую форму: <programlisting>EXEC SQL ...;</programlisting> Такие операторы синтаксически занимают место операторов C. В зависимости от конкретного оператора, они могут размещаться на глобальном уровне или внутри функции. Встраиваемые операторы <acronym>SQL</acronym> следуют правилам учёта регистра, принятым в обычном коде <acronym>SQL</acronym>, а не в C. Они также допускают вложенные комментарии в стиле C, разрешённые стандартом SQL. Однако остальная часть программы, написанная на C, в соответствии со стандартом C содержать вложенные комментарии не может.</para>

  <para>Все встраиваемые операторы SQL рассматриваются в следующих разделах.</para>
 </sect1>

 <sect1 id="ecpg-connect">
  <title>Управление подключениями к базе данных</title>

  <para>В этом разделе описывается, как открывать, закрывать и переключать подключения к базам данных.</para>

  <sect2 id="ecpg-connecting">
   <title>Подключение к серверу баз данных</title>

  <para>Подключение к базе данных выполняется следующим оператором: <programlisting>EXEC SQL CONNECT TO <replaceable>цель-подключения</replaceable> <optional>AS <replaceable>имя-подключения</replaceable></optional> <optional>USER <replaceable>имя-пользователя</replaceable></optional>;</programlisting> <replaceable>Цель</replaceable> может задаваться следующими способами: <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>имя_бд</replaceable><optional>@<replaceable>имя_сервера</replaceable></optional><optional>:<replaceable>порт</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>имя_сервера</replaceable><optional>:<replaceable>порт</replaceable></optional><optional>/<replaceable>имя_бд</replaceable></optional><optional>?<replaceable>параметры</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>имя_сервера</replaceable><optional>:<replaceable>порт</replaceable></optional><optional>/<replaceable>имя_бд</replaceable></optional><optional>?<replaceable>параметры</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>строковая константа SQL, содержащая одну из вышеприведённых записей</simpara>
    </listitem>

    <listitem>
     <simpara>ссылка на символьную переменную, содержащую одну из вышеприведённых записей (см. примеры)</simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist> Если цель подключения задаётся буквально (то есть не через переменную) и значение не заключается в кавычки, регистр в этой строке не учитывается, как в обычном SQL. В этом случае при необходимости также можно заключить в двойные кавычки отдельные параметры. На практике, чтобы не провоцировать ошибки, лучше заключать строку в апострофы, либо передавать её в переменной. С целью подключения <literal>DEFAULT</literal> устанавливается подключение к базе данных по умолчанию с именем пользователя по умолчанию. Другое имя пользователя или имя подключения в этом случае указать нельзя.</para>

  <para>Также разными способами можно указать имя пользователя: <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>имя_пользователя</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>имя_пользователя</replaceable>/<replaceable>пароль</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>имя_пользователя</replaceable> IDENTIFIED BY <replaceable>пароль</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>имя_пользователя</replaceable> USING <replaceable>пароль</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist> В показанных выше строках <replaceable>имя_пользователя</replaceable> и <replaceable>пароль</replaceable> могут задаваться идентификатором или строковой константой SQL, либо ссылкой на символьную переменную.</para>

  <para>Указание <replaceable>имя-подключения</replaceable> применяется, когда в одной программе нужно использовать несколько подключений. Его можно опустить, если программа работает только с одним подключением. Соединение, открытое последним, становится текущим и будет использоваться по умолчанию при выполнении операторов SQL (это описывается далее в этой главе).</para>

  <para>Вот некоторые примеры оператора <command>CONNECT</command>: <programlisting>EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/* или EXEC SQL CONNECT TO :target USER :user/:passwd; */</programlisting> В последней форме используется вариант, названный выше ссылкой на символьную переменную. В последующих разделах вы узнаете, как в SQL-операторах можно использовать переменные C, приставляя перед именем двоеточие.</para>

  <para>Учтите, что формат цели подключения не описывается в стандарте SQL. Поэтому, если вы хотите разрабатывать переносимые приложения, имеет смысл применить подход, показанный в последнем примере, и сформировать строку подключения отдельно.</para>
  </sect2>

  <sect2 id="ecpg-set-connection">
   <title>Выбор подключения</title>

  <para>SQL-операторы в программах со встраиваемым SQL по умолчанию выполняются с текущим подключением, то есть с подключением, которое было открыто последним. Если приложению нужно управлять несколькими подключениями, это можно сделать двумя способами.</para>

  <para>Первый вариант — явно выбирать подключение для каждого SQL-оператора, например, так: <programlisting>EXEC SQL AT <replaceable>имя-подключения</replaceable> SELECT ...;</programlisting> Этот вариант хорошо подходит для случаев, когда приложению нужно использовать несколько подключений в смешанном порядке.</para>

  <para>Если ваше приложение выполняется в нескольких потоках, они не могут использовать подключение одновременно. Поэтому вы должны либо явно управлять доступом (используя мьютексы), либо использовать отдельные подключения для каждого потока.</para>

  <para>Второй вариант — выполнять оператор, переключающий текущее подключение. Этот оператор записывается так: <programlisting>EXEC SQL SET CONNECTION <replaceable>имя-подключения</replaceable>;</programlisting> Этот вариант особенно удобен, когда с одним подключением нужно выполнить несколько операторов.</para>

  <para>Следующий пример программы демонстрирует управление несколькими подключениями к базам данных: <programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;

    /* This query would be executed in the last opened database "testdb3". */
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);

    /* Using "AT" to run a query in "testdb2" */
    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

    /* Switch the current connection to "testdb1". */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting> Этот пример должен вывести следующее: <screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen></para>
  </sect2>

  <sect2 id="ecpg-disconnect">
   <title>Закрытие подключения</title>

  <para>Чтобы закрыть подключение, примените следующий оператор: <programlisting>EXEC SQL DISCONNECT <optional><replaceable>подключение</replaceable></optional>;</programlisting> <replaceable>Подключение</replaceable> можно задать следующими способами: <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>имя-подключения</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist> Если имя подключения не задано, закрывается текущее подключение.</para>

  <para>Хорошим стилем считается, когда приложение явно закрывает каждое подключение, которое оно открыло.</para>
  </sect2>

 </sect1>

 <sect1 id="ecpg-commands">
  <title>Запуск команд SQL</title>

  <para>В приложении со встраиваемым SQL можно запустить любую команду SQL. Ниже приведены несколько примеров, показывающих как это делать.</para>

  <sect2 id="ecpg-executing">
   <title>Выполнение операторов SQL</title>

  <para>Создание таблицы: <programlisting>EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;</programlisting></para>

  <para>Добавление строк: <programlisting>EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;</programlisting></para>

  <para>Удаление строк: <programlisting>EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;</programlisting></para>

  <para>Изменение: <programlisting>EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;</programlisting></para>

  <para>Операторы <literal>SELECT</literal>, возвращающие одну строку результата, также могут выполняться непосредственно командой <literal>EXEC SQL</literal>. Чтобы обработать наборы результатов с несколькими строками, приложение должно использовать курсоры; см. <xref remap="4" linkend="ecpg-cursors"/> ниже. (В отдельных случаях приложение может выбрать сразу несколько строк в переменную массива; см. <xref remap="4" linkend="ecpg-variables-arrays"/>.)</para>

  <para>Выборка одной строки: <programlisting>EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';</programlisting></para>

  <para>Так же можно получить параметр конфигурации командой <literal>SHOW</literal>: <programlisting>EXEC SQL SHOW search_path INTO :var;</programlisting></para>

  <para>Идентификаторы вида <literal>:<replaceable>имя</replaceable></literal> воспринимаются как <firstterm>переменные среды</firstterm>, то есть они ссылаются на переменные программы C. Они рассматриваются в <xref remap="6" linkend="ecpg-variables"/>.</para>
  </sect2>

  <sect2 id="ecpg-cursors">
   <title>Использование курсоров</title>

  <para>Чтобы получить набор результатов, содержащий несколько строк, приложение должно объявить курсор и выбирать каждую строку через него. Использование курсора подразумевает следующие шаги: объявление курсора, открытие его, выборку строки через курсор, повторение предыдущего шага, и наконец, закрытие курсора.</para>

  <para>Выборка с использованием курсоров: <programlisting>EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;</programlisting></para>

  <para>Более подробно объявление курсора описывается в <xref remap="6" linkend="ecpg-sql-declare"/>, а команда <literal>FETCH</literal> описана в <xref remap="6" linkend="sql-fetch"/>.</para>

   <note>
    <para>Команда <command>DECLARE</command> в ECPG на самом деле не передаёт этот оператор серверу &productname;. Курсор открывается на сервере (командой сервера <command>DECLARE</command>) в момент, когда выполняется команда <command>OPEN</command>.</para>
   </note>
  </sect2>

  <sect2 id="ecpg-transactions">
   <title>Управление транзакциями</title>

  <para>В режиме по умолчанию операторы фиксируются только когда выполняется <command>EXEC SQL COMMIT</command>. Интерфейс встраиваемого SQL также поддерживает автофиксацию транзакций (так работает <application>libpq</application> по умолчанию); она включается аргументом командной строки <option>-t</option> программы <command>ecpg</command> (см. <xref remap="4" linkend="app-ecpg"/>) либо оператором <literal>EXEC SQL SET AUTOCOMMIT TO ON</literal>. В режиме автофиксации каждая команда фиксируется автоматически, если только она не помещена в явный блок транзакции. Этот режим можно выключить явным образом, выполнив <literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>.</para>

   <para>Поддерживаются следующие команды управления транзакциями: <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>Зафиксировать текущую транзакцию.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>Откатить текущую транзакцию.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>Включить режим автофиксации.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>Отключить режим автофиксации. По умолчанию он отключён.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>

  <sect2 id="ecpg-prepared">
   <title>Подготовленные операторы</title>

   <para>Когда значения, передаваемые оператору SQL, неизвестны во время компиляции, или один и тот же оператор будет использоваться многократно, могут быть полезны подготовленные операторы.</para>

   <para>Оператор подготавливается командой <literal>PREPARE</literal>. Вместо значений, которые ещё неизвестны, вставляются местозаполнители <quote><literal>?</literal></quote>: <programlisting>EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";</programlisting></para>

   <para>Если оператор возвращает одну строку, приложение может вызвать <literal>EXECUTE</literal> после <literal>PREPARE</literal> для выполнения этого оператора, указав фактические значения для местозаполнителей в предложении <literal>USING</literal>: <programlisting>EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;</programlisting></para>

   <para>Если оператор возвращает несколько строк, приложение может использовать курсор, объявленный на базе подготовленного оператора. Чтобы привязать входные параметры, курсор нужно открыть с предложением <literal>USING</literal>: <programlisting>EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

/* по достижении конца набора результатов прервать цикл while */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;</programlisting></para>

   <para>Когда подготовленный оператор больше не нужен, его следует освободить: <programlisting>EXEC SQL DEALLOCATE PREPARE <replaceable>имя</replaceable>;</programlisting></para>

   <para>Подробнее оператор <literal>PREPARE</literal> описан в <xref remap="6" linkend="ecpg-sql-prepare"/>. Также обратитесь к <xref remap="3" linkend="ecpg-dynamic"/> за дополнительными сведениями о местозаполнителях и входных параметрах.</para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-variables">
  <title>Использование переменных среды</title>

  <para>В <xref remap="6" linkend="ecpg-commands"/> вы увидели, как можно выполнять операторы SQL в программе со встраиваемым SQL. Некоторые из этих операторов использовали только фиксированные значения и не давали возможности вставлять в операторы произвольные значения или обрабатывать значения, возвращённые запросом. Операторы такого вида не очень полезны в реальных приложениях. В этом разделе подробно описывается, как можно передавать данные между программой на C и встраиваемыми операторами SQL, используя простой механизм, так называемые <firstterm>переменные среды</firstterm>. В программе со встраиваемым SQL мы считаем SQL-операторы <firstterm>внедрёнными</firstterm> в код программы на C, <firstterm>языке среды</firstterm>. Таким образом, переменные программы на C называются <firstterm>переменными среды</firstterm>.</para>

  <para>Ещё один способ передать значения данных между сервером &productname; и приложениями ECPG заключается в использовании дескрипторов SQL, как описано в <xref remap="6" linkend="ecpg-descriptors"/>.</para>

  <sect2 id="ecpg-variables-overview">
   <title>Обзор</title>

   <para>Передавать данные между программой C и операторами SQL во встраиваемом SQL очень просто. Вместо того, чтобы вставлять данные в оператор, что влечёт дополнительные усложнения, в частности нужно правильно заключать значения в кавычки, можно просто записать имя переменной C в операторе SQL, предварив его двоеточием. Например: <programlisting>EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);</programlisting> Этот оператор обращается к двум переменным C с именами <varname>v1</varname> и <varname>v2</varname> и также использует обычную строковую константу SQL, показывая тем самым, что можно свободно сочетать разные виды данных.</para>

   <para>Этот метод включения переменных C в операторы SQL работает везде, где оператор SQL принимает выражение значения.</para>
  </sect2>

  <sect2 id="ecpg-declare-sections">
   <title>Секции объявлений</title>

   <para>Чтобы передать данные из программы в базу данных, например, в виде параметров запроса, либо получить данные из базы данных в программе, переменные C, которые должны содержать эти данные, нужно объявить в специально помеченных секциях, чтобы препроцессор встраиваемого SQL знал о них.</para>

   <para>Секция начинается с: <programlisting>EXEC SQL BEGIN DECLARE SECTION;</programlisting> и заканчивается командой: <programlisting>EXEC SQL END DECLARE SECTION;</programlisting> Между этими строками должны располагаться обычные объявления переменных C, например: <programlisting>int   x = 4;
char  foo[16], bar[16];</programlisting> Как здесь показано, переменной можно присвоить начальное значение. Область видимости переменной определяется расположением секции, в которой она объявляется в программе. Вы также можете объявить переменную следующим образом (при этом неявно создаётся секция объявлений): <programlisting>EXEC SQL int i = 4;</programlisting> Вы можете включать в программу столько секций объявлений, сколько захотите.</para>

   <para>Эти объявления выводятся в результирующий файл как объявления обычных переменных C, так что эти переменные не нужно объявлять снова. Переменные, которые не предназначены для использования в командах SQL, можно объявить как обычно вне этих специальных секций.</para>

   <para>Определение структуры или объединения тоже должно размещаться в секции <literal>DECLARE</literal>. В противном случае препроцессор не сможет воспринять эти типы, так как не будет знать их определения.</para>
  </sect2>

  <sect2 id="ecpg-retrieving">
   <title>Получение результатов запроса</title>

   <para>Теперь вы умеете передавать данные, подготовленные вашей программой, в команду SQL. Но как получить результаты запроса? Для этой цели во встраиваемом SQL есть особые вариации обычных команд <command>SELECT</command> и <command>FETCH</command>. У этих команд есть специальное предложение <literal>INTO</literal>, определяющее, в какие переменные среды будут помещены получаемые значения. <command>SELECT</command> используется для запросов, возвращающих только одну строку, а <command>FETCH</command> применяется с курсором для запросов, возвращающих несколько строк.</para>

   <para>Пример: <programlisting>/*
 * предполагается существование такой таблицы:
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;</programlisting> Предложение <literal>INTO</literal> размещается между списком выборки и предложением <literal>FROM</literal>. Число элементов в списке выборки должно равняться числу элементов в списке после <literal>INTO</literal> (также называемом целевым списком).</para>

   <para>Следующий пример демонстрирует использование команды <command>FETCH</command>: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);</programlisting> Здесь предложение <literal>INTO</literal> размещается после всех остальных обычных предложений.</para>

  </sect2>

  <sect2 id="ecpg-variables-type-mapping">
   <title>Сопоставление типов</title>

   <para>Когда приложения ECPG передают данные между сервером &productname; и программой на C, например, получая результаты запроса с сервера или выполняя операторы SQL с входными параметрам, эти данные должны преобразовываться из типов &productname; в типы переменных языка среды (а именно типы языка C) и наоборот. Одно из главных качеств ECPG состоит в том, что в большинстве случаев он делает это автоматически.</para>

   <para>В этом отношении можно выделить два вида типов данных. К первому относятся простые типы данных &productname;, такие как <type>integer</type> и <type>text</type>, которые приложение может непосредственно читать и писать. С другими типами данных, такими как <type>timestamp</type> и <type>numeric</type>, можно работать только через специальные функции; см. <xref remap="4" linkend="ecpg-special-types"/>.</para>

   <para>В <xref remap="6" linkend="ecpg-datatype-hostvars-table"/> показано, как типы данных &productname; соответствуют типам данных C. Когда нужно передать или получить значение определённого типа данных &productname;, вы должны объявить переменную C соответствующего типа C в секции объявлений.</para>

   <table id="ecpg-datatype-hostvars-table">
    <title>Соответствие между типами данных &productname; и типами переменных C</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Тип данных &productname;</entry>
       <entry>Тип переменной среды</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>С этим типом можно работать только через специальные функции; см. <xref remap="4" linkend="ecpg-special-types"/>.</para></footnote></entry>
      </row>

      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>

      <row>
       <entry><type>character(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</replaceable>+1]</type>, <type>VARCHAR[<replaceable>n</replaceable>+1]</type><footnote><para>объявляется в <filename>ecpglib.h</filename></para></footnote></entry>
      </row>

      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>

      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><para>объявляется в <filename>ecpglib.h</filename> при отсутствии стандартного объявления</para></footnote></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect3 id="ecpg-char">
    <title>Работа с символьными строками</title>

    <para>Для обработки типов символьных строк SQL, таких как <type>varchar</type> и <type>text</type>, предлагаются два варианта объявления переменных среды.</para>

    <para>Первый способ заключается в использовании <type>char[]</type>, массива <type>char</type>, как чаще всего и представляются символьные данные в C. <programlisting>EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;</programlisting> Заметьте, что о длине этого массива вы должны подумать сами. Если вы укажете данную переменную среды в качестве целевой переменной запроса, возвращающего строку длиннее 49 символов, произойдёт переполнение буфера.</para>

    <para>В качестве другого подхода можно использовать специальный тип <type>VARCHAR</type>, представленный в ECPG. Определение массива типа <type>VARCHAR</type> преобразуется в структуру (<type>struct</type>) с собственным именем для каждой переменной. Объявление вида: <programlisting>VARCHAR var[180];</programlisting> преобразуется в: <programlisting>struct varchar_var { int len; char arr[180]; } var;</programlisting> Член структуры <structfield>arr</structfield> содержит строку, включающую завершающий нулевой байт. Таким образом, чтобы сохранить строку в переменной типа <type>VARCHAR</type>, эта переменная должна быть объявлена с длиной, учитывающей завершающий нулевой байт. Член структуры <structfield>len</structfield> содержит длину строки, сохранённой в <structfield>arr</structfield>, без завершающего нулевого байта. Когда на вход запросу подаётся переменная среды, у которой <literal>strlen(arr)</literal> отличается от <structfield>len</structfield>, применяется наименьшее значение.</para>

    <para><type>VARCHAR</type> можно записать в верхнем или нижнем регистре, но не в смешанном.</para>

    <para>Переменные <type>char</type> и <type>VARCHAR</type> также могут содержать значения других типов SQL в их строковом представлении.</para>
   </sect3>

   <sect3 id="ecpg-special-types">
    <title>Обработка специальных типов данных</title>

    <para>ECPG представляет некоторые особые типы, которые должны помочь вам легко оперировать некоторыми специальными типами данных &productname;. В частности, в нём реализована поддержка типов <type>numeric</type>, <type>decimal</type>, <type>date</type>, <type>timestamp</type> и <type>interval</type>. Для этих типов нельзя подобрать полезное соответствие с примитивными типами среды (например, <type>int</type>, <type>long long int</type> или <type>char[]</type>), так как они имеют сложную внутреннюю структуру. Приложения, работающие с этими типами, должны объявлять переменные особых типов и работать с ними, применяя функции из библиотеки pgtypes. Эта библиотека, подробно описанная в <xref remap="6" linkend="ecpg-pgtypes"/> содержит базовые функции для оперирования этими типами, чтобы вам не требовалось, например, передавать запрос SQL-серверу, когда нужно просто добавить интервал к значению времени.</para>

    <para>Эти особые типы данных описаны в следующих подразделах. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обратитесь к <xref remap="3" linkend="ecpg-pgtypes"/>.</para>

    <sect4 id="ecpg-type-timestamp-date">
     <title>timestamp, date</title>

     <para>Для работы с переменными <type>timestamp</type> в приложении ECPG применяется следующая схема.</para>

     <para>Сначала в программу нужно включить заголовочный файл, чтобы получить определение типа <type>timestamp</type>: <programlisting>#include &lt;pgtypes_timestamp.h&gt;</programlisting></para>

     <para>Затем объявите в секции объявлений переменную типа <type>timestamp</type>: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;</programlisting></para>

     <para>Прочитав значение в эту переменную, выполняйте действия с ним, используя функции в библиотеке pgtypes. В следующем примере значение <type>timestamp</type> преобразуется в текстовый вид (ASCII) с помощью функции <function>PGTYPEStimestamp_to_asc()</function>: <programlisting>EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));</programlisting> Этот пример выведет такой результат: <screen>
ts = 2010-06-27 18:03:56.949343
</screen></para>

     <para>Таким же образом можно работать и с типом DATE. В программу нужно включить <filename>pgtypes_date.h</filename>, объявить переменную типа date, и затем можно будет преобразовать значение DATE в текстовый вид, используя функцию <function>PGTYPESdate_to_asc()</function>. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обратитесь к <xref remap="3" linkend="ecpg-pgtypes"/>.</para>
    </sect4>

    <sect4 id="ecpg-type-interval">
     <title>interval</title>

     <para>Принцип работы с типом <type>interval</type> тот же, что и с типами <type>timestamp</type> и <type>date</type>, однако для значения типа <type>interval</type> нужно явно выделить память. Другими словами, блок памяти для этой переменной должен размещаться в области кучи, а не в стеке.</para>

     <para>Пример программы: <programlisting>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pgtypes_interval.h&gt;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}</programlisting></para>
    </sect4>

    <sect4 id="ecpg-type-numeric-decimal">
     <title>numeric, decimal</title>

     <para>Типы <type>numeric</type> и <type>decimal</type> обрабатываются так же, как и тип <type>interval</type>: вы должны определить указатель, выделить некоторое пространство памяти в куче и обращаться к переменной, используя функции в библиотеке pgtypes. Чтобы подробнее узнать о функциях в библиотеке pgtypes, обратитесь к <xref remap="3" linkend="ecpg-pgtypes"/>.</para>

     <para>Для типа <type>decimal</type> никакие специальные функции не реализованы. Для дальнейшей обработки приложение должно преобразовать его в переменную <type>numeric</type>, применив функцию из библиотеки pgtypes.</para>

     <para>Следующий пример демонстрирует работу с переменными типов <type>numeric</type> и <type>decimal</type>. <programlisting>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pgtypes_numeric.h&gt;

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* Преобразовать decimal в numeric, чтобы вывести десятичное значение. */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}</programlisting></para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-variables-nonprimitive-c">
    <title>Переменные среды для непримитивных типов</title>

    <para>В качестве переменных среды также можно использовать массивы, определения типов, структуры и указатели.</para>

    <sect4 id="ecpg-variables-arrays">
     <title>Массивы</title>

     <para>Для применения массивов в качестве переменных среды есть два варианта использования. Во-первых, в массиве <type>char[]</type> или <type>VARCHAR[]</type> можно сохранить текстовую строку, как рассказывалось в <xref remap="6" linkend="ecpg-char"/>. Во-вторых, в массив можно получить несколько строк из результата запроса, не используя курсор. Чтобы не применяя массивы, обработать результат запроса, состоящий из нескольких строк, нужно использовать курсор и команду <command>FETCH</command>. Но с переменными-массивами несколько строк можно получить сразу. Длина определяемого массива должна быть достаточной для размещения всех строк, иначе скорее всего произойдёт переполнение буфера.</para>

     <para>Следующий пример сканирует системную таблицу <literal>pg_database</literal> и показывает все OID и имена доступных баз данных: <programlisting>int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;

    /* Получить в массивы сразу несколько строк. */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}</programlisting> Этот пример выводит следующий результат. (Точные значения зависят от локальных обстоятельств.) <screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen></para>
    </sect4>

    <sect4 id="ecpg-variables-struct">
     <title>Структуры</title>

     <para>Для получения значений сразу нескольких столбцов можно применить структуру, имена членов которой совпадают с именами столбцов результата запроса. Структура позволяет обрабатывать значения нескольких столбцов в одной переменной среды.</para>

     <para>Следующий пример получает значения OID, имена и размеры имеющихся баз данных из системной таблицы <literal>pg_database</literal>, используя при этом функцию <function>pg_database_size()</function>. В этом примере переменная типа структуры <varname>dbinfo_t</varname> с членами, имена которых соответствуют именам всех столбцов результата <literal>SELECT</literal>, применяется для получения одной строки результата без вовлечения в оператор <literal>FETCH</literal> нескольких переменных среды. <programlisting>EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* по достижении конца набора результатов прервать цикл while */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Выбрать несколько столбцов в одну структуру. */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* Напечатать члены структуры. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;</programlisting></para>

     <para>Этот пример показывает следующий результат. (Точные значения зависят от локальных обстоятельств.) <screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen></para>

     <para>Переменные среды типа структуры <quote>вбирают в себя</quote> столько столбцов, сколько полей содержит структура. Значения дополнительных столбцов можно присвоить другим переменным среды. Например, приведённую выше программу можно видоизменить следующим образом, разместив переменную <varname>size</varname> вне структуры: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* по достижении конца набора результатов прервать цикл while */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Выбрать несколько столбцов в одну структуру. */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* Напечатать члены структуры. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;</programlisting></para>
    </sect4>

    <sect4>
     <title>Определения типов</title>

     <para>Чтобы сопоставить новые типы с уже существующими, используйте ключевое слово <literal>typedef</literal>. <programlisting>EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;</programlisting> Заметьте, что вы также можете написать: <programlisting>EXEC SQL TYPE serial_t IS long;</programlisting> Это объявление не обязательно должно находиться в секции объявлений.</para>
    </sect4>

    <sect4>
     <title>Указатели</title>

     <para>Вы можете объявлять указатели на самые распространённые типы. Учтите, однако, что указатели нельзя использовать в качестве целевых переменных запросов без автовыделения. За дополнительными сведениями об автовыделении обратитесь к <xref remap="3" linkend="ecpg-descriptors"/>.</para>

     <para>
<programlisting>EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;</programlisting>
     </para>
    </sect4>
   </sect3>
  </sect2>

  <sect2 id="ecpg-variables-nonprimitive-sql">
   <title>Обработка непримитивных типов данных SQL</title>

   <para>В этом разделе описывается как работать с нескалярными и пользовательскими типами уровня SQL в приложениях ECPG. Заметьте, что этот подход отличается от использования переменных непримитивных типов, описанного в предыдущем разделе.</para>

   <sect3>
    <title>Массивы</title>

    <para>Многомерные массивы уровня SQL в ECPG напрямую не поддерживаются, но одномерные массивы уровня SQL могут быть сопоставлены с переменными-массивами среды C и наоборот. Однако учтите, что когда создаётся оператор, ecpg не знает типов столбцов, поэтому не может проверить, вводится ли массив C в соответствующий массив уровня SQL. Обрабатывая результат оператора SQL, ecpg имеет необходимую информацию и таким образом может убедиться, что с обеих сторон массивы.</para>

    <para>Если запрос обращается к отдельным <emphasis>элементам</emphasis> массива, это избавляет от необходимости применять массивы в ECPG. В этом случае следует использовать переменную среды, имеющую тип, который можно сопоставить типу элемента. Например, если типом столбца является массив <type>integer</type>, можно использовать переменную среды типа <type>int</type>. Аналогично, если тип элемента — <type>varchar</type> или <type>text</type>, можно использовать переменную типа <type>char[]</type> или <type>VARCHAR[]</type>.</para>

    <para>Предположим, что у нас есть таблица: <programlisting>CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)</programlisting> Следующая программа получает 4-ый элемент массива и сохраняет его в переменной среды, имеющей тип <type>int</type>: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;</programlisting> Этот пример выводит следующий результат: <screen>
ii=4
</screen></para>

    <para>Чтобы сопоставить несколько элементов массива с несколькими элементами переменной-массивом среды, каждый элемент массива SQL нужно по отдельности связать с каждым элементом массива среды, например: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}</programlisting></para>

    <para>Ещё раз обратите внимание, что в этом случае вариант <programlisting>EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* НЕПРАВИЛЬНО */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}</programlisting> не будет работать корректно, так как столбец с типом массива нельзя напрямую сопоставить с переменной-массивом среды.</para>

    <para>Можно также применить обходное решение — хранить массивы в их внешнем строковом представлении в переменных среды типа <type>char[]</type> или <type>VARCHAR[]</type>. Более подробно это представление описывается в <xref remap="6" linkend="arrays-input"/>. Заметьте, это означает, что с таким массивом в программе нельзя будет работать естественным образом (без дополнительного разбора текстового представления).</para>
   </sect3>

   <sect3>
    <title>Составные типы</title>

    <para>Составные типы в ECPG напрямую не поддерживаются, но есть простое обходное решение. Для решения этой проблемы можно применить те же подходы, что были описаны выше для массивов: обращаться к каждому атрибуту по отдельности или использовать внешнее строковое представление.</para>

    <para>Для следующих примеров предполагается, что существует такой тип и таблица: <programlisting>CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, '&productname;') );</programlisting> Самое очевидное решение заключается в обращении к каждому атрибуту по отдельности. Следующая программа получает данные из тестовой таблицы, выбирая атрибуты типа <type>comp_t</type> по одному: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* Указать каждый элемент столбца составного типа в списке SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Выбрать каждый элемент столбца составного типа в переменную среды. */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;</programlisting></para>

    <para>В развитие этого примера, переменные среды, в которые помещаются результаты команды <command>FETCH</command>, можно собрать в одну структуру. Подробнее переменные среды в форме структуры описываются в <xref remap="6" linkend="ecpg-variables-struct"/>. Чтобы перейти к структуре, пример можно изменить как показано ниже. Переменные среды, <varname>intval</varname> и <varname>textval</varname>, становятся членами структуры <structname>comp_t</structname>, и эта структура указывается в команде <command>FETCH</command>. <programlisting>EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* Поместить каждый элемент составного типа в список SELECT. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Поместить все значения списка SELECT в одну структуру. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;</programlisting> Хотя в команде <command>FETCH</command> используется структура, имена атрибутов в предложении <command>SELECT</command> задаются по одному. Это можно дополнительно улучшить, написав <literal>*</literal>, что будет обозначать все атрибуты значения составного типа. <programlisting>...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Выбрать все значения в списке SELECT в одну структуру. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...</programlisting> Таким образом составные типы можно сопоставить со структурами практически прозрачно, хотя ECPG и не понимает составные типы.</para>

    <para>Наконец, также можно сохранить значения составного типа в их внешнем строковом представлении в переменных среды типа <type>char[]</type> или <type>VARCHAR[]</type>. Однако при таком подходе нет простой возможности обращаться из программы к полям значения.</para>
   </sect3>

   <sect3>
    <title>Пользовательские базовые типы</title>

    <para>Определяемые пользователем базовые типы не поддерживаются ECPG напрямую. Для них можно использовать внешнее строковое представление и переменные среды типа <type>char[]</type> или <type>VARCHAR[]</type>, и это решение действительно будет подходящим и достаточным для большинства типов.</para>

    <para>Следующий фрагмент кода демонстрирует использование типа данных <type>complex</type> из примера в <xref remap="6" linkend="xtypes"/>. Внешнее строковое представление этого типа имеет форму <literal>(%lf,%lf)</literal> и определено в функциях <function>complex_in()</function> и <function>complex_out()</function> в <xref remap="6" linkend="xtypes"/>. Следующий пример вставляет значения комплексного типа <literal>(1,1)</literal> и <literal>(3,3)</literal> в столбцы <literal>a</literal> и <literal>b</literal>, а затем выбирает их из таблицы. <programlisting>EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;</programlisting> Этот пример выводит следующий результат: <screen>
a=(1,1), b=(3,3)
</screen></para>

    <para>Другое обходное решение состоит в том, чтобы избегать прямого использования пользовательских типов в ECPG, а вместо этого создать функцию или приведение, выполняющее преобразование между пользовательским типом и примитивным типом, который может обработать ECPG. Заметьте однако, что приведения типов, особенно неявные, нужно добавлять в систему типов очень осторожно.</para>

    <para>Например: <programlisting>CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;</programlisting> После такого определения следующий код <programlisting>EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));</programlisting> будет работать так же, как <programlisting>EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');</programlisting></para>
   </sect3>
  </sect2>

  <sect2 id="ecpg-indicators">
   <title>Индикаторы</title>

   <para>Приведённые выше примеры никак не обрабатывали значения NULL. На самом деле, в примерах с извлечением данных возникнет ошибка, если они выберут из базы данных значение NULL. Чтобы можно было передавать значения NULL в базу данных или получать их из базы данных, вы должны добавить объявление второй переменной среды для каждой переменной среды, содержащей данные. Эта вторая переменная среды называется <firstterm>индикатором</firstterm> и содержит флаг, показывающий, что в данных передаётся NULL, и при этом значение основной переменной среды игнорируется. Следующий пример демонстрирует правильную обработку значений NULL: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;</programlisting> Переменная индикатора <varname>val_ind</varname> будет равна нулю, если значение не NULL, или отрицательному числу, если NULL.</para>

   <para>Индикатор выполняет ещё одну функцию: если он содержит положительное число, это означает, что значение не NULL, но оно было обрезано, когда сохранялось в переменной среды.</para>

   <para>Если препроцессору <command>ecpg</command> передаётся аргумент <literal>-r no_indicator</literal>, он работает в режиме <quote>без индикатора</quote>. В этом режиме, если переменная индикатора не определена, значения NULL обозначаются (при вводе и выводе) для символьных строк пустой строкой, а для целочисленных типов наименьшим возможным значением этого типа (например, <symbol>INT_MIN</symbol> для <type>int</type>).</para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
  <title>Динамический SQL</title>

  <para>Во многих случаях конкретные операторы SQL, которые должно выполнять приложение, известны в момент написания приложения. В некоторых случаях, однако, операторы SQL формируются во время выполнения или поступают из внешнего источника. В этих случаях операторы SQL нельзя внедрить непосредственно в исходный код C, но есть средство, позволяющее вызывать произвольные операторы SQL, передаваемые в строковой переменной.</para>

  <sect2 id="ecpg-dynamic-without-result">
   <title>Выполнение операторов без набора результатов</title>

   <para>Самый простой способ выполнить произвольный оператор SQL — применить команду <command>EXECUTE IMMEDIATE</command>. Например: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;</programlisting> <command>EXECUTE IMMEDIATE</command> можно применять для SQL-операторов, которые не возвращают набор результатов (например, DDL, <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>). Выполнять операторы, которые получают данные, (например, <command>SELECT</command>) таким образом нельзя. Как выполнять такие операторы, рассказывается в следующем разделе.</para>
  </sect2>

  <sect2 id="ecpg-dynamic-input">
   <title>Выполнение оператора с входными параметрами</title>

   <para>Более эффективно выполнять произвольный оператор SQL можно, подготовив его один раз, а затем запуская подготовленный оператор столько, сколько нужно. Также можно подготовить обобщённую версию оператора, а затем выполнять специализированные его версии, подставляя в него параметры. Подготавливая оператор, поставьте знаки вопроса там, где позже хотите подставить параметры. Например: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';</programlisting></para>

   <para>Когда подготовленный оператор больше не нужен, его следует освободить: <programlisting>EXEC SQL DEALLOCATE PREPARE <replaceable>имя</replaceable>;</programlisting></para>
  </sect2>

  <sect2 id="ecpg-dynamic-with-result">
   <title>Выполнение оператора с набором результатов</title>

   <para>Для выполнения оператора SQL с одной строкой результата можно применить команду <command>EXECUTE</command>. Чтобы сохранить результат, добавьте предложение <literal>INTO</literal>. <programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting> Команда <command>EXECUTE</command> может содержать предложение <literal>INTO</literal> и/или предложение <literal>USING</literal>, либо не содержать ни того, ни другого.</para>

   <para>Если ожидается, что запрос вернёт более одной строки результата, следует применять курсор, как показано в следующем примере. (Подробно курсоры описываются в <xref remap="6" linkend="ecpg-cursors"/>.) <programlisting>EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-pgtypes">
  <title>Библиотека pgtypes</title>

  <para>Библиотека pgtypes сопоставляет типы базы данных <productname>&productname;</productname> с их эквивалентами в C, которые можно использовать в программах на C. Она также предлагает функции для выполнения простых вычислений с этими типами в C, то есть без помощи сервера <productname>&productname;</productname>. Рассмотрите следующий пример: <programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
free(out);
]]>
</programlisting></para>

  <sect2 id="ecpg-pgtypes-numeric">
   <title>Тип numeric</title>
   <para>Тип numeric позволяет производить вычисления с фиксированной точностью. Эквивалентный ему тип на сервере <productname>&productname;</productname> описан в <xref remap="6" linkend="datatype-numeric"/>. Ввиду того, что переменная имеет фиксированную точность, она должна расширяться и сжиматься динамически. Поэтому такие переменные можно создавать только в области кучи, используя функции <function>PGTYPESnumeric_new</function> и <function>PGTYPESnumeric_free</function>. Тип decimal подобен numeric, но имеет ограниченную точность, и поэтому может размещаться и в области кучи, и в стеке.</para>
   <para>Для работы с типом numeric можно использовать следующие функции: <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>Запрашивает указатель на новую переменную, размещённую в памяти. <synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>Освобождает переменную типа numeric, высвобождая всю её память. <synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>Разбирает числовой тип из строковой записи. <synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis> Допускаются в частности следующие форматы: <literal>-2</literal>, <literal>.794</literal>, <literal>+3.44</literal>, <literal>592.49E07</literal> и <literal>-32.84e-4</literal>. Если значение удаётся разобрать успешно, возвращается действительный указатель, в противном случае указатель NULL. На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <literal>*endptr</literal>. Поэтому в <literal>endptr</literal> свободно можно передать NULL.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>Возвращает указатель на строку, выделенную функцией <function>malloc</function> и содержащую строковое представление значения <literal>num</literal> числового типа. <synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis> Числовое значение будет выводиться с заданным в <literal>dscale</literal> количеством цифр после запятой, округлённое при необходимости.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>Суммирует две числовые переменные и возвращает результат в третьей. <synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis> Эта функция суммирует переменные <literal>var1</literal> и <literal>var2</literal> в результирующую переменную <literal>result</literal>. Функция возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>Вычисляет разность двух числовых переменных и возвращает результат в третьей. <synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis> Эта функция вычитает переменную <literal>var2</literal> из <literal>var1</literal>. Результат операции помещается в переменную <literal>result</literal>. Функция возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>Перемножает две числовые переменные и возвращает результат в третьей. <synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis> Эта функция перемножает переменные <literal>var1</literal> и <literal>var2</literal>. Результат операции сохраняется в переменной <literal>result</literal>. Функция возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>Вычисляет частное двух числовых переменных и возвращает результат в третьей. <synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis> Эта функция делит переменную <literal>var1</literal> на <literal>var2</literal>. Результат операции сохраняется в переменной <literal>result</literal>. Функция возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>Сравнивает две числовые переменные. <synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis> Эта функция производит сравнение двух числовых переменных. При ошибке возвращается <literal>INT_MAX</literal>. В случае успеха функция возвращает одно из трёх возможных значений: <itemizedlist>
        <listitem>
         <para>1, если <literal>var1</literal> больше <literal>var2</literal></para>
        </listitem>
        <listitem>
         <para>-1, если <literal>var1</literal> меньше <literal>var2</literal></para>
        </listitem>
        <listitem>
         <para>0, если <literal>var1</literal> и <literal>var2</literal> равны</para>
        </listitem>
       </itemizedlist></para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>Преобразует переменную int в переменную numeric. <synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis> Эта функция принимает целочисленную переменную со знаком типа signed int и сохраняет её значение в переменной <literal>var</literal> типа numeric. Функция возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>Преобразует переменную long int в переменную numeric. <synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis> Эта функция принимает целочисленную переменную со знаком типа signed long int и сохраняет её значение в переменной <literal>var</literal> типа numeric. Функция возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>Копирует одну числовую переменную в другую. <synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis> Эта функция копирует значение переменной, на которую указывает <literal>src</literal>, в переменную, на которую указывает <literal>dst</literal>. Она возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>Преобразует переменную типа double в переменную numeric. <synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis> Эта функция принимает переменную типа double и сохраняет преобразованное значение в переменной, на которую указывает <literal>dst</literal>. Она возвращает 0 в случае успеха и -1 при ошибке.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>Преобразует переменную типа numeric в переменную double. <synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis> Эта функция преобразует значение типа numeric переменной, на которую указывает <literal>nv</literal>, в переменную типа double, на которую указывает <literal>dp</literal>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <literal>errno</literal> дополнительно устанавливается значение <literal>PGTYPES_NUM_OVERFLOW</literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>Преобразует переменную типа numeric в переменную int. <synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis> Эта функция преобразует значение типа numeric переменной, на которую указывает <literal>nv</literal>, в целочисленную переменную, на которую указывает <literal>ip</literal>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <literal>errno</literal> дополнительно устанавливается значение <literal>PGTYPES_NUM_OVERFLOW</literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>Преобразует переменную типа numeric в переменную long. <synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis> Эта функция преобразует значение типа numeric переменной, на которую указывает <literal>nv</literal>, в целочисленную переменную типа long, на которую указывает <literal>lp</literal>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <literal>errno</literal> дополнительно устанавливается значение <literal>PGTYPES_NUM_OVERFLOW</literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>Преобразует переменную типа numeric в переменную decimal. <synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis> Эта функция преобразует значение типа numeric переменной, на которую указывает <literal>src</literal>, в переменную типа decimal, на которую указывает <literal>dst</literal>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <literal>errno</literal> дополнительно устанавливается значение <literal>PGTYPES_NUM_OVERFLOW</literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>Преобразует переменную типа decimal в переменную numeric. <synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis> Эта функция преобразует значение типа decimal переменной, на которую указывает <literal>src</literal>, в переменную типа numeric, на которую указывает <literal>dst</literal>. Она возвращает 0 в случае успеха и -1 при ошибке. Так как тип decimal реализован как ограниченная версия типа numeric, при таком преобразовании переполнение невозможно.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>
  </sect2>

  <sect2 id="ecpg-pgtypes-date">
   <title>Тип date</title>
   <para>Тип date, реализованный в C, позволяет программам работать с данными типа date в SQL. Соответствующий тип сервера <productname>&productname;</productname> описан в <xref remap="6" linkend="datatype-datetime"/>.</para>
   <para>Для работы с типом date можно использовать следующие функции: <variablelist>
     <varlistentry id="pgtypesdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>Извлекает часть даты из значения типа timestamp. <synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis> Эта функция получает в единственном аргументе значение времени типа timestamp и возвращает извлечённую из него дату.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>Разбирает дату из её текстового представления. <synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis> Эта функция получает строку C char* <literal>str</literal> и указатель на строку C char* <literal>endptr</literal>. На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <literal>*endptr</literal>. Поэтому в <literal>endptr</literal> свободно можно передать NULL.</para>
       <para>Заметьте, что эта функция всегда подразумевает формат дат MDY (месяц-день-год) и никакой переменной для изменения этого формата в ECPG нет.</para>
       <para>Все допустимые форматы ввода перечислены в <xref remap="6" linkend="ecpg-pgtypesdate-from-asc-table"/>.</para>
        <table id="ecpg-pgtypesdate-from-asc-table">
         <title>Допустимые форматы ввода для <function>PGTYPESdate_from_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Ввод</entry>
            <entry>Результат</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
            <entry><literal>год и день года</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
            <entry><literal>День по юлианскому календарю</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
            <entry><literal>99 год до нашей эры</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>Возвращает текстовое представление переменной типа date. <synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis> Эта функция получает в качестве единственного параметра дату <literal>dDate</literal> и выводит её в виде <literal>1999-01-18</literal>, то есть в формате <literal>YYYY-MM-DD</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>Извлекает значения дня, месяца и года из переменной типа date. <synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis> Эта функция получает дату <literal>d</literal> и указатель на 3 целочисленных значения <literal>mdy</literal>. Имя переменной указывает на порядок значений: в <literal>mdy[0]</literal> записывается номер месяца, в <literal>mdy[1]</literal> — номер дня, а в <literal>mdy[2]</literal> — год.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>Образует значение даты из массива 3 целых чисел, задающих день, месяц и год даты. <synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis> Эта функция получает в первом аргументе массив из 3 целых чисел (<literal>mdy</literal>), а во втором указатель на переменную типа date, в которую будет помещён результат операции.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>Возвращает число, представляющее день недели для заданной даты. <synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis> Эта функция принимает в единственном аргументе переменную <literal>d</literal> типа date и возвращает целое число, выражающее день недели для этой даты. <itemizedlist>
         <listitem>
          <para>0 — Воскресенье</para>
         </listitem>
         <listitem>
          <para>1 — Понедельник</para>
         </listitem>
         <listitem>
          <para>2 — Вторник</para>
         </listitem>
         <listitem>
          <para>3 — Среда</para>
         </listitem>
         <listitem>
          <para>4 — Четверг</para>
         </listitem>
         <listitem>
          <para>5 — Пятница</para>
         </listitem>
         <listitem>
          <para>6 — Суббота</para>
         </listitem>
        </itemizedlist></para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>Выдаёт текущую дату. <synopsis>
void PGTYPESdate_today(date *d);
</synopsis> Эта функция получает указатель на переменную (<literal>d</literal>) типа date, в которую будет записана текущая дата.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>Преобразует переменную типа date в текстовое представление по маске формата. <synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis> Эта функция принимает дату для преобразования (<literal>dDate</literal>), маску формата (<literal>fmtstring</literal>) и строку, в которую будет помещено текстовое представление даты (<literal>outbuf</literal>).</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
       <para>В строке формата можно использовать следующие коды полей: <itemizedlist>
         <listitem>
          <para><literal>dd</literal> — Номер дня в месяце.</para>
         </listitem>
         <listitem>
          <para><literal>mm</literal> — Номер месяца в году.</para>
         </listitem>
         <listitem>
          <para><literal>yy</literal> — Номер года в виде двух цифр.</para>
         </listitem>
         <listitem>
          <para><literal>yyyy</literal> — Номер года в виде четырёх цифр.</para>
         </listitem>
         <listitem>
          <para><literal>ddd</literal> — Название дня недели (сокращённое).</para>
         </listitem>
         <listitem>
          <para><literal>mmm</literal> — Название месяца (сокращённое).</para>
         </listitem>
        </itemizedlist> Все другие символы копируются в выводимую строку 1:1.</para>
       <para>В <xref remap="6" linkend="ecpg-pgtypesdate-fmt-asc-example-table"/> перечислены несколько возможных форматов. Это даёт представление, как можно использовать эту функцию. Все строки вывода даны для одной даты: 23 ноября 1959 г.</para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
         <title>Допустимые форматы ввода для <function>PGTYPESdate_fmt_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Формат</entry>
            <entry>Результат</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>Преобразует строку C <type>char*</type> в значение типа date по маске формата. <synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis> Эта функция принимает указатель на переменную типа date (<literal>d</literal>), в которую будет помещён результат операции, маску формата для разбора даты (<literal>fmt</literal>) и строку C char*, содержащую текстовое представление даты (<literal>str</literal>). Ожидается, что текстовое представление будет соответствовать маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция анализирует только порядок элементов и ищет в нём подстроки <literal>yy</literal> или <literal>yyyy</literal>, обозначающие позицию года, подстроку <literal>mm</literal>, обозначающую позицию месяца, и <literal>dd</literal>, обозначающую позицию дня.</para>
       <para>В <xref linkend="ecpg-rdefmtdate-example-table"/> перечислены несколько возможных форматов. Это даёт представление, как можно использовать эту функцию.</para>
        <table id="ecpg-rdefmtdate-example-table">
         <title>Допустимые форматы ввода для <function>rdefmtdate</function></title>
         <tgroup cols="3">
          <thead>
           <row>
            <entry>Формат</entry>
            <entry>Строка</entry>
            <entry>Результат</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>In the year 2525, in the month of July, mankind will be alive on the 28th day</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
            <entry><literal>I said on the 28th of July in the year 2525</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>

  <sect2 id="ecpg-pgtypes-timestamp">
   <title>Тип timestamp</title>
   <para>Тип timestamp, реализованный в C, позволяет программам работать с данными типа timestamp в SQL. Соответствующий тип сервера <productname>&productname;</productname> описан в <xref remap="6" linkend="datatype-datetime"/>.</para>
   <para>Для работы с типом timestamp можно использовать следующие функции: <variablelist>
     <varlistentry id="pgtypestimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>Разбирает значение даты/времени из текстового представления в переменную типа timestamp. <synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis> Эта функция получает строку (<literal>str</literal>), которую нужно разобрать, и указатель на строку C char* (<literal>endptr</literal>). На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <literal>*endptr</literal>. Поэтому в <literal>endptr</literal> свободно можно передать NULL.</para>
       <para>В случае успеха эта функция возвращает разобранное время, а в случае ошибки возвращается <literal>PGTYPESInvalidTimestamp</literal> и в <varname>errno</varname> устанавливается значение <literal>PGTYPES_TS_BAD_TIMESTAMP</literal>. См. замечание относительно <xref linkend="pgtypesinvalidtimestamp"/>.</para>
       <para>Вообще вводимая строка может содержать допустимое указание даты, пробельные символы и допустимое указание времени в любом сочетании. Заметьте, что часовые пояса ECPG не поддерживает. Эта функция может разобрать их, но не задействует их в вычислениях как это делает, например, сервер <productname>&productname;</productname>. Указания часового пояса во вводимой строке просто игнорируются.</para>
       <para>В <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table"/> приведены несколько примеров вводимых строк.</para>
        <table id="ecpg-pgtypestimestamp-from-asc-example-table">
         <title>Допустимые форматы ввода для <function>PGTYPEStimestamp_from_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Ввод</entry>
            <entry>Результат</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
            <entry><literal>1999-01-08 04:05:06.789 (указание часового пояса игнорируется)</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187 04:05-08:00</literal></entry>
            <entry><literal>1999-01-08 04:05:00 (указание часового пояса игнорируется)</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       <para>Преобразует значение даты в строку C char*. <synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis> Эта функция принимает в качестве единственного аргумента <literal>tstamp</literal> значение типа timestamp и возвращает размещённую в памяти строку, содержащую текстовое представление даты/времени.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       <para>Получает текущее время. <synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis> Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую указывает <literal>ts</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       <para>Преобразует переменную типа timestamp в строку C char* по маске формата. <synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis> Эта функция получает в первом аргументе (<literal>ts</literal>) указатель на переменную типа timestamp, а в последующих указатель на буфер вывода (<literal>output</literal>), максимальную длину строки, которую может принять буфер (<literal>str_len</literal>), и маску формата, с которой будет выполняться преобразование (<literal>fmtstr</literal>).</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
       <para>В маске формата можно использовать коды формата, перечисленные ниже. Эти же коды принимает функция <function>strftime</function> из библиотеки <productname>libc</productname>. Любые символы, не относящиеся к кодам формата, будут просто скопированы в буфер вывода. <itemizedlist>
         <listitem>
          <para><literal>%A</literal> — заменяется локализованным представлением полного названия дня недели.</para>
         </listitem>
         <listitem>
          <para><literal>%a</literal> — заменяется локализованным представлением сокращённого названия дня недели.</para>
         </listitem>
         <listitem>
          <para><literal>%B</literal> — заменяется локализованным представлением полного названия месяца.</para>
         </listitem>
         <listitem>
          <para><literal>%b</literal> — заменяется локализованным представлением сокращённого названия месяца.</para>
         </listitem>
         <listitem>
          <para><literal>%C</literal> — заменяется столетием (год / 100) в виде десятичного числа; одиночная цифра предваряется нулём.</para>
         </listitem>
         <listitem>
          <para><literal>%c</literal> — заменяется локализованным представлением даты и времени.</para>
         </listitem>
         <listitem>
          <para><literal>%D</literal> — равнозначно <literal>%m/%d/%y</literal>.</para>
         </listitem>
         <listitem>
          <para><literal>%d</literal> — заменяется днём месяца в виде десятичного числа (01-31).</para>
         </listitem>
         <listitem>
          <para><literal>%E*</literal> <literal>%O*</literal> — расширения локали POSIX. Последовательности <literal>%Ec</literal> <literal>%EC</literal> <literal>%Ex</literal> <literal>%EX</literal> <literal>%Ey</literal> <literal>%EY</literal> <literal>%Od</literal> <literal>%Oe</literal> <literal>%OH</literal> <literal>%OI</literal> <literal>%Om</literal> <literal>%OM</literal> <literal>%OS</literal> <literal>%Ou</literal> <literal>%OU</literal> <literal>%OV</literal> <literal>%Ow</literal> <literal>%OW</literal> <literal>%Oy</literal> должны выводить альтернативные представления.</para>
          <para>Кроме того, альтернативные названия месяцев представляет код формата <literal>%OB</literal> (используется отдельно, без упоминания дня).</para>
         </listitem>
         <listitem>
          <para><literal>%e</literal> — заменяется днём в виде десятичного числа (1-31); одиночная цифра предваряется пробелом.</para>
         </listitem>
         <listitem>
          <para><literal>%F</literal> — равнозначно <literal>%Y-%m-%d</literal>.</para>
         </listitem>
         <listitem>
          <para><literal>%G</literal> — заменяется годом в виде десятичного числа (со столетием). При этом годом считается тот, что содержит наибольшую часть недели (дни недели начинаются с понедельника).</para>
         </listitem>
         <listitem>
          <para><literal>%g</literal> — заменяется тем же годом, что и <literal>%G</literal>, но в виде десятичного числа без столетия (00-99).</para>
         </listitem>
         <listitem>
          <para><literal>%H</literal> — заменяется часами (в 24-часовом формате) в виде десятичного числа (00-23).</para>
         </listitem>
         <listitem>
          <para><literal>%h</literal> — равнозначно <literal>%b</literal>.</para>
         </listitem>
         <listitem>
          <para><literal>%I</literal> — заменяется часами (в 12-часовом формате) в виде десятичного числа (01-12).</para>
         </listitem>
         <listitem>
          <para><literal>%j</literal> — заменяется днём года в виде десятичного числа (001-366).</para>
         </listitem>
         <listitem>
          <para><literal>%k</literal> — заменяется часами (в 24-часовом формате) в виде десятичного числа (0-23); одиночная цифра предваряется пробелом.</para>
         </listitem>
         <listitem>
          <para><literal>%l</literal> — заменяется часами (в 12-часовом формате) в виде десятичного числа (1-12); одиночная цифра предваряется пробелом.</para>
         </listitem>
         <listitem>
          <para><literal>%M</literal> — заменяется минутами в виде десятичного числа (00-59).</para>
         </listitem>
         <listitem>
          <para><literal>%m</literal> — заменяется номером месяца в виде десятичного числа (01-12).</para>
         </listitem>
         <listitem>
          <para><literal>%n</literal> — заменяется символом новой строки.</para>
         </listitem>
         <listitem>
          <para><literal>%O*</literal> — равнозначно <literal>%E*</literal>.</para>
         </listitem>
         <listitem>
          <para><literal>%p</literal> — заменяется локализованным представлением <quote>до полудня</quote> или <quote>после полудня</quote> в зависимости от времени.</para>
         </listitem>
         <listitem>
          <para><literal>%R</literal> — равнозначно <literal>%H:%M</literal>.</para>
         </listitem>
         <listitem>
          <para><literal>%r</literal> — равнозначно <literal>%I:%M:%S %p</literal>.</para>
         </listitem>
         <listitem>
          <para><literal>%S</literal> — заменяется секундами в виде десятичного числа (00-60).</para>
         </listitem>
         <listitem>
          <para><literal>%s</literal> — заменяется числом секунд с начала эпохи, по мировому времени (UTC).</para>
         </listitem>
         <listitem>
          <para><literal>%T</literal> — равнозначно <literal>%H:%M:%S</literal></para>
         </listitem>
         <listitem>
          <para><literal>%t</literal> — заменяется символом табуляции.</para>
         </listitem>
         <listitem>
          <para><literal>%U</literal> — заменяется номером недели в году (первым днём недели считается воскресенье) в виде десятичного числа (00-53).</para>
         </listitem>
         <listitem>
          <para><literal>%u</literal> — заменяется номером дня недели (первым днём недели считается понедельник) в виде десятичного числа (1-7).</para>
         </listitem>
         <listitem>
          <para><literal>%V</literal> — заменяется номером недели в году (первым днём недели считается понедельник) в виде десятичного числа (01-53). Если к недели, включающей 1 января, относятся 4 или больше дней нового года, она считается неделей с номером 1; в противном случае это последняя неделя предыдущего года, а неделей под номером 1 будет следующая.</para>
         </listitem>
         <listitem>
          <para><literal>%v</literal> — равнозначно <literal>%e-%b-%Y</literal>.</para>
         </listitem>
         <listitem>
          <para><literal>%W</literal> — заменяется номером недели в году (первым днём недели считается понедельник) в виде десятичного числа (00-53).</para>
         </listitem>
         <listitem>
          <para><literal>%w</literal> — заменяется номером дня недели (первым днём недели считается воскресенье) в виде десятичного числа (0-6).</para>
         </listitem>
         <listitem>
          <para><literal>%X</literal> — заменяется локализованным представлением времени.</para>
         </listitem>
         <listitem>
          <para><literal>%x</literal> — заменяется локализованным представлением даты.</para>
         </listitem>
         <listitem>
          <para><literal>%Y</literal> — заменяется годом со столетием в виде десятичного числа.</para>
         </listitem>
         <listitem>
          <para><literal>%y</literal> — заменяется годом без столетия в виде десятичного числа (00-99).</para>
         </listitem>
         <listitem>
          <para><literal>%Z</literal> — заменяется названием часового пояса.</para>
         </listitem>
         <listitem>
          <para><literal>%z</literal> — заменяется смещением часового пояса от UTC; ведущий знак плюс обозначает смещение к востоку от UTC, а знак минус — к западу, часы и минуты задаются парами цифр без разделителя между ними (эта форма установлена для даты в RFC 822).</para>
         </listitem>
         <listitem>
          <para><literal>%+</literal> — заменяется локализованным представлением даты и времени.</para>
         </listitem>
         <listitem>
          <para><literal>%-*</literal> — расширение GNU libc. Отключает дополнение чисел по ширине при выводе.</para>
         </listitem>
         <listitem>
          <para>$_* — расширение GNU libc. Явно включает дополнение пробелами.</para>
         </listitem>
         <listitem>
          <para><literal>%0*</literal> — расширение GNU libc. Явно включает дополнение нулями.</para>
         </listitem>
         <listitem>
          <para><literal>%%</literal> — заменяется символом <literal>%</literal>.</para>
         </listitem>
        </itemizedlist></para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       <para>Вычитает одно значение времени из другого и сохраняет результат в переменной типа interval. <synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis> Эта функция вычитает значение типа timestamp, на которое указывает <literal>ts2</literal>, из значения timestamp, на которое указывает <literal>ts1</literal>, и сохраняет результат в переменной типа interval, на которую указывает <literal>iv</literal>.</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       <para>Разбирает значение типа timestamp из текстового представления с заданной маской формата. <synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis> Эта функция получает текстовое представление даты/времени в переменной <literal>str</literal>, а также маску формата для разбора в переменной <literal>fmt</literal>. Результат будет сохранён в переменной, на которую указывает <literal>d</literal>.</para>
       <para>Если вместо маски формата <literal>fmt</literal> передаётся NULL, эта функция переходит к стандартной маске форматирования, а именно: <literal>%Y-%m-%d %H:%M:%S</literal>.</para>
       <para>Данная функция является обратной к функции <xref linkend="pgtypestimestampfmtasc"/>. Обратитесь к её документации, чтобы узнать о возможных вариантах маски формата.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       <para>Добавляет переменную типа interval к переменной типа timestamp. <synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis> Эта функция получает указатель на переменную <literal>tin</literal> типа timestamp и указатель на переменную <literal>span</literal> типа interval. Она добавляет временной интервал к значению даты/времени и сохраняет полученную дату/время в переменной типа timestamp, на которую указывает <literal>tout</literal>.</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       <para>Вычитает переменную типа interval из переменной типа timestamp. <synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis> Эта функция вычитает значение типа interval, на которое указывает <literal>span</literal>, из значения типа timestamp, на которое указывает <literal>tin</literal>, и сохраняет результат в переменной, на которую указывает <literal>tout</literal>.</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>

  <sect2 id="ecpg-pgtypes-interval">
   <title>Тип interval</title>
   <para>Тип interval, реализованный в C, позволяет программам работать с данными типа interval в SQL. Соответствующий тип сервера <productname>&productname;</productname> описан в <xref remap="6" linkend="datatype-datetime"/>.</para>
   <para>Для работы с типом interval можно использовать следующие функции: <variablelist>

     <varlistentry id="pgtypesintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>Возвращает указатель на новую переменную interval, размещённую в памяти. <synopsis>
interval *PGTYPESinterval_new(void);
</synopsis></para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>Освобождает место, занимаемое ранее размещённой в памяти переменной типа interval. <synopsis>
void PGTYPESinterval_new(interval *intvl);
</synopsis></para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>Разбирает значение типа interval из его текстового представления. <synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis> Эта функция разбирает входную строку <literal>str</literal> и возвращает указатель на размещённую в памяти переменную типа interval. На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <literal>*endptr</literal>. Поэтому в <literal>endptr</literal> свободно можно передать NULL.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>Преобразует переменную типа interval в текстовое представление. <synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis> Эта функция преобразует переменную типа interval, на которую указывает <literal>span</literal>, в строку C char*. Её вывод выглядит примерно так: <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>Копирует переменную типа interval. <synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis> Эта функция копирует переменную типа interval, на которую указывает <literal>intvlsrc</literal>, в переменную, на которую указывает <literal>intvldest</literal>. Заметьте, что для целевой переменной необходимо предварительно выделить память.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>

  <sect2 id="ecpg-pgtypes-decimal">
   <title>Тип decimal</title>
   <para>Тип decimal похож на тип numeric, однако его максимальная точность ограничена 30 значащими цифрами. В отличие от типа numeric, который можно создать только в области кучи, тип decimal можно создать и в стеке, и в области кучи (посредством функций <function>PGTYPESdecimal_new</function> и <function>PGTYPESdecimal_free</function>). Для работы с типом decimal есть много других функций, подключаемых в режиме совместимости с <productname>Informix</productname>, описанном в <xref remap="6" linkend="ecpg-informix-compat"/>.</para>
   <para>Для работы с типом decimal можно использовать следующие функции (содержащиеся не в библиотеке <literal>libcompat</literal>). <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>Запрашивает указатель на новую переменную decimal, размещённую в памяти. <synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>Освобождает переменную типа decimal, высвобождая всю её память. <synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis></para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>

   <sect2 id="ecpg-pgtypes-errno">
    <title>Значения errno, которые устанавливает pgtypeslib</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>Аргумент должен содержать переменную типа numeric (либо указывать на переменную типа numeric), но представление этого типа в памяти оказалось некорректным.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>Произошло переполнение. Так как тип numeric может принимать значения практически любой точности, при преобразовании этого типа в другие типы возможно переполнение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>Произошло антипереполнение. Так как тип numeric может принимать значения практически любой точности, при преобразовании переменной этого типа в другие типы возможно антипереполнение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>Имела место попытка деления на ноль.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>Функции <function>PGTYPESdate_from_asc</function> передана некорректная строка даты.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>Функции <function>PGTYPESdate_defmt_asc</function> переданы некорректные аргументы.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>В строке, переданной функции <function>PGTYPESdate_defmt_asc</function>, оказался неправильный компонент даты.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>Функции <function>PGTYPESinterval_from_asc</function> передана некорректная строка, задающая интервал, либо функции <function>PGTYPESinterval_to_asc</function> передано некорректное значение интервала.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>Обнаружено несоответствие при выводе компонентов день/месяц/год в функции <function>PGTYPESdate_defmt_asc</function>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>Функция <function>PGTYPESdate_defmt_asc</function> обнаружила некорректное значение дня месяца.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>Функция <function>PGTYPESdate_defmt_asc</function> обнаружила некорректное значение месяца.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>Функции <function>PGTYPEStimestamp_from_asc</function> передана некорректная строка даты/времени, либо функции <function>PGTYPEStimestamp_to_asc</function> передано некорректное значение типа timestamp.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>Значение типа timestamp, представляющее бесконечность, получено в недопустимом контексте.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-constants">
    <title>Специальные константы pgtypeslib</title>
   <para>
    <variablelist>
     <varlistentry id="pgtypesinvalidtimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>Значение типа timestamp, представляющее недопустимое время. Это значение возвращает функция <function>PGTYPEStimestamp_from_asc</function> при ошибке разбора. Заметьте, что вследствие особенности внутреннего представления типа <type>timestamp</type>, значение <literal>PGTYPESInvalidTimestamp</literal> в то же время представляет корректное время (<literal>1899-12-31 23:59:59</literal>). Поэтому для выявления ошибок необходимо, чтобы приложение не только сравнивало результат функции с <literal>PGTYPESInvalidTimestamp</literal>, но и проверяло условие <literal>errno != 0</literal> после каждого вызова <function>PGTYPEStimestamp_from_asc</function>.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
  <title>Использование областей дескрипторов</title>

  <para>Области дескрипторов SQL дают возможности для более сложной обработки результатов операторов <command>SELECT</command>, <command>FETCH</command> и <command>DESCRIBE</command>. Область дескриптора SQL объединяет в одной структуре данные одной строки и элементы метаданных. Эти метаданные особенно полезны при выполнении динамических SQL-операторов, когда характер результирующих столбцов может быть неизвестен заранее. &productname; предлагает два подхода к использованию областей дескрипторов: именованные области SQL-дескрипторов и области SQLDA в структурах C.</para>

  <sect2 id="ecpg-named-descriptors">
   <title>Именованные области SQL-дескрипторов</title>

   <para>Именованная область SQL-дескриптора состоит из заголовка, содержащего сведения обо всём дескрипторе, и одного или нескольких дескрипторов элементов, которые по сути описывают отдельные столбцы в строке результата.</para>

   <para>Прежде чем вы сможете использовать область SQL-дескриптора, её нужно выделить: <programlisting>EXEC SQL ALLOCATE DESCRIPTOR <replaceable>идентификатор</replaceable>;</programlisting> Заданный идентификатор играет роль <quote>имени переменной</quote> области дескриптора. <remark>Какова область видимости выделенного дескриптора?</remark> Когда дескриптор оказывается ненужным, его следует освободить: <programlisting>EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>идентификатор</replaceable>;</programlisting></para>

   <para>Чтобы воспользоваться областью дескриптора, её нужно указать в качестве целевого объекта в предложении <literal>INTO</literal>, вместо перечисления переменных среды: <programlisting>EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;</programlisting> Если набор результатов пуст, в области дескриптора будут, тем не менее, содержаться метаданные из запроса, то есть имена полей.</para>

   <para>Получить метаданные набора результатов для ещё не выполненных подготовленных запросов можно, воспользовавшись оператором <command>DESCRIBE</command>: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;</programlisting></para>

   <para>До PostgreSQL версии 9.0 ключевое слово <literal>SQL</literal> было необязательным, так что предложения <literal>DESCRIPTOR</literal> и <literal>SQL DESCRIPTOR</literal> создавали именованные области SQL-дескрипторов. Теперь оно стало обязательным; без слова <literal>SQL</literal> создаются области SQLDA, см. <xref remap="4" linkend="ecpg-sqlda-descriptors"/>.</para>

   <para>В операторах <command>DESCRIBE</command> и <command>FETCH</command> ключевые слова <literal>INTO</literal> и <literal>USING</literal> действуют примерно одинаково: они указывают вывести набор результатов и метаданные в область дескриптора.</para>

   <para>Возникает вопрос: а как же получить данные из области дескриптора? Область дескриптора можно представить как структуру с именованными полями. Чтобы получить значение поля из заголовка и сохранить его в переменной среды, нужно выполнить команду: <programlisting>EXEC SQL GET DESCRIPTOR <replaceable>имя</replaceable> :<replaceable>переменная_среды</replaceable> = <replaceable>поле</replaceable>;</programlisting> В настоящее время определено только одно поле заголовка: <replaceable>COUNT</replaceable>, которое говорит, сколько областей дескрипторов элементов существует (то есть, сколько столбцов содержится в результате). Переменная среды должна иметь целочисленный тип. Чтобы получить поле из области дескриптора элемента, нужно выполнить команду: <programlisting>EXEC SQL GET DESCRIPTOR <replaceable>имя</replaceable> VALUE <replaceable>номер</replaceable> :<replaceable>переменная_среды</replaceable> = <replaceable>поле</replaceable>;</programlisting> В качестве <replaceable>num</replaceable> можно задать обычное целое или переменную среды, содержащую целое число. Допустимые поля: <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> (integer)</term>
      <listitem>
       <para>число строк в наборе результатов</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>собственно элемент данных (тип данных поля зависит от запроса)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> (целое)</term>
      <listitem>
       <para>Когда <literal>TYPE</literal> равно <literal>9</literal>, <literal>DATETIME_INTERVAL_CODE</literal> содержит значение <literal>1</literal> для <literal>DATE</literal>, <literal>2</literal> для <literal>TIME</literal>, <literal>3</literal> для <literal>TIMESTAMP</literal>, <literal>4</literal> для <literal>TIME WITH TIME ZONE</literal>, либо <literal>5</literal> для <literal>TIMESTAMP WITH TIME ZONE</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> (целое)</term>
      <listitem>
       <para>не реализовано</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> (целое)</term>
      <listitem>
       <para>индикатор (отмечающий значение NULL или усечение значения)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> (целое)</term>
      <listitem>
       <para>не реализовано</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> (целое)</term>
      <listitem>
       <para>длина данных в символах</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (строка)</term>
      <listitem>
       <para>имя столбца</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> (целое)</term>
      <listitem>
       <para>не реализовано</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> (целое)</term>
      <listitem>
       <para>длина символьного представления данных в байтах</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> (целое)</term>
      <listitem>
       <para>точность (для типа <type>numeric</type>)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> (целое)</term>
      <listitem>
       <para>длина данных в символах</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> (целое)</term>
      <listitem>
       <para>длина символьного представления данных в байтах</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> (целое)</term>
      <listitem>
       <para>масштаб (для типа <type>numeric</type>)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> (целое)</term>
      <listitem>
       <para>числовой код типа данных столбца</para>
      </listitem>
     </varlistentry>
    </variablelist></para>

   <para>В операторах <command>EXECUTE</command>, <command>DECLARE</command> и <command>OPEN</command> ключевые слова <literal>INTO</literal> и <literal>USING</literal> действуют по-разному. Область дескриптора также можно сформировать вручную, чтобы передать входные параметры запросу или курсору, а команда <literal>USING SQL DESCRIPTOR <replaceable>имя</replaceable></literal> даёт возможность передать входные аргументы параметризованному запросу. Оператор, формирующий именованную область SQL-дескриптора, выглядит так: <programlisting>EXEC SQL SET DESCRIPTOR <replaceable>имя</replaceable> VALUE <replaceable>номер</replaceable> <replaceable>поле</replaceable> = :<replaceable>переменная_среды</replaceable>;</programlisting></para>

   <para>&productname; поддерживает выборку сразу нескольких записей в одном операторе <command>FETCH</command> и может сохранить их данные в переменной среды, если эта переменная — массив. Например: <programlisting>EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;</programlisting></para>

  </sect2>

  <sect2 id="ecpg-sqlda-descriptors">
   <title>Области дескрипторов SQLDA</title>

   <para>Область дескриптора SQLDA представляет собой структуру языка C, в которую можно получить набор результатов и метаданные запроса. Одна такая структура содержит одну запись из набора данных. <programlisting>EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;</programlisting> Заметьте, что ключевое слово <literal>SQL</literal> в этом случае опускается. Замечания относительно применения ключевых слов <literal>INTO</literal> и <literal>USING</literal> в <xref remap="6" linkend="ecpg-named-descriptors"/> применимы и здесь, с дополнением. В операторе <command>DESCRIBE</command> можно полностью опустить ключевое слово <literal>DESCRIPTOR</literal>, если присутствует ключевое слово <literal>INTO</literal>: <programlisting>EXEC SQL DESCRIBE prepared_statement INTO mysqlda;</programlisting></para>

    <procedure>
     <para>Общая схема использования SQLDA выглядит так:</para>
     <step><simpara>Подготовить запрос и объявить курсор для него.</simpara></step>
     <step><simpara>Объявить SQLDA для строк результата.</simpara></step>
     <step><simpara>Объявить SQLDA для входных параметров и инициализировать их (выделить память, задать параметры).</simpara></step>
     <step><simpara>Открыть курсор с входной SQLDA.</simpara></step>
     <step><simpara>Выбрать строки из курсора и сохранить их в выходной SQLDA.</simpara></step>
     <step><simpara>Прочитать значения из выходной SQLDA в переменные среды (и преобразовать при необходимости).</simpara></step>
     <step><simpara>Закрыть курсор.</simpara></step>
     <step><simpara>Освободить область памяти, выделенную для входной SQLDA.</simpara></step>
    </procedure>

   <sect3>
    <title>Структура данных SQLDA</title>

    <para>Для SQLDA используются три типа данных: <type>sqlda_t</type>, <type>sqlvar_t</type> и <type>struct sqlname</type>.</para>

    <tip>
     <para>Структура данных SQLDA в &productname; подобна той, что используется в IBM DB2 Universal Database, так что часть технической информации по SQLDA в DB2 может быть полезна и для понимания устройства SQLDA в &productname;.</para>
    </tip>

    <sect4 id="ecpg-sqlda-sqlda">
     <title>Структура sqlda_t</title>

     <para>Тип структуры <type>sqlda_t</type> представляет тип собственно SQLDA. Эта структура описывает одну запись. Две или более структур <type>sqlda_t</type> могут объединяться в связанный список по указателям в поле <structfield>desc_next</structfield>, и таким образом образовывать упорядоченный набор строк. Поэтому, когда выбираются две или более строк, приложение может прочитать их, проследуя по указателям <structfield>desc_next</structfield> во всех узлах <type>sqlda_t</type>.</para>

     <para>Тип <type>sqlda_t</type> определяется так: <programlisting>struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;</programlisting> Его поля имеют следующее назначение: <variablelist>
     <varlistentry>
      <term><literal>sqldaid</literal></term>
      <listitem>
       <para>Содержит строковую константу <literal>"SQLDA "</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</literal></term>
      <listitem>
       <para>Содержит размер выделенного пространства в байтах.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</literal></term>
      <listitem>
       <para>Содержит число входных параметров для параметризованного запроса, когда передаётся в операторы <command>OPEN</command>, <command>DECLARE</command> или <command>EXECUTE</command> с ключевым словом <literal>USING</literal>. В структуре, выводимой операторами <command>SELECT</command>, <command>EXECUTE</command> или <command>FETCH</command>, данное значение совпадает с <literal>sqld</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</literal></term>
      <listitem>
       <para>Содержит число полей в наборе результатов.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</literal></term>
      <listitem>
       <para>Если запрос выдаёт несколько записей, возвращается несколько связанных структур SQLDA, а <literal>desc_next</literal> содержит указатель на следующую запись в списке.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</literal></term>
      <listitem>
       <para>Это массив столбцов в наборе результатов.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlvar">
     <title>Структура sqlvar_t</title>

     <para>Тип структуры <type>sqlvar_t</type> содержит значение столбца и метаданные, в частности, тип и длину. Эта структура определяется так: <programlisting>struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;</programlisting> Её поля имеют следующее назначение: <variablelist>
         <varlistentry>
         <term><literal>sqltype</literal></term>
          <listitem>
           <para>Содержит идентификатор типа данного поля. Возможные значения перечислены в <literal>enum ECPGttype</literal> в <literal>ecpgtype.h</literal>.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</literal></term>
          <listitem>
           <para>Содержит двоичную длину поля, например, 4 байта для <type>ECPGt_int</type>.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</literal></term>
          <listitem>
           <para>Указывает на данные. Формат данных описан в <xref remap="6" linkend="ecpg-variables-type-mapping"/>.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</literal></term>
          <listitem>
           <para>Указывает на индикатор NULL. 0 соответствует значению не NULL, -1 — NULL.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</literal></term>
          <listitem>
           <para>Имя поля.</para>
          </listitem>
         </varlistentry>
        </variablelist></para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlname">
     <title>Структура struct sqlname</title>

     <para>Структура <type>struct sqlname</type> содержит имя столбца. Она включена в <type>sqlvar_t</type> в качестве члена. Эта структура определена так: <programlisting>#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};</programlisting> Её поля имеют следующее назначение: <variablelist>
             <varlistentry>
              <term><literal>length</literal></term>
               <listitem>
                <para>Содержит длину имени поля.</para>
               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</literal></term>
               <listitem>
                <para>Содержит собственно имя поля.</para>
               </listitem>
              </varlistentry>
            </variablelist></para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-sqlda-output">
    <title>Получение набора результатов с применением SQLDA</title>

    <procedure>
     <para>Чтобы получить набор результатов запроса через SQLDA, нужно проделать примерно следующее:</para>
     <step><simpara>Объявить структуру <type>sqlda_t</type> для получения набора результатов.</simpara></step>
     <step><simpara>Выполнить команды <command>FETCH</command>/<command>EXECUTE</command>/<command>DESCRIBE</command> для обработки запроса с указанной SQLDA.</simpara></step>
     <step><simpara>Определить число записей в наборе результатов, прочитав <structfield>sqln</structfield>, член структуры <type>sqlda_t</type>.</simpara></step>
     <step><simpara>Получить значения каждого столбца из элементов <literal>sqlvar[0]</literal>, <literal>sqlvar[1]</literal> и т. д., составляющих массив, включённый в структуру <type>sqlda_t</type>.</simpara></step>
     <step><simpara>Перейти к следующей строке (структуре <type>sqlda_t</type>) по указателю <structfield>desc_next</structfield>, члену структуры <type>sqlda_t</type>.</simpara></step>
     <step><simpara>При необходимости повторить эти действия.</simpara></step>
    </procedure>

    <para>Далее показывается, как получить набор результатов через SQLDA.</para>

    <para>Сначала объявите структуру <type>sqlda_t</type>, в которую будет помещён набор результатов. <programlisting>sqlda_t *sqlda1;</programlisting></para>

    <para>Затем укажите эту SQLDA в команде. В данном примере это команда <command>FETCH</command>. <programlisting>EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;</programlisting></para>

    <para>Обработайте все строки в цикле с переходом по связанному списку. <programlisting>sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda-&gt;desc_next)
{
    ...
}</programlisting></para>

    <para>Внутри этого цикла реализуйте ещё один цикл чтения данных каждого столбца (структуры <type>sqlvar_t</type>) в строке. <programlisting>for (i = 0; i &lt; cur_sqlda-&gt;sqld; i++)
{
    sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}</programlisting></para>

    <para>Чтобы получить значение столбца, прочитайте значение поля <structfield>sqltype</structfield>, члена структуры <type>sqlvar_t</type>. Затем выберите подходящий способ, в зависимости от типа столбца, копирования данных из поля <structfield>sqlvar</structfield> в переменную среды. <programlisting>char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}</programlisting></para>
   </sect3>

   <sect3 id="ecpg-sqlda-input">
    <title>Передача значений параметров через SQLDA</title>

    <procedure>
     <para>Чтобы передать параметры подготовленному запросу через SQLDA, нужно проделать примерно следующее:</para>
     <step><simpara>Создать подготовленный запрос (подготовленный оператор)</simpara></step>
     <step><simpara>Объявить структуру sqlda_t в качестве входной SQLDA.</simpara></step>
     <step><simpara>Выделить область памяти (структуру sqlda_t) для входной SQLDA.</simpara></step>
     <step><simpara>Установить (скопировать) входные значения в выделенной памяти.</simpara></step>
     <step><simpara>Открыть курсор, указав входную SQLDA.</simpara></step>
    </procedure>

    <para>Рассмотрим это на примере.</para>

    <para>Сначала создайте подготовленный оператор. <programlisting>EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;</programlisting></para>

    <para>Затем выделите память для SQLDA и установите число входных параметров в поле <structfield>sqln</structfield>, члене структуры <type>sqlda_t</type>. Когда для подготовленного запроса требуются два или более входных параметров, приложение должно выделить дополнительное место в памяти, размер которого вычисляется как (число параметров - 1) * sizeof(sqlvar_t). В показанном здесь примере выделяется место для двух параметров. <programlisting>sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2-&gt;sqln = 2; /* число входных переменных */</programlisting></para>

    <para>Выделив память, сохраните значения параметров в массиве <literal>sqlvar[]</literal>. (Этот же массив используется для значений столбцов, когда SQLDA получает набор результатов.) В данном примере передаются два параметра: <literal>"postgres"</literal> (строкового типа) и <literal>1</literal> (целочисленного типа). <programlisting>sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = "postgres";
sqlda2-&gt;sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);</programlisting></para>

    <para>Откройте курсор с указанием ранее созданной SQLDA, чтобы входные параметры были переданы подготовленному оператору. <programlisting>EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;</programlisting></para>

    <para>Наконец, закончив использование входных SQLDA, необходимо явно освободить выделенную для них память, в отличие от SQLDA, получающих результаты запросов. <programlisting>free(sqlda2);</programlisting></para>
   </sect3>

   <sect3 id="ecpg-sqlda-example">
    <title>Пример приложения, использующего SQLDA</title>

    <para>Представленный здесь пример программы показывает, как выбрать из системных каталогов статистику доступа к базам данных, определённых входными параметрами.</para>

    <para>Это приложение соединяет записи двух системных таблиц, pg_database и pg_stat_database по OID базы данных, и также выбирает и показывает статистику, принимая два входных параметра (база данных <literal>postgres</literal> и OID <literal>1</literal>).</para>

    <para>Сначала создайте SQLDA для ввода параметров и SQLDA для вывода результатов. <programlisting>EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* выходной дескриптор */
sqlda_t *sqlda2; /* входной дескриптор */</programlisting></para>

    <para>Затем подключитесь к базе данных, подготовьте оператор и объявите курсор для подготовленного оператора. <programlisting>int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;</programlisting></para>

    <para>Затем запишите некоторые значения параметров во входную SQLDA. Выделите память для входной SQLDA и установите количество параметров в <literal>sqln</literal>. Запишите тип, значение и длину значения в поля <literal>sqltype</literal>, <literal>sqldata</literal> и <literal>sqllen</literal> структуры <literal>sqlvar</literal>. <programlisting>    /* Создать структуру SQLDA для входных параметров. */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2-&gt;sqln = 2; /* number of input variables */

    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
    sqlda2-&gt;sqlvar[0].sqldata = "postgres";
    sqlda2-&gt;sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
    sqlda2-&gt;sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);</programlisting></para>

    <para>Подготовив входную SQLDA, откройте курсор с ней. <programlisting>    /* Открыть курсор с входными параметрами. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;</programlisting></para>

    <para>Выберите строки из открытого курсора в выходную SQLDA. (Обычно, чтобы выбрать все строки в наборе результатов, нужно повторять <command>FETCH</command> в цикле.) <programlisting>    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Назначить дескриптор курсору */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;</programlisting></para>

    <para>Затем прочитайте выбранные записи из SQLDA, следуя по связанному списку структуры <type>sqlda_t</type>. <programlisting>    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda-&gt;desc_next)
    {
        ...</programlisting></para>

    <para>Прочитайте все столбцы первой записи. Количество столбцов хранится в поле <structfield>sqld</structfield>, а данные первого столбца в <literal>sqlvar[0]</literal>, оба эти поля — члены структуры <type>sqlda_t</type>. <programlisting>        /* Вывести каждый столбец в строке. */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1-&gt;sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';</programlisting></para>

    <para>Теперь данные столбцов сохранены в переменной <varname>v</varname>. Скопируйте все элементы данных в переменные среды, определив тип столбца по полю <literal>v.sqltype</literal>. <programlisting>            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* integer */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }</programlisting></para>

    <para>Закончив обработку всех записей, закройте курсор и отключитесь от базы данных. <programlisting>    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;</programlisting></para>

    <para>Вся программа показана в <xref remap="6" linkend="ecpg-sqlda-example-example"/>.</para>

    <example id="ecpg-sqlda-example-example">
     <title>Пример программы на базе SQLDA</title>
<programlisting>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* дескриптор для выходных данных */
sqlda_t *sqlda2; /* дескриптор для входных данных */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* Создать структуру SQLDA для входных параметров */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2-&gt;sqln = 2; /* число входных переменных */

    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
    sqlda2-&gt;sqlvar[0].sqldata = "postgres";
    sqlda2-&gt;sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
    sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);

    /* Открыть курсор с входными параметрами. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Присвоить дескриптор курсору */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda-&gt;desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* Напечатать каждый столбец в строке. */
            for (i=0 ; i&lt;cur_sqlda-&gt;sqld ; i++)
            {
                sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* integer */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}</programlisting>

     <para>Вывод этой программы должен быть примерно таким (некоторые числа будут меняться).</para>

<screen>oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)</screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="ecpg-errors">
  <title>Обработка ошибок</title>

  <para>В этом разделе описывается, как можно обрабатывать исключительные условия и предупреждения в программе со встраиваемым SQL. Для этого предназначены два средства, которые могут дополнять друг друга. <itemizedlist>
    <listitem>
     <simpara>Можно настроить функции-обработчики для обработки предупреждений и ошибок, воспользовавшись командой <literal>WHENEVER</literal>.</simpara>
    </listitem>

    <listitem>
     <simpara>Подробную информацию об ошибке или предупреждении можно получить через переменную <varname>sqlca</varname>.</simpara>
    </listitem>
   </itemizedlist></para>

  <sect2 id="ecpg-whenever">
   <title>Установка обработчиков</title>

   <para>Один простой метод перехвата ошибок и предупреждений заключается в назначении определённого действия, которое будет выполняться при некотором условии. В общем виде: <programlisting>EXEC SQL WHENEVER <replaceable>условие</replaceable> <replaceable>действие</replaceable>;</programlisting></para>

   <para>Здесь <replaceable>условие</replaceable> может быть следующим: <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>Указанное действие вызывается, когда при выполнении оператора SQL происходит ошибка.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>Указанное действие вызывается, когда при выполнении оператора SQL выдаётся предупреждение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>Указанное действие вызывается, когда оператор SQL получает или обрабатывает ноль строк. (Это обстоятельство не считается ошибкой, но бывает полезно отследить его.)</para>
      </listitem>
     </varlistentry>
    </variablelist></para>

   <para><replaceable>действие</replaceable> может быть следующим: <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>Это фактически означает, что условие игнорируется. Это поведение по умолчанию.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>метка</replaceable></literal></term>
      <term><literal>GO TO <replaceable>метка</replaceable></literal></term>
      <listitem>
       <para>Перейти к указанной метке (используя оператор <literal>goto</literal> языка C).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>Вывести сообщение в устройство стандартного вывода. Это полезно для простых программ или при разработке прототипов. Содержание этого сообщения не настраивается.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>Вызвать <literal>exit(1)</literal>, что приведёт к завершению программы.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>Выполнить оператор <literal>break</literal> языка C. Этот вариант следует использовать только в циклах или операторах <literal>switch</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>имя</replaceable> (<replaceable>аргументы</replaceable>)</literal></term>
      <term><literal>DO <replaceable>имя</replaceable> (<replaceable>аргументы</replaceable>)</literal></term>
      <listitem>
       <para>Вызвать указанные функции C с заданными аргументами.</para>
      </listitem>
     </varlistentry>
    </variablelist> В стандарте SQL описаны только действия <literal>CONTINUE</literal> и <literal>GOTO</literal> (и <literal>GO TO</literal>).</para>

   <para>Ниже показан простой пример использования этих команд. Эта конструкция выводит простое сообщение при выдаче предупреждения и прерывает программу в случае ошибки: <programlisting>EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;</programlisting></para>

   <para>Оператор <literal>EXEC SQL WHENEVER</literal> является директивой препроцессора SQL, а не оператором языка C. Устанавливаемое им действие при ошибках или предупреждениях применяется ко всем встраиваемым операторам SQL ниже точки, где устанавливается обработчик, если только это действие не было изменено после первой команды <literal>EXEC SQL WHENEVER</literal>, и до SQL-оператора, вызвавшего это условие, вне зависимости от хода выполнения программы на C. Поэтому обе следующие программы на C не дадут желаемого эффекта: <programlisting>/*
 * НЕПРАВИЛЬНО
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}</programlisting> <programlisting>/*
 * НЕПРАВИЛЬНО
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}</programlisting></para>
  </sect2>

  <sect2 id="ecpg-sqlca">
   <title>sqlca</title>

   <para>Для более гибкой обработки ошибок в интерфейсе встраиваемого SQL представлена глобальная переменная с именем <varname>sqlca</varname> (SQL Communication Area, Область сведений SQL), имеющая следующую структуру: <programlisting>struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;</programlisting> (В многопоточной программе каждый поток автоматически получает собственную копию <varname>sqlca</varname>. Это работает подобно стандартной в C глобальной переменной <varname>errno</varname>.)</para>

   <para>Структура <varname>sqlca</varname> покрывает и предупреждения, и ошибки. Если в процессе выполнения оператора выдаётся несколько предупреждений или ошибок, <varname>sqlca</varname> будет содержать сведения только о последнем(ей) из них.</para>

   <para>Если последний оператор <acronym>SQL</acronym> выполняется без ошибки, <literal>sqlca.sqlcode</literal> будет содержать 0, а <literal>sqlca.sqlstate</literal> — <literal>"00000"</literal>. Если выдаётся предупреждение или ошибка, в <literal>sqlca.sqlcode</literal> будет содержаться отрицательное число, а <literal>sqlca.sqlstate</literal> будет отличаться от <literal>"00000"</literal>. Положительное значение <literal>sqlca.sqlcode</literal> устанавливается при нейтральном событии, например, когда последний запрос возвращает ноль строк. Поля <literal>sqlcode</literal> и <literal>sqlstate</literal> представляют две различные схемы кодов ошибок; подробнее они описаны ниже.</para>

   <para>Если последний оператор SQL был успешным, в <literal>sqlca.sqlerrd[1]</literal> содержится OID обработанной строки (если это уместно), а в <literal>sqlca.sqlerrd[2]</literal> количество обработанных или возвращённых строк (если это уместно для команды).</para>

   <para>В случае ошибки или предупреждения <literal>sqlca.sqlerrm.sqlerrmc</literal> будет содержать строку, описывающую ошибку. Поле <literal>sqlca.sqlerrm.sqlerrml</literal> содержит длину сообщения об ошибке, которое хранится в <literal>sqlca.sqlerrm.sqlerrmc</literal> (результат функции <function>strlen()</function>, который не очень интересен для программиста C). Заметьте, что некоторые сообщения могут не умещаться в массив <literal>sqlerrmc</literal> фиксированного размера; они будут обрезаться.</para>

   <para>В случае предупреждения, в <literal>sqlca.sqlwarn[2]</literal> записывается символ <literal>W</literal>. (Во всех других случаях значение будет отличным от <literal>W</literal>.) Символ <literal>W</literal> в <literal>sqlca.sqlwarn[1]</literal> показывает, что значение было обрезано при сохранении в переменной среды. <literal>W</literal> в <literal>sqlca.sqlwarn[0]</literal> устанавливается, если предупреждение отмечается в каком-либо другом элементе массива.</para>

   <para>Поля <structfield>sqlcaid</structfield>, <structfield>sqlcabc</structfield>, <structfield>sqlerrp</structfield> и остальные элементы <structfield>sqlerrd</structfield> и <structfield>sqlwarn</structfield> в настоящее время не содержат полезной информации.</para>

   <para>Структура <varname>sqlca</varname> не определена в стандарте SQL, но реализована в нескольких других СУБД SQL. Принципиально она определяется одинаково, но если вы хотите, чтобы ваши приложения были переносимыми, тщательно изучите различия реализаций.</para>

   <para>В следующем примере, демонстрирующем применение <literal>WHENEVER</literal> в сочетании с <varname>sqlca</varname>, выводится содержимое <varname>sqlca</varname> при возникновении ошибки. Это может быть полезно для отладки или в прототипах, пока не реализован более <quote>дружественный пользователю</quote> обработчик ошибок. <programlisting>EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}</programlisting> Результат может выглядеть следующим образом (при ошибке, вызванной опечаткой в имени таблицы): <screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen></para>
  </sect2>

  <sect2 id="ecpg-sqlstate-sqlcode">
   <title><literal>SQLSTATE</literal> и <literal>SQLCODE</literal></title>

   <para>Поля <literal>sqlca.sqlstate</literal> и <literal>sqlca.sqlcode</literal> отражают две различные схемы, представляющие коды ошибок. Обе схемы пришли из стандарта SQL, но схема <literal>SQLCODE</literal> была признана устаревшей в редакции SQL-92 и исключена в последующих редакциях. Поэтому в новых приложениях настоятельно рекомендуется использовать <literal>SQLSTATE</literal>.</para>

   <para><literal>SQLSTATE</literal> задаётся в массиве из пяти символов. Эти пять символов содержат цифры или буквы в верхнем регистре, представляющие коды различных условий ошибок и предупреждений. <literal>SQLSTATE</literal> определяется по иерархической схеме: первые два символа обозначают общий класс условия, а следующие три — подкласс общего условия. Успешное состояние обозначается кодом <literal>00000</literal>. По большей части коды <literal>SQLSTATE</literal> определены в стандарте SQL. Сервер <productname>&productname;</productname> поддерживает коды ошибок <literal>SQLSTATE</literal> естественным образом; поэтому используя во всех приложениях именно эту схему кодов ошибок, можно добиться высокой степени согласованности. За дальнейшими сведениями обратитесь к <xref remap="3" linkend="errcodes-appendix"/>.</para>

   <para><literal>SQLCODE</literal> — устаревшая схема, в которой коды ошибок представлены просто целыми числами. Значение 0 обозначает успешное завершение, положительное значение — успешное завершение с дополнительной информацией, а отрицательное говорит об ошибке. В стандарте SQL определено только положительное значение +100, показывающее, что последняя команда вернула или затронула ноль строк, но отрицательные значения не определены. Таким образом, с этой схемой нельзя рассчитывать на переносимость и она не имеет иерархической структуры. Исторически сложилось, что процессор встраиваемого SQL для <productname>&productname;</productname> назначает некоторые определённые значения <literal>SQLCODE</literal> для собственного использования; они перечислены ниже с числовыми значениями и символьными именами. Помните, что эти коды несовместимы с другими реализациями SQL. Поэтому для упрощения перевода приложений на схему <literal>SQLSTATE</literal> вместе с этими кодами перечисляются соответствующие значения <literal>SQLSTATE</literal>. Однако однозначного соответствия один-к-одному или один-ко-многим между этими двумя схемами не существует (на самом деле это соответствие многие-ко-многим), поэтому следует свериться со списком <literal>SQLSTATE</literal> в <xref remap="6" linkend="errcodes-appendix"/> в каждом случае.</para>

   <para><literal>SQLCODE</literal> может принимать следующие значения: <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>Показывает, что ошибки нет. (SQLSTATE 00000)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>Это нейтральное условие, показывающее, что последняя команда вернула или обработала ноль строк, либо курсор достиг конца. (SQLSTATE 02000)</para>

      <para>Выбирая данные из курсора в цикле, можно проверять этот код, чтобы понять, когда нужно прервать цикл, следующим образом: <programlisting>while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}</programlisting> Но <literal>WHENEVER NOT FOUND DO BREAK</literal> внутри по сути делает это же, поэтому такое явное условие обычно ничем не лучше.</para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>Указывает, что закончилась виртуальная память. Числовое значение определено как <literal>-ENOMEM</literal>. (SQLSTATE YE001)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>Указывает, что препроцессор сгенерировал код, который не понимает библиотека. Возможно, вы используете несовместимые версии препроцессора и библиотеки. (SQLSTATE YE002)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>Это означает, что в команде было указано больше переменных среды, чем она ожидает. (SQLSTATE 07001 или 07002)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>Это означает, что в команде было указано меньше переменных среды, чем она ожидает. (SQLSTATE 07001 или 07002)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>Это означает, что запрос вернул несколько строк, но оператор был подготовлен только для одной строки результата (например, потому что переданные переменные — не массивы). (SQLSTATE 21000)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>Переменная среды типа <type>int</type> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <type>int</type>. Для этого преобразования библиотека использует функцию <function>strtol()</function>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>Переменная среды типа <type>unsigned int</type> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <type>unsigned int</type>. Для этого преобразования библиотека использует функцию <function>strtoul()</function>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>Переменная среды типа <type>float</type> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать во <type>float</type>. Для этого преобразования библиотека использует функцию <function>strtod()</function>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <para>Переменная среды типа <type>numeric</type> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <type>numeric</type>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <para>Переменная среды типа <type>interval</type> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <type>interval</type>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <para>Переменная среды типа <type>date</type> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <type>date</type>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <para>Переменная среды типа <type>timestamp</type> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <type>timestamp</type>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>Это означает, что переменная среды имеет тип <type>bool</type>, а значение в базе данных отличается от <literal>'t'</literal> или <literal>'f'</literal>. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>Серверу <productname>&productname;</productname> был передан пустой оператор. (Этого обычно не должно происходить в программе со встраиваемым SQL, так что это может указывать на внутреннюю ошибку.) (SQLSTATE YE002)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>Возвращено значение NULL, но переменная-индикатор NULL не задана. (SQLSTATE 22002)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>Там, где требуется массив, была передана обычная переменная. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>База данных возвратила обычную переменную там, где требуется значение-массив. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <para>Не удалось вставить значение в массив. (SQLSTATE 42804)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>Программа попыталась использовать несуществующее подключение. (SQLSTATE 08003)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>Программа попыталась использовать подключение, которое существует, но не было открыто. (Это внутренняя ошибка.) (SQLSTATE YE002)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>Оператор, который вы пытаетесь выполнить, не был подготовлен. (SQLSTATE 26000)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>Ошибка повторяющегося ключа, нарушение ограничения уникальности (режим совместимости с Informix). (SQLSTATE 23505)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>Указанный дескриптор не найден. Оператор, который вы пытаетесь использовать, не был подготовлен. (SQLSTATE 33000)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>Указанный индекс дескриптора вне диапазона. (SQLSTATE 07009)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>Запрошен неверный элемент дескриптора. (Это внутренняя ошибка.) (SQLSTATE YE002)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>При выполнении динамического оператора база данных возвратила числовое значение, тогда как переменная среды — не числовая. (SQLSTATE 07006)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>При выполнении динамического оператора база данных возвратила не числовое значение, тогда как переменная среды — числовая. (SQLSTATE 07006)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>Результат подзапроса представлен не одной строкой (режим совместимости с Informix). (SQLSTATE 21000)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>Ошибка произошла на стороне сервера <productname>&productname;</productname>. В тексте ошибки содержится сообщение об ошибке от сервера <productname>&productname;</productname>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>Сервер <productname>&productname;</productname> сообщает, что клиент не может запускать, фиксировать или отменять транзакцию. (SQLSTATE 08007)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>Попытка подключения к базе данных была неудачной. (SQLSTATE 08001)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>Ошибка повторяющегося ключа, нарушение ограничения уникальности. (SQLSTATE 23505)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>Результат подзапроса представлен не одной строкой. (SQLSTATE 21000)</para>
     </listitem>
    </varlistentry>

    


    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <para>Указано неверное имя курсора. (SQLSTATE 34000)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <para>Транзакция в процессе выполнения. (SQLSTATE 25001)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <para>Нет активной (выполняющейся) транзакции. (SQLSTATE 25P01)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <para>Было указано имя существующего курсора. (SQLSTATE 42P03)</para>
     </listitem>
    </varlistentry>

   </variablelist></para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
  <title>Директивы препроцессора</title>

  <para>Препроцессор <command>ecpg</command> поддерживает ряд директив, которые позволяют управлять разбором и обработкой исходных файлов.</para>

  <sect2 id="ecpg-include">
   <title>Включение файлов</title>

   <para>Для включения внешнего файла в программу со встраиваемым SQL, используется конструкция: <programlisting>EXEC SQL INCLUDE <replaceable>имя_файла</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>имя_файла</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>имя_файла</replaceable>";</programlisting> Встретив такую директиву, препроцессор встраиваемого SQL будет искать файл <literal><replaceable>имя_файла</replaceable>.h</literal>, обрабатывать его и включать в выходной код C. В результате встраиваемые операторы SQL во включённом таким образом файле будут обработаны корректно.</para>

   <para>Препроцессор <command>ecpg</command> будет искать указанный файл в нескольких каталогах в следующем порядке: <itemizedlist>
     <listitem><simpara>текущий каталог</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>каталог включаемых файлов &productname;, определённый во время сборки (например, <filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist> Но когда используется форма <literal>EXEC SQL INCLUDE "<replaceable>имя_файла</replaceable>"</literal>, просматривается только текущий каталог.</para>

   <para>В каждом каталоге препроцессор будет сначала искать файл с заданным именем, а если не обнаружит его, попытается найти файл с добавленным расширением <literal>.h</literal> (если только заданное имя файла уже не содержит это расширение).</para>

   <para>Заметьте, что команда <command>EXEC SQL INCLUDE</command> <emphasis>не</emphasis> равнозначна включению: <programlisting>#include &lt;<replaceable>имя_файла</replaceable>.h&gt;</programlisting> так как во втором случае включаемый файл не проходит через препроцессор SQL-команд. Естественно, директиву C <literal>#include</literal> можно по-прежнему применять для включения других заголовочных файлов.</para>

   <note>
    <para>Имя включаемого файла чувствительно к регистру, несмотря на то, что остальная команда <literal>EXEC SQL INCLUDE</literal> подчиняется обычным правилам чувствительности к регистру SQL.</para>
   </note>
  </sect2>

  <sect2 id="ecpg-define">
   <title>Директивы define и undef</title>
   <para>Во встраиваемом SQL есть конструкция, подобная директиве <literal>#define</literal>, известной в C: <programlisting>EXEC SQL DEFINE <replaceable>имя</replaceable>;
EXEC SQL DEFINE <replaceable>имя</replaceable> <replaceable>значение</replaceable>;</programlisting> Используя её, можно определить имя: <programlisting>EXEC SQL DEFINE HAVE_FEATURE;</programlisting> И также можно определить константы: <programlisting>EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';</programlisting> Удалить предыдущее определение позволяет команда <literal>undef</literal>: <programlisting>EXEC SQL UNDEF MYNUMBER;</programlisting></para>

   <para>Разумеется, в программе со встраиваемым SQL можно продолжать использовать версии <literal>#define</literal> и <literal>#undef</literal> языка C. Отличие состоит в том, когда вычисляются определяемые значения. Когда применяется команда <literal>EXEC SQL DEFINE</literal>, вычислять определения и подставлять значения будет препроцессор <command>ecpg</command>. Например, если написать: <programlisting>EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;</programlisting> подстановку выполнит <command>ecpg</command> и компилятор C никогда не увидит имени или идентификатора <literal>MYNUMBER</literal>. Заметьте, что с другой стороны <literal>#define</literal> не подходит для определения константы, которую вы хотите использовать во встраиваемом SQL, так как препроцессор встраиваемого SQL не сможет увидеть это определение.</para>
  </sect2>

  <sect2 id="ecpg-ifdef">
   <title>Директивы ifdef, ifndef, else, elif и endif</title>
   <para>Для условной компиляции блоков кода можно использовать следующие указания: <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>имя</replaceable>;</literal></term>
     <listitem>
     <para>Проверяет <replaceable>имя</replaceable> и обрабатывает последующие строки, если <replaceable>имя</replaceable> было определено командой <literal>EXEC SQL define <replaceable>имя</replaceable></literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>имя</replaceable>;</literal></term>
     <listitem>
     <para>Проверяет <replaceable>имя</replaceable> и обрабатывает последующие строки, если <replaceable>имя</replaceable> <emphasis>не</emphasis> было определено командой <literal>EXEC SQL define <replaceable>имя</replaceable></literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>Начинает альтернативную ветвь условия, открытого командой <literal>EXEC SQL ifdef <replaceable>имя</replaceable></literal> или <literal>EXEC SQL ifndef <replaceable>имя</replaceable></literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>имя</replaceable>;</literal></term>
     <listitem>
     <para>Проверяет <replaceable>имя</replaceable> и начинает альтернативную ветвь условия, если <replaceable>имя</replaceable> было определено командой <literal>EXEC SQL define <replaceable>имя</replaceable></literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>Завершает ветвь условия.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

   <para>Пример: <programlisting>EXEC SQL ifndef TZVAR;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL endif;</programlisting></para>

  </sect2>
 </sect1>

  <sect1 id="ecpg-process">
  <title>Компиляция программ со встраиваемым SQL</title>

  <para>Теперь, когда вы получили представление, как писать программы на C со встраиваемым SQL, вы наверное хотите узнать, как их компилировать. Прежде чем компилировать код C, необходимо пропустить исходный файл через препроцессор встраиваемого <acronym>SQL</acronym> в <acronym>C</acronym>, который преобразует записанные вами операторы <acronym>SQL</acronym> в вызовы специальных функций. После компиляции полученный объектный код нужно скомпоновать со специальной библиотекой, содержащей необходимые функции. Эти функции получают информацию из аргументов, выполняют команды <acronym>SQL</acronym> через интерфейс <application>libpq</application>, и помещают результат в аргументы, заданные для вывода.</para>

  <para>Программа препроцессора называется <filename>ecpg</filename> и входит в состав обычной инсталляции <productname>&productname;</productname>. Программам со встраиваемым SQL, как правило, даются имена с расширением <filename>.pgc</filename>. Если вы создали код программы в файле <filename>prog1.pgc</filename>, вы можете обработать его, просто выполнив: <programlisting>ecpg prog1.pgc</programlisting> При этом будет создан файл <filename>prog1.c</filename>. Если имена входных файлов не следуют этому соглашению, имя выходного файла можно задать явно в аргументе <option>-o</option>.</para>

  <para>Обработанный препроцессором файл можно скомпилировать обычным образом, например, так: <programlisting>cc -c prog1.c</programlisting> В сгенерированные исходные файлы C включаются заголовочные файлы из инсталляции <productname>&productname;</productname>, поэтому если вы установили <productname>&productname;</productname> так, что соответствующий каталог не просматривается по умолчанию, вам придётся добавить указание вида <literal>-I/usr/local/pgsql/include</literal> в командную строку компиляции.</para>

  <para>Чтобы скомпоновать программу со встраиваемым SQL, необходимо подключить библиотеку <filename>libecpg</filename> примерно так: <programlisting>cc -o myprog prog1.o prog2.o ... -lecpg</programlisting> Возможно, и для этого понадобится добавить в командную строку указание вида <literal>-L/usr/local/pgsql/lib</literal>.</para>

  <para>Чтобы узнать пути вашей инсталляции, можно воспользоваться командой <command>pg_config</command><indexterm><primary>pg_config</primary> <secondary sortas="ecpg">с ecpg</secondary></indexterm> или <command>pkg-config</command><indexterm><primary>pkg-config</primary> <secondary sortas="ecpg">с ecpg</secondary></indexterm> (в качестве имени пакета нужно указать <literal>libecpg</literal>).</para>

  <para>Если вы организуете процесс сборки большого проекта с применением <application>make</application>, может быть удобно включить в ваши сборочные файлы следующее неявное правило: <programlisting>ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;</programlisting></para>

  <para>Полный синтаксис вызова команды <command>ecpg</command> приведён в описании <xref linkend="app-ecpg"/>.</para>

  <para>Библиотека <application>ecpg</application> по умолчанию потокобезопасна. Однако для компиляции клиентского кода могут потребоваться параметры командной строки для настройки многопоточности.</para>
 </sect1>

 <sect1 id="ecpg-library">
  <title>Библиотечные функции</title>

  <para>Библиотека <filename>libecpg</filename> в основном содержит <quote>скрытые</quote> функции, применяемые для реализации функциональности, выражаемой встраиваемыми командами SQL. Но есть также некоторые функции, которые можно вызывать напрямую. Заметьте, что код, задействующий эти функции, будет непереносимым.</para>

  <itemizedlist>
   <listitem>
    <para><function>ECPGdebug(int <replaceable>вкл</replaceable>, FILE *<replaceable>поток</replaceable>)</function> с первым аргументом, отличным от нуля, включает вывод отладочных сообщений в заданный <replaceable>поток</replaceable>. Журнал сообщений, полученный таким образом, будет содержать все операторы <acronym>SQL</acronym> с заданными входными переменными и результаты, выданные сервером <productname>&productname;</productname>. Это может быть очень полезно для поиска ошибок в командах <acronym>SQL</acronym>.</para>
    <note>
    <para>В Windows, если библиотека <application>ecpg</application> и приложение скомпилированы с разными флагами, эта функция может вызвать крах приложения из-за различий внутреннего представления указателей <literal>FILE</literal>. В частности, флаги многопоточной/однопоточной, выпускаемой/отладочной или статической/динамической сборки должны быть одинаковыми для библиотеки и всех использующих её приложений.</para>
    </note>
   </listitem>

   <listitem>
     <para><function>ECPGget_PGconn(const char *<replaceable>имя_подключения</replaceable>) </function> возвращает указатель на подключение к базе данных, имеющее заданное имя. Если аргумент <replaceable>имя_подключения</replaceable> равен <literal>NULL</literal>, возвращается указатель на текущее подключение. Если определить подключение не удаётся, возвращается <literal>NULL</literal>. Полученный указатель на подключение, если требуется, можно использовать при вызове любых других функций <application>libpq</application>.</para>
     <note>
     <para>Манипулировать подключениями, открытыми средствами <application>ecpg</application>, напрямую через <application>libpq</application> не следует.</para>
     </note>
   </listitem>

   <listitem>
     <para><function>ECPGtransactionStatus(const char *<replaceable>имя_подключения</replaceable>)</function> возвращает состояние текущей транзакции для подключения, на которое указывает <replaceable>имя_подключения</replaceable>. Возвращаемые коды состояния перечислены в описании входящей в libpq функции <function>PQtransactionStatus()</function> в <xref remap="6" linkend="libpq-status"/>.</para>
   </listitem>

   <listitem>
    <para><function>ECPGstatus(int <replaceable>номер_строки</replaceable>, const char* <replaceable>имя_подключения</replaceable>)</function> возвращает true при наличии подключения к базе данных и false в противном случае. В аргументе <replaceable>имя_подключения</replaceable> можно передать <literal>NULL</literal>, если применяется одно подключение.</para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-lo">
  <title>Большие объекты</title>

  <para>ECPG не поддерживает большие объекты напрямую, но приложение на базе ECPG может работать с большими объектами, используя предназначенные для этого функции, получив необходимый объект <type>PGconn</type> в результате вызова <function>ECPGget_PGconn()</function>. (Однако использовать функцию <function>ECPGget_PGconn()</function> и напрямую воздействовать на объекты <type>PGconn</type> следует очень осторожно; в идеале стоит исключить при этом другие обращения к базе данных через ECPG.)</para>

  <para>Подробнее функция <function>ECPGget_PGconn()</function> описана в <xref remap="6" linkend="ecpg-library"/>. Интерфейс функций для работы с большими объектами рассмотрен в <xref remap="6" linkend="largeobjects"/>.</para>

  <para>Функции для работы с большими объектами должны вызываться в блоке транзакций, поэтому если режим автофиксации отключён, необходимо явно выдавать команды <command>BEGIN</command>.</para>

  <para>В <xref remap="6" linkend="ecpg-lo-example"/> приведён пример программы, показывающий, как создать, записать и прочитать большой объект в приложении ECPG.</para>

  <example id="ecpg-lo-example">
   <title>Программа на базе ECPG, работающая с большими объектами</title>
<programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

    /* create */
    loid = lo_create(conn, 0);
    if (loid &lt; 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

    /* write test */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc &lt; 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* read test */
    fd = lo_open(conn, loid, INV_READ);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc &lt; 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* check */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

    /* cleanup */
    rc = lo_unlink(conn, loid);
    if (rc &lt; 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
  </example>
 </sect1>

 <sect1 id="ecpg-cpp">
  <title>Приложения на <acronym>C++</acronym></title>

  <para>ECPG обеспечивает поддержку языка C++ в ограниченном объёме. Некоторые её особенности описаны в этом разделе.</para>

  <para>Препроцессор <command>ecpg</command> принимает входной файл, написанный на C (или языке, подобном C) со встраиваемыми командами SQL, преобразует встроенные команды SQL в конструкции языка C и в результате формирует файл <filename>.c</filename>. Объявления библиотечных функций, вызываемых в конструкциях C, которые генерирует <command>ecpg</command>, заворачиваются в блоки <literal>extern "C" { ... }</literal> при использовании C++, так что они должны прозрачно работать в C++.</para>

  <para>Однако вообще говоря, препроцессор <command>ecpg</command> понимает только C; он не воспринимает особый синтаксис и зарезервированные слова языка C++. Поэтому какой-то код SQL, встроенный в код приложения на C++, в котором используются сложные особенности C++, может корректно не обработаться препроцессором или не работать как ожидается.</para>

  <para>Надёжный подход к применению внедрённого кода SQL в приложении на C++ заключается в том, чтобы скрыть вызовы ECPG в модуле C, который будет вызываться приложением на C++ для работы с базой данных и который будет скомпонован с остальным кодом C++. Подробнее это описано в <xref remap="6" linkend="ecpg-cpp-and-c"/>.</para>

  <sect2 id="ecpg-cpp-scope">
   <title>Область видимости переменных среды</title>

   <para>Препроцессор <command>ecpg</command> имеет понимание области видимости переменных в C. С языком C это довольно просто, так как область видимости переменных определяется их блоками кода. В C++, однако, переменные-члены класса задействуются не в том блоке кода, в каком они объявлены, так что препроцессор <command>ecpg</command> не сможет корректно определить область видимости таких переменных.</para>

   <para>Например, в следующем случае препроцессор <command>ecpg</command> не сможет найти определение переменной <literal>dbname</literal> в методе <literal>test</literal>, так что произойдёт ошибка. <programlisting>class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}</programlisting> При обработке данного кода будет выдано сообщение: <screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
(test_cpp.pgc:28: ОШИБКА: переменная "dbname" не объявлена)</para>

   <para>Для решения этой проблемы можно немного изменить метод <literal>test</literal> и задействовать в нём локальную переменную для промежуточного хранения. Но предложенный подход нельзя считать хорошим, так как это портит код и снижает производительность. <programlisting>void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}</programlisting></para>
  </sect2>

  <sect2 id="ecpg-cpp-and-c">
   <title>Разработка приложения на C++ с внешним модулем на C</title>

   <para>Если вы поняли технические ограничения препроцессора <command>ecpg</command> с C++, вы можете прийти к заключению, что для использования ECPG в приложениях на C++ лучше связывать код C с кодом C++ на стадии компоновки, а не внедрять команды SQL непосредственно в код на C++. В данном разделе показывается, как отделить встраиваемые команды SQL от кода приложения на C++, на простом примере. В этом примере приложение реализуется на C++, а взаимодействие с сервером &productname; построено на C и ECPG.</para>

   <para>Для сборки нужно создать три типа файлов: файл на C (<filename>*.pgc</filename>), заголовочный файл и файл на C++: <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>Модуль подпрограмм будет выполнять SQL-команды, встроенные в C. Этот код нужно будет преобразовать в <filename>test_mod.c</filename> с помощью препроцессора. <programlisting>#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}</programlisting></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
       <para>Заголовочный файл с объявлениями функций в модуле на языке C (<filename>test_mod.pgc</filename>). Он включается в <filename>test_cpp.cpp</filename>. Объявления в этом файле должны заключаться в блок <literal>extern "C"</literal>, так как он будет связываться с модулем C++. <programlisting>#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif</programlisting></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
       <para>Основной код приложения, содержащий функцию <function>main</function>, а также, в данном примере, класс C++. <programlisting>#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t-&gt;test();
    return 0;
}</programlisting></para>
      </listitem>
     </varlistentry>
    </variablelist></para>

   <para>Для сборки приложения проделайте следующее. Преобразуйте <filename>test_mod.pgc</filename> в <filename>test_mod.c</filename> с помощью <command>ecpg</command>, а затем получите <filename>test_mod.o</filename>, скомпилировав <filename>test_mod.c</filename> компилятором C: <programlisting>ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o</programlisting></para>

   <para>После этого получите <filename>test_cpp.o</filename>, скомпилировав <filename>test_cpp.cpp</filename> компилятором C++: <programlisting>c++ -c test_cpp.cpp -o test_cpp.o</programlisting></para>

   <para>Наконец, свяжите полученные объектные файлы, <filename>test_cpp.o</filename> и <filename>test_mod.o</filename>, в один исполняемый файл, выполнив компоновку под управлением компилятора C++: <programlisting>c++ test_cpp.o test_mod.o -lecpg -o test_cpp</programlisting></para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-sql-commands">
  <title>Команды встраиваемого SQL</title>

  <para>В этом разделе описаны все команды, предназначенные специально для встраиваемого SQL. В <xref remap="6" linkend="sql-commands"/> также описаны обычные команды SQL, которые можно использовать и как встраиваемые, если явно не отмечено обратное.</para>

  <refentry id="ecpg-sql-allocate-descriptor">
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
    <refpurpose>выделить область SQL-дескриптора</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>ALLOCATE DESCRIPTOR <replaceable class="parameter">имя</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>ALLOCATE DESCRIPTOR</command> выделяет новую именованную область SQL-дескриптора, через которую можно обмениваться данными между сервером &productname; и программой на C.</para>

    <para>После использования области дескрипторов должны освобождаться командой <command>DEALLOCATE DESCRIPTOR</command>.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя</replaceable></term>
      <listitem>
       <para>Имя SQL-дескриптора, задаётся с учётом регистра. Это может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>EXEC SQL ALLOCATE DESCRIPTOR mydesc;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>ALLOCATE DESCRIPTOR</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-deallocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
     <member><xref linkend="ecpg-sql-set-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-connect">
   <refnamediv>
    <refname>CONNECT</refname>
    <refpurpose>установить подключение к базе данных</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>CONNECT TO <replaceable>цель_подключения</replaceable> [ AS <replaceable>имя_подключения</replaceable> ] [ USER <replaceable>пользователь_подключения</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>пользователь_подключения</replaceable>
DATABASE <replaceable>цель_подключения</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para>Команда <command>CONNECT</command> устанавливает подключение клиента к серверу &productname;.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">цель_подключения</replaceable></term>
      <listitem>
       <para><replaceable class="parameter">цель_соединения</replaceable> задаёт целевой сервер и базу для подключения в одной из нескольких форм. <variablelist>
         <varlistentry>
          <term>[ <replaceable>имя_бд</replaceable> ] [ <literal>@</literal><replaceable>сервер</replaceable> ] [ <literal>:</literal><replaceable>порт</replaceable> ]</term>
          <listitem>
           <para>Подключение по TCP/IP</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>сервер</replaceable> [ <literal>:</literal><replaceable>порт</replaceable> ] <literal>/</literal> [ <replaceable>имя_бд</replaceable> ] [ <literal>?</literal><replaceable>параметр_подключения</replaceable> ]</term>
          <listitem>
           <para>Подключение через доменные сокеты Unix</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>сервер</replaceable> [ <literal>:</literal><replaceable>порт</replaceable> ] <literal>/</literal> [ <replaceable>имя_бд</replaceable> ] [ <literal>?</literal><replaceable>параметр_подключения</replaceable> ]</term>
          <listitem>
           <para>Подключение по TCP/IP</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>Строковая константа SQL</term>
          <listitem>
           <para>содержащая значение в одной из показанных выше форм</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>переменная среды</term>
          <listitem>
           <para>переменная среды типа <type>char[]</type> или <type>VARCHAR[]</type>, содержащая значение в одной из показанных выше форм</para>
          </listitem>
         </varlistentry>
        </variablelist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">объект_соединения</replaceable></term>
      <listitem>
       <para>Необязательный идентификатор подключения, позволяющий обращаться к этому подключению в других командах. Это может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">пользователь_подключения</replaceable></term>
      <listitem>
       <para>Имя пользователя для подключения к базе данных.</para>

       <para>В этом параметре также можно передать имя и пароль одним из следующих способов: <literal><replaceable>имя_пользователя</replaceable>/<replaceable>пароль</replaceable></literal>, <literal><replaceable>имя_пользователя</replaceable> IDENTIFIED BY <replaceable>пароль</replaceable></literal> или <literal><replaceable>имя_пользователя</replaceable> USING <replaceable>пароль</replaceable></literal>.</para>

       <para>В качестве имени пользователя и пароля можно задать идентификаторы SQL, строковые константы или переменные среды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>Использовать все параметры подключения по умолчанию, которые определены библиотекой libpq.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

    <para>Несколько вариантов указания параметров подключения: <programlisting>EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;</programlisting></para>

    <para>Следующий пример программы демонстрирует применение переменных среды для определения параметров подключения: <programlisting>int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    char *dbname     = "testdb";    /* имя базы данных */
    char *user       = "testuser";  /* имя пользователя подключения */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* строка подключения */
    char ver[256];                  /* буфер для хранения строки версии */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT pgpro_version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT pgpro_version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}</programlisting></para>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>CONNECT</command> описана в стандарте SQL, но формат параметров подключения определяется реализацией.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-disconnect"/></member>
     <member><xref linkend="ecpg-sql-set-connection"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-deallocate-descriptor">
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
    <refpurpose>освободить область SQL-дескриптора</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>DEALLOCATE DESCRIPTOR <replaceable class="parameter">имя</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>DEALLOCATE DESCRIPTOR</command> освобождает область именованного SQL-дескриптора.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя</replaceable></term>
      <listitem>
       <para>Имя дескриптора, подлежащего освобождению, задаётся с учётом регистра. Это может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>EXEC SQL DEALLOCATE DESCRIPTOR mydesc;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>DEALLOCATE DESCRIPTOR</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
     <member><xref linkend="ecpg-sql-set-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-declare">
   <refnamediv>
    <refname>DECLARE</refname>
    <refpurpose>определить курсор</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>DECLARE <replaceable class="parameter">имя_курсора</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">подготовленный_оператор</replaceable>
DECLARE <replaceable class="parameter">имя_курсора</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">запрос</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>DECLARE</command> объявляет курсор для прохода по набору результатов подготовленного оператора. Эта команда несколько отличается от обычной SQL-команды <command>DECLARE</command>: тогда как последняя выполняет запрос и подготавливает набор результатов для получения, встраиваемая SQL-команда просто объявляет имя в качестве <quote>переменной цикла</quote> для прохода по набору результатов запроса; фактически запрос выполнится, когда курсор будет открыт командой <command>OPEN</command>.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>
    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">имя_курсора</replaceable></term>
      <listitem>
       <para>Имя курсора, задаётся с учётом регистра. Это может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">подготовленный_оператор</replaceable></term>
      <listitem>
       <para>Имя подготовленного запроса, задаваемое SQL-идентификатором или переменной среды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">запрос</replaceable></term>
      <listitem>
       <para>Команда <xref linkend="sql-select"/> или <xref linkend="sql-values"/>, выдающая строки, которые будут получены через курсор.</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>Параметры курсора рассматриваются в описании <xref linkend="sql-declare"/>.</para>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

    <para>Примеры объявления курсора для запроса: <programlisting>EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT pgpro_version();</programlisting></para>

    <para>Пример объявления курсора для подготовленного оператора: <programlisting>EXEC SQL PREPARE stmt1 AS SELECT pgpro_version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;</programlisting></para>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>DECLARE</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-open"/></member>
     <member><xref linkend="sql-close"/></member>
     <member><xref linkend="sql-declare"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-describe">
   <refnamediv>
    <refname>DESCRIBE</refname>
    <refpurpose>получить информацию о подготовленном операторе или наборе результатов</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>DESCRIBE [ OUTPUT ] <replaceable class="parameter">подготовленный_оператор</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="parameter">имя_дескриптора</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">подготовленный_оператор</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="parameter">имя_дескриптора</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">подготовленный_оператор</replaceable> INTO <replaceable class="parameter">имя_sqlda</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>DESCRIBE</command> получает метаданные о результирующих столбцах, содержащихся в подготовленном операторе, не считывая собственно строки результата.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">подготовленный_оператор</replaceable></term>
      <listitem>
       <para>Имя подготовленного оператора. Это может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">имя_дескриптора</replaceable></term>
      <listitem>
       <para>Имя дескриптора, задаётся с учётом регистра. Это может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">имя_sqlda</replaceable></term>
      <listitem>
       <para>Имя переменной SQLDA.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>DESCRIBE</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-disconnect">
   <refnamediv>
    <refname>DISCONNECT</refname>
    <refpurpose>закрыть подключение к базе данных</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>DISCONNECT <replaceable class="parameter">имя_подключения</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT DEFAULT
DISCONNECT ALL</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>DISCONNECT</command> закрывает подключение (или все подключения) к базе данных.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя_подключения</replaceable></term>
      <listitem>
       <para>Имя подключения к базе данных устанавливается командой <command>CONNECT</command>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CURRENT</literal></term>
      <listitem>
       <para>Закрывает <quote>текущее</quote> подключение, то есть подключение, открытое последним, либо установленное командой <command>SET CONNECTION</command>. Текущее подключение подразумевается по умолчанию, если <command>DISCONNECT</command> выполняется без аргументов.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>Закрывает подключение по умолчанию.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>Закрывает все открытые подключения.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>int
main(void)
{
    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* закрывает con3          */
    EXEC SQL DISCONNECT DEFAULT;  /* закрывает DEFAULT       */
    EXEC SQL DISCONNECT ALL;      /* закрывает con2 и con1 */

    return 0;
}</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>DISCONNECT</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"/></member>
     <member><xref linkend="ecpg-sql-set-connection"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-execute-immediate">
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
    <refpurpose>динамически подготовить и выполнить оператор</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>EXECUTE IMMEDIATE <replaceable class="parameter">строка</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>EXECUTE IMMEDIATE</command> немедленно подготавливает и выполняет динамически задаваемый оператор SQL, не получая при этом строки результата.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">строка</replaceable></term>
      <listitem>
       <para>Строковая константа C или переменная среды, содержащая SQL-оператор, который нужно выполнить.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

    <para>Пример выполнения оператора <command>INSERT</command> с применением команды <command>EXECUTE IMMEDIATE</command> и переменной среды <varname>command</varname>: <programlisting>sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;</programlisting></para>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>EXECUTE IMMEDIATE</command> описана в стандарте SQL.</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-get-descriptor">
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
    <refpurpose>получить информацию из области дескриптора SQL</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>GET DESCRIPTOR <replaceable class="parameter">имя_дескриптора</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">элемент_заголовка_дескриптора</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="parameter">имя_дескриптора</replaceable> VALUE <replaceable class="parameter">номер_столбца</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">элемент_дескриптора</replaceable> [, ... ]</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>GET DESCRIPTOR</command> получает информацию о наборе результатов запроса из области дескриптора SQL и сохраняет её в переменные среды. Область дескриптора обычно предварительно заполняется командами <command>FETCH</command> или <command>SELECT</command>, чтобы из неё можно было перенести сопутствующую информацию в переменные среды.</para>

    <para>Эта команда имеет две формы: первая форма выдаёт элементы из <quote>заголовка</quote> дескриптора, который относится ко всему набору результатов в целом. Например, это число строк. Другая форма, требующая указания в дополнительном параметре номера столбца, выдаёт информацию о конкретном столбце строки. В качестве примеров можно привести имя столбца и фактическое значение в этом столбце.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя_дескриптора</replaceable></term>
      <listitem>
       <para>Имя дескриптора.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">элемент_заголовка_дескриптора</replaceable></term>
      <listitem>
       <para>Идентификатор, определяющий, какой элемент заголовка нужно получить. В настоящее время поддерживается только <literal>COUNT</literal>, позволяющий получить число столбцов в наборе результатов.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">номер_столбца</replaceable></term>
      <listitem>
       <para>Номер столбца, информацию о котором нужно получить. Нумерация начинается с 1.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">элемент_дескриптора</replaceable></term>
      <listitem>
       <para>Идентификатор, определяющий, какой элемент информации о столбце нужно получить. Список поддерживаемых элементов приведён в <xref remap="6" linkend="ecpg-named-descriptors"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">cvariable</replaceable></term>
      <listitem>
       <para>Переменная среды, в которую будут сохранены данные, полученные из области дескриптора.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

    <para>Пример получения числа столбцов в наборе результатов: <programlisting>EXEC SQL GET DESCRIPTOR d :d_count = COUNT;</programlisting></para>

    <para>Пример получения размера данных в первом столбце: <programlisting>EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;</programlisting></para>

    <para>Пример получения содержимого данных второго столбца в виде строки: <programlisting>EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;</programlisting></para>

    <para>Следующий пример демонстрирует всю процедуру выполнения <literal>SELECT current_database();</literal> и вывода числа столбцов, длины данных в столбце и содержимого столбца: <programlisting>int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL ALLOCATE DESCRIPTOR d;

    /* Объявить, открыть курсор и присвоить ему дескриптор */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

    /* Получить общее число столбцов */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    /* Получить размер возвращённого столбца */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

    /* Выбрать возвращённый столбец в виде строки */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

    /* Закрытие */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}</programlisting> При выполнении этого примера будет получен такой результат: <screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen></para>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>GET DESCRIPTOR</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-set-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-open">
   <refnamediv>
    <refname>OPEN</refname>
    <refpurpose>открыть динамический курсор</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>OPEN <replaceable class="parameter">имя_курсора</replaceable>
OPEN <replaceable class="parameter">имя_курсора</replaceable> USING <replaceable class="parameter">значение</replaceable> [, ... ]
OPEN <replaceable class="parameter">имя_курсора</replaceable> USING SQL DESCRIPTOR <replaceable class="parameter">имя_дескриптора</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>OPEN</command> открывает курсор и в дополнение может связывать фактические значения с местозаполнителями в объявлении курсора. Курсор должен быть предварительно объявлен командой <command>DECLARE</command>. Команда <command>OPEN</command> запускает выполнение запроса на сервере.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя_курсора</replaceable></term>
      <listitem>
       <para>Имя открываемого курсора. Этот может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">значение</replaceable></term>
      <listitem>
       <para>Значение, связываемое с местозаполнителем в курсоре. Это может быть константа SQL, переменная среды или переменная среды с индикатором.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">имя_дескриптора</replaceable></term>
      <listitem>
       <para>Имя дескриптора, содержащего значения, которые должны быть связаны с местозаполнителями в курсоре. Это может быть идентификатор SQL или переменная среды.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>OPEN</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-declare"/></member>
     <member><xref linkend="sql-close"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-prepare">
   <refnamediv>
    <refname>PREPARE</refname>
    <refpurpose>подготовить оператор к выполнению</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>PREPARE <replaceable class="parameter">имя</replaceable> FROM <replaceable class="parameter">строка</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para>Команда <command>PREPARE</command> подготавливает к выполнению динамический оператор, задаваемый в виде строки. Она отличается от обычного SQL-оператора <xref linkend="sql-prepare"/>, который также можно использовать во встраиваемых командах. Для обоих типов подготовленных операторов применяется команда <xref linkend="sql-execute"/>.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">подготовленный_оператор</replaceable></term>
      <listitem>
       <para>Идентификатор для подготовленного запроса.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">строка</replaceable></term>
      <listitem>
       <para>Строковая константа C или переменная среды, содержащая подготавливаемый оператор: SELECT, INSERT, UPDATE или DELETE.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>
<programlisting>char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>PREPARE</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="sql-execute"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-autocommit">
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
    <refpurpose>установить режим автофиксации для текущего сеанса</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>SET AUTOCOMMIT { = | TO } { ON | OFF }</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>SET AUTOCOMMIT</command> устанавливает режим автофиксации для текущего сеанса использования базы данных. По умолчанию программы со встраиваемым SQL работают <emphasis>не</emphasis> в режиме автофиксации, так что в определённые моменты нужно явно выполнять <command>COMMIT</command>. Эта команда может переключить сеанс в режим автофиксации, когда неявно фиксируется каждый отдельный оператор.</para>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para><command>SET AUTOCOMMIT</command> — расширение &productname; ECPG.</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-connection">
   <refnamediv>
    <refname>SET CONNECTION</refname>
    <refpurpose>выбрать подключение к базе данных</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>SET CONNECTION [ TO | = ] <replaceable class="parameter">имя_подключения</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>SET CONNECTION</command> устанавливает <quote>текущее</quote> подключение к базе данных, которое будет использоваться командами, не задающими подключение явно.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя_подключения</replaceable></term>
      <listitem>
       <para>Имя подключения к базе данных устанавливается командой <command>CONNECT</command>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>Устанавливает заданное подключение подключением по умолчанию.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>SET CONNECTION</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"/></member>
     <member><xref linkend="ecpg-sql-disconnect"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-descriptor">
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
    <refpurpose>внести информацию в область дескриптора SQL</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>SET DESCRIPTOR <replaceable class="parameter">имя_дескриптора</replaceable> <replaceable class="parameter">элемент_заголовка_дескриптора</replaceable> = <replaceable>значение</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="parameter">имя_дескриптора</replaceable> VALUE <replaceable class="parameter">номер</replaceable> <replaceable class="parameter">элемент_дескриптора</replaceable> = <replaceable>значение</replaceable> [, ...]</synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para><command>SET DESCRIPTOR</command> заполняет область SQL-дескриптора значениями. Заполненная область дескриптора обычно применяется для привязывания параметров при выполнении подготовленного запроса.</para>

    <para>Эта команда имеет две формы: первая применяется к <quote>заголовку</quote> дескриптора, который не зависит от конкретных данных. Вторая форма устанавливает значения для определённых полей по номерам.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя_дескриптора</replaceable></term>
      <listitem>
       <para>Имя дескриптора.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">элемент_заголовка_дескриптора</replaceable></term>
      <listitem>
       <para>Идентификатор, определяющий, какой элемент заголовка нужно задать. В настоящее время поддерживается только <literal>COUNT</literal>, позволяющий задать число элементов в дескрипторе.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">номер</replaceable></term>
      <listitem>
       <para>Номер элемента дескриптора, для которого задаётся значение. Нумерация начинается с 1.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">элемент_дескриптора</replaceable></term>
      <listitem>
       <para>Идентификатор, определяющий, какой элемент нужно установить в дескрипторе. Список поддерживаемых элементов приведён в <xref remap="6" linkend="ecpg-named-descriptors"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">значение</replaceable></term>
      <listitem>
       <para>Значение, которое нужно поместить в элемент дескриптора. Это может быть константа SQL или переменная среды.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>
<programlisting>EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>SET DESCRIPTOR</command> описана в стандарте SQL.</para>
   </refsect1>

   <refsect1>
    <title>См. также</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-type">
   <refnamediv>
    <refname>TYPE</refname>
    <refpurpose>создать новый тип данных</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>TYPE <replaceable class="parameter">имя_типа</replaceable> IS <replaceable class="parameter">тип_С</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para>Команда <command>TYPE</command> определяет новый тип C. Она равнозначна добавлению <literal>typedef</literal> в секции объявлений.</para>

    <para>Эта команда принимается, только когда <command>ecpg</command> запускается с параметром <option>-c</option>.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя_типа</replaceable></term>
      <listitem>
       <para>Имя нового типа. Это имя должно быть допустимым для типа в языке C.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">тип_С</replaceable></term>
      <listitem>
       <para>Определение типа C.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];</programlisting>

    <para>Пример программы, в которой используется <command>EXEC SQL TYPE</command>: <programlisting>EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}</programlisting> Эта программа выдаёт следующее: <screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen></para>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>TYPE</command> — расширение &productname;.</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-var">
   <refnamediv>
    <refname>VAR</refname>
    <refpurpose>определить переменную</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>VAR <replaceable>имя_переменной</replaceable> IS <replaceable>тип_С</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para>Команда <command>VAR</command> назначает переменной среды новый тип данных C. Переменная среды должна быть объявлена ранее в секции объявлений.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">имя_переменной</replaceable></term>
      <listitem>
       <para>Имя переменной C.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">тип_С</replaceable></term>
      <listitem>
       <para>Определение типа C.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;</programlisting>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>VAR</command> — расширение &productname;.</para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-whenever">
   <refnamediv>
    <refname>WHENEVER</refname>
    <refpurpose>определить действие, которое должно выполняться, когда при обработке SQL-оператора возникает определённое условие</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="parameter">действие</replaceable></synopsis>
   </refsynopsisdiv>

   <refsect1>
    <title>Описание</title>

    <para>Устанавливает поведение в случае определённых условий (строки не найдены, выданы предупреждения или ошибки SQL и т. д.), возникающих в ходе выполнения SQL.</para>
   </refsect1>

   <refsect1>
    <title>Параметры</title>

    <para>Описание параметров приведено в <xref remap="6" linkend="ecpg-whenever"/>.</para>
   </refsect1>

   <refsect1>
    <title>Примеры</title>

<programlisting>EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;</programlisting>

    <para>Типичное применение конструкция <literal>WHENEVER NOT FOUND BREAK</literal> находит в обработке результатов запроса в цикле: <programlisting>int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

    /* по достижении конца набора результатов прервать цикл while */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}</programlisting></para>
   </refsect1>

   <refsect1>
    <title>Совместимость</title>

    <para>Команда <command>WHENEVER</command> описана в стандарте SQL, но большинство действий относятся к расширениям &productname;.</para>
   </refsect1>
  </refentry>
 </sect1>

 <sect1 id="ecpg-informix-compat">
  <title>Режим совместимости с <productname>Informix</productname></title>
  <para>Препроцессор <command>ecpg</command> может работать в так называемом <firstterm>режиме совместимости с Informix</firstterm>. Если этот режим включён, <command>ecpg</command> старается работать как предкомпилятор <productname>Informix</productname> для кода <productname>Informix</productname> E/SQL. Вообще говоря, это позволяет записывать встраиваемые команды SQL, используя знак доллара вместо слов <literal>EXEC SQL</literal>: <programlisting>$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;</programlisting></para>

  <note>
   <para>Между <literal>$</literal> и последующей директивой препроцессора (в частности, <literal>include</literal>, <literal>define</literal>, <literal>ifdef</literal> и т. п.) не должно быть пробельных символов. В противном случае препроцессор воспримет следующее слово как имя переменной среды.</para>
  </note>

  <para>Поддерживаются два режима совместимости: <literal>INFORMIX</literal> и <literal>INFORMIX_SE</literal></para>
  <para>При компоновке программ, использующих этот режим совместимости, обязательно подключите библиотеку <literal>libcompat</literal>, поставляемую с ECPG.</para>
  <para>Помимо ранее упомянутого синтаксического сахара, режим совместимости с <productname>Informix</productname> приносит из E/SQL в ECPG набор функций для ввода, вывода и преобразования данных, а также встраиваемые операторы SQL.</para>
  <para>Режим совместимости с <productname>Informix</productname> тесно связан с библиотекой pgtypeslib из ECPG. Библиотека pgtypeslib сопоставляет типы данных SQL с типами данных в ведущей программе на C, а большинство дополнительных функций режима совместимости с <productname>Informix</productname> позволяют работать с этими типами C. Заметьте, однако, что степень совместимости ограничена. ECPG не пытается копировать поведение <productname>Informix</productname>; вы можете выполнять примерно те же операции и пользоваться функции с теми же именами и с тем же поведением, но если вы используете <productname>Informix</productname>, просто заменить одно средство другим на данный момент нельзя. Более того, есть различия и в типах данных. В частности, типы даты и интервала в <productname>&productname;</productname> не воспринимают диапазоны, как например, <literal>YEAR TO MINUTE</literal>, так что и в ECPG это не будет поддерживаться.</para>

  <sect2 id="ecpg-informix-types">
   <title>Дополнительные типы</title>
   <para>Теперь в режиме Informix без указания <literal>typedef</literal> поддерживается специальный псевдотип Informix "string" для хранения символьной строки, обрезаемой справа. На самом деле, в режиме Informix ECPG откажется обрабатывать исходные файлы, содержащие определение типа <literal>typedef некоторый_тип string;</literal> <programlisting>EXEC SQL BEGIN DECLARE SECTION;
string userid; /* эта переменная будет содержать обрезанные данные */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;</programlisting></para>
  </sect2>

  <sect2 id="ecpg-informix-statements">
   <title>Дополнительные/недостающие операторы встраиваемого SQL</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</literal></term>
      <listitem>
       <para>Этот оператор закрывает текущее подключение. Фактически это синоним команды <literal>DISCONNECT CURRENT</literal> в ECPG: <programlisting>$CLOSE DATABASE;                /* закрыть текущее подключение */
EXEC SQL CLOSE DATABASE;</programlisting></para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE имя_курсора</literal></term>
      <listitem>
       <para>Из-за различий в подходах ECPG и ESQL/C Informix (т. е. другого разделения на чисто грамматические преобразования и вызовы нижележащей библиотеки времени выполнения), в ECPG нет оператора <literal>FREE имя_курсора</literal>. Это связано с тем, что в ECPG команда <literal>DECLARE CURSOR</literal> не сводится к вызову функции в библиотеке времени выполнения, которая бы принимала имя курсора. Это значит, что курсоры SQL в библиотеке ECPG не требуют обслуживания, оно требуется только на уровне сервера &productname;.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE имя_оператора</literal></term>
      <listitem>
       <para>Команда <literal>FREE имя_оператора</literal> является синонимом команды <literal>DEALLOCATE PREPARE имя_оператора</literal>.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-sqlda">
   <title>Области дескрипторов SQLDA, совместимые с Informix</title>
   <para>Режим совместимости с Informix поддерживает структуру, отличную от описанной в <xref remap="6" linkend="ecpg-sqlda-descriptors"/>. См. ниже: <programlisting>struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;</programlisting></para>

   <para>Глобальные свойства: <variablelist>

     <varlistentry>
     <term><literal>sqld</literal></term>
      <listitem>
       <para>Число полей в дескрипторе <literal>SQLDA</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</literal></term>
      <listitem>
       <para>Указатель на свойства по полям.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</literal></term>
      <listitem>
       <para>Не используется, заполняется нулями.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</literal></term>
      <listitem>
       <para>Размер структуры в памяти.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</literal></term>
      <listitem>
       <para>Указатель на следующую структуру SQLDA, если набор результатов содержит больше одной записи.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</literal></term>
      <listitem>
       <para>Неиспользуемый указатель, содержит NULL. Сохраняется для совместимости с Informix.</para>
      </listitem>
     </varlistentry>

    </variablelist> Свойства, относящиеся к полям, описаны ниже, они хранятся в массиве <literal>sqlvar</literal>: <variablelist>

     <varlistentry>
     <term><literal>sqltype</literal></term>
      <listitem>
       <para>Тип поля. Соответствующие константы представлены в <literal>sqltypes.h</literal></para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</literal></term>
      <listitem>
       <para>Длина данных поля.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</literal></term>
      <listitem>
       <para>Указатель на данные поля. Этот указатель имеет тип <literal>char *</literal>, но он указывает на данные в двоичном формате. Например: <programlisting>int intval;

switch (sqldata-&gt;sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata-&gt;sqlvar[i].sqldata;
        break;
  ...
}</programlisting></para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</literal></term>
      <listitem>
       <para>Указатель на индикатор NULL. Если возвращается командами DESCRIBE или FETCH, это всегда действительный указатель. Если передаётся на вход команде <literal>EXECUTE ... USING sqlda;</literal>, NULL вместо указателя означает, что значение этого поля отлично от NULL. Чтобы обозначить NULL в поле, необходимо корректно установить этот указатель и <literal>sqlitype</literal>. Например: <programlisting>if (*(int2 *)sqldata-&gt;sqlvar[i].sqlind != 0)
    printf("value is NULL\n");</programlisting></para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</literal></term>
      <listitem>
       <para>Имя поля, в виде строки с завершающим 0.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</literal></term>
      <listitem>
       <para>Зарезервировано в Informix, значение <function>PQfformat()</function> для данного поля.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</literal></term>
      <listitem>
       <para>Тип данных индикатора NULL. При получении данных с сервера это всегда SQLSMINT. Когда <literal>SQLDA</literal> используется в параметризованном запросе, данные индикатора обрабатываются в соответствии с указанным здесь типом.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</literal></term>
      <listitem>
       <para>Длина данных индикатора NULL.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</literal></term>
      <listitem>
       <para>Расширенный тип поля, результат функции <function>PQftype()</function>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</literal></term>
     <term><literal>sqltypelen</literal></term>
     <term><literal>sqlownerlen</literal></term>
     <term><literal>sqlsourcetype</literal></term>
     <term><literal>sqlownername</literal></term>
     <term><literal>sqlsourceid</literal></term>
     <term><literal>sqlflags</literal></term>
     <term><literal>sqlreserved</literal></term>
      <listitem>
       <para>Не используются.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</literal></term>
      <listitem>
       <para>Совпадает с <literal>sqldata</literal>, если <literal>sqllen</literal> превышает 32 Кбайта.</para>
      </listitem>
     </varlistentry>

    </variablelist> Например: <programlisting>EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* Это объявление не обязательно должно быть внутри DECLARE SECTION */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* Освобождать нужно только основную структуру,
                  * sqlda и sqlda-&gt;sqlvar находятся в одной выделенной области. */</programlisting> Дополнительную информацию можно найти в заголовочном файле <literal>sqlda.h</literal> и в регрессионном тесте <literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>.</para>
  </sect2>

  <sect2 id="ecpg-informix-functions">
   <title>Дополнительные функции</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</function></term>
      <listitem>
       <para>Складывает два значения типа decimal. <synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis> Эта функция получает указатель на первый операнд типа decimal (<literal>arg1</literal>), указатель на второй операнд типа decimal (<literal>arg2</literal>) и указатель на переменную типа decimal, в которую будет записана сумма (<literal>sum</literal>). В случае успеха эта функция возвращает 0. <symbol>ECPG_INFORMIX_NUM_OVERFLOW</symbol> возвращается в случае переполнения, а <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</symbol> в случае антипереполнения. При любых других ошибках возвращается -1, а в <varname>errno</varname> устанавливается код <varname>errno</varname> из pgtypeslib.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</function></term>
      <listitem>
       <para>Сравнивает два значения типа decimal. <synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis> Эта функция получает указатель на первое значение типа decimal (<literal>arg1</literal>), указатель на второе значение типа decimal (<literal>arg2</literal>) и возвращает целое, отражающее результат сравнения этих чисел. <itemizedlist>
         <listitem>
          <para>1, если значение, на которое указывает <literal>arg1</literal>, больше значения, на которое указывает <literal>var2</literal></para>
         </listitem>
         <listitem>
          <para>-1, если значение, на которое указывает <literal>arg1</literal>, меньше значения, на которое указывает <literal>arg2</literal></para>
         </listitem>
         <listitem>
          <para>0, если значение, на которое указывает <literal>arg1</literal>, равно значению, на которое указывает <literal>arg2</literal></para>
         </listitem>
        </itemizedlist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</function></term>
      <listitem>
       <para>Копирует значение типа decimal. <synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis> Функция принимает в первом аргументе (<literal>src</literal>) указатель на значение decimal, которое должно быть скопировано, а во втором аргументе (<literal>target</literal>) принимает указатель на структуру типа decimal для скопированного значения.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</function></term>
      <listitem>
       <para>Преобразует значение из представления ASCII в тип decimal. <synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis> Эта функция получает указатель на строку, содержащую строковое представление числа, которое нужно преобразовать, (<literal>cp</literal>), а также его длину <literal>len</literal>. В <literal>np</literal> передаётся указатель на переменную типа decimal, в которую будет помещён результат преобразования.</para>
       <para>Допустимыми являются, например следующие форматы: <literal>-2</literal>, <literal>.794</literal>, <literal>+3.44</literal>, <literal>592.49E07</literal> или <literal>-32.84e-4</literal>.</para>
       <para>В случае успеха эта функция возвращает 0. При переполнении или антипереполнении возвращается <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> или <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно. Если разобрать ASCII-представление не удаётся, возвращается <literal>ECPG_INFORMIX_BAD_NUMERIC</literal> или <literal>ECPG_INFORMIX_BAD_EXPONENT</literal>, если не удаётся разобрать компонент экспоненты.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</function></term>
      <listitem>
       <para>Преобразует значение double в значение типа decimal. <synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis> Данная функция принимает в первом аргументе (<literal>dbl</literal>) переменную типа double, которая должна быть преобразована. Во втором аргументе (<literal>np</literal>) она принимает указатель на переменную decimal, в которую будет помещён результат операции.</para>
       <para>Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить преобразование не удалось.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</function></term>
      <listitem>
       <para>Преобразует значение int в значение типа decimal. <synopsis>
int deccvint(int in, decimal *np);
</synopsis> Данная функция принимает в первом аргументе (<literal>in</literal>) переменную типа int, которая должна быть преобразована. Во втором аргументе (<literal>np</literal>) она принимает указатель на переменную decimal, в которую будет помещён результат операции.</para>
       <para>Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить преобразование не удалось.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvlong</function></term>
      <listitem>
       <para>Преобразует значение long в значение типа decimal. <synopsis>
int deccvlong(long lng, decimal *np);
</synopsis> Данная функция принимает в первом аргументе (<literal>lng</literal>) переменную типа long, которая должна быть преобразована. Во втором аргументе (<literal>np</literal>) она принимает указатель на переменную decimal, в которую будет помещён результат операции.</para>
       <para>Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить преобразование не удалось.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</function></term>
      <listitem>
       <para>Делит одну переменную типа decimal на другую. <synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis> Эта функция получает указатели на переменные (<literal>n1</literal> и <literal>n2</literal>) и вычисляет частное <literal>n1</literal>/<literal>n2</literal>. В <literal>result</literal> передаётся указатель на переменную, в которую будет помещён результат операции.</para>
       <para>В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае переполнения или антипереполнения данная функция возвращает <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> или <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно. При попытке деления на ноль возвращается <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</function></term>
      <listitem>
       <para>Перемножает два значения типа decimal. <synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis> Эта функция получает указатели на переменные (<literal>n1</literal> и <literal>n2</literal>) и вычисляет произведение <literal>n1</literal>*<literal>n2</literal>. В <literal>result</literal> передаётся указатель на переменную, в которую будет помещён результат операции.</para>
       <para>В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае переполнения или антипереполнения данная функция возвращает <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> или <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</function></term>
      <listitem>
       <para>Вычитает одно значение типа decimal из другого. <synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis> Эта функция получает указатели на переменные (<literal>n1</literal> и <literal>n2</literal>) и вычисляет разность <literal>n1</literal>-<literal>n2</literal>. В <literal>result</literal> передаётся указатель на переменную, в которую будет помещён результат операции.</para>
       <para>В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае переполнения или антипереполнения данная функция возвращает <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> или <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</function></term>
      <listitem>
       <para>Преобразует переменную типа decimal в представление ASCII (в строку C char*). <synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis> Эта функция получает указатель на переменную типа decimal (<literal>np</literal>), которая будет преобразована в текстовое представление. Аргумент <literal>cp</literal> указывает на буфер, в который будет помещён результат операции. Аргумент <literal>right</literal> определяет, сколько должно выводиться цифр правее десятичной точки. Результат будет округлён до этого числа десятичных цифр. Значение <literal>right</literal>, равное -1, указывает, что выводиться должны все имеющиеся десятичные цифры. Если длина выходного буфера, которую задаёт <literal>len</literal>, недостаточна для помещения в него текстового представления, включая завершающий нулевой байт, в буфере сохраняется один знак <literal>*</literal> и возвращается -1.</para>
       <para>Эта функция возвращает -1, если буфер <literal>cp</literal> слишком мал, либо <literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal> при нехватке памяти.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</function></term>
      <listitem>
       <para>Преобразует переменную типа decimal в тип double. <synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis> Эта функция получает указатель (<literal>np</literal>) на значение decimal, которое нужно преобразовать, и указатель (<literal>dblp</literal>) на переменную double, в которую будет помещён результат операции.</para>
       <para>В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование не удалось.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</function></term>
      <listitem>
       <para>Преобразует переменную типа decimal в тип integer. <synopsis>
int dectoint(decimal *np, int *ip);
</synopsis> Эта функция получает указатель (<literal>np</literal>) на значение decimal, которое нужно преобразовать, и указатель (<literal>ip</literal>) на целочисленную переменную, в которую будет помещён результат операции.</para>
       <para>В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование не удалось. В случае переполнения возвращается <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>.</para>
       <para>Заметьте, что реализация ECPG отличается от реализации <productname>Informix</productname>. В <productname>Informix</productname> целое ограничивается диапазоном -32767 .. 32767, тогда как в ECPG ограничение зависит от архитектуры (<literal>-INT_MAX .. INT_MAX</literal>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</function></term>
      <listitem>
       <para>Преобразует переменную типа decimal в тип long. <synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis> Эта функция получает указатель (<literal>np</literal>) на значение decimal, которое нужно преобразовать, и указатель (<literal>lngp</literal>) на переменную типа long, в которую будет помещён результат операции.</para>
       <para>В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование не удалось. В случае переполнения возвращается <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>.</para>
       <para>Заметьте, что реализация ECPG отличается от реализации <productname>Informix</productname>. В <productname>Informix</productname> длинное целое ограничено диапазоном -2&nbsp;147&nbsp;483&nbsp;647 .. 2&nbsp;147&nbsp;483&nbsp;647, тогда как в ECPG ограничение зависит от архитектуры (<literal>-LONG_MAX .. LONG_MAX</literal>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</function></term>
      <listitem>
       <para>Преобразует дату в строку C char*. <synopsis>
int rdatestr(date d, char *str);
</synopsis> Эта функция принимает два аргумента. В первом (<literal>d</literal>) передаётся дата, которую нужно преобразовать, а во втором указатель на целевую строку. Результат всегда выводится в формате <literal>yyyy-mm-dd</literal>, так что для этой строки нужно выделить минимум 11 байт (включая завершающий нулевой байт).</para>
       <para>Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.</para>
       <para>Заметьте, что реализация ECPG отличается от реализации <productname>Informix</productname>. В <productname>Informix</productname> формат вывода можно изменить переменными окружения, а в ECPG он фиксирован.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</function></term>
      <listitem>
       <para>Разбирает текстовое представление даты. <synopsis>
int rstrdate(char *str, date *d);
</synopsis> Эта функция получает текстовое представление (<literal>str</literal>) даты, которую нужно преобразовать, и указатель на переменную типа date (<literal>d</literal>). Для данной функции нельзя задать маску формата. Она использует стандартную маску формата <productname>Informix</productname>, а именно: <literal>mm/dd/yyyy</literal>. Внутри эта функция вызывает <function>rdefmtdate</function>. Таким образом, <function>rstrdate</function> не будет быстрее, и если у вас есть выбор, используйте функцию <function>rdefmtdate</function>, которая позволяет явно задать маску формата.</para>
       <para>Эта функция возвращает те же значения, что и <function>rdefmtdate</function>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</function></term>
      <listitem>
       <para>Выдаёт текущую дату. <synopsis>
void rtoday(date *d);
</synopsis> Эта функция получает указатель на переменную (<literal>d</literal>) типа date, в которую будет записана текущая дата.</para>
       <para>Внутри эта функция вызывает <xref linkend="pgtypesdatetoday"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</function></term>
      <listitem>
       <para>Извлекает значения дня, месяца и года из переменной типа date. <synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis> Эта функция получает дату <literal>d</literal> и указатель на 3 коротких целочисленных значения <literal>mdy</literal>. Имя переменной указывает на порядок значений: в <literal>mdy[0]</literal> записывается номер месяца, в <literal>mdy[1]</literal> — номер дня, а в <literal>mdy[2]</literal> — год.</para>
       <para>В текущем состоянии эта функция всегда возвращает 0.</para>
       <para>Внутри эта функция вызывает <xref linkend="pgtypesdatejulmdy"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</function></term>
      <listitem>
       <para>Преобразует символьную строку в значение типа date по маске формата. <synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis> Эта функция принимает указатель на переменную типа date (<literal>d</literal>), в которую будет помещён результат операции, маску формата для разбора даты (<literal>fmt</literal>) и строку C char*, содержащую текстовое представление даты (<literal>str</literal>). Ожидается, что текстовое представление будет соответствовать маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция анализирует только порядок элементов и ищет в нём подстроки <literal>yy</literal> или <literal>yyyy</literal>, обозначающие позицию года, подстроку <literal>mm</literal>, обозначающую позицию месяца, и <literal>dd</literal>, обозначающую позицию дня.</para>
       <para>Эта функция возвращает следующие значения: <itemizedlist>
         <listitem>
          <para>0 — Функция выполнена успешно.</para>
         </listitem>
         <listitem>
          <para><literal>ECPG_INFORMIX_ENOSHORTDATE</literal> — Дата не содержит разделителей между днём, месяцем и годом. С таким форматом входная строка должна быть длиной ровно 6 или 8 байт, но это не так.</para>
         </listitem>
         <listitem>
          <para><literal>ECPG_INFORMIX_ENOTDMY</literal> — Строка формата не определяет корректно последовательный порядок года, месяца и дня.</para>
         </listitem>
         <listitem>
          <para><literal>ECPG_INFORMIX_BAD_DAY</literal> — Во входной строке отсутствует корректное указание дня.</para>
         </listitem>
         <listitem>
          <para><literal>ECPG_INFORMIX_BAD_MONTH</literal> — Во входной строке отсутствует корректное указание месяца.</para>
         </listitem>
         <listitem>
          <para><literal>ECPG_INFORMIX_BAD_YEAR</literal> — Во входной строке отсутствует корректное указание года.</para>
         </listitem>
        </itemizedlist></para>
       <para>В реализации этой функции вызывается <xref linkend="pgtypesdatedefmtasc"/>. Примеры вводимых строк приведены в таблице в её описании.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</function></term>
      <listitem>
       <para>Преобразует переменную типа date в текстовое представление по маске формата. <synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis> Эта функция принимает дату для преобразования (<literal>d</literal>), маску формата (<literal>fmt</literal>) и строку, в которую будет помещено текстовое представление даты (<literal>str</literal>).</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
       <para>Внутри эта функция вызывает <xref linkend="pgtypesdatefmtasc"/>, примеры форматов можно найти в её описании.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</function></term>
      <listitem>
       <para>Образует значение даты из массива 3 коротких целых, задающих день, месяц и год даты. <synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis> Эта функция получает в первом аргументе массив из 3 коротких целых (<literal>mdy</literal>), а во втором указатель на переменную типа date, в которую будет помещён результат операции.</para>
       <para>В настоящее время эта функция всегда возвращает 0.</para>
       <para>В реализации этой функции вызывается <xref linkend="pgtypesdatemdyjul"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</function></term>
      <listitem>
       <para>Возвращает число, представляющее день недели для заданной даты. <synopsis>
int rdayofweek(date d);
</synopsis> Эта функция принимает в единственном аргументе переменную <literal>d</literal> типа date и возвращает целое число, выражающее день недели для этой даты. <itemizedlist>
         <listitem>
          <para>0 — Воскресенье</para>
         </listitem>
         <listitem>
          <para>1 — Понедельник</para>
         </listitem>
         <listitem>
          <para>2 — Вторник</para>
         </listitem>
         <listitem>
          <para>3 — Среда</para>
         </listitem>
         <listitem>
          <para>4 — Четверг</para>
         </listitem>
         <listitem>
          <para>5 — Пятница</para>
         </listitem>
         <listitem>
          <para>6 — Суббота</para>
         </listitem>
        </itemizedlist></para>
       <para>В реализации этой функции вызывается <xref linkend="pgtypesdatedayofweek"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</function></term>
      <listitem>
       <para>Получает текущее время. <synopsis>
void dtcurrent(timestamp *ts);
</synopsis> Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую указывает <literal>ts</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</function></term>
      <listitem>
       <para>Разбирает время из текстового представления в переменную типа timestamp. <synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis> Эта функция получает строку (<literal>str</literal>), которую нужно разобрать, и указатель на переменную типа timestamp, в которую будет помещён результат операции (<literal>ts</literal>).</para>
       <para>Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.</para>
       <para>Внутри эта функция вызывает <xref linkend="pgtypestimestampfromasc"/>. Примеры вводимых строк приведены в таблице в её описании.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</function></term>
      <listitem>
       <para>Разбирает время из текстового представления в переменную типа timestamp по маске формата. <synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis> Эта функция получает строку (<literal>inbuf</literal>), которую нужно разобрать, маску формата (<literal>fmtstr</literal>) и указатель на переменную timestamp, в которой будет содержаться результат операции (<literal>dtvalue</literal>).</para>
       <para>В реализации этой функции используется <xref linkend="pgtypestimestampdefmtasc"/>. Список допустимых кодов формата приведён в её описании.</para>
       <para>Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</function></term>
      <listitem>
       <para>Вычитает одно значение времени из другого и возвращает переменную типа interval. <synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis> Эта функция вычитает значение timestamp, на которое указывает <literal>ts2</literal>, из значения timestamp, на которое указывает <literal>ts1</literal>, и сохраняет результат в переменной типа interval, на которую указывает <literal>iv</literal>.</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</function></term>
      <listitem>
       <para>Преобразует переменную типа timestamp в строку C char*. <synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis> Эта функция получает указатель (<literal>ts</literal>) на переменную типа timestamp, которую нужно преобразовать, и строку (<literal>output</literal>) для сохранения результата операции. Она преобразует <literal>ts</literal> в текстовое представление согласно стандарту SQL, то есть по маске <literal>YYYY-MM-DD HH:MM:SS</literal>.</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</function></term>
      <listitem>
       <para>Преобразует переменную типа timestamp в строку C char* по маске формата. <synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis> Эта функция получает в первом аргументе (<literal>ts</literal>) указатель на переменную типа timestamp, а в последующих указатель на буфер вывода (<literal>output</literal>), максимальную длину строки, которую может принять буфер (<literal>str_len</literal>), и маску формата, с которой будет выполняться преобразование (<literal>fmtstr</literal>).</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
       <para>Внутри эта функция использует <xref linkend="pgtypestimestampfmtasc"/>. Примеры допустимых масок формата можно найти в её описании.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</function></term>
      <listitem>
       <para>Преобразует переменную типа interval в строку C char*. <synopsis>
int intoasc(interval *i, char *str);
</synopsis> Эта функция получает указатель (<literal>i</literal>) на переменную типа interval, которую нужно преобразовать, и строку (<literal>str</literal>) для сохранения результата операции. Она преобразует <literal>i</literal> в текстовое представление согласно стандарту SQL, то есть по маске <literal>YYYY-MM-DD HH:MM:SS</literal>.</para>
       <para>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</function></term>
      <listitem>
       <para>Преобразует длинное целое в текстовое представление по маске формата. <synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis> Эта функция принимает значение типа long (<literal>lng_val</literal>), маску формата (<literal>fmt</literal>) и указатель на выходной буфер (<literal>outbuf</literal>). Она преобразует длинное целое в его текстовое представление согласно заданной маске формата.</para>
       <para>Маску формата можно составить из следующих символов, определяющих формат: <itemizedlist>
         <listitem>
          <para><literal>*</literal> (звёздочка) — если в данной позиции будет пусто, заполнить её звёздочкой.</para>
         </listitem>
         <listitem>
          <para><literal>&amp;</literal> (амперсанд) — если в данной позиции будет пусто, заполнить её нулём.</para>
         </listitem>
         <listitem>
          <para><literal>#</literal> — заменить ведущие нули пробелами.</para>
         </listitem>
         <listitem>
          <para><literal>&lt;</literal> — выровнять число в строке по левой стороне.</para>
         </listitem>
         <listitem>
          <para><literal>,</literal> (запятая) — сгруппировать числа, содержащие четыре и более цифр, в группы по три цифры через запятую.</para>
         </listitem>
         <listitem>
          <para><literal>.</literal> (точка) — этот символ отделяет целую часть числа от дробной.</para>
         </listitem>
         <listitem>
          <para><literal>-</literal> (минус) — с отрицательным числом должен выводиться знак минус.</para>
         </listitem>
         <listitem>
          <para><literal>+</literal> (плюс) — с положительным числом должен выводиться знак плюс.</para>
         </listitem>
         <listitem>
          <para><literal>(</literal> — это символ заменяет знак минус перед отрицательным числом. Сам знак минус выводиться не будет.</para>
         </listitem>
         <listitem>
          <para><literal>)</literal> — этот символ заменяет минус и выводится после отрицательного числа.</para>
         </listitem>
         <listitem>
          <para><literal>$</literal> — символ денежной суммы.</para>
         </listitem>
        </itemizedlist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</function></term>
      <listitem>
       <para>Приводит строку к верхнему регистру. <synopsis>
void rupshift(char *str);
</synopsis> Эта функция получает указатель на строку и приводит в ней каждый символ в нижнем регистре к верхнему регистру.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</function></term>
      <listitem>
       <para>Возвращает число символов в строке, не считая завершающих пробелов. <synopsis>
int byleng(char *str, int len);
</synopsis> Эта функция принимает в первом аргументе (<literal>str</literal>) строку фиксированной длины, а во втором (<literal>len</literal>) её длину. Она возвращает число значимых символов, то есть длину строки без завершающих пробелов.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</function></term>
      <listitem>
       <para>Копирует строку фиксированной длины в строку с завершающим нулём. <synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis> Эта функция принимает строку фиксированной длины (<literal>src</literal>), которую нужно скопировать, её длину (<literal>len</literal>) и указатель на целевой буфер в памяти (<literal>dest</literal>). Учтите, что для буфера, на который указывает <literal>dest</literal>, необходимо выделить как минимум <literal>len+1</literal> байт. Данная функция копирует в новую область не больше <literal>len</literal> байт (меньше, если в исходной строке есть завершающие пробелы) и добавляет завершающий 0.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</function></term>
      <listitem>
       <para><synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis> Эта функция определена, но не реализована на данный момент!</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</function></term>
      <listitem>
       <para><synopsis>
int rtypalign(int offset, int type);
</synopsis> Эта функция определена, но не реализована на данный момент!</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</function></term>
      <listitem>
       <para><synopsis>
int rtypmsize(int type, int len);
</synopsis> Эта функция определена, но не реализована на данный момент!</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</function></term>
      <listitem>
       <para><synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis> Эта функция определена, но не реализована на данный момент!</para>
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</function></term>
      <listitem>
       <para>Присваивает переменной NULL. <synopsis>
int rsetnull(int t, char *ptr);
</synopsis> Эта функция получает целое, определяющее тип переменной, и указатель на саму переменную, приведённый к указателю C char*.</para>
       <para>Определены следующие типы: <itemizedlist>
         <listitem>
          <para><literal>CCHARTYPE</literal> — для переменной типа <type>char</type> или <type>char*</type></para>
         </listitem>
         <listitem>
          <para><literal>CSHORTTYPE</literal> — для переменной типа <type>short int</type></para>
         </listitem>
         <listitem>
          <para><literal>CINTTYPE</literal> — для переменной типа <type>int</type></para>
         </listitem>
         <listitem>
          <para><literal>CBOOLTYPE</literal> — для переменной типа <type>boolean</type></para>
         </listitem>
         <listitem>
          <para><literal>CFLOATTYPE</literal> — для переменной типа <type>float</type></para>
         </listitem>
         <listitem>
          <para><literal>CLONGTYPE</literal> — для переменной типа <type>long</type></para>
         </listitem>
         <listitem>
          <para><literal>CDOUBLETYPE</literal> — для переменной типа <type>double</type></para>
         </listitem>
         <listitem>
          <para><literal>CDECIMALTYPE</literal> — для переменной типа <type>decimal</type></para>
         </listitem>
         <listitem>
          <para><literal>CDATETYPE</literal> — для переменной типа <type>date</type></para>
         </listitem>
         <listitem>
          <para><literal>CDTIMETYPE</literal> — для переменной типа <type>timestamp</type></para>
         </listitem>
        </itemizedlist></para>

       <para>Примеры вызова этой функции: <programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</function></term>
      <listitem>
       <para>Проверяет содержимое переменной на NULL. <synopsis>
int risnull(int t, char *ptr);
</synopsis> Эта функция получает тип проверяемой переменной (<literal>t</literal>), а также указатель на неё (<literal>ptr</literal>). Заметьте, что этот указатель нужно привести к char*. Список возможных типов переменных приведён в описании функции <xref linkend="rsetnull"/>.</para>
       <para>Примеры использования этой функции: <programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting></para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-constants">
   <title>Дополнительные константы</title>
   <para>Заметьте, что все эти константы относятся к ошибкам и все они представлены отрицательными значениями. Из описаний различных констант вы также можете узнать, какими именно числами они представлены в текущей реализации. Однако полагаться на эти числа не следует. Тем не менее, вы можете рассчитывать на то, что все эти значения будут отрицательными. <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если при вычислении происходит переполнение. Внутри оно представляется числом -1200 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если при вычислении происходит антипереполнение. Внутри оно представляется числом -1201 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>Функции возвращают это значение при попытке деления на ноль. Внутри оно представляется числом -1202 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если при разборе даты встретилось некорректное указание года. Внутри оно представляется числом -1204 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если при разборе даты встретилось некорректное указание месяца. Внутри оно представляется числом -1205 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если при разборе даты встретилось некорректное указание дня. Внутри оно представляется числом -1206 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если процедуре разбора даты требуется короткая запись даты, но строка даты имеет неподходящую длину. Внутри оно представляется числом -1209 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если при форматировании даты происходит ошибка. Внутри оно представляется числом -1210 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если им не хватает памяти для выполнения операций. Внутри оно представляется числом -1211 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если процедура разбора должна была получить маску формата (например, <literal>mmddyy</literal>), но не все поля были записаны правильно. Внутри оно представляется числом -1212 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если процедура разбора не может получить числовое значение из текстового представления, потому что оно некорректно, либо если процедура вычисления не может произвести операцию с числовыми переменными из-за недопустимого значения минимум одной из этих переменных. Внутри оно представляется числом -1213 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если процедура разбора не может воспринять экспоненту в числе. Внутри оно представляется числом -1216 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если процедура разбора не может разобрать дату. Внутри оно представляется числом -1218 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</literal></term>
      <listitem>
       <para>Функции возвращают это значение, если процедуре разбора передаются посторонние символы, которая она не может разобрать. Внутри оно представляется числом -1264 (определение <productname>Informix</productname>).</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-develop">
  <title>Внутреннее устройство</title>

  <para>В этом разделе рассказывается, как препроцессор <application>ECPG</application> устроен внутри. Эта информация может оказаться полезной для пользователей, желающих понять, как использовать <application>ECPG</application>.</para>

   <para>Первые четыре строки, которые <command>ecpg</command> записывает в вывод, фиксированы. Первые две строки содержат комментарии, а следующие две директивы включения, подключающие интерфейс к библиотеке. Затем препроцессор прочитывает файл и продолжает запись в вывод. Обычно он просто печатает всё в устройство вывода.</para>

   <para>Встречая команду <command>EXEC SQL</command>, он вмешивается и изменяет её. Данная команда начинается со слов <command>EXEC SQL</command> и заканчивается знаком <command>;</command>. Всё между ними воспринимается как оператор <acronym>SQL</acronym> и разбирается для подстановки переменных.</para>

   <para>Подстановка переменных имеет место, когда символ начинается с двоеточия (<literal>:</literal>). ECPG будет искать переменную с таким именем среди переменных, ранее объявленных в секции <literal>EXEC SQL DECLARE</literal>.</para>

   <para>Самая важная функция в библиотеке — <function>ECPGdo</function>, которая осуществляет выполнение большинства команд. Она принимает переменное число аргументов (это число легко может достигать 50, и мы надеемся, что это не приведёт к проблемам ни на какой платформе).</para>

   <para>Ей передаются следующие аргументы: <variablelist>
     <varlistentry>
      <term>Номер строки</term>
      <listitem>
       <para>Номер исходной строки; используется только в сообщениях об ошибках.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Строка</term>
      <listitem>
       <para>Команда <acronym>SQL</acronym>, которая должна быть выполнена. На её содержимое влияют входные переменные, то есть переменные, добавленные в команду, но неизвестные во время компиляции. Места, в которые должны вставляться переменные, обозначаются знаками <literal>?</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Входные переменные</term>
      <listitem>
       <para>Для каждой входной переменной формируются десять аргументов. (См. ниже.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</parameter></term>
      <listitem>
       <para>Перечисление (<type>enum</type>), показывающее, что больше входных переменных нет.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Выходные переменные</term>
      <listitem>
       <para>Для каждой входной переменной формируются десять аргументов. (См. ниже.) Эти переменные заполняются данной функцией.</para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</parameter></term>
       <listitem>
       <para>Перечисление (<type>enum</type>), показывающее, что больше выходных переменных нет.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>

   <para>Для каждой переменной, включённой в команду <acronym>SQL</acronym>, эта функция принимает десять аргументов: <orderedlist>
     <listitem>
      <para>Тип в виде специального символа.</para>
     </listitem>

     <listitem>
      <para>Указатель на значение или указатель на указатель.</para>
     </listitem>

     <listitem>
      <para>Размер переменной, если она имеет тип <type>char</type> или <type>varchar</type>.</para>
     </listitem>

     <listitem>
      <para>Число элементов в массиве (при выборке данных в массив).</para>
     </listitem>

     <listitem>
      <para>Смещение следующего элемента в массиве (при выборке данных в массив).</para>
     </listitem>

     <listitem>
      <para>Тип переменной-индикатора в виде специального символа.</para>
     </listitem>

     <listitem>
      <para>Указатель на переменную-индикатор.</para>
     </listitem>

     <listitem>
      <para>0</para>
     </listitem>

     <listitem>
      <para>Число элементов в массиве индикаторов (при выборке данных в массив).</para>
     </listitem>

     <listitem>
      <para>Смещение следующего элемента в массиве индикаторов (при выборке данных в массив).</para>
     </listitem>
    </orderedlist></para>

   <para>Заметьте, что не все команды SQL обрабатываются таким образом. Например, команда открытия курсора вида: <programlisting>EXEC SQL OPEN <replaceable>курсор</replaceable>;</programlisting> не копируется в вывод. Вместо этого в позиции команды <command>OPEN</command> применяется команда <command>DECLARE</command> этого курсора, так как на самом деле курсор открывает она.</para>

   <para>Ниже показан полный пример, демонстрирующий результат обработки препроцессором файла <filename>foo.pgc</filename> (детали могут меняться от версии к версии препроцессора): <programlisting>EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;</programlisting> преобразуется в: <programlisting><![CDATA[
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include <ecpgtype.h>;
#include <ecpglib.h>;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int result;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting> (Отступы здесь добавлены для читаемости, препроцессор их не вставляет.)</para>
 </sect1>
</chapter>
