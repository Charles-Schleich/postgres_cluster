<!-- doc/src/xml/manage-ag.xml -->

<chapter id="managing-databases">
 <title>Управление базами данных</title>

 <indexterm zone="managing-databases"><primary>база данных</primary></indexterm>

 <para>Каждый работающий экземпляр сервера <productname>&productname;</productname> обслуживает одну или несколько баз данных. Поэтому базы данных представляют собой вершину иерархии <acronym>SQL</acronym>-объектов (<quote>объектов базы данных</quote>). Данная глава описывает свойства баз данных, процессы создания, управления и удаления.</para>

 <sect1 id="manage-ag-overview">
  <title>Обзор</title>

  <indexterm zone="manage-ag-overview"><primary>схема</primary></indexterm>

  <para>База данных — именованная коллекция объектов <acronym>SQL</acronym> (<quote>объектов базы данных</quote>). В целом, каждый объект базы данных (таблицы, функции и т. д.) принадлежит одной и только одной базе данных. (Правда есть несколько системных каталогов, например, <literal>pg_database</literal>, которые принадлежат всему кластеру и доступны для каждой базы данных этого кластера.) Если точнее, база данных это набор схем, которые включают в себя таблицы, функции и т. д. Таким образом, полная иерархия включает в себя: сервер, базу данных, схему, таблицу (или иные типы объектов, к примеру, функции).</para>

  <para>При подключении к серверу базы данных, клиент должен указать в параметрах подключения имя базы данных, с которой нужно соединиться. Одно соединение не может иметь доступ более чем к одной базе данных. Однако приложение не ограничено в количестве соединений к одной и той же или разным базам данных. Базы данных разделены физически и контроль доступа осуществляется на уровне соединения. В случае, когда один экземпляр сервера <productname>&productname;</productname> обслуживает проекты или пользователей, которых необходимо изолировать друг от друга, рекомендуется размещать их в раздельных базах данных. В случае, когда проекты или пользователи взаимосвязаны и должны иметь возможность использовать общие ресурсы, они должны размещаться в одной базе данных, но, возможно, в раздельных схемах. Схемы — в чистом виде логическая структура, и кто к чему может получить доступ управляется системой привилегий. Более подробная информация по управлению схемами приведена в <xref remap="6" linkend="ddl-schemas"/>.</para>

  <para>Базы данных создаются командой <command>CREATE DATABASE</command> (см. <xref remap="4" linkend="manage-ag-createdb"/>), а удаляются командой <command>DROP DATABASE</command> (см. <xref remap="4" linkend="manage-ag-dropdb"/>). Список существующих баз данных можно посмотреть в системном каталоге <structname>pg_database</structname>, например, <synopsis>
SELECT datname FROM pg_database;
</synopsis> Метакоманда <literal>\l</literal> или ключ <option>-l</option> командной строки приложения <xref linkend="app-psql"/> также позволяют вывести список существующих баз данных.</para>

  <note>
   <para>Стандарт <acronym>SQL</acronym> называет базы данных <quote>каталогами</quote>, но на практике у них нет отличий.</para>
  </note>
 </sect1>

 <sect1 id="manage-ag-createdb">
  <title>Создание базы данных</title>

  <indexterm><primary>CREATE DATABASE</primary></indexterm>

  <para>Для создания базы данных сервер <productname>&productname;</productname> должен быть развёрнут и запущен (см. <xref remap="4" linkend="server-start"/>).</para>

  <para>База данных создаётся SQL-командой <xref linkend="sql-createdatabase"/>: <synopsis>
CREATE DATABASE <replaceable>имя</replaceable>;
</synopsis> где <replaceable>имя</replaceable> подчиняется правилам именования идентификаторов <acronym>SQL</acronym>. Текущий пользователь автоматически назначается владельцем. Владелец может удалить свою базу, что также приведёт к удалению всех её объектов, в том числе, имеющих других владельцев.</para>

  <para>Создание баз данных это привилегированная операция. Как предоставить права доступа, описано в <xref remap="6" linkend="role-attributes"/>.</para>

  <para>Поскольку для выполнения команды <command>CREATE DATABASE</command> необходимо подключение к серверу базы данных, возникает вопрос как создать самую первую базу данных. Первая база данных всегда создаётся командой <command>initdb</command> при инициализации пространства хранения данных (см. <xref remap="4" linkend="creating-cluster"/>.) Эта база данных называется <literal>postgres</literal>.<indexterm><primary>postgres</primary></indexterm> Далее для создания первой <quote>обычной</quote> базы данных можно подключиться к <literal>postgres</literal>.</para>

  <para>Вторая база данных <literal>template1</literal>,<indexterm><primary>template1</primary></indexterm> также создаётся во время инициализации кластера. При каждом создании новой базы данных в рамках кластера по факту производится клонирование шаблона <literal>template1</literal>. При этом любые изменения сделанные в <literal moreinfo=" none">template1</literal> распространяются на все созданные впоследствии базы данных. Следует избегать создания объектов в <literal>template1</literal>, за исключением ситуации, когда их необходимо автоматически добавлять в новые базы. Более подробно в <xref remap="6" linkend="manage-ag-templatedbs"/>.</para>

  <para>Для удобства, есть утилита командной строки для создания баз данных, <command>createdb</command>.<indexterm><primary>createdb</primary></indexterm> <synopsis>
createdb <replaceable class="parameter">dbname</replaceable>
</synopsis> Утилита <command>createdb</command> не делает ничего волшебного, она просто подключается к базе данных <literal>postgres</literal> и выполняет ранее описанную SQL-команду <command>CREATE DATABASE</command>. Подробнее о её вызове можно узнать в <xref remap="6" linkend="app-createdb"/>. Обратите внимание, что команда <command>createdb</command> без параметров создаст базу данных с именем текущего пользователя.</para>

  <note>
   <para><xref linkend="client-authentication"/> содержит информацию о том, как ограничить права на подключение к заданной базе данных.</para>
  </note>

  <para>Иногда необходимо создать базу данных для другого пользователя и назначить его владельцем, чтобы он мог конфигурировать и управлять ею. Для этого используйте одну из следующих команд: <programlisting>CREATE DATABASE <replaceable>имя_базы</replaceable> OWNER <replaceable>имя_роли</replaceable>;</programlisting> из среды SQL, или: <programlisting>createdb -O <replaceable>имя_роли</replaceable> <replaceable>имя_базы</replaceable></programlisting> из командной строки ОС. Лишь суперпользователь может создавать базы данных для других (для ролей, членом которых он не является).</para>
 </sect1>

 <sect1 id="manage-ag-templatedbs">
  <title>Шаблоны баз данных</title>

  <para>По факту команда <command>CREATE DATABASE</command> выполняет копирование существующей базы данных. По умолчанию копируется стандартная системная база <literal>template1</literal>. <indexterm><primary>template1</primary></indexterm> Таким образом, <literal>template1</literal> это шаблон, на основе которого создаются новые базы. Если добавить объекты в <literal>template1</literal>, то впоследствии они будут копироваться в новые базы данных. Это позволяет внести изменения в стандартный набор объектов. Например, если в <literal>template1</literal> установить процедурный язык <application>PL/Perl</application>, то он будет доступен в новых базах без дополнительных действий.</para>

  <para>Также существует вторая системная база <literal>template0</literal>.<indexterm><primary>template0</primary></indexterm> При инициализации она содержит те же самые объекты, что и <literal>template1</literal>, предопределённые в рамках устанавливаемой версии <productname>&productname;</productname>. Не нужно вносить никаких изменений в <literal>template0</literal> после инициализации кластера. Если в команде <command>CREATE DATABASE</command> указать на необходимость копирования <literal>template0</literal> вместо <literal>template1</literal>, то на выходе можно получить <quote>чистую</quote> пользовательскую базу данных без изменений, внесённых в <literal>template1</literal>. Это удобно, когда производится восстановление из дампа данных с помощью утилиты <literal>pg_dump</literal>: скрипт дампа лучше выполнять в чистую базу, во избежание каких-либо конфликтов с объектами, которые могли быть добавлены в <literal>template1</literal>.</para>

  <para>Другая причина, для копирования <literal>template0</literal> вместо <literal>template1</literal> заключается в том, что можно указать новые параметры локали и кодировку при копировании <literal>template0</literal>, в то время как для копий <literal>template1</literal> они не должны меняться. Это связано с тем, что <literal>template1</literal> может содержать данные в специфических кодировках и локалях, в отличие от <literal>template0</literal>.</para>

  <para>Для создания базы данных на основе <literal>template0</literal>, используйте: <programlisting>CREATE DATABASE <replaceable>dbname</replaceable> TEMPLATE template0;</programlisting> из среды SQL, или: <programlisting>createdb -T template0 <replaceable>dbname</replaceable></programlisting> из командной строки ОС.</para>

  <para>Можно создавать дополнительные шаблоны баз данных, и, более того, можно копировать любую базу данных кластера, если указать её имя в качестве шаблона в команде <command>CREATE DATABASE</command>. Важно понимать, что это (пока) не рассматривается в качестве основного инструмента для реализации возможности <quote><command>COPY DATABASE</command></quote>. Важным является то, что при копировании все сессии к копируемой базе данных должны быть закрыты. <command>CREATE DATABASE</command> выдаст ошибку, если есть другие подключения; во время операции копирования новые подключения к этой базе данных не разрешены.</para>

  <para>В таблице <literal>pg_database</literal><indexterm><primary>pg_database</primary></indexterm> есть два полезных флага для каждой базы данных: столбцы <literal>datistemplate</literal> и <literal>datallowconn</literal>. <literal>datistemplate</literal> указывает на факт того, что база данных может выступать в качестве шаблона в команде <command>CREATE DATABASE</command>. Если флаг установлен, то для пользователей с правом <literal>CREATEDB</literal> клонирование доступно; если флаг не установлен, то лишь суперпользователь и владелец базы данных могут её клонировать. Если <literal>datallowconn</literal> не установлен, то новые подключения к этой базе не допустимы (однако текущие сессии не закрываются при сбросе этого флага). База <literal>template0</literal> обычно помечена как <literal>datallowconn = false</literal> для избежания любых её модификаций. И <literal>template0</literal>, и <literal>template1</literal> всегда должны быть помечены флагом <literal>datistemplate = true</literal>.</para>

  <note>
   <para><literal>template1</literal> и <literal>template0</literal> не выделены как-то особенно, кроме того факта, что <literal>template1</literal> используется по умолчанию в команде <command>CREATE DATABASE</command>. Например, можно удалить <literal>template1</literal> и безболезненно создать заново из <literal>template0</literal>. Это можно посоветовать в случае, если <literal>template1</literal> был замусорен. (Чтобы удалить <literal>template1</literal>, необходимо сбросить флаг <literal>pg_database.datistemplate = false</literal>.)</para>

   <para>База данных <literal>postgres</literal> также создаётся при инициализации кластера. Она используется пользователями и приложениями для подключения по умолчанию. Представляет собой всего лишь копию <literal>template1</literal>, и может быть удалена и повторно создана при необходимости.</para>
  </note>
 </sect1>

 <sect1 id="manage-ag-config">
  <title>Конфигурирование баз данных</title>

  <para>Обратившись к <xref remap="3" linkend="runtime-config"/> можно выяснить, что сервер <productname>&productname;</productname> имеет множество параметров конфигурации времени исполнения. Можно выставить специфичные для базы данных значения по умолчанию.</para>

  <para>Например, если по какой-то причине необходимо выключить <acronym>GEQO</acronym> оптимизатор в какой-то из баз, то можно, либо выключить его для всех баз данных одновременно, либо убедиться, что все клиенты заботятся об этом, выполняя команду <literal>SET geqo TO off</literal>. Для того чтобы это действовало по умолчанию в конкретной базе данных, необходимо выполнить команду: <programlisting>ALTER DATABASE mydb SET geqo TO off;</programlisting> Установка сохраняется, но не применяется тотчас. В последующих подключениях к этой базе данных, эффект будет таким, будто перед началом сессии была выполнена команда <literal>SET geqo TO off;</literal>. Стоит обратить внимание, что пользователь по-прежнему может изменять этот параметр во время сессии; ведь это просто значение по умолчанию. Чтобы сбросить такое установленное значение, используйте <literal>ALTER DATABASE <replaceable>dbname</replaceable> RESET <replaceable>varname</replaceable></literal>.</para>
 </sect1>

 <sect1 id="manage-ag-dropdb">
  <title>Удаление базы данных</title>

  <para>Базы данных удаляются командой <xref linkend="sql-dropdatabase"/>:<indexterm><primary>DROP DATABASE</primary></indexterm> <synopsis>
DROP DATABASE <replaceable>имя</replaceable>;
</synopsis> Лишь владелец базы данных или суперпользователь могут удалить базу. При удалении также удаляются все её объекты. Удаление базы данных это необратимая операция.</para>

  <para>Невозможно выполнить команду <command>DROP DATABASE</command> пока существует хоть одно подключение к заданной базе. Однако можно подключиться к любой другой, в том числе и <literal>template1</literal>. <literal>template1</literal> может быть единственной возможностью при удалении последней пользовательской базы данных кластера.</para>

  <para>Также существует утилита командной строки для удаления баз данных <xref linkend="app-dropdb"/>:<indexterm><primary>dropdb</primary></indexterm> <synopsis>
dropdb <replaceable class="parameter">dbname</replaceable>
</synopsis> (В отличие от команды <command>createdb</command> утилита не использует имя текущего пользователя по умолчанию).</para>
 </sect1>

 <sect1 id="manage-ag-tablespaces">
  <title>Табличные пространства</title>

  <indexterm zone="manage-ag-tablespaces"><primary>табличное пространство</primary></indexterm>

  <para>Табличные пространства в <productname>&productname;</productname> позволяют администраторам организовать логику размещения файлов объектов базы данных в файловой системе. К однажды созданному табличному пространству можно обращаться по имени на этапе создания объектов.</para>

  <para>Табличные пространства позволяют администратору управлять дисковым пространством для инсталляции <productname>&productname;</productname>. Это полезно минимум по двум причинам. Во-первых, это нехватка места в разделе, на котором был инициализирован кластер и невозможность его расширения. Табличное пространство можно создать в другом разделе и использовать его до тех пор, пока не появится возможность переконфигурирования системы.</para>

  <para>Во-вторых, табличные пространства позволяют администраторам оптимизировать производительность согласно бизнес-процессам, связанным с объектами базы данных. Например, часто используемый индекс можно разместить на очень быстром и надёжном, но дорогом SSD-диске. В то же время таблица с архивными данными, которые редко используются и скорость к доступа к ним не важна, может быть размещена в более дешёвом и медленном хранилище.</para>

  <warning>
   <para>Несмотря на внешнее размещение относительно основного каталога хранения данных &productname;, табличные пространства являются неотъемлемой частью кластера и <emphasis>не могут</emphasis> трактоваться, как самостоятельная коллекция файлов данных. Они зависят от метаданных, расположенных в главном каталоге, и потому не могут быть подключены к другому кластеру, или копироваться по отдельности. Также, в случае потери табличного пространства (при удалении файлов, сбое диска и т. п.), кластер может оказаться недоступным или не сможет запуститься. Таким образом, при размещении табличного пространства во временной файловой системе, например, в RAM-диске, возникает угроза надёжности всего кластера.</para>
  </warning>

  <para>Для создания табличного пространства используется команда <xref linkend="sql-createtablespace"/>, например:<indexterm><primary>CREATE TABLESPACE</primary></indexterm>: <programlisting>CREATE TABLESPACE fastspace LOCATION '/ssd1/postgresql/data';</programlisting> Каталог должен существовать, быть пустым и принадлежать пользователю ОС, под которым запущен <productname>&productname;</productname>. Все созданные впоследствии объекты, принадлежащие целевому табличному пространству, будут храниться в файлах расположенных в этом каталоге. Каталог не должен размещаться на съёмных или устройствах временного хранения, так как кластер может перестать функционировать из-за потери этого пространства.</para>

  <note>
   <para>Обычно нет смысла создавать более одного пространства на одну логическую файловую систему, так как нет возможности контролировать расположение отдельных файлов в файловой системе. Однако <productname>&productname;</productname> не накладывает никаких ограничений в этом отношении, и более того, напрямую не заботится о точках монтирования файловой системы. Просто осуществляется хранение файлов в указанных каталогах.</para>
  </note>

  <para>Создавать табличное пространство должен суперпользователь базы данных, но после этого можно разрешить обычным пользователям его использовать. Для этого необходимо предоставить привилегию <literal>CREATE</literal> на табличное пространство.</para>

  <para>Таблицы, индексы и целые базы данных могут храниться в отдельных табличных пространствах. Для этого пользователь с правом <literal>CREATE</literal> на табличное пространство должен указать его имя в качестве параметра соответствующей команды. Например, далее создаётся таблица в табличном пространстве <literal>space1</literal>: <programlisting>CREATE TABLE foo(i int) TABLESPACE space1;</programlisting></para>

  <para>Как вариант, используйте параметр <xref linkend="guc-default-tablespace"/>: <programlisting>SET default_tablespace = space1;
CREATE TABLE foo(i int);</programlisting> Когда <varname>default_tablespace</varname> имеет значение отличное от пустой строки, он будет использоваться неявно в качестве значения параметра <literal>TABLESPACE</literal> в командах <command>CREATE TABLE</command> и <command>CREATE INDEX</command>, если в самой команде не задано иное.</para>

  <para>Существует параметр <xref linkend="guc-temp-tablespaces"/>, который указывает на размещение временных таблиц и индексов, а также файлов, создаваемых, например, при операциях сортировки больших наборов данных. Предпочтительнее, в качестве значения этого параметра, указывать не одно имя, а список из нескольких табличных пространств. Это поможет распределить нагрузку, связанную с временными объектами, по различным табличным пространствам. При каждом создании временного объекта будет случайным образом выбираться имя из указанного списка табличных пространств.</para>

  <para>Табличное пространство, связанное с базой данных, также используется для хранения её системных каталогов. Более того, это табличное пространство используется по умолчанию для таблиц, индексов и временных файлов, создаваемых в базе данных, если не указано иное в выражении <literal>TABLESPACE</literal>, или переменной <varname>default_tablespace</varname>, или <varname>temp_tablespaces</varname> (соответственно). Если база данных создана без указания конкретного табличного пространства, то используется пространство, к которому принадлежит копируемый шаблон.</para>

  <para>При инициализации кластера автоматически создаются два табличных пространства. Табличное пространство <literal>pg_global</literal> используется для общих системных каталогов. Табличное пространство <literal>pg_default</literal> используется по умолчанию для баз данных <literal>template1</literal> и <literal>template0</literal> (в свою очередь, также является пространством по умолчанию для других баз данных, пока не будет явно указано иное в выражении <literal>TABLESPACE</literal> команды <command>CREATE DATABASE</command>).</para>

  <para>После создания, табличное пространство можно использовать в рамках любой базы данных, при условии, что у пользователя имеются необходимые права. Это означает, что табличное пространство невозможно удалить до тех пор, пока не будут удалены все объекты баз данных, использующих это пространство.</para>

  <para>Для удаления пустого табличного пространства используйте команду <xref linkend="sql-droptablespace"/>.</para>

  <para>Чтобы получить список табличных пространств можно сделать запрос к системному каталогу <link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>, например, <synopsis>
SELECT spcname FROM pg_tablespace;
</synopsis> Метакоманда <literal>\db</literal> утилиты <xref linkend="app-psql"/> также позволяет отобразить список существующих табличных пространств.</para>

  <para><productname>&productname;</productname> использует символические ссылки для упрощения реализации табличных пространств. Это означает, что табличные пространства могут использоваться <emphasis>только</emphasis> в системах, поддерживающих символические ссылки.</para>

  <para>Каталог <filename>$PGDATA/pg_tblspc</filename> содержит символические ссылки, которые указывают на внешние табличные пространства кластера. Хоть и не рекомендуется, но возможно регулировать табличные пространства вручную, переопределяя эти ссылки. Ни при каких обстоятельствах эти операции нельзя проводить, пока запущен сервер баз данных. Обратите внимание, что в версии PostgreSQL 9.1 и более ранних также необходимо обновить информацию в <structname>pg_tablespace</structname> о новых расположениях. (Если это не сделать, то <literal>pg_dump</literal> будет продолжать выводить старые расположения табличных пространств.)</para>

 </sect1>
</chapter>
