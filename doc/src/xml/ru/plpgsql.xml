<!-- doc/src/xml/plpgsql.xml -->

<chapter id="plpgsql">
  <title><application>PL/pgSQL</application> — процедурный язык <acronym>SQL</acronym></title>

 <indexterm zone="plpgsql"><primary>PL/pgSQL</primary></indexterm>

 <sect1 id="plpgsql-overview">
  <title>Обзор</title>

 <para><application>PL/pgSQL</application> это процедурный язык для СУБД <productname>&productname;</productname>. Целью проектирования <application>PL/pgSQL</application> было создание загружаемого процедурного языка, который: <itemizedlist>
     <listitem>
      <para>используется для создания функций и триггеров,</para>
     </listitem>
     <listitem>
      <para>добавляет управляющие структуры к языку <acronym>SQL</acronym>,</para>
     </listitem>
     <listitem>
      <para>может выполнять сложные вычисления,</para>
     </listitem>
     <listitem>
      <para>наследует все пользовательские типы, функции и операторы,</para>
     </listitem>
     <listitem>
      <para>может быть определён как доверенный язык,</para>
     </listitem>
     <listitem>
      <para>прост в использовании.</para>
     </listitem>
    </itemizedlist></para>

   <para>Функции <application>PL/pgSQL</application> могут использоваться везде, где допустимы встроенные функции. Например, можно создать функции со сложными вычислениями и условной логикой, а затем использовать их при определении операторов или в индексных выражениях.</para>

   <para>В версии <productname>PostgreSQL</productname> 9.0 и выше, <application>PL/pgSQL</application> устанавливается по умолчанию. Тем не менее, это по-прежнему загружаемый модуль и администраторы, особо заботящиеся о безопасности, могут удалить его при необходимости.</para>

  <sect2 id="plpgsql-advantages">
   <title>Преимущества использования <application>PL/pgSQL</application></title>

    <para><productname>&productname;</productname> и большинство других СУБД используют <acronym>SQL</acronym> в качестве языка запросов. <acronym>SQL</acronym> хорошо переносим и прост в изучении. Однако каждый оператор <acronym>SQL</acronym> выполняется индивидуально на сервере базы данных.</para>

    <para>Это значит, что ваше клиентское приложение должно каждый запрос отправлять на сервер, ждать пока он будет обработан, получать результат, делать некоторые вычисления, затем отправлять последующие запросы на сервер. Всё это требует межпроцессного взаимодействия, а также несёт нагрузку на сеть, если клиент и сервер базы данных расположены на разных компьютерах.</para>

    <para><application>PL/pgSQL</application> позволяет сгруппировать блок вычислений и последовательность запросов <emphasis>внутри</emphasis> сервера базы данных, таким образом, мы получаем силу процедурного языка и простоту использования <acronym>SQL</acronym> при значительной экономии накладных расходов на клиент-серверное взаимодействие.</para>
    <itemizedlist>

     <listitem><para>Исключаются дополнительные обращения между клиентом и сервером</para></listitem>

     <listitem><para>Промежуточные ненужные результаты не передаются между сервером и клиентом</para></listitem>

     <listitem><para>Есть возможность избежать многочисленных разборов одного запроса</para></listitem>

    </itemizedlist>
    <para>В результате это приводит к значительному увеличению производительности по сравнению с приложением, которое не использует хранимых функций.</para>

    <para>Кроме того, <application>PL/pgSQL</application> позволяет использовать все типы данных, операторы и функции <acronym>SQL</acronym>.</para>
  </sect2>

  <sect2 id="plpgsql-args-results">
   <title>Поддерживаемые типы данных аргументов и возвращаемых значений</title>

    <para>Функции на <application>PL/pgSQL</application> могут принимать в качестве аргументов все поддерживаемые сервером скалярные типы данных или массивы и возвращать в качестве результата любой из этих типов. Они могут принимать и возвращать именованные составные типы (строковый тип). Также есть возможность объявить функцию на <application>PL/pgSQL</application>, возвращающую <type>record</type>, это означает, что результатом является строковый тип, чьи столбцы будут определены в спецификации вызывающего запроса, как описано в <xref remap="6" linkend="queries-tablefunctions"/>.</para>

    <para>Использование маркера <literal>VARIADIC</literal> позволяет объявлять функции на <application>PL/pgSQL</application> с переменным числом аргументов. Это работает точно так же, как и для функций на SQL, как описано в <xref remap="6" linkend="xfunc-sql-variadic-functions"/>.</para>

    <para>Функции на <application>PL/pgSQL</application> могут принимать и возвращать полиморфные типы <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type> и <type>anyrange</type>. В таких случаях фактические типы данных могут меняться от вызова к вызову, как описано в <xref linkend="extend-types-polymorphic"/>. Пример показан в <xref remap="6" linkend="plpgsql-declaration-parameters"/>.</para>

    <para>Функции на <application>PL/pgSQL</application> могут возвращать <quote>множества</quote> (или таблицы) любого типа, которые могут быть возвращены в виде одного объекта. Такие функции генерируют вывод, выполняя команду <command>RETURN NEXT</command> для каждого элемента результирующего набора или <command>RETURN QUERY</command> для вывода результата запроса.</para>

    <para>Наконец, при отсутствии полезного возвращаемого значения функция на <application>PL/pgSQL</application> может возвращать <type>void</type>.</para>

    <para>Функции на <application>PL/pgSQL</application> можно объявить с выходными параметрами вместо явного задания типа возвращаемого значения. Это не добавляет никаких фундаментальных возможностей языку, но часто бывает удобно, особенно для возвращения нескольких значений. Нотация <literal>RETURNS TABLE</literal> может использоваться вместо <literal>RETURNS SETOF</literal>.</para>

    <para>Конкретные примеры рассматриваются в <xref remap="6" linkend="plpgsql-declaration-parameters"/> и <xref remap="6" linkend="plpgsql-statements-returning"/>.</para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
  <title>Структура <application>PL/pgSQL</application></title>

  <para>Функции, написанные на <application>PL/pgSQL</application>, определяются на сервере командами <xref linkend="sql-createfunction"/>. Такая команда обычно выглядит, например, так: <programlisting>CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS '<replaceable>тело функции</replaceable>'
LANGUAGE plpgsql;</programlisting> Если рассматривать <command>CREATE FUNCTION</command>, тело функции представляет собой просто текстовую строку. Часто для написания тела функции удобнее заключать эту строку в доллары (см. <xref remap="4" linkend="sql-syntax-dollar-quoting"/>), а не в обычные апострофы. Если не применять заключение в доллары, все апострофы или обратные косые черты в теле функции придётся экранировать, дублируя их. Почти во всех примерах в этой главе тело функций заключается в доллары.</para>

  <para><application>PL/pgSQL</application> это блочно-структурированный язык. Текст тела функции должен быть <firstterm>блоком</firstterm>. Структура блока: <synopsis>
<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>объявления</replaceable> </optional>
BEGIN
    <replaceable>операторы</replaceable>
END <optional> <replaceable>метка</replaceable> </optional>;
</synopsis></para>

    <para>Каждое объявление и каждый оператор в блоке должны завершаться символом ";"(точка с запятой). Блок, вложенный в другой блок, должен иметь точку с запятой после <literal>END</literal>, как показано выше. Однако финальный <literal>END</literal>, завершающий тело функции, не требует точки с запятой.</para>

    <tip>
     <para>Распространённой ошибкой является добавление точки с запятой сразу после <literal>BEGIN</literal>. Это неправильно и приведёт к синтаксической ошибке.</para>
    </tip>

    <para><replaceable>Метка</replaceable> требуется только тогда, когда нужно идентифицировать блок в операторе <literal>EXIT</literal>, или дополнить имена переменных, объявленных в этом блоке. Если метка указана после <literal>END</literal>, то она должна совпадать с меткой в начале блока.</para>

    <para>Ключевые слова не чувствительны к регистру символов. Как и в обычных SQL-командах, идентификаторы неявно преобразуются к нижнему регистру, если они не взяты в двойные кавычки.</para>

    <para>Комментарии в <application>PL/pgSQL</application> коде работают так же, как и в обычном SQL. Двойное тире (<literal>--</literal>) начинает комментарий, который завершается в конце строки. Блочный комментарий начинается с <literal>/*</literal> и завершается <literal>*/</literal>. Блочные комментарии могут быть вложенными.</para>

    <para>Любой оператор в выполняемой секции блока может быть <firstterm>вложенным блоком</firstterm>. Вложенные блоки используются для логической группировки нескольких операторов или локализации области действия переменных для группы операторов. Во время выполнения вложенного блока переменные, объявленные в нём, скрывают переменные внешних блоков с такими же именами. Чтобы получить доступ к внешним переменным, нужно дополнить их имена меткой блока. Например: <programlisting>CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 30
    quantity := 50;
    --
    -- Создаем вложенный блок
    --
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 80
        RAISE NOTICE 'Во внешнем блоке quantity = %', outerblock.quantity;  -- Выводится 50
    END;

    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;</programlisting></para>

    <note>
     <para>Существует скрытый <quote>внешний блок</quote>, окружающий тело каждой функции на <application>PL/pgSQL</application>. Этот блок содержит объявления параметров функции (если они есть), а также некоторые специальные переменные, такие как <literal>FOUND</literal> (см. <xref remap="4" linkend="plpgsql-statements-diagnostics"/>). Этот блок имеет метку, совпадающую с именем функции, таким образом, параметры и специальные переменные могут быть дополнены именем функции.</para>
    </note>

    <para>Важно не путать использование <command>BEGIN</command>/<command>END</command> для группировки операторов в <application>PL/pgSQL</application> с одноименными SQL-командами для управления транзакциями. <command>BEGIN</command>/<command>END</command> в <application>PL/pgSQL</application> служат только для группировки предложений; они не начинают и не заканчивают транзакции. Функции и триггерные процедуры всегда выполняются в рамках транзакции, начатой во внешнем запросе — они не могут начать или завершить эту транзакцию, так как у них внутри нет контекста для выполнения таких действий. Однако блок содержащий секцию <literal>EXCEPTION</literal> создаёт вложенную транзакцию, которая может быть отменена, не затрагивая внешней транзакции. Подробнее это описано в <xref remap="6" linkend="plpgsql-error-trapping"/>.</para>
  </sect1>

  <sect1 id="plpgsql-declarations">
    <title>Объявления</title>

    <para>Все переменные, используемые в блоке, должны быть определены в секции объявления. (За исключением переменной-счётчика цикла <literal>FOR</literal>, которая объявляется автоматически. Для цикла по диапазону чисел автоматически объявляется целочисленная переменная, а для цикла по результатам курсора - переменная типа <literal>record</literal>.)</para>

    <para>Переменные <application>PL/pgSQL</application> могут иметь любой тип данных SQL, такой как <type>integer</type>, <type>varchar</type>, <type>char</type>.</para>

    <para>Примеры объявления переменных: <programlisting>user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;</programlisting></para>

    <para>Общий синтаксис объявления переменной: <synopsis>
<replaceable>имя</replaceable> <optional> CONSTANT </optional> <replaceable>тип</replaceable> <optional> COLLATE <replaceable>имя_правила_сортировки</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>выражение</replaceable> </optional>;
</synopsis> Предложение <literal>DEFAULT</literal>, если присутствует, задаёт начальное значение, которое присваивается переменной при входе в блок. Если отсутствует, то переменная инициализируется <acronym>SQL</acronym>-значением <literal>NULL</literal>. Указание <literal>CONSTANT</literal> предотвращает изменение значения переменной после инициализации, таким образом, значение остаётся постоянным в течение всего блока. Параметр <literal>COLLATE</literal> определяет правило сортировки, которое будет использоваться для этой переменной (см. <xref remap="4" linkend="plpgsql-declaration-collation"/>). Если указано <literal>NOT NULL</literal>, то попытка присвоить <literal>NULL</literal> во время выполнения приведёт к ошибке. Все переменные, объявленные как <literal>NOT NULL</literal>, должны иметь непустые значения по умолчанию. Можно использовать знак равенства (<literal>=</literal>) вместо совместимого с PL/SQL <literal>:=</literal>.</para>

     <para>Значение по умолчанию вычисляется и присваивается переменной каждый раз при входе в блок (не только при первом вызове функции). Так, например, если переменная типа <type>timestamp</type> имеет функцию <literal>now()</literal> в качестве значения по умолчанию, это приведёт к тому, что переменная всегда будет содержать время текущего вызова функции, а не время, когда функция была предварительно скомпилирована.</para>

     <para>Примеры: <programlisting>quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;</programlisting></para>

    <sect2 id="plpgsql-declaration-parameters">
     <title>Объявление параметров функции</title>

     <para>Переданные в функцию параметры именуются идентификаторами <literal>$1</literal>, <literal>$2</literal> и т. д. Дополнительно, для улучшения читаемости, можно объявить псевдонимы для параметров <literal>$<replaceable>n</replaceable></literal>. Либо псевдоним, либо цифровой идентификатор используются для обозначения параметра.</para>

     <para>Создать псевдоним можно двумя способами. Предпочтительный способ это дать имя параметру в команде <command>CREATE FUNCTION</command>, например: <programlisting>CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</programlisting> Другой способ это явное объявление псевдонима при помощи синтаксиса: <synopsis>
<replaceable>имя</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis> Предыдущий пример для этого стиля выглядит так: <programlisting>CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</programlisting></para>

    <note>
     <para>Эти два примера не полностью эквивалентны. В первом случае, на <literal>subtotal</literal> можно ссылаться как <literal>sales_tax.subtotal</literal>, а во втором случае такая ссылка невозможна. (Если бы к внутреннему блоку была добавлена метка, то <literal>subtotal</literal> можно было бы дополнить этой меткой.)</para>
    </note>

     <para>Ещё несколько примеров: <programlisting>CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- здесь вычисления, использующие v_string и index
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;</programlisting></para>

     <para>Когда функция на <application>PL/pgSQL</application> объявляется с выходными параметрами, им выдаются цифровые идентификаторы <literal>$<replaceable>n</replaceable></literal> и для них можно создавать псевдонимы точно таким же способом, как и для обычных входных параметров. Выходной параметр это фактически переменная, стартующая с NULL и которой присваивается значение во время выполнения функции. Возвращается последнее присвоенное значение. Например, функция sales_tax может быть переписана так: <programlisting>CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</programlisting> Обратите внимание, что мы опустили <literal>RETURNS real</literal> &mdash; хотя можно было и включить, но это было бы излишним.</para>

     <para>Выходные параметры наиболее полезны для возвращения нескольких значений. Простейший пример: <programlisting>CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;</programlisting> Как обсуждалось в <xref remap="6" linkend="xfunc-output-parameters"/>, здесь фактически создаётся анонимный тип <literal>record</literal> для возвращения результата функции. Если используется предложение <literal>RETURNS</literal>, то оно должна выглядеть как <literal>RETURNS record</literal>.</para>

     <para>Есть ещё способ объявить функцию на <application>PL/pgSQL</application> с использованием <literal>RETURNS TABLE</literal>, например: <programlisting>CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;</programlisting> Это в точности соответствует объявлению одного или нескольких параметров <literal>OUT</literal> и указанию <literal>RETURNS SETOF <replaceable>некий_тип</replaceable></literal>.</para>

     <para>Для функции на <application>PL/pgSQL</application>, возвращающей полиморфный тип (<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>, <type>anyrange</type>), создаётся специальный параметр <literal>$0</literal>. Его тип данных соответствует типу, фактически возвращаемому функцией, и который устанавливается на основании фактических типов входных параметров (см. <xref remap="4" linkend="extend-types-polymorphic"/>). Это позволяет функции получить доступ к фактически возвращаемому типу данных, как показано в <xref remap="6" linkend="plpgsql-declaration-type"/>. Параметр <literal>$0</literal> инициализируется в <literal>NULL</literal> и его можно изменять внутри функции. Таким образом, его можно использовать для хранения возвращаемого значения, хотя это необязательно. Параметру <literal>$0</literal> можно дать псевдоним. В следующем примере функция работает с любым типом данных, поддерживающим оператор <literal>+</literal>: <programlisting>CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;</programlisting></para>

     <para>Такой же эффект получается при объявлении одного или нескольких выходных параметров полиморфного типа. При этом <literal>$0</literal> не создаётся; выходные параметры сами используются для этой цели. Например: <programlisting>CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;</programlisting></para>
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
   <title><literal>ALIAS</literal></title>

<synopsis><replaceable>новое_имя</replaceable> ALIAS FOR <replaceable>старое_имя</replaceable>;</synopsis>

   <para>Синтаксис <literal>ALIAS</literal> более общий, чем предполагалось в предыдущем разделе: псевдонимы можно объявлять для любых переменных, а не только для параметров функции. Основная практическая польза в том, чтобы назначить другие имена переменным с предопределёнными названиями, таким как <varname>NEW</varname> или <varname>OLD</varname> в триггерной процедуре.</para>

   <para>Примеры: <programlisting>DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;</programlisting></para>

   <para>Поскольку <literal>ALIAS</literal> даёт два различных способа именования одних и тех же объектов, то его неограниченное использование может привести к путанице. Лучше всего использовать <literal>ALIAS</literal> для переименования предопределённых имён.</para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
   <title>Наследование типов данных</title>

<synopsis><replaceable>переменная</replaceable>%TYPE</synopsis>

   <para>Конструкция <literal>%TYPE</literal> предоставляет тип данных переменной или столбца таблицы. Её можно использовать для объявления переменных, содержащих значения из базы данных. Например, для объявления переменной с таким же типом, как и столбец <literal>user_id</literal> в таблице <literal>users</literal> нужно написать: <programlisting>user_id users.user_id%TYPE;</programlisting></para>

   <para>Используя <literal>%TYPE</literal>, не нужно знать тип данных структуры, на которую вы ссылаетесь. И самое главное, если в будущем тип данных изменится (например: тип данных для <literal>user_id</literal> поменяется с <type>integer</type> на <type>real</type>), то вам может не понадобиться изменять определение функции.</para>

   <para>Использование <literal>%TYPE</literal> особенно полезно в полиморфных функциях, поскольку типы данных, необходимые для внутренних переменных, могут меняться от одного вызова к другому. Соответствующие переменные могут быть созданы с применением <literal>%TYPE</literal> к аргументам и возвращаемому значению функции.</para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
     <title>Типы кортежей</title>

<synopsis><replaceable>имя</replaceable> <replaceable>имя_таблицы</replaceable><literal>%ROWTYPE</literal>;
<replaceable>имя</replaceable> <replaceable>имя_составного_типа</replaceable>;</synopsis>

   <para>Переменная составного типа называется <firstterm>строковой</firstterm> переменной (или переменной <firstterm>типа строки</firstterm>). Значением такой переменной может быть целая строка, полученная в результате выполнения запроса <command>SELECT</command> или <command>FOR</command>, при условии, что набор столбцов запроса соответствует заявленному типу переменной. Доступ к отдельным значениям полей строковой переменной осуществляется, как обычно, через точку, например <literal>rowvar.field</literal>.</para>

   <para>Строковая переменная может быть объявлена с таким же типом, как и строка в существующей таблице или представлении, используя нотацию <replaceable>имя_таблицы</replaceable><literal>%ROWTYPE</literal>; или с именем составного типа. (Поскольку каждая таблица имеет соответствующий составной тип с таким же именем, то на самом деле в <productname>&productname;</productname> не имеет значения, пишете ли вы <literal>%ROWTYPE</literal> или нет. Но использование <literal>%ROWTYPE</literal> более переносимо.)</para>

   <para>Параметры функции могут быть составного типа (строки таблицы). В этом случае соответствующий идентификатор <literal>$<replaceable>n</replaceable></literal> будет строковой переменной, поля которой можно выбирать, например <literal>$1.user_id</literal>.</para>

   <para>Только определённые пользователем столбцы таблицы доступны в переменной строкового типа, но не OID или другие системные столбцы (потому что это может быть строка представления). Поля строкового типа наследуют размер и точность от типов данных столбцов таблицы, таких как <type>char(<replaceable>n</replaceable>)</type>.</para>

   <para>Ниже приведён пример использования составных типов. <structname>table1</structname> и <structname>table2</structname> это существующие таблицы, имеющие, по меньшей мере, перечисленные столбцы: <programlisting>CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;</programlisting></para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
   <title>Тип <type>record</type></title>

<synopsis><replaceable>имя</replaceable> RECORD;</synopsis>

   <para>Переменные типа <type>record</type> похожи на переменные строкового типа, но они не имеют предопределённой структуры. Они приобретают фактическую структуру от строки, которая им присваивается командами <command>SELECT</command> или <command>FOR</command>. Структура переменной типа <type>record</type> может меняться каждый раз при присвоении значения. Следствием этого является то, что пока значение не присвоено первый раз, переменная типа <type>record</type> не имеет структуры и любая попытка получить доступ к отдельному полю приведёт к ошибке во время исполнения.</para>

   <para>Обратите внимание, что <literal>RECORD</literal> это не подлинный тип данных, а только лишь заполнитель. Также следует понимать, что функция на <application>PL/pgSQL</application>, имеющая тип возвращаемого значения <type>record</type>, это не то же самое, что и переменная типа <type>record</type>, хотя такая функция может использовать переменную типа <type>record</type> для хранения своего результата. В обоих случаях фактическая структура строки неизвестна во время создания функции, но для функции, возвращающей <type>record</type>, фактическая структура определяется во время разбора вызывающего запроса, в то время как переменная типа <type>record</type> может менять свою структуру на лету.</para>
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
   <title>Упорядочение переменных <application>PL/pgSQL</application></title>

   <indexterm><primary>collation</primary> <secondary>in PL/pgSQL</secondary></indexterm>

   <para>Когда функция на <application>PL/pgSQL</application> имеет один или несколько параметров сортируемых типов данных, правило сортировки определяется при каждом вызове функции в зависимости от правил сортировки фактических аргументов, как описано в <xref remap="6" linkend="collation"/>. Если оно определено успешно (т. е. среди аргументов нет конфликтов между неявными правилами сортировки), то все соответствующие параметры неявно трактуются как имеющее это правило сортировки. Внутри функции это будет влиять на поведение операторов, зависящих от используемого правила сортировки. Рассмотрим пример: <programlisting>CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;</programlisting> В первом случае <function>less_than</function> будет использовать для сравнения общее правило сортировки для <structfield>text_field_1</structfield> и <structfield>text_field_2</structfield>, в то время как во втором случае будет использоваться правило <literal>C</literal>.</para>

   <para>Кроме того, определённое для вызова функции правило сортировки также будет использоваться для любых локальных переменных соответствующего типа. Таким образом, функция не станет работать по-другому, если её переписать так: <programlisting>CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;</programlisting></para>

   <para>Если параметров с типами данных, поддерживающими сортировку, нет, или для параметров невозможно определить общее правило сортировки, тогда для параметров и локальных переменных применяются правила, принятые для их типа данных по умолчанию (которые обычно совпадают с правилами сортировки по умолчанию, принятыми для базы данных, но могут отличаться для переменных доменных типов).</para>

   <para>Локальная переменная может иметь правило сортировки, отличное от правила по умолчанию. Для этого используется параметр <literal>COLLATE</literal> в объявлении переменной, например: <programlisting>DECLARE
    local_a text COLLATE "en_US";</programlisting> Этот параметр переопределяет правило сортировки, которое получила бы переменная в соответствии с вышеуказанными правилами.</para>

   <para>И, конечно же, можно явно указывать параметр <literal>COLLATE</literal> для конкретных операций внутри функции, если к ним требуется применить конкретное правило сортировки. Например: <programlisting>CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;</programlisting> Как и в обычной SQL-команде, это переопределяет правила сортировки, связанные с полями таблицы, параметрами и локальными переменными, которые используются в данном выражении.</para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
  <title>Выражения</title>

    <para>Все выражения, используемые в операторах <application>PL/pgSQL</application>, обрабатываются основным исполнителем <acronym>SQL</acronym>-сервера. Например, для вычисления такого выражения: <synopsis>
IF <replaceable>выражение</replaceable> THEN ...
</synopsis> <application>PL/pgSQL</application> отправит следующий запрос исполнителю SQL: <synopsis>
SELECT <replaceable>выражение</replaceable>
</synopsis> При формировании команды <command>SELECT</command> все вхождения имён переменных <application>PL/pgSQL</application> заменяются параметрами, как подробно описано в <xref remap="6" linkend="plpgsql-var-subst"/>. Это позволяет один раз подготовить план выполнения команды <command>SELECT</command> и повторно использовать его в последующих вычислениях с различными значениями переменных. Таким образом, при первом использовании выражения, по сути происходит выполнение команды <command>PREPARE</command>. Например, если мы объявили две целочисленные переменные <literal>x</literal> и <literal>y</literal>, и написали: <programlisting>IF x &lt; y THEN ...</programlisting> то, что реально происходит за сценой, эквивалентно: <programlisting>PREPARE <replaceable>имя_оператора</replaceable>(integer, integer) AS SELECT $1 &lt; $2;</programlisting> и затем, эта подготовленная команда исполняется (<command>EXECUTE</command>) для каждого оператора <command>IF</command> с текущими значениями переменных <application>PL/pgSQL</application>, переданных как значения параметров. Обычно эти детали не важны для пользователей <application>PL/pgSQL</application>, но их полезно знать при диагностировании проблем. Более подробно об этом рассказывается в <xref remap="6" linkend="plpgsql-plan-caching"/>.</para>
  </sect1>

  <sect1 id="plpgsql-statements">
  <title>Основные операторы</title>

   <para>В этом и последующих разделах описаны все типы операторов, которые понимает <application>PL/pgSQL</application>. Все, что не признается в качестве одного из этих типов операторов, считается командой SQL и отправляется для исполнения в основную машину базы данных, как описано в <xref remap="6" linkend="plpgsql-statements-sql-noresult"/> и <xref remap="6" linkend="plpgsql-statements-sql-onerow"/>.</para>

   <sect2 id="plpgsql-statements-assignment">
    <title>Присваивания</title>

    <para>Присвоение значения переменной <application>PL/pgSQL</application> записывается в виде: <synopsis>
<replaceable>переменная</replaceable> { := | = } <replaceable>выражение</replaceable>;
</synopsis> Как описывалось ранее, выражение в таком операторе вычисляется с помощью SQL-команды <command>SELECT</command>, посылаемой в основную машину базы данных. Выражение должно получить одно значение (возможно, значение строки, если переменная строкового типа или типа <type>record</type>). Целевая переменная может быть простой переменной (возможно, дополненной именем блока), полем в переменной строкового типа или записи; или элементом массива, который является простой переменной или полем. Для присвоения можно использовать знак равенства (<literal>=</literal>) вместо совместимого с PL/SQL <literal>:=</literal>.</para>

    <para>Если тип данных результата выражения не соответствует типу данных переменной, это значение будет преобразовано к нужному типу с использованием приведения присваивания (см. <xref remap="4" linkend="typeconv-query"/>). В случае отсутствия приведения присваивания для этой пары типов, интерпретатор <application>PL/pgSQL</application> попытается преобразовать значение результата через текстовый формат, то есть применив функцию вывода типа результата, а за ней функцию ввода типа переменной. Заметьте, что при этом функция ввода может выдавать ошибки времени выполнения, если не воспримет строковое представление значения результата.</para>

    <para>Примеры: <programlisting>tax := subtotal * 0.06;
my_record.user_id := 20;</programlisting></para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-noresult">
    <title>Выполнение команды, не возвращающей результат</title>

    <para>В функции на <application>PL/pgSQL</application> можно выполнить любую команду SQL, не возвращающую строк, просто написав эту команду (например, <command>INSERT</command> без предложения <literal>RETURNING</literal>).</para>

    <para>Имя любой переменной <application>PL/pgSQL</application> в тексте команды рассматривается как параметр, а затем текущее значение переменной подставляется в качестве значения параметра во время выполнения. Это в точности совпадает с описанной ранее обработкой для выражений; за подробностями обратитесь к <xref remap="3" linkend="plpgsql-var-subst"/>.</para>

    <para>При выполнении SQL-команды таким образом, <application>PL/pgSQL</application> может кешировать и повторно использовать план выполнения команды, как обсуждается в <xref remap="6" linkend="plpgsql-plan-caching"/>.</para>

    <para>Иногда бывает полезно вычислить значение выражения или запроса <command>SELECT</command>, но отказаться от результата, например, при вызове функции, у которой есть побочные эффекты, но нет полезного результата. Для этого в <application>PL/pgSQL</application>, используется оператор <command>PERFORM</command>: <synopsis>
PERFORM <replaceable>запрос</replaceable>;
</synopsis> Эта команда выполняет <replaceable>запрос</replaceable> и отбрасывает результат. <replaceable>Запросы</replaceable> пишутся таким же образом, как и в команде SQL <command>SELECT</command>, но ключевое слово <command>SELECT</command> заменяется на <command>PERFORM</command>. Для запросов <command>WITH</command> после <command>PERFORM</command> нужно поместить запрос в скобки. (В этом случае запрос может вернуть только одну строку.) Переменные <application>PL/pgSQL</application> будут подставлены в запрос так же, как и в команду, не возвращающую результат, план запроса также кешируется. Кроме того, специальная переменная <literal>FOUND</literal> устанавливается в истину, если запрос возвращает, по крайней мере, одну строку, или ложь, если не возвращает ни одной строки (см. <xref remap="4" linkend="plpgsql-statements-diagnostics"/>).</para>

    <note>
     <para>Можно предположить, что такой же результат получается непосредственно командой <command>SELECT</command>, но в настоящее время использование <command>PERFORM</command> является единственным способом. Команда SQL, которая может возвращать строки, например <command>SELECT</command>, будет отклонена с ошибкой, если не имеет предложения <literal>INTO</literal>, как описано в следующем разделе.</para>
    </note>

    <para>Пример: <programlisting>PERFORM create_mv('cs_session_page_requests_mv', my_query);</programlisting></para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
    <title>Выполнение запроса, возвращающего одну строку</title>

    <indexterm zone="plpgsql-statements-sql-onerow"><primary>SELECT INTO</primary> <secondary>in PL/pgSQL</secondary></indexterm>

    <indexterm zone="plpgsql-statements-sql-onerow"><primary>RETURNING INTO</primary> <secondary>in PL/pgSQL</secondary></indexterm>

    <para>Результат SQL-команды, возвращающей одну строку (возможно из нескольких столбцов), может быть присвоен переменной типа <type>record</type>, переменной строкового типа или списку скалярных переменных. Для этого нужно к основной команде SQL добавить предложение <literal>INTO</literal>. Так, например: <synopsis>
SELECT <replaceable>выражения_select</replaceable> INTO <optional>STRICT</optional> <replaceable>цель</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>выражения</replaceable> INTO <optional>STRICT</optional> <replaceable>цель</replaceable>;
UPDATE ... RETURNING <replaceable>выражения</replaceable> INTO <optional>STRICT</optional> <replaceable>цель</replaceable>;
DELETE ... RETURNING <replaceable>выражения</replaceable> INTO <optional>STRICT</optional> <replaceable>цель</replaceable>;
</synopsis> где <replaceable>цель</replaceable> может быть переменной типа <type>record</type>, строковой переменной или разделённым запятыми списком скалярных переменных, полей записи/строки. Переменные <application>PL/pgSQL</application> подставляются в оставшуюся часть запроса, план выполнения кешируется, так же, как было описано выше для команд, не возвращающих строки. Это работает для команд <command>SELECT</command>, <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> с предложением <literal>RETURNING</literal> и утилит, возвращающих результат в виде набора строк (таких, как <command>EXPLAIN</command>). За исключением предложения <literal>INTO</literal>, это те же SQL-команды, как их можно написать вне <application>PL/pgSQL</application>.</para>

   <tip>
    <para>Обратите внимание, что данная интерпретация <command>SELECT</command> с <literal>INTO</literal> полностью отличается от <productname>&productname;</productname> команды <command>SELECT INTO</command>, где в <literal>INTO</literal> указывается вновь создаваемая таблица. Если вы хотите в функции на <application>PL/pgSQL</application> создать таблицу, основанную на результате команды <command>SELECT</command>, используйте синтаксис <command>CREATE TABLE ... AS SELECT</command>.</para>
   </tip>

    <para>Если результат запроса присваивается переменной строкового типа или списку переменных, то они должны в точности соответствовать по количеству и типам данных столбцам результата, иначе произойдёт ошибка во время выполнения. Если используется переменная типа <type>record</type>, то она автоматически приводится к строковому типу результата запроса.</para>

    <para>Предложение INTO может появиться практически в любом месте SQL-команды. Обычно его записывают непосредственно перед или сразу после списка <replaceable>выражения_select</replaceable> в <command>SELECT</command> или в конце команды для команд других типов. Рекомендуется следовать этому соглашению на случай, если правила разбора <application>PL/pgSQL</application> ужесточатся в будущих версиях.</para>

    <para>Если указание <literal>STRICT</literal> отсутствует в предложении <literal>INTO</literal>, то <replaceable>цели</replaceable> присваивается первая строка, возвращённая запросом; или NULL, если запрос не вернул строк. (Заметим, что понятие <quote>первая строка</quote> определяется неоднозначно без <literal>ORDER BY</literal>.) Все остальные строки результата после первой отбрасываются. Можно проверить специальную переменную <literal>FOUND</literal> (см. <xref remap="4" linkend="plpgsql-statements-diagnostics"/>), чтобы определить, была ли возвращена запись: <programlisting>SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'Сотрудник % не найден', myname;
END IF;</programlisting> Если добавлено указание <literal>STRICT</literal>, то запрос должен вернуть ровно одну строку или произойдёт ошибка во время выполнения: либо <literal>NO_DATA_FOUND</literal> (нет строк), либо <literal>TOO_MANY_ROWS</literal> (более одной строки). Можно использовать секцию исключений в блоке для обработки ошибок, например: <programlisting>BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'Сотрудник % не найден', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Сотрудник % уже существует', myname;
END;</programlisting> После успешного выполнения команды с указанием <literal>STRICT</literal>, значение переменной <literal>FOUND</literal> всегда устанавливается в истину.</para>

    <para>Для <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> с <literal>RETURNING</literal>, <application>PL/pgSQL</application> возвращает ошибку, если выбрано более одной строки, даже в том случае, когда указание <literal>STRICT</literal> отсутствует. Так происходит потому, что у этих команд нет возможности, типа <literal>ORDER BY</literal>, указать какая из задействованных строк должна быть возвращена.</para>

    <para>Если для функции включён режим <literal>print_strict_params</literal>, то при возникновении ошибки, связанной с нарушением условия <literal>STRICT</literal>, в детальную (<literal>DETAIL</literal>) часть сообщения об ошибке будет включена информация о параметрах, переданных запросу. Изменить значение <literal>print_strict_params</literal> можно установкой параметра <varname>plpgsql.print_strict_params</varname>. Но это повлияет только на функции, скомпилированные после изменения. Для конкретной функции можно использовать указание компилятора, например: <programlisting>CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
    userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END
$$ LANGUAGE plpgsql;</programlisting> В случае сбоя будет сформировано примерно такое сообщение об ошибке <programlisting>ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement</programlisting></para>

    <note>
     <para>С указанием <literal>STRICT</literal> поведение <command>SELECT INTO</command> и связанных операторов соответствует принятому в Oracle PL/SQL.</para>
    </note>

    <para>Как действовать в случаях, когда требуется обработать несколько строк результата, описано в <xref remap="6" linkend="plpgsql-records-iterating"/>.</para>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
    <title>Выполнение динамически формируемых команд</title>

    <para>Часто требуется динамически формировать команды внутри функций на <application>PL/pgSQL</application>, то есть такие команды, в которых при каждом выполнении могут использоваться разные таблицы или типы данных. Обычно <application>PL/pgSQL</application> кеширует планы выполнения (как описано в <xref remap="6" linkend="plpgsql-plan-caching"/>), но в случае с динамическими командами это не будет работать. Для исполнения динамических команд предусмотрен оператор <command>EXECUTE</command>: <synopsis>
EXECUTE <replaceable class="command">строка-команды</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>цель</replaceable> </optional> <optional> USING <replaceable>выражение</replaceable> <optional>, ... </optional> </optional>;
</synopsis> где <replaceable>строка-команды</replaceable> это выражение, формирующее строку (типа <type>text</type>) с текстом команды, которую нужно выполнить. Необязательная <replaceable>цель</replaceable> — это переменная-запись, переменная-кортеж или разделённый запятыми список простых переменных и полей записи/кортежа, куда будут помещены результаты команды. Необязательные выражения в <literal>USING</literal> формируют значения, которые будут вставлены в команду.</para>

    <para>В сформированном тексте команды замена имён переменных <application>PL/pgSQL</application> на их значения проводиться не будет. Все необходимые значения переменных должны быть вставлены в командную строку при её построении, либо нужно использовать параметры, как описано ниже.</para>

    <para>Также, нет никакого плана кеширования для команд, выполняемых с помощью <command>EXECUTE</command>. Вместо этого план создаётся каждый раз при выполнении. Таким образом, строка команды может динамически создаваться внутри функции для выполнения действий с различными таблицами и столбцами.</para>

    <para>Предложение <literal>INTO</literal> указывает, куда должны быть помещены результаты SQL-команды, возвращающей строки. Если используется переменная строкового типа или список переменных, то они должны в точности соответствовать структуре результата запроса (когда используется переменная типа <type>record</type>, она автоматически приводится к строковому типу результата запроса). Если возвращается несколько строк, то только первая будет присвоена переменной(ым) в <literal>INTO</literal>. Если не возвращается ни одной строки, то присваивается NULL. Без предложения <literal>INTO</literal> результаты запроса отбрасываются.</para>

    <para>С указанием <literal>STRICT</literal> запрос должен вернуть ровно одну строку, иначе выдаётся сообщение об ошибке.</para>

    <para>В тексте команды можно использовать значения параметров, ссылки на параметры обозначаются как <literal>$1</literal>, <literal>$2</literal> и т. д. Эти символы указывают на значения, находящиеся в предложении <literal>USING</literal>. Такой метод зачастую предпочтительнее, чем вставка значений в команду в виде текста: он позволяет исключить во время исполнения дополнительные расходы на преобразования значений в текст и обратно, и не открывает возможности для SQL-инъекций, не требуя применять экранирование или кавычки для спецсимволов. Пример: <programlisting>EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</programlisting></para>

    <para>Обратите внимание, что символы параметров можно использовать только вместо значений данных. Если же требуется динамически формировать имена таблиц или столбцов, их необходимо вставлять в виде текста. Например, если в предыдущем запросе необходимо динамически задавать имя таблицы, можно сделать следующее: <programlisting>EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</programlisting> В качестве более аккуратного решения, вместо имени таблиц или столбцов можно использовать указание формата <literal>%I</literal> с функцией <function>format()</function> (текст, разделённый символами новой строки, соединяется вместе): <programlisting>EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;</programlisting> Ещё одно ограничение состоит в том, что символы параметров могут использоваться только в командах <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</command>. В операторы других типов (обычно называемые служебными) значения нужно вставлять в текстовом виде, даже если это просто значения данных.</para>

    <para>Команда <command>EXECUTE</command> c неизменяемым текстом и параметрами USING (как в первом примере выше), функционально эквивалентна команде, записанной напрямую в <application>PL/pgSQL</application>, в которой переменные <application>PL/pgSQL</application> автоматически заменяются значениями. Важное отличие в том, что <command>EXECUTE</command> при каждом исполнении заново строит план команды с учётом текущих значений параметров, тогда как <application>PL/pgSQL</application> строит общий план выполнения и кеширует его при повторном использовании. В тех случаях, когда наилучший план выполнения сильно зависит от значений параметров, может быть полезно использовать <command>EXECUTE</command> для гарантии того, что не будет выбран общий план.</para>

    <para>В настоящее время команда <command>SELECT INTO</command> не поддерживается в <command>EXECUTE</command>, вместо этого нужно выполнять обычный <command>SELECT</command> и указать <literal>INTO</literal> для самой команды <command>EXECUTE</command>.</para>

   <note>
    <para>Оператор <command>EXECUTE</command> в <application>PL/pgSQL</application> не имеет отношения к одноименному SQL-оператору сервера <productname>&productname;</productname>. Серверный <command>EXECUTE</command> не может напрямую использоваться в функциях на <application>PL/pgSQL</application> (и в этом нет необходимости).</para>
   </note>

   <example id="plpgsql-quote-literal-example">
   <title>Использование кавычек в динамических запросах</title>

    <indexterm><primary>quote_ident</primary> <secondary>использование в PL/pgSQL</secondary></indexterm>

    <indexterm><primary>quote_literal</primary> <secondary>использование в PL/pgSQL</secondary></indexterm>

    <indexterm><primary>quote_nullable</primary> <secondary>использование в PL/pgSQL</secondary></indexterm>

    <indexterm><primary>format</primary> <secondary>использование в PL/pgSQL</secondary></indexterm>

    <para>При работе с динамическими командами часто приходится иметь дело с экранированием одинарных кавычек. Рекомендуемым методом для взятия текста в кавычки в теле функции является экранирование знаками доллара. (Если имеется унаследованный код, не использующий этот метод, пожалуйста, обратитесь к обзору в <xref remap="6" linkend="plpgsql-quote-tips"/>, это поможет сэкономить усилия при переводе кода к более приемлемому виду.)</para>

    <para>Динамические значения требуют особого внимания, так как они могут содержать апострофы. Например, можно использовать функцию <function>format()</function> (предполагается, что тело функции заключается в доллары, так что апострофы дублировать не нужно): <programlisting>EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;</programlisting> Также можно напрямую вызывать функции заключения в кавычки: <programlisting>EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);</programlisting></para>

    <para>Этот пример демонстрирует использование функций <function>quote_ident</function> и <function>quote_literal</function> (см. <xref remap="4" linkend="functions-string"/>). Для надёжности, выражения, содержащие идентификаторы столбцов и таблиц должны использовать функцию <function>quote_ident</function> при добавлении в текст запроса. А для выражений со значениями, которые должны быть обычными строками, используется функция <function>quote_literal</function>. Эти функции выполняют соответствующие шаги, чтобы вернуть текст, по ситуации заключённый в двойные или одинарные кавычки и с правильно экранированными специальными символами.</para>

    <para>Так как функция <function>quote_literal</function> помечена как <literal>STRICT</literal>, то она всегда возвращает NULL, если переданный ей аргумент имеет значение NULL. В приведённом выше примере, если <literal>newvalue</literal> или <literal>keyvalue</literal> были NULL, вся строка с текстом запроса станет NULL, что приведёт к ошибке в <command>EXECUTE</command>. Для предотвращения этой проблемы используйте функцию <function>quote_nullable</function>, которая работает так же, как <function>quote_literal</function> за исключением того, что при вызове с пустым аргументом возвращает строку 'NULL'. Например: <programlisting>EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);</programlisting> Если вы имеете дело со значениями, которые могут быть пустыми, то, как правило, нужно использовать <function>quote_nullable</function> вместо <function>quote_literal</function>.</para>

    <para>Как обычно, необходимо убедиться, что значения NULL в запросе не принесут неожиданных результатов. Например, следующее условие <literal>WHERE</literal> <programlisting>'WHERE key = ' || quote_nullable(keyvalue)</programlisting> никогда не выполнится, если <literal>keyvalue</literal> — NULL, так как применение <literal>=</literal> с операндом, имеющим значение NULL, всегда даёт NULL. Если требуется, чтобы NULL обрабатывалось как обычное значение, то условие выше нужно переписать так: <programlisting>'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)</programlisting> (В настоящее время <literal>IS NOT DISTINCT FROM</literal> работает менее эффективно, чем <literal>=</literal>, так что используйте этот способ, только если это действительно необходимо. Подробнее особенности NULL и <literal>IS DISTINCT</literal> описаны в <xref remap="6" linkend="functions-comparison"/>.)</para>

    <para>Обратите внимание, что использование знака $ полезно только для взятия в кавычки фиксированного текста. Плохая идея написать этот пример так: <programlisting>EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);</programlisting> потому что <literal>newvalue</literal> может также содержать <literal>$$</literal>. Эта же проблема может возникнуть и с любым другим разделителем, используемым после знака <literal>$</literal>. Поэтому, чтобы безопасно заключить заранее неизвестный текст в кавычки, <emphasis>нужно</emphasis> использовать соответствующие функции: <function>quote_literal</function>, <function>quote_nullable</function>, или <function>quote_ident</function>.</para>

    <para>Динамические операторы SQL также можно безопасно сформировать, используя функцию <function>format</function> (см. <xref remap="4" linkend="functions-string"/>). Например: <programlisting>EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);</programlisting> Указание <literal>%I</literal> равнозначно вызову <function>quote_ident</function>, а <literal>%L</literal> — вызову <function>quote_nullable</function>. Функция <function>format</function> может применяться в сочетании с предложением <literal>USING</literal>: <programlisting>EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;</programlisting> Эта форма лучше, так как с ней переменные обрабатываются в их собственном формате данных, а не преобразуются безусловно в текст, чтобы затем выводиться с использованием <literal>%L</literal>. Она также и более эффективна.</para>
   </example>

    <para>Более объёмный пример использования динамической команды и <command>EXECUTE</command> можно увидеть в <xref remap="6" linkend="plpgsql-porting-ex2"/>. В нём создаётся и динамически выполняется команда <command>CREATE FUNCTION</command> для определения новой функции.</para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
    <title>Статус выполнения команды</title>

    <para>Определить результат команды можно несколькими способами. Во-первых, можно воспользоваться командой <command>GET DIAGNOSTICS</command>, имеющей форму: <synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>переменная</replaceable> { = | := } <replaceable>элемент</replaceable> <optional> , ... </optional>;
</synopsis> Эта команда позволяет получить системные индикаторы состояния. Слово <literal>CURRENT</literal> не несёт смысловой нагрузки (но см. также описание <command>GET STACKED DIAGNOSTICS</command> в <xref remap="6" linkend="plpgsql-exception-diagnostics"/>). Каждый <replaceable>элемент</replaceable> представляется ключевым словом, указывающим, какое значение состояния нужно присвоить заданной <replaceable>переменной</replaceable> (она должна иметь подходящий тип данных, чтобы принять его). Доступные в настоящее время элементы состояния показаны в <xref remap="6" linkend="plpgsql-current-diagnostics-values"/>. Вместо принятого в стандарте SQL присваивания (<literal>=</literal>) можно применять присваивание с двоеточием (<literal>:=</literal>). Например: <programlisting>GET DIAGNOSTICS integer_var = ROW_COUNT;</programlisting></para>

     <table id="plpgsql-current-diagnostics-values">
      <title>Доступные элементы диагностики</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Имя</entry>
         <entry>Тип</entry>
         <entry>Описание</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><varname>ROW_COUNT</varname></entry>
         <entry><type>bigint</type></entry>
         <entry>число строк, обработанных последней командой <acronym>SQL</acronym></entry>
        </row>
        <row>
         <entry><varname>RESULT_OID</varname></entry>
         <entry><type>oid</type></entry>
         <entry>OID последней строки, вставленной предыдущей командой <acronym>SQL</acronym> (полезен только после команды <command>INSERT</command> для таблицы, содержащей OID)</entry>
        </row>
        <row>
         <entry><literal>PG_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>строки текста, описывающие текущий стек вызовов (см. <xref remap="4" linkend="plpgsql-call-stack"/>)</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>Второй способ определения статуса выполнения команды заключается в проверке значения специальной переменной <literal>FOUND</literal>, имеющей тип <type>boolean</type>. При вызове функции на <application>PL/pgSQL</application>, переменная <literal>FOUND</literal> инициализируется в ложь. Далее, значение переменной изменяется следующими операторами: <itemizedlist>
          <listitem>
           <para><command>SELECT INTO</command> записывает в <literal>FOUND</literal> true, если строка присвоена, или false, если строки не были получены.</para>
          </listitem>
          <listitem>
           <para><command>PERFORM</command> записывает в <literal>FOUND</literal> true, если строки выбраны (и отброшены) или false, если строки не выбраны.</para>
          </listitem>
          <listitem>
           <para><command>UPDATE</command>, <command>INSERT</command> и <command>DELETE</command> записывают в <literal>FOUND</literal> true, если при их выполнении была задействована хотя бы одна строка, или false, если ни одна строка не была задействована.</para>
          </listitem>
          <listitem>
           <para><command>FETCH</command> записывают в <literal>FOUND</literal> true, если команда вернула строку, или false, если строка не выбрана.</para>
          </listitem>
          <listitem>
           <para><command>MOVE</command> записывают в <literal>FOUND</literal> true при успешном перемещении курсора, в противном случае — false.</para>
          </listitem>
          <listitem>
           <para><command>FOR</command>, как и <command>FOREACH</command>, записывает в <literal>FOUND</literal> true, если была произведена хотя бы одна итерация цикла, в противном случае — false. При этом значение <literal>FOUND</literal> будет установлено только после выхода из цикла. Пока цикл выполняется, оператор цикла не изменяет значение переменной. Но другие операторы внутри цикла могут менять значение <literal>FOUND</literal>.</para>
          </listitem>
          <listitem>
           <para><command>RETURN QUERY</command> и <command>RETURN QUERY EXECUTE</command> записывают в <literal>FOUND</literal> true, если запрос вернул хотя бы одну строку, или false, если строки не выбраны.</para>
          </listitem>
         </itemizedlist> Другие операторы <application>PL/pgSQL</application> не меняют значение <literal>FOUND</literal>. Помните в частности, что <command>EXECUTE</command> изменяет вывод <command>GET DIAGNOSTICS</command>, но не меняет <literal>FOUND</literal>.</para>

    <para><literal>FOUND</literal> является локальной переменной в каждой функции <application>PL/pgSQL</application> и любые её изменения, влияют только на текущую функцию.</para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
    <title>Не делать ничего</title>

    <para>Иногда бывает полезен оператор, который не делает ничего. Например, он может показывать, что одна из ветвей if/then/else сознательно оставлена пустой. Для этих целей используется <command>NULL</command>: <synopsis>
NULL;
</synopsis></para>

    <para>В следующем примере два фрагмента кода эквивалентны: <programlisting>BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- игнорируем ошибку
END;</programlisting> <programlisting>BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- игнорируем ошибку
END;</programlisting> Какой вариант выбрать — дело вкуса.</para>

    <note>
     <para>В Oracle PL/SQL не допускаются пустые списки операторов, поэтому <command>NULL</command> <emphasis>обязателен</emphasis> в подобных ситуациях. В <application>PL/pgSQL</application> разрешается не писать ничего.</para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
   <title>Управляющие структуры</title>

   <para>Управляющие структуры, вероятно, наиболее полезная и важная часть <application>PL/pgSQL</application>. С их помощью можно очень гибко и эффективно манипулировать данными <productname>&productname;</productname>.</para>

   <sect2 id="plpgsql-statements-returning">
    <title>Команды для возврата значения из функции</title>

    <para>Две команды позволяют вернуть данные из функции: <command>RETURN</command> и <command>RETURN NEXT</command>.</para>

    <sect3>
     <title><command>RETURN</command></title>

<synopsis>RETURN <replaceable>выражение</replaceable>;</synopsis>

     <para><command>RETURN</command> с последующим выражением прекращает выполнение функции и возвращает значение выражения в вызывающую программу. Эта форма используется для функций <application>PL/pgSQL</application>, которые не возвращают набор строк.</para>

     <para>В функции, возвращающей скалярный тип, результирующее выражение автоматически приводится к типу возвращаемого значения. Однако, чтобы вернуть составной тип (строку), возвращаемое выражение должно в точности содержать требуемый набор столбцов. При этом может потребоваться явное приведение типов.</para>

     <para>Для функции с выходными параметрами просто используйте <command>RETURN</command> без выражения. Будут возвращены текущие значения выходных параметров.</para>

     <para>Для функции, возвращающей <type>void</type>, <command>RETURN</command> можно использовать в любом месте, но без выражения после <command>RETURN</command>.</para>

     <para>Возвращаемое значение функции не может остаться не определённым. Если достигнут конец блока верхнего уровня, а оператор <command>RETURN</command> так и не встретился, происходит ошибка времени исполнения. Это не касается функций с выходными параметрами и функций, возвращающих <type>void</type>. Для них оператор <command>RETURN</command> выполняется автоматически по окончании блока верхнего уровня.</para>

     <para>Несколько примеров: <programlisting>-- Функции, возвращающие скалярный тип данных
RETURN 1 + 2;
RETURN scalar_var;

-- Функции, возвращающие составной тип данных
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- требуется приведение типов</programlisting></para>
    </sect3>

    <sect3>
     <title><command>RETURN NEXT</command> и <command>RETURN QUERY</command></title>
    <indexterm><primary>RETURN NEXT</primary> <secondary>in PL/pgSQL</secondary></indexterm>
    <indexterm><primary>RETURN QUERY</primary> <secondary>in PL/pgSQL</secondary></indexterm>

<synopsis>RETURN NEXT <replaceable>выражение</replaceable>;
RETURN QUERY <replaceable>запрос</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">строка-команды</replaceable> <optional>USING <replaceable>выражение</replaceable> <optional>, ...</optional></optional>;</synopsis>

     <para>Для функций на <application>PL/pgSQL</application>, возвращающих <literal>SETOF <replaceable>некий_тип</replaceable></literal>, нужно действовать несколько по-иному. Отдельные элементы возвращаемого значения формируются командами <command>RETURN NEXT</command> или <command>RETURN QUERY</command>, а финальная команда <command>RETURN</command> без аргументов завершает выполнение функции. <command>RETURN NEXT</command> используется как со скалярными, так и с составными типами данных. Для составного типа результат функции возвращается в виде таблицы. <command>RETURN QUERY</command> добавляет результат выполнения запроса к результату функции. <command>RETURN NEXT</command> и <command>RETURN QUERY</command> можно свободно смешивать в теле функции, в этом случае их результаты будут объединены.</para>

     <para><command>RETURN NEXT</command> и <command>RETURN QUERY</command> не выполняют возврат из функции. Они просто добавляют строки в результирующее множество. Затем выполнение продолжается со следующего оператора в функции. Успешное выполнение <command>RETURN NEXT</command> и <command>RETURN QUERY</command> формирует множество строк результата. Для выхода из функции используется <command>RETURN</command>, обязательно без аргументов (или можно просто дождаться окончания выполнения функции).</para>

     <para><command>RETURN QUERY</command> имеет разновидность <command>RETURN QUERY EXECUTE</command>, предназначенную для динамического выполнения запроса. В текст запроса можно добавить параметры, используя <literal>USING</literal>, также как и с командой <command>EXECUTE</command>.</para>

     <para>Для функции с выходными параметрами просто используйте <command>RETURN NEXT</command> без аргументов. При каждом исполнении <command>RETURN NEXT</command> текущие значения выходных параметров сохраняются для последующего возврата в качестве строки результата. Обратите внимание, что если функция с выходными параметрами должна возвращать множество значений, то при объявлении нужно указывать <literal>RETURNS SETOF</literal>. При этом если выходных параметров несколько, то используется <literal>RETURNS SETOF record</literal>, а если только один с типом <replaceable>некий_тип</replaceable>, то <literal>RETURNS SETOF <replaceable>некий_тип</replaceable></literal>.</para>

     <para>Пример использования <command>RETURN NEXT</command>: <programlisting>CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -- здесь возможна обработка данных
        RETURN NEXT r; -- добавляет текущую строку запроса к возвращаемому результату
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();</programlisting></para>

     <para>Пример использования <command>RETURN QUERY</command>: <programlisting>CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);

    -- Так как выполнение ещё не закончено, можно проверить, были ли возвращены строки
    -- Если нет, то вызываем исключение
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Нет рейсов на дату: %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;

-- Возвращает доступные рейсы, либо вызывает исключение
SELECT * FROM get_available_flightid(CURRENT_DATE);</programlisting></para>

     <note>
      <para>В текущей реализации <command>RETURN NEXT</command> и <command>RETURN QUERY</command> результирующее множество накапливается целиком, прежде чем будет возвращено из функции. Если множество очень большое, то это может отрицательно сказаться на производительности, так как при нехватке оперативной памяти данные записываются на диск. В следующих версиях <application>PL/pgSQL</application> это ограничение будет снято. В настоящее время управлять количеством оперативной памяти в подобных случаях можно параметром конфигурации <xref linkend="guc-work-mem"/>. При наличии свободной памяти администраторы должны рассмотреть возможность увеличения значения данного параметра.</para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-conditionals">
    <title>Условные операторы</title>

    <para>Операторы <command>IF</command> и <command>CASE</command> позволяют выполнять команды в зависимости от определённых условий. <application>PL/pgSQL</application> поддерживает три формы <command>IF</command>: <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
    </itemizedlist> и две формы <command>CASE</command>: <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist></para>

    <sect3>
     <title><literal>IF-THEN</literal></title>

<synopsis>IF <replaceable>логическое-выражение</replaceable> THEN
    <replaceable>операторы</replaceable>
END IF;</synopsis>

       <para><literal>IF-THEN</literal> это простейшая форма <literal>IF</literal>. Операторы между <literal>THEN</literal> и <literal>END IF</literal> выполняются, если условие (<replaceable>логическое-выражение</replaceable>) истинно. В противном случае они опускаются.</para>

       <para>Пример: <programlisting>IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;</programlisting></para>
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</literal></title>

<synopsis>IF <replaceable>логическое-выражение</replaceable> THEN
    <replaceable>операторы</replaceable>
ELSE
    <replaceable>операторы</replaceable>
END IF;</synopsis>

       <para><literal>IF-THEN-ELSE</literal> добавляет к <literal>IF-THEN</literal> возможность указать альтернативный набор операторов, которые будут выполнены, если условие не истинно (в том числе, если условие NULL).</para>

       <para>Примеры: <programlisting>IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;</programlisting> <programlisting>IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;</programlisting></para>
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</literal></title>

<synopsis>IF <replaceable>логическое-выражение</replaceable> THEN
    <replaceable>операторы</replaceable>
<optional>ELSIF <replaceable>логическое-выражение</replaceable> THEN <replaceable>операторы</replaceable> <optional>ELSIF <replaceable>логическое-выражение</replaceable> THEN <replaceable>операторы</replaceable> ...</optional></optional>
<optional>ELSE <replaceable>операторы</replaceable></optional>
END IF;</synopsis>

       <para>В некоторых случаях двух альтернатив недостаточно. <literal>IF-THEN-ELSIF</literal> обеспечивает удобный способ проверки нескольких вариантов по очереди. Условия в <literal>IF</literal> последовательно проверяются до тех пор, пока не будет найдено первое истинное. После этого операторы, относящиеся к этому условию, выполняются, и управление переходит к следующей после <literal>END IF</literal> команде. (Все последующие условия не проверяются.) Если ни одно из условий <literal>IF</literal> не является истинным, то выполняется блок <literal>ELSE</literal> (если присутствует).</para>

       <para>Пример: <programlisting>IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- раз мы здесь, значит значение number не определено (NULL)
    result := 'NULL';
END IF;</programlisting></para>

       <para>Вместо ключевого слова <literal>ELSIF</literal> можно использовать <literal>ELSEIF</literal>.</para>

       <para>Другой вариант сделать то же самое, это использование вложенных операторов <literal>IF-THEN-ELSE</literal>, как в следующем примере: <programlisting>IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;</programlisting></para>

       <para>Однако это требует написания соответствующих <literal>END IF</literal> для каждого <literal>IF</literal>, что при наличии нескольких альтернатив делает код более громоздким, чем использование <literal>ELSIF</literal>.</para>
     </sect3>

     <sect3>
      <title>Простой <literal>CASE</literal></title>

<synopsis>CASE <replaceable>выражение-поиска</replaceable>
    WHEN <replaceable>выражение</replaceable> <optional>, <replaceable>выражение</replaceable> <optional>...</optional></optional> THEN
      <replaceable>операторы</replaceable>
  <optional>WHEN <replaceable>выражение</replaceable> <optional>, <replaceable>выражение</replaceable> <optional>...</optional></optional> THEN <replaceable>операторы</replaceable> ...</optional>
  <optional>ELSE <replaceable>операторы</replaceable></optional>
END CASE;</synopsis>

      <para>Простая форма <command>CASE</command> реализует условное выполнение на основе сравнения операндов. <replaceable>Выражение-поиска</replaceable> вычисляется (один раз) и последовательно сравнивается с каждым <replaceable>выражением</replaceable> в условиях <literal>WHEN</literal>. Если совпадение найдено, то выполняются соответствующие <replaceable>операторы</replaceable> и управление переходит к следующей после <literal>END CASE</literal> команде. (Все последующие выражения <literal>WHEN</literal> не проверяются.) Если совпадение не было найдено, то выполняются <replaceable>операторы</replaceable> в <literal>ELSE</literal>. Но если <literal>ELSE</literal> нет, то вызывается исключение <literal>CASE_NOT_FOUND</literal>.</para>

      <para>Пример: <programlisting>CASE x
    WHEN 1, 2 THEN
        msg := 'один или два';
    ELSE
        msg := 'значение, отличное от один или два';
END CASE;</programlisting></para>
     </sect3>

     <sect3>
      <title><literal>CASE</literal> с перебором условий</title>

<synopsis>CASE
    WHEN <replaceable>логическое-выражение</replaceable> THEN
      <replaceable>операторы</replaceable>
  <optional>WHEN <replaceable>логическое-выражение</replaceable> THEN <replaceable>операторы</replaceable> ...</optional>
  <optional>ELSE <replaceable>операторы</replaceable></optional>
END CASE;</synopsis>

      <para>Эта форма <command>CASE</command> реализует условное выполнение, основываясь на истинности логических условий. Каждое <replaceable>логическое-выражение</replaceable> в предложении <literal>WHEN</literal> вычисляется по порядку до тех пор, пока не будет найдено истинное. Затем выполняются соответствующие <replaceable>операторы</replaceable> и управление переходит к следующей после <literal>END CASE</literal> команде. (Все последующие выражения <literal>WHEN</literal> не проверяются.) Если ни одно из условий не окажется истинным, то выполняются <replaceable>операторы</replaceable> в <literal>ELSE</literal>. Но если <literal>ELSE</literal> нет, то вызывается исключение <literal>CASE_NOT_FOUND</literal>.</para>

      <para>Пример: <programlisting>CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'значение в диапазоне между 0 и 10';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'значение в диапазоне между 11 и 20';
END CASE;</programlisting></para>

      <para>Эта форма <command>CASE</command> полностью эквивалента <literal>IF-THEN-ELSIF</literal>, за исключением того, что при невыполнении всех условий и отсутствии <literal>ELSE</literal>, <literal>IF-THEN-ELSIF</literal> ничего не делает, а <command>CASE</command> вызывает ошибку.</para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
    <title>Простые циклы</title>

    <indexterm zone="plpgsql-control-structures-loops"><primary>цикл</primary> <secondary>в PL/pgSQL</secondary></indexterm>

    <para>Операторы <literal>LOOP</literal>, <literal>EXIT</literal>, <literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</literal> и <literal>FOREACH</literal> позволяют повторить серию команд в функции на <application>PL/pgSQL</application>.</para>

    <sect3>
     <title><literal>LOOP</literal></title>

<synopsis><optional>&lt;&lt;<replaceable>метка</replaceable>&gt;&gt;</optional>
LOOP
    <replaceable>операторы</replaceable>
END LOOP <optional> <replaceable>метка</replaceable> </optional>;</synopsis>

     <para><literal>LOOP</literal> организует безусловный цикл, который повторяется до бесконечности, пока не будет прекращён операторами <literal>EXIT</literal> или <command>RETURN</command>. Для вложенных циклов можно использовать <replaceable>метку</replaceable> в операторах <literal>EXIT</literal> и <literal>CONTINUE</literal>, чтобы указать, к какому циклу эти операторы относятся.</para>
    </sect3>

     <sect3>
      <title><literal>EXIT</literal></title>

     <indexterm><primary>EXIT</primary> <secondary>в PL/pgSQL</secondary></indexterm>

<synopsis>EXIT <optional> <replaceable>метка</replaceable> </optional> <optional>WHEN <replaceable>логическое-выражение</replaceable></optional>;</synopsis>

       <para>Если <replaceable>метка</replaceable> не указана, то завершается самый внутренний цикл, далее выполняется оператор, следующий за <literal>END LOOP</literal>. Если <replaceable>метка</replaceable> указана, то она должна относиться к текущему или внешнему циклу, или это может быть метка блока. При этом в именованном цикле/блоке выполнение прекращается, а управление переходит к следующему оператору после соответствующего <literal>END</literal>.</para>

       <para>При наличии <literal>WHEN</literal> цикл прекращается, только если <replaceable>логическое-выражение</replaceable> истинно. В противном случае управление переходит к оператору, следующему за <literal>EXIT</literal>.</para>

       <para><literal>EXIT</literal> можно использовать со всеми типами циклов, не только с безусловным.</para>

       <para>Когда <literal>EXIT</literal> используется для выхода из блока, управление переходит к следующему оператору после окончания блока. Обратите внимание, что для выхода из блока нужно обязательно указывать <replaceable>метку</replaceable>. <literal>EXIT</literal> без <replaceable>метки</replaceable> не позволяет прекратить работу блока. (Это изменение по сравнению с версиями <productname>PostgreSQL</productname> до 8.4, в которых разрешалось использовать <literal>EXIT</literal> без <replaceable>метки</replaceable> для прекращения работы текущего блока.)</para>

       <para>Примеры: <programlisting>LOOP
    -- здесь вычисления 
    IF count &gt; 0 THEN
        EXIT;  -- выход из цикла
    END IF;
END LOOP;

LOOP
    -- здесь вычисления
    EXIT WHEN count &gt; 0;  -- аналогично предыдущему примеру
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- здесь вычисления
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- выход из блока ablock
    END IF;
    -- вычисления не будут выполнены, если stocks &gt; 100000
END;</programlisting></para>
     </sect3>

     <sect3>
      <title><literal>CONTINUE</literal></title>

     <indexterm><primary>CONTINUE</primary> <secondary>в PL/pgSQL</secondary></indexterm>

<synopsis>CONTINUE <optional> <replaceable>метка</replaceable> </optional> <optional>WHEN <replaceable>логическое-выражение</replaceable></optional>;</synopsis>

       <para>Если <replaceable>метка</replaceable> не указана, то начинается следующая итерация самого внутреннего цикла. То есть все оставшиеся в цикле операторы пропускаются, и управление переходит к управляющему выражению цикла (если есть) для определения, нужна ли ещё одна итерация цикла. Если <replaceable>метка</replaceable> присутствует, то она указывает на метку цикла, выполнение которого будет продолжено.</para>

       <para>При наличии <literal>WHEN</literal> следующая итерация цикла начинается только тогда, когда <replaceable>логическое-выражение</replaceable> истинно. В противном случае управление переходит к оператору, следующему за <literal>CONTINUE</literal>.</para>

       <para><literal>CONTINUE</literal> можно использовать со всеми типами циклов, не только с безусловным.</para>

       <para>Примеры: <programlisting>LOOP
    -- здесь вычисления
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- Вычисления для count в диапазоне 50 .. 100
END LOOP;</programlisting></para>
     </sect3>


     <sect3>
      <title><literal>WHILE</literal></title>

     <indexterm><primary>WHILE</primary> <secondary>в PL/pgSQL</secondary></indexterm>

<synopsis><optional>&lt;&lt;<replaceable>метка</replaceable>&gt;&gt;</optional>
WHILE <replaceable>логическое-выражение</replaceable> LOOP
    <replaceable>операторы</replaceable>
END LOOP <optional> <replaceable>метка</replaceable> </optional>;</synopsis>

       <para><literal>WHILE</literal> выполняет серию команд до тех пор, пока истинно <replaceable>логическое-выражение</replaceable>. Выражение проверяется непосредственно перед каждым входом в тело цикла.</para>

       <para>Пример: <programlisting>WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- здесь вычисления
END LOOP;

WHILE NOT done LOOP
    -- здесь вычисления
END LOOP;</programlisting></para>
     </sect3>

     <sect3 id="plpgsql-integer-for">
      <title><literal>FOR</literal> (целочисленный вариант)</title>

<synopsis><optional>&lt;&lt;<replaceable>метка</replaceable>&gt;&gt;</optional>
FOR <replaceable>имя</replaceable> IN <optional>REVERSE</optional> <replaceable>выражение</replaceable> .. <replaceable>выражение</replaceable> <optional>BY <replaceable>выражение</replaceable></optional> LOOP
    <replaceable>операторы</replaceable>
END LOOP <optional> <replaceable>метка</replaceable> </optional>;</synopsis>

       <para>В этой форме цикла <literal>FOR</literal> итерации выполняются по диапазону целых чисел. Переменная <replaceable>имя</replaceable> автоматически определяется с типом <type>integer</type> и существует только внутри цикла (если уже существует переменная с таким именем, то внутри цикла она будет игнорироваться). Выражения для нижней и верхней границы диапазона чисел вычисляются один раз при входе в цикл. Если не указано <literal>BY</literal>, то шаг итерации 1, в противном случае используется значение в <literal>BY</literal>, которое вычисляется, опять же, один раз при входе в цикл. Если указано <literal>REVERSE</literal>, то после каждой итерации величина шага вычитается, а не добавляется.</para>

       <para>Примеры целочисленного <literal>FOR</literal>: <programlisting>FOR i IN 1..10 LOOP
    -- внутри цикла переменная i будет иметь значения 1,2,3,4,5,6,7,8,9,10
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- внутри цикла переменная i будет иметь значения 10,9,8,7,6,5,4,3,2,1
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- внутри цикла переменная i будет иметь значения 10,8,6,4,2
END LOOP;</programlisting></para>

       <para>Если нижняя граница цикла больше верхней границы (или меньше, в случае <literal>REVERSE</literal>), то тело цикла не выполняется вообще. При этом ошибка не возникает.</para>

       <para>Если с циклом <literal>FOR</literal> связана <replaceable>метка</replaceable>, к целочисленной переменной цикла можно обращаться по имени, указывая эту <replaceable>метку</replaceable>.</para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
    <title>Цикл по результатам запроса</title>

    <para>Другой вариант <literal>FOR</literal> позволяет организовать цикл по результатам запроса. Синтаксис: <synopsis>
<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>
FOR <replaceable>цель</replaceable> IN <replaceable>запрос</replaceable> LOOP
    <replaceable>операторы</replaceable>
END LOOP <optional> <replaceable>метка</replaceable> </optional>;
</synopsis> Переменная <replaceable>цель</replaceable> может быть строковой переменной, переменной типа <type>record</type> или разделённым запятыми списком скалярных переменных. Переменной <replaceable>цель</replaceable> последовательно присваиваются строки результата запроса, и для каждой строки выполняется тело цикла. Пример: <programlisting>CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing materialized views...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -- Здесь "mviews" содержит одну запись из cs_materialized_views

        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);
        EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);
        EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;</programlisting> Если цикл завершается по команде <literal>EXIT</literal>, то последняя присвоенная строка доступна и после цикла.</para>

    <para>В качестве <replaceable>запроса</replaceable> в этом типе оператора <literal>FOR</literal> может задаваться любая команда SQL, возвращающая строки. Чаще всего это <command>SELECT</command>, но также можно использовать и <command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</command> с предложением <literal>RETURNING</literal>. Кроме того, возможно применение и некоторых служебных команд, например <command>EXPLAIN</command>.</para>

    <para>Для переменных <application>PL/pgSQL</application> в тексте запроса выполняется подстановка значений, план запроса кешируется для возможного повторного использования, как подробно описано в <xref remap="6" linkend="plpgsql-var-subst"/> и <xref remap="6" linkend="plpgsql-plan-caching"/>.</para>

    <para>Ещё одна разновидность этого типа цикла <literal>FOR-IN-EXECUTE</literal>: <synopsis>
<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>
FOR <replaceable>цель</replaceable> IN EXECUTE <replaceable>выражение_проверки</replaceable> <optional> USING <replaceable>выражение</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>операторы</replaceable>
END LOOP <optional> <replaceable>метка</replaceable> </optional>;
</synopsis> Она похожа на предыдущую форму, за исключением того, что текст запроса указывается в виде строкового выражения. Текст запроса формируется и для него строится план выполнения при каждом входе в цикл. Это даёт программисту выбор между скоростью предварительно разобранного запроса и гибкостью динамического запроса, так же, как и в случае с обычным оператором <command>EXECUTE</command>. Как и в <command>EXECUTE</command>, значения параметров могут быть добавлены в команду с использованием <literal>USING</literal>.</para>

    <para>Ещё один способ организовать цикл по результатам запроса это объявить курсор. Описание в <xref remap="6" linkend="plpgsql-cursor-for-loop"/>.</para>
   </sect2>

   <sect2 id="plpgsql-foreach-array">
    <title>Цикл по элементам массива</title>

    <para>Цикл <literal>FOREACH</literal> очень похож на <literal>FOR</literal>. Отличие в том, что вместо перебора строк SQL-запроса происходит перебор элементов массива. (В целом, <literal>FOREACH</literal> предназначен для перебора выражений составного типа. Варианты реализации цикла для работы с прочими составными выражениями помимо массивов могут быть добавлены в будущем.) Синтаксис цикла <literal>FOREACH</literal>: <synopsis>
<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>цель</replaceable> <optional> SLICE <replaceable>число</replaceable> </optional> IN ARRAY <replaceable>выражение</replaceable> LOOP
    <replaceable>операторы</replaceable>
END LOOP <optional> <replaceable>метка</replaceable> </optional>;
</synopsis></para>

    <para>Без указания <literal>SLICE</literal>, или если <literal>SLICE</literal> равен 0, цикл выполняется по всем элементам массива, полученного из <replaceable>выражения</replaceable>. Переменной <replaceable>цель</replaceable> последовательно присваивается каждый элемент массива и для него выполняется тело цикла. Пример цикла по элементам целочисленного массива: <programlisting>CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;</programlisting> Обход элементов проводится в том порядке, в котором они сохранялись, независимо от размерности массива. Как правило, <replaceable>цель</replaceable> это одиночная переменная, но может быть и списком переменных, когда элементы массива имеют составной тип (записи). В этом случае переменным присваиваются значения из последовательных столбцов составного элемента массива.</para>

    <para>При положительном значении <literal>SLICE</literal> <literal>FOREACH</literal> выполняет итерации по срезам массива, а не по отдельным элементам. Значение <literal>SLICE</literal> должно быть целым числом, не превышающим размерности массива. Переменная <replaceable>цель</replaceable> должна быть массивом, который получает последовательные срезы исходного массива, где размерность каждого среза задаётся значением <literal>SLICE</literal>. Пример цикла по одномерным срезам: <programlisting>CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}</programlisting></para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
    <title>Обработка ошибок</title>

    <indexterm><primary>исключения</primary> <secondary>в PL/pgSQL</secondary></indexterm>

    <para>По умолчанию любая возникающая ошибка прерывает выполнение функции на <application>PL/pgSQL</application>, а также транзакцию, относящуюся к этой функции. Использование в блоке секции <literal>EXCEPTION</literal> позволяет перехватывать и обрабатывать ошибки. Синтаксис секции <literal>EXCEPTION</literal> расширяет синтаксис обычного блока: <synopsis>
<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>объявления</replaceable> </optional>
BEGIN
    <replaceable>операторы</replaceable>
EXCEPTION
    WHEN <replaceable>условие</replaceable> <optional> OR <replaceable>условие</replaceable> ... </optional> THEN
        <replaceable>операторы_обработчика</replaceable>
    <optional> WHEN <replaceable>условие</replaceable> <optional> OR <replaceable>условие</replaceable> ... </optional> THEN
          <replaceable>операторы_обработчика</replaceable>
      ... </optional>
END;
</synopsis></para>

    <para>Если ошибок не было, то выполняются все <replaceable>операторы</replaceable> блока и управление переходит к следующему оператору после <literal>END</literal>. Но если при выполнении <replaceable>оператора</replaceable> происходит ошибка, то дальнейшая обработка прекращается и управление переходит к списку исключений в секции <literal>EXCEPTION</literal>. В этом списке ищется первое исключение, условие которого соответствует ошибке. Если исключение найдено, то выполняются соответствующие <replaceable>операторы_обработчика</replaceable> и управление переходит к следующему оператору после <literal>END</literal>. Если исключение не найдено, то ошибка передаётся наружу, как будто секции <literal>EXCEPTION</literal> не было. При этом ошибку можно перехватить в секции <literal>EXCEPTION</literal> внешнего блока. Если ошибка так и не была перехвачена, то обработка функции прекращается.</para>

    <para>В качестве <replaceable>условия</replaceable> может задаваться одно из имён, перечисленных в <xref remap="6" linkend="errcodes-appendix"/>. Если задаётся имя категории, ему соответствуют все ошибки в данной категории. Специальному имени условия <literal>OTHERS</literal> (другие) соответствуют все типы ошибок, кроме <literal>QUERY_CANCELED</literal> и <literal>ASSERT_FAILURE</literal>. (И эти два типа ошибок можно перехватить по имени, но часто это неразумно.) Имена условий воспринимаются без учёта регистра. Условие ошибки также можно задать кодом <literal>SQLSTATE</literal>; например, эти два варианта равнозначны: <programlisting>WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...</programlisting></para>

    <para>Если при выполнении <replaceable>операторов_обработчика</replaceable> возникнет новая ошибка, то она не может быть перехвачена в этой секции <literal>EXCEPTION</literal>. Ошибка передаётся наружу и её можно перехватить в секции <literal>EXCEPTION</literal> внешнего блока.</para>

    <para>При выполнении команд в секции <literal>EXCEPTION</literal> локальные переменные функции на <application>PL/pgSQL</application> сохраняют те значения, которые были на момент возникновения ошибки. Однако, будут отменены все изменения в базе данных, выполненные в блоке. В качестве примера рассмотрим следующий фрагмент: <programlisting>INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'перехватили ошибку division_by_zero';
        RETURN x;
END;</programlisting> При присвоении значения переменной <literal>y</literal> произойдёт ошибка <literal>division_by_zero</literal>. Она будет перехвачена в секции <literal>EXCEPTION</literal>. Оператор <command>RETURN</command> вернёт значение <literal>x</literal>, увеличенное на единицу, но изменения сделанные командой <command>UPDATE</command> будут отменены. Изменения, выполненные командой <command>INSERT</command>, которая предшествует блоку, не будут отменены. В результате, база данных будет содержать <literal>Tom Jones</literal>, а не <literal>Joe Jones</literal>.</para>

    <tip>
     <para>Наличие секции <literal>EXCEPTION</literal> значительно увеличивает накладные расходы на вход/выход из блока. Поэтому не используйте <literal>EXCEPTION</literal> без надобности.</para>
    </tip>

    <example id="plpgsql-upsert-example">
    <title>Обработка исключений для команд <command>UPDATE</command>/<command>INSERT</command></title>
    <para>В этом примере обработка исключений помогает выполнить либо команду <command>UPDATE</command>, либо <command>INSERT</command>, в зависимости от ситуации. Однако в современных приложениях вместо этого приёма рекомендуется использовать <command>INSERT</command> с <literal>ON CONFLICT DO UPDATE</literal>. Данный пример предназначен в первую очередь для демонстрации управления выполнением <application>PL/pgSQL</application>: <programlisting>CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -- для начала UPDATE записи по значению ключа
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- записи с таким ключом нет, поэтому попытаемся её вставить
        -- если параллельно с нами кто-то ещё пытается вставить запись с таким же ключом,
        -- то мы получим ошибку уникальности
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- Здесь ничего не делаем,
            -- продолжаем цикл, чтобы повторить UPDATE.
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');</programlisting> В этом коде предполагается, что ошибка <literal>unique_violation</literal> вызывается самой командой <command>INSERT</command>, а не, скажем, внутренним оператором <command>INSERT</command> в функции триггера для этой таблицы. Некорректное поведение также возможно, если в таблице будет несколько уникальных индексов; тогда операция будет повторяться вне зависимости от того, нарушение какого индекса вызвало ошибку. Используя средства, рассмотренные далее, можно сделать код более надёжным, проверяя, что перехвачена именно ожидаемая ошибка.</para>
    </example>

   <sect3 id="plpgsql-exception-diagnostics">
    <title>Получение информации об ошибке</title>

    <para>При обработке исключений часто бывает необходимым получить детальную информацию о произошедшей ошибке. Для этого в <application>PL/pgSQL</application> есть два способа: использование специальных переменных и команда <command>GET STACKED DIAGNOSTICS</command>.</para>

    <para>Внутри секции <literal>EXCEPTION</literal> специальная переменная <varname>SQLSTATE</varname> содержит код ошибки, для которой было вызвано исключение (список возможных кодов ошибок приведён в <xref remap="6" linkend="errcodes-table"/>). Специальная переменная <varname>SQLERRM</varname> содержит сообщение об ошибке, связанное с исключением. Эти переменные являются неопределёнными вне секции <literal>EXCEPTION</literal>.</para>

    <para>Также в обработчике исключения можно получить информацию о текущем исключении командой <command>GET STACKED DIAGNOSTICS</command>, которая имеет вид: <synopsis>
GET STACKED DIAGNOSTICS <replaceable>переменная</replaceable> { = | := } <replaceable>элемент</replaceable> <optional> , ... </optional>;
</synopsis> Каждый <replaceable>элемент</replaceable> представляется ключевым словом, указывающим, какое значение состояния нужно присвоить заданной <replaceable>переменной</replaceable> (она должна иметь подходящий тип данных, чтобы принять его). Доступные в настоящее время элементы состояния показаны в <xref remap="6" linkend="plpgsql-exception-diagnostics-values"/>.</para>

     <table id="plpgsql-exception-diagnostics-values">
      <title>Элементы диагностики ошибок</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Имя</entry>
         <entry>Тип</entry>
         <entry>Описание</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry><type>text</type></entry>
         <entry>код исключения, возвращаемый SQLSTATE</entry>
        </row>
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>имя столбца, относящегося к исключению</entry>
        </row>
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>имя ограничения целостности, относящегося к исключению</entry>
        </row>
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>имя типа данных, относящегося к исключению</entry>
        </row>
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>текст основного сообщения исключения</entry>
        </row>
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>имя таблицы, относящейся к исключению</entry>
        </row>
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>имя схемы, относящейся к исключению</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry><type>text</type></entry>
         <entry>текст детального сообщения исключения (если есть)</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry><type>text</type></entry>
         <entry>текст подсказки к исключению (если есть)</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>строки текста, описывающие стек вызовов в момент исключения (см. <xref remap="4" linkend="plpgsql-call-stack"/>)</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>Если исключение не устанавливает значение для идентификатора, то возвращается пустая строка.</para>

    <para>Пример: <programlisting>DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -- здесь происходит обработка, которая может вызвать исключение
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;</programlisting></para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-call-stack">
   <title>Получение информации о месте выполнения</title>

   <para>Команда <command>GET DIAGNOSTICS</command>, ранее описанная в <xref remap="6" linkend="plpgsql-statements-diagnostics"/>, получает информацию о текущем состоянии выполнения кода (тогда как команда <command>GET STACKED DIAGNOSTICS</command>, рассмотренная ранее, выдаёт информацию о состоянии выполнения в момент предыдущей ошибки). Её элемент состояния <literal>PG_CONTEXT</literal> позволяет определить текущее место выполнения кода. <literal>PG_CONTEXT</literal> возвращает текст с несколькими строками, описывающий стек вызова. В первой строке отмечается текущая функция и выполняемая в данный момент команда <command>GET DIAGNOSTICS</command>, а во второй и последующих строках отмечаются функции выше по стеку вызовов. Например: <programlisting>CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Стек вызова ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Стек вызова ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)</programlisting></para>

   <para><literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal> возвращает похожий стек вызовов, но описывает не текущее место, а место, в котором произошла ошибка.</para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
   <title>Курсоры</title>

   <indexterm zone="plpgsql-cursors"><primary>курсор</primary> <secondary>в PL/pgSQL</secondary></indexterm>

   <para>Вместо того чтобы сразу выполнять весь запрос, есть возможность настроить курсор, инкапсулирующий запрос, и затем получать результат запроса по нескольку строк за раз. Одна из причин так делать заключается в том, чтобы избежать переполнения памяти, когда результат содержит большое количество строк. (Пользователям <application>PL/pgSQL</application> не нужно об этом беспокоиться, так как циклы <literal>FOR</literal> автоматически используют курсоры, чтобы избежать проблем с памятью.) Более интересным вариантом использования является возврат из функции ссылки на курсор, что позволяет вызывающему получать строки запроса. Это эффективный способ получать большие наборы строк из функций.</para>

   <sect2 id="plpgsql-cursor-declarations">
    <title>Объявление курсорных переменных</title>

    <para>Доступ к курсорам в <application>PL/pgSQL</application> осуществляется через курсорные переменные, которые всегда имеют специальный тип данных <type>refcursor</type>. Один из способов создать курсорную переменную, просто объявить её как переменную типа <type>refcursor</type>. Другой способ заключается в использовании синтаксиса объявления курсора, который в общем виде выглядит так: <synopsis>
<replaceable>имя</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>аргументы</replaceable> ) </optional> FOR <replaceable>запрос</replaceable>;
</synopsis> (Для совместимости с Oracle, <literal>FOR</literal> можно заменять на <literal>IS</literal>.) С указанием <literal>SCROLL</literal> курсор можно будет прокручивать назад. При <literal>NO SCROLL</literal> прокрутка назад не разрешается. Если ничего не указано, то возможность прокрутки назад зависит от запроса. Если указаны <replaceable>аргументы</replaceable>, то они должны представлять собой пары <literal><replaceable>имя</replaceable> <replaceable>тип_данных</replaceable></literal>, разделённые через запятую. Эти пары определяют имена, которые будут заменены значениями параметров в данном запросе. Фактические значения для замены этих имён появятся позже, при открытии курсора.</para>
    <para>Примеры: <programlisting>DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;</programlisting> Все три переменные имеют тип данных <type>refcursor</type>. Первая может быть использована с любым запросом, вторая связана (<literal>bound</literal>) с полностью сформированным запросом, а последняя связана с параметризованным запросом. (<literal>key</literal> будет заменён целочисленным значением параметра при открытии курсора.) Про переменную <literal>curs1</literal> говорят, что она является несвязанной (<literal>unbound</literal>), так как к ней не привязан никакой запрос.</para>
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
    <title>Открытие курсора</title>

    <para>Прежде чем получать строки из курсора, его нужно открыть. (Это эквивалентно действию SQL-команды <command>DECLARE CURSOR</command>.) В <application>PL/pgSQL</application> есть три формы оператора <command>OPEN</command>, две из которых используются для несвязанных курсорных переменных, а третья для связанных.</para>

    <note>
     <para>Связанные курсорные переменные можно использовать с циклом <command>FOR</command> без явного открытия курсора, как описано в <xref remap="6" linkend="plpgsql-cursor-for-loop"/>.</para>
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>запрос</replaceable></title>

<synopsis>OPEN <replaceable>несвязанная_переменная_курсора</replaceable> <optional><optional>NO</optional> SCROLL</optional> FOR <replaceable>запрос</replaceable>;</synopsis>

       <para>Курсорная переменная открывается и получает конкретный запрос для выполнения. Курсор не может уже быть открытым, а курсорная переменная обязана быть несвязанной (то есть просто переменной типа <type>refcursor</type>). Запрос должен быть командой <command>SELECT</command> или любой другой, которая возвращает строки (к примеру <command>EXPLAIN</command>). Запрос обрабатывается так же, как и другие команды SQL в <application>PL/pgSQL</application>: имена переменных <application>PL/pgSQL</application> заменяются на значения, план запроса кешируется для повторного использования. Подстановка значений переменных <application>PL/pgSQL</application> проводится при открытии курсора командой <command>OPEN</command>, последующие изменения значений переменных не влияют на работу курсора. <literal>SCROLL</literal> и <literal>NO SCROLL</literal> имеют тот же смысл, что и для связанного курсора.</para>

       <para>Пример: <programlisting>OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;</programlisting></para>
     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<synopsis>OPEN <replaceable>несвязанная_переменная_курсора</replaceable> <optional><optional>NO</optional> SCROLL</optional> FOR EXECUTE <replaceable class="command">строка_запроса</replaceable>
                                     <optional>USING <replaceable>выражение</replaceable> <optional>, ...</optional></optional>;</synopsis>

         <para>Переменная курсора открывается и получает конкретный запрос для выполнения. Курсор не может быть уже открыт и он должен быть объявлен как несвязанная переменная курсора (то есть, как просто переменная <type>refcursor</type>). Запрос задаётся строковым выражением, так же, как в команде <command>EXECUTE</command>. Как обычно, это даёт возможность гибко менять план запроса от раза к разу (см. <xref remap="4" linkend="plpgsql-plan-caching"/>). Это также означает, что замена переменных происходит не в самой строке команды. Как и с <command>EXECUTE</command>, значения параметров вставляются в динамическую команду, используя <literal>format()</literal> и <literal>USING</literal>. Параметры <literal>SCROLL</literal> и <literal>NO SCROLL</literal> здесь действуют так же, как и со связанным курсором.</para>

       <para>Пример: <programlisting>OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;</programlisting> В этом примере в текст запроса вставляется имя таблицы с применением <function>format()</function>. Значение, сравниваемое с <literal>col1</literal>, вставляется посредством параметра <literal>USING</literal>, так что заключать его в апострофы не нужно.</para>
     </sect3>

    <sect3 id="plpgsql-open-bound-cursor">
     <title>Открытие связанного курсора</title>

<synopsis>OPEN <replaceable>связанная_переменная_курсора</replaceable> <optional>( <optional><replaceable>имя_аргумента</replaceable> :=</optional> <replaceable>значение_аргумента</replaceable> <optional>, ...</optional> )</optional>;</synopsis>

         <para>Эта форма <command>OPEN</command> используется для открытия курсорной переменной, которая была связана с запросом при объявлении. Курсор не может уже быть открытым. Список фактических значений аргументов должен присутствовать только в том случае, если курсор объявлялся с параметрами. Эти значения будут подставлены в запрос.</para>

         <para>План запроса для связанного курсора всегда считается кешируемым. В этом случае, нет эквивалента <command>EXECUTE</command>. Обратите внимание, что <literal>SCROLL</literal> и <literal>NO SCROLL</literal> не могут быть указаны в этой форме <command>OPEN</command>, возможность прокрутки назад была определена при объявлении курсора.</para>

         <para>При передаче значений аргументов можно использовать позиционную или именную нотацию. В позиционной нотации все аргументы указываются по порядку. В именной нотации имя каждого аргумента отделяется от выражения аргумента с помощью <literal>:=</literal>. Это подобно вызову функций, описанному в <xref remap="6" linkend="sql-syntax-calling-funcs"/>. Также разрешается смешивать позиционную и именную нотации.</para>

         <para>Примеры (здесь используются ранее объявленные курсоры): <programlisting>OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);</programlisting></para>

         <para>Так как для связанного курсора выполняется подстановка значений переменных, то, на самом деле, существует два способа передать значения в курсор. Либо использовать явные аргументы в <command>OPEN</command>, либо неявно, ссылаясь на переменные <application>PL/pgSQL</application> в запросе. В связанном курсоре можно ссылаться только на те переменные, которые были объявлены до самого курсора. В любом случае, значение переменной для подстановки в запрос будет определяться на момент выполнения <command>OPEN</command>. Вот ещё один способ получить тот же результат с <literal>curs3</literal>, как в примере выше: <programlisting>DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;</programlisting></para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
    <title>Использование курсоров</title>

    <para>После того, как курсор был открыт, с ним можно работать при помощи описанных здесь операторов.</para>

    <para>Работать с курсором необязательно в той же функции, где он был открыт. Из функции можно вернуть значение с типом <type>refcursor</type>, что позволит вызывающему продолжить работу с курсором. (Внутри <type>refcursor</type> представляет собой обычное строковое имя так называемого портала, содержащего активный запрос курсора. Это имя можно передавать, присваивать другим переменным с типом <type>refcursor</type> и так далее, при этом портал не нарушается.)</para>

    <para>Все порталы неявно закрываются в конце транзакции. Поэтому значение <type>refcursor</type> можно использовать для ссылки на открытый курсор только до конца транзакции.</para>

    <sect3>
     <title><literal>FETCH</literal></title>

<synopsis>FETCH <optional><replaceable>направление</replaceable> { FROM | IN }</optional> <replaceable>курсор</replaceable> INTO <replaceable>цель</replaceable>;</synopsis>

    <para><command>FETCH</command> извлекает следующую строку из курсора в <replaceable>цель</replaceable>. В качестве <replaceable>цели</replaceable> может быть строковая переменная, переменная типа <type>record</type>, или разделённый запятыми список простых переменных, как и в <command>SELECT INTO</command>. Если следующей строки нет, <replaceable>цели</replaceable> присваивается NULL. Как и в <command>SELECT INTO</command>, проверить, была ли получена запись, можно при помощи специальной переменной <literal>FOUND</literal>.</para>

    <para>Здесь <replaceable>направление</replaceable> может быть любым допустимым в SQL-команде <xref linkend="sql-fetch"/> вариантом, кроме тех, что извлекают более одной строки. А именно: <literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, <literal>ABSOLUTE</literal> <replaceable>число</replaceable>, <literal>RELATIVE</literal> <replaceable>число</replaceable>, <literal>FORWARD</literal> или <literal>BACKWARD</literal>. Без указания <replaceable>направления</replaceable> используется значение <literal>NEXT</literal>. Значения <replaceable>направления</replaceable>, которые требуют перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт с указанием <literal>SCROLL</literal>.</para>

    <para><replaceable>курсор</replaceable> это переменная с типом <type>refcursor</type>, которая ссылается на открытый портал курсора.</para>

    <para>Примеры: <programlisting>FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;</programlisting></para>
     </sect3>

    <sect3>
     <title><literal>MOVE</literal></title>

<synopsis>MOVE <optional><replaceable>направление</replaceable> { FROM | IN }</optional> <replaceable>курсор</replaceable>;</synopsis>

    <para><command>MOVE</command> перемещает курсор без извлечения данных. <command>MOVE</command> работает точно также как и <command>FETCH</command>, но при этом только перемещает курсор и не извлекает строку, к которой переместился. Как и в <command>SELECT INTO</command>, проверить успешность перемещения можно с помощью специальной переменной <literal>FOUND</literal>.</para>

    <para>Здесь <replaceable>направление</replaceable> может быть любым допустимым в SQL-команде <xref linkend="sql-fetch"/> вариантом, а именно: <literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, <literal>ABSOLUTE</literal> <replaceable>число</replaceable>, <literal>RELATIVE</literal> <replaceable>число</replaceable>, <literal>ALL</literal>, <literal>FORWARD</literal> <optional><replaceable>число</replaceable> | <literal>ALL</literal></optional> или <literal>BACKWARD</literal> <optional><replaceable>число</replaceable> | <literal>ALL</literal></optional>. Без указания <replaceable>направления</replaceable> используется значение <literal>NEXT</literal>. Значения <replaceable>направления</replaceable>, которые требуют перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт с указанием <literal>SCROLL</literal>.</para>

    <para>Примеры: <programlisting>MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;</programlisting></para>
     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>

<synopsis>UPDATE <replaceable>таблица</replaceable> SET ... WHERE CURRENT OF <replaceable>курсор</replaceable>;
DELETE FROM <replaceable>таблица</replaceable> WHERE CURRENT OF <replaceable>курсор</replaceable>;</synopsis>

       <para>Когда курсор позиционирован на строку таблицы, эту строку можно изменить или удалить при помощи курсора. Есть ограничения на то, каким может быть запрос курсора (в частности, не должно быть группировок), и крайне желательно использовать указание <literal>FOR UPDATE</literal>. За дополнительными сведениями обратитесь к странице справки <xref remap="1" linkend="sql-declare"/>.</para>

       <para>Пример: <programlisting>UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;</programlisting></para>
     </sect3>

    <sect3>
     <title><literal>CLOSE</literal></title>

<synopsis>CLOSE <replaceable>курсор</replaceable>;</synopsis>

       <para><command>CLOSE</command> закрывает связанный с курсором портал. Используется для того, чтобы освободить ресурсы раньше, чем закончится транзакция, или чтобы освободить курсорную переменную для повторного открытия.</para>

       <para>Пример: <programlisting>CLOSE curs1;</programlisting></para>
     </sect3>

    <sect3>
     <title>Возврат курсора из функции</title>

       <para>Курсоры можно возвращать из функции на <application>PL/pgSQL</application>. Это полезно, когда нужно вернуть множество строк и столбцов, особенно если выборки очень большие. Для этого, в функции открывается курсор и его имя возвращается вызывающему (или просто открывается курсор, используя указанное имя портала, каким-либо образом известное вызывающему). Вызывающий затем может извлекать строки из курсора. Курсор может быть закрыт вызывающим или он будет автоматически закрыт при завершении транзакции.</para>

       <para>Имя портала, используемое для курсора, может быть указано разработчиком или будет генерироваться автоматически. Чтобы указать имя портала, нужно просто присвоить строку в переменную <type>refcursor</type> перед его открытием. Значение строки переменной <type>refcursor</type> будет использоваться командой <command>OPEN</command> как имя портала. Однако, если переменная <type>refcursor</type> имеет значение NULL, <command>OPEN</command> автоматически генерирует имя, которое не конфликтует с любым существующим порталом и присваивает его переменной <type>refcursor</type>.</para>

       <note>
        <para>Связанная курсорная переменная инициализируется в строковое значение, представляющее собой имя самой переменной. Таким образом, имя портала совпадает с именем курсорной переменной, кроме случаев, когда разработчик переопределил имя, присвоив новое значение перед открытием курсора. Несвязанная курсорная переменная инициализируется в NULL и получит автоматически сгенерированное уникальное имя, если не будет переопределена.</para>
       </note>

       <para>Следующий пример показывает один из способов передачи имени курсора вызывающему: <programlisting>CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;</programlisting></para>

       <para>В следующем примере используется автоматическая генерация имени курсора: <programlisting>CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- для использования курсоров, необходимо начать транзакцию
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;</programlisting></para>

       <para>В следующем примере показан один из способов вернуть несколько курсоров из одной функции: <programlisting>CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- для использования курсоров необходимо начать транзакцию
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;</programlisting></para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
    <title>Обработка курсора в цикле</title>

    <para>Один из вариантов цикла <command>FOR</command> позволяет перебирать строки, возвращённые курсором. Вот его синтаксис: <synopsis>
<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>
FOR <replaceable>переменная-запись</replaceable> IN <replaceable>связанная_переменная_курсора</replaceable> <optional> ( <optional> <replaceable>имя_аргумента</replaceable> := </optional> <replaceable>значение_аргумента</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>операторы</replaceable>
END LOOP <optional> <replaceable>метка</replaceable> </optional>;
</synopsis> Курсорная переменная должна быть связана с запросом при объявлении. Курсор <emphasis>не может</emphasis> быть открытым. Команда <command>FOR</command> автоматически открывает курсор и автоматически закрывает при завершении цикла. Список фактических значений аргументов должен присутствовать только в том случае, если курсор объявлялся с параметрами. Эти значения будут подставлены в запрос, также как и при выполнении <command>OPEN</command> (см. <xref remap="4" linkend="plpgsql-open-bound-cursor"/>).</para>

   <para>Данная <replaceable>переменная-запись</replaceable> автоматически определяется как переменная типа <type>record</type> и существует только внутри цикла (другие объявленные переменные с таким именем игнорируется в цикле). Каждая возвращаемая курсором строка последовательно присваивается этой переменной и выполняется тело цикла.</para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
   <title>Сообщения и ошибки</title>

  <sect2 id="plpgsql-statements-raise">
   <title>Вывод сообщений и ошибок</title>

   <indexterm><primary>RAISE</primary> <secondary>в PL/pgSQL</secondary></indexterm>

   <indexterm><primary>вывод ошибок</primary> <secondary>в PL/pgSQL</secondary></indexterm>

   <para>Команда <command>RAISE</command> предназначена для вывода сообщений и вызова ошибок. <synopsis>
RAISE <optional> <replaceable class="parameter">уровень</replaceable> </optional> '<replaceable class="parameter">формат</replaceable>' <optional>, <replaceable class="parameter">выражение</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">параметр</replaceable> = <replaceable class="parameter">значение</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">уровень</replaceable> </optional> <replaceable class="parameter">имя_условия</replaceable> <optional> USING <replaceable class="parameter">параметр</replaceable> = <replaceable class="parameter">выражение</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">уровень</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">параметр</replaceable> = <replaceable class="parameter">выражение</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">уровень</replaceable> </optional> USING <replaceable class="parameter">параметр</replaceable> = <replaceable class="parameter">выражение</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis> <replaceable class="parameter">уровень</replaceable> задаёт уровень важности ошибки. Возможные значения: <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal> и <literal>EXCEPTION</literal>. По умолчанию используется <literal>EXCEPTION</literal>. <literal>EXCEPTION</literal> вызывает ошибку (что обычно прерывает текущую транзакцию), остальные значения <replaceable class="parameter">уровня</replaceable> только генерируют сообщения с различными уровнями приоритета. Будут ли сообщения конкретного приоритета переданы клиенту или записаны в журнал сервера, или и то, и другое, зависит от конфигурационных переменных <xref linkend="guc-log-min-messages"/> и <xref linkend="guc-client-min-messages"/>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="runtime-config"/>.</para>

   <para>После указания <replaceable class="parameter">уровня</replaceable>, если оно есть, можно задать <replaceable class="parameter">формат</replaceable> (это должна быть простая строковая константа, не выражение). Строка формата определяет вид текста об ошибке, который будет выдан. За строкой формата могут следовать необязательные выражения аргументов, которые будут вставлены в сообщение. Внутри строки формата знак <literal>%</literal> заменяется строковым представлением значения очередного аргумента. Чтобы выдать символ <literal>%</literal> буквально, продублируйте его (как <literal>%%</literal>). Число аргументов должно совпадать с числом местозаполнителей <literal>%</literal> в строке формата, иначе при компиляции функции возникнет ошибка.</para>

   <para>В следующем примере символ <literal>%</literal> будет заменён на значение <literal>v_job_id</literal>: <programlisting>RAISE NOTICE 'Вызов функции cs_create_job(%)', v_job_id;</programlisting></para>

   <para>При помощи <literal>USING</literal> и последующих элементов <replaceable class="parameter">параметр</replaceable> = <replaceable class="parameter">выражение</replaceable> можно добавить дополнительную информацию к отчёту об ошибке. Все <replaceable class="parameter">выражения</replaceable> представляют собой строковые выражения. Возможные ключевые слова для <replaceable class="parameter">параметра</replaceable> следующие: <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
       <para>Устанавливает текст сообщения об ошибке. Этот параметр не может использоваться, если в команде <command>RAISE</command> присутствует <replaceable class="parameter">формат</replaceable> перед <literal>USING</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <para>Предоставляет детальное сообщение об ошибке.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <para>Предоставляет подсказку по вызванной ошибке.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <para>Устанавливает код ошибки (<literal>SQLSTATE</literal>). Код ошибки задаётся либо по имени, как показано в <xref remap="6" linkend="errcodes-appendix"/>, или напрямую, пятисимвольный код <literal>SQLSTATE</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <para>Предоставляет имя соответствующего объекта, связанного с ошибкой.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>

   <para>Этот пример прерывает транзакцию и устанавливает сообщение об ошибке с подсказкой: <programlisting>RAISE EXCEPTION 'Несуществующий ID --&gt; %', user_id
      USING HINT = 'Проверьте ваш пользовательский ID';</programlisting></para>

   <para>Следующие два примера демонстрируют эквивалентные способы задания <literal>SQLSTATE</literal>: <programlisting>RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';</programlisting></para>

   <para>У команды <command>RAISE</command> есть и другой синтаксис, в котором в качестве главного аргумента используется имя или код <literal>SQLSTATE</literal> ошибки. Например: <programlisting>RAISE division_by_zero;
RAISE SQLSTATE '22012';</programlisting> Предложение <literal>USING</literal> в этом синтаксисе можно использовать для того, чтобы переопределить стандартное сообщение об ошибке, детальное сообщение, подсказку. Ещё один вариант предыдущего примера: <programlisting>RAISE unique_violation USING MESSAGE = 'ID пользователя уже существует: ' || user_id;</programlisting></para>

   <para>Ещё один вариант — использовать <literal>RAISE USING</literal> или <literal>RAISE <replaceable class="parameter">уровень</replaceable> USING</literal>, а всё остальное записать в списке <literal>USING</literal>.</para>

   <para>И заключительный вариант, в котором <command>RAISE</command> не имеет параметров вообще. Эта форма может использоваться только в секции <literal>EXCEPTION</literal> блока и предназначена для того, чтобы повторно вызвать ошибку, которая сейчас перехвачена и обрабатывается.</para>

   <note>
    <para>До версии <productname>PostgreSQL</productname> 9.1 команда <command>RAISE</command> без параметров всегда вызывала ошибку с выходом из блока, содержащего активную секцию <literal>EXCEPTION</literal>. Эту ошибку нельзя было перехватить, даже если <command>RAISE</command> в секции <literal>EXCEPTION</literal> поместить во вложенный блок со своей секцией <literal>EXCEPTION</literal>. Это было сочтено удивительным и не совместимым с Oracle PL/SQL.</para>
   </note>

   <para>Если в команде <command>RAISE EXCEPTION</command> не задано ни имя, ни <literal>SQLSTATE</literal> код, то по умолчанию используются <literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>). В качестве текста сообщения об ошибке (если не задан) используется имя или <literal>SQLSTATE</literal> код.</para>

   <note>
    <para>При задании <literal>SQLSTATE</literal> кода необязательно использовать только список предопределённых кодов ошибок. В качестве кода ошибки может быть любое пятисимвольное значение, состоящее из цифр и/или ASCII символов в верхнем регистре, кроме <literal>00000</literal>. Не рекомендуется использовать коды ошибок, которые заканчиваются на <literal>000</literal>, потому что так обозначаются коды категорий. И чтобы их перехватить, нужно перехватывать целую категорию.</para>
   </note>

  </sect2>

  <sect2 id="plpgsql-statements-assert">
   <title>Проверка утверждений</title>

   <indexterm><primary>ASSERT</primary> <secondary>в PL/pgSQL</secondary></indexterm>

   <indexterm><primary>утверждения</primary> <secondary>в PL/pgSQL</secondary></indexterm>

   <indexterm><primary>параметр конфигурации <varname>plpgsql.check_asserts</varname></primary></indexterm>

   <para>Оператор <command>ASSERT</command> представляет удобное средство вставлять отладочные проверки в функции <application>PL/pgSQL</application>. <synopsis>
ASSERT <replaceable class="parameter">условие</replaceable> <optional> , <replaceable class="parameter">сообщение</replaceable> </optional>;
</synopsis> Здесь <replaceable class="parameter">условие</replaceable> — это булевское выражение, которое, как ожидается, должно быть всегда истинным; если это так, оператор <command>ASSERT</command> больше ничего не делает. Если же оно возвращает ложь или NULL, этот оператор выдаёт исключение <literal>ASSERT_FAILURE</literal>. (Если ошибка происходит при вычислении <replaceable class="parameter">условия</replaceable>, она выдаётся как обычная ошибка.)</para>

   <para>Если в нём задаётся необязательное <replaceable class="parameter">сообщение</replaceable>, результат этого выражения (если он не NULL) заменяет сообщение об ошибке по умолчанию <quote>assertion failed</quote> (нарушение истинности), в случае, если <replaceable class="parameter">условие</replaceable> не выполняется. В обычном случае, когда условие утверждения выполняется, выражение <replaceable class="parameter">сообщения</replaceable> не вычисляется.</para>

   <para>Проверку утверждений можно включить или отключить с помощью конфигурационного параметра <literal>plpgsql.check_asserts</literal>, принимающего булевское значение; по умолчанию она включена (<literal>on</literal>). Если этот параметр отключён (<literal>off</literal>), операторы <command>ASSERT</command> ничего не делают.</para>

   <para>Учтите, что оператор <command>ASSERT</command> предназначен для выявления программных дефектов, а не для вывода обычных ошибок (для этого используется оператор <command>RAISE</command>, описанный выше).</para>

  </sect2>

 </sect1>

 <sect1 id="plpgsql-trigger">
  <title>Триггерные процедуры</title>

  <indexterm zone="plpgsql-trigger"><primary>trigger</primary> <secondary>in PL/pgSQL</secondary></indexterm>

  <para>В <application>PL/pgSQL</application> можно создавать триггерные процедуры, которые будут вызываться при изменениях данных или событиях в базе данных. Триггерная процедура создаётся командой <command>CREATE FUNCTION</command>, при этом у функции не должно быть аргументов, а типом возвращаемого значения должен быть <type>trigger</type> (для триггеров, срабатывающих при изменениях данных) или <type>event_trigger</type> (для триггеров, срабатывающих при событиях в базе). Для триггеров автоматически определяются специальные локальные переменные с именами вида <varname>PG_<replaceable>переменная</replaceable></varname>, описывающие условие, повлекшее вызов триггера.</para>

  <sect2 id="plpgsql-dml-trigger">
   <title>Триггеры при изменении данных</title>

  <para><link linkend="triggers">Триггер при изменении данных</link> объявляется как функция без аргументов и с типом результата <type>trigger</type>. Заметьте, что эта функция должна объявляться без аргументов, даже если ожидается, что она будет получать аргументы, заданные в команде <command>CREATE TRIGGER</command> &mdash; такие аргументы передаются через <varname>TG_ARGV</varname>, как описано ниже.</para>

  <para>Когда функция на <application>PL/pgSQL</application> срабатывает как триггер, в блоке верхнего уровня автоматически создаются несколько специальных переменных: <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>Тип данных <type>RECORD</type>. Переменная содержит новую строку базы данных для команд <command>INSERT</command>/<command>UPDATE</command> в триггерах уровня строки. В триггерах уровня оператора и для команды <command>DELETE</command> этой переменной значение не присваивается.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>Тип данных <type>RECORD</type>. Переменная содержит старую строку базы данных для команд <command>UPDATE</command>/<command>DELETE</command> в триггерах уровня строки. В триггерах уровня оператора и для команды <command>INSERT</command> этой переменной значение не присваивается.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>Тип данных <type>name</type>. Переменная содержит имя сработавшего триггера.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>Тип данных <type>text</type>. Строка, содержащая <literal>BEFORE</literal>, <literal>AFTER</literal> или <literal>INSTEAD OF</literal>, в зависимости от определения триггера.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>Тип данных <type>text</type>. Строка, содержащая <literal>ROW</literal> или <literal>STATEMENT</literal>, в зависимости от определения триггера.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>Тип данных <type>text</type>. Строка, содержащая <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal> или <literal>TRUNCATE</literal>, в зависимости от того, для какой операции сработал триггер.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>Тип данных <type>oid</type>. OID таблицы, для которой сработал триггер.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>Тип данных <type>name</type>. Имя таблицы, для которой сработал триггер. Эта переменная устарела и может стать недоступной в будущих релизах. Вместо неё нужно использовать <literal>TG_TABLE_NAME</literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>Тип данных <type>name</type>. Имя таблицы, для которой сработал триггер.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>Тип данных <type>name</type>. Имя схемы, содержащей таблицу, для которой сработал триггер.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>Тип данных <type>integer</type>. Число аргументов в команде <command>CREATE TRIGGER</command>, которые передаются в триггерную процедуру.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>Тип данных массив <type>text</type>. Аргументы от оператора <command>CREATE TRIGGER</command>. Индекс массива начинается с 0. Для недопустимых значений индекса ( &lt; 0 или &gt;= <varname>tg_nargs</varname>) возвращается NULL.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

   <para>Триггерная функция должна вернуть либо <symbol>NULL</symbol>, либо запись/строку, соответствующую структуре таблице, для которой сработал триггер.</para>

   <para>Если <literal>BEFORE</literal> триггер уровня строки возвращает <symbol>NULL</symbol>, то все дальнейшие действия с этой строкой прекращаются (т. е. не срабатывают последующие триггеры, команда <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> для этой строки не выполняется). Если возвращается не <symbol>NULL</symbol>, то дальнейшая обработка продолжается именно с этой строкой. Возвращение строки отличной от начальной <varname>NEW</varname>, изменяет строку, которая будет вставлена или изменена. Поэтому, если в триггерной функции нужно выполнить некоторые действия и не менять саму строку, то нужно возвратить переменную <varname>NEW</varname> (или её эквивалент). Для того чтобы изменить сохраняемую строку, можно поменять отдельные значения в переменной <varname>NEW</varname> и затем её вернуть. Либо создать и вернуть полностью новую переменную. В случае строчного триггера <literal>BEFORE</literal> для команды <command>DELETE</command> само возвращаемое значение не имеет прямого эффекта, но оно должно быть отличным от <symbol>NULL</symbol>, чтобы не прерывать обработку строки. Обратите внимание, что переменная <varname>NEW</varname> всегда <symbol>NULL</symbol> в триггерах на <command>DELETE</command>, поэтому возвращать её не имеет смысла. Традиционной идиомой для триггеров <command>DELETE</command> является возврат переменной <varname>OLD</varname>.</para>

   <para>Триггеры <literal>INSTEAD OF</literal> (это всегда триггеры уровня строк и они могут применяться только с представлениями) могут возвращать NULL, чтобы показать, что они не выполняли никаких изменений, так что обработку этой строки можно не продолжать (то есть, не вызывать последующие триггеры и не считать строку в числе обработанных строк для окружающих команд <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>). В противном случае должно быть возвращено значение, отличное от NULL, показывающее, что триггер выполнил запрошенную операцию. Для операций <command>INSERT</command> и <command>UPDATE</command> возвращаемым значением должно быть <varname>NEW</varname>, которое триггерная функция может модифицировать для поддержки предложений <command>INSERT RETURNING</command> и <command>UPDATE RETURNING</command> (это также повлияет на значение строки, передаваемое последующим триггерам, или доступное под специальным псевдонимом <varname>EXCLUDED</varname> в операторе <command>INSERT</command> с предложением <literal>ON CONFLICT DO UPDATE</literal>). Для операций <command>DELETE</command> возвращаемым значением должно быть <varname>OLD</varname>.</para>

   <para>Возвращаемое значение для строчного триггера AFTER и триггеров уровня оператора (BEFORE или AFTER) всегда игнорируется. Это может быть и NULL. Однако, в этих триггерах по-прежнему можно прервать вызвавшую их команду, для этого нужно явно вызвать ошибку.</para>

   <para><xref linkend="plpgsql-trigger-example"/> показывает пример триггерной процедуры в <application>PL/pgSQL</application>.</para>

   <example id="plpgsql-trigger-example">
    <title>Триггерная процедура <application>PL/pgSQL</application></title>

    <para>Триггер гарантирует, что всякий раз, когда в таблице добавляется или изменяется запись, в этой записи сохраняется информация о текущем пользователе и временной метке. Также контролируется, что имя сотрудника указано и размер зарплаты выше нуля.</para>

<programlisting>CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- Проверить, что указаны имя сотрудника и зарплата
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- Кто будет работать, если за это надо будет платить?
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- Запомнить, кто и когда изменил запись
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();</programlisting>
   </example>

   <para>Другой вариант вести журнал изменений для таблицы предполагает создание новой таблицы, которая будет содержать отдельную запись для каждой выполненной команды INSERT, UPDATE, DELETE. Этот подход можно рассматривать как протоколирование изменений таблицы для аудита. <xref linkend="plpgsql-trigger-audit-example"/> показывает реализацию соответствующей триггерной процедуры в <application>PL/pgSQL</application>.</para>

   <example id="plpgsql-trigger-audit-example">
    <title>Триггерная процедура для аудита в <application>PL/pgSQL</application></title>

    <para>Триггер гарантирует, что любая команда на вставку, изменение или удаление строки в таблице <literal>emp</literal> будет записана для аудита в таблице <literal>emp_audit</literal>. Также записывается информация о пользователе, выполнившем операцию, временной метке и типе операции.</para>

<programlisting>CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- Создаем строку в emp_audit, которая отражает выполненную операцию.
        -- Воспользуемся переменной TG_OP для определения типа операции.
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
            RETURN NEW;
        END IF;
        RETURN NULL; -- возвращаемое значение для триггера AFTER не имеет значения
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();</programlisting>
   </example>

   <para>У предыдущего примера есть разновидность, которая использует представление, соединяющее основную таблицу и таблицу аудита, для отображения даты последнего изменения каждой строки. При этом подходе по-прежнему ведётся полный журнал аудита в отдельной таблице, но также имеется представление с упрощенным аудиторским следом. Это представление содержит временную метку, которая вычисляется для каждой строки из данных аудиторской таблицы. <xref linkend="plpgsql-view-trigger-audit-example"/> показывает пример триггера на представление для аудита в <application>PL/pgSQL</application>.</para>

   <example id="plpgsql-view-trigger-audit-example">
    <title>Триггер на представление для аудита в <application>PL/pgSQL</application></title>

    <para>Триггер на представление используется для того, чтобы сделать это представление изменяемым и гарантировать, что любая команда на вставку, изменение или удаление строки в представлении будет записана для аудита в таблицу <literal>emp_audit</literal>. Также записываются временная метка, имя пользователя и тип выполняемой операции. Представление показывает дату последнего изменения для каждой строки.</para>

<programlisting>CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
        -- Выполняем требуемую операцию в emp и создаем строку в emp_audit,
        -- которая отражает сделанную операцию.
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();</programlisting>
   </example>

   <para>Один из вариантов использования триггеров это поддержание в актуальном состоянии отдельной таблицы итогов для некоторой таблицы. В некоторых случаях отдельная таблица с итогами может использоваться в запросах вместо основной таблицы. При этом зачастую время выполнения запросов значительно сокращается. Эта техника широко используется в хранилищах данных, где таблицы фактов могут быть очень большими. <xref linkend="plpgsql-trigger-summary-example"/> показывает триггерную процедуру в <application>PL/pgSQL</application>, которая поддерживает таблицу итогов для таблицы фактов в хранилище данных.</para>


   <example id="plpgsql-trigger-summary-example">
    <title>Триггерная процедура в <application>PL/pgSQL</application> для поддержки таблицы итогов</title>

    <para>Представленная здесь схема данных частично основана на примере <emphasis>Grocery Store </emphasis> из книги <emphasis>The Data Warehouse Toolkit</emphasis> (автор Ralph Kimball).</para>

<programlisting>--
-- Основные таблицы: таблица измерений временных периодов и таблица фактов продаж
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- Таблица с итогами продаж по периодам
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- Функция и триггер, обновляющие столбцы с итоговыми значениями при выполнении
-- команд INSERT, UPDATE, DELETE
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -- определим на сколько произошло увеличение/уменьшение количеств
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- запрещаем изменять time_key
            -- для таких изменений больше подходит DELETE + INSERT
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Запрещено изменение time_key : % -&gt; %',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- вставляем или обновляем строку в таблице итогов.
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- ничего не делаем
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;</programlisting>
   </example>
</sect2>

  <sect2 id="plpgsql-event-trigger">
   <title>Триггеры событий</title>

   <para>В <application>PL/pgSQL</application> можно создавать <link linkend="event-triggers">событийные триггеры</link>. <productname>&productname;</productname> требует, чтобы процедура, которая вызывается как событийный триггер, объявлялась без аргументов и типом возвращаемого значения был <literal>event_trigger</literal>.</para>

   <para>Когда функция на <application>PL/pgSQL</application> вызывается как событийный триггер, в блоке верхнего уровня автоматически создаются несколько специальных переменных: <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>Тип данных <type>text</type>. Строка, содержащая событие, для которого сработал триггер.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>Тип данных <type>text</type>. Переменная, содержащая тег команды, для которой сработал триггер.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

   <para><xref linkend="plpgsql-event-trigger-example"/> показывает пример процедуры событийного триггера в <application>PL/pgSQL</application>.</para>

   <example id="plpgsql-event-trigger-example">
    <title>Процедура событийного триггера в <application>PL/pgSQL</application></title>

    <para>Этот пример триггера просто выдаёт сообщение <literal>NOTICE</literal> каждый раз, когда выполняется поддерживаемая команда.</para>

<programlisting>CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'Произошло событие: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE snitch();</programlisting>
   </example>
  </sect2>

  </sect1>

  <sect1 id="plpgsql-implementation">
   <title><application>PL/pgSQL</application> изнутри</title>

   <para>В этом разделе обсуждаются некоторые детали реализации, которые пользователям <application>PL/pgSQL</application> важно знать.</para>

  <sect2 id="plpgsql-var-subst">
   <title>Подстановка переменных</title>

   <para>SQL-операторы и выражения внутри функции на <application>PL/pgSQL</application> могут ссылаться на переменные и параметры этой функции. За кулисами <application>PL/pgSQL</application> заменяет параметры запросов для таких ссылок. Параметры будут заменены только в местах, где параметр или ссылка на столбец синтаксически допустимы. Как крайний случай, рассмотрим следующий пример плохого стиля программирования: <programlisting>INSERT INTO foo (foo) VALUES (foo);</programlisting> Первый раз <literal>foo</literal> появляется на том месте, где синтаксически должно быть имя таблицы, поэтому замены не будет, даже если функция имеет переменную <literal>foo</literal>. Второй раз <literal>foo</literal> встречается там, где должно быть имя столбца таблицы, поэтому замены не будет и здесь. Только третье вхождение <literal>foo</literal> является кандидатом на то, чтобы быть ссылкой на переменную функции.</para>

   <note>
    <para>Версии <productname>PostgreSQL</productname> до 9.0 пытаются заменить переменную во всех трёх случаях, что приводит к синтаксической ошибке.</para>
   </note>

   <para>Если имена переменных синтаксически не отличаются от названий столбцов таблицы, то возможна двусмысленность и в ссылках на таблицы. Является ли данное имя ссылкой на столбец таблицы или ссылкой на переменную? Изменим предыдущий пример: <programlisting>INSERT INTO dest (col) SELECT foo + bar FROM src;</programlisting> Здесь <literal>dest</literal> и <literal>src</literal> должны быть именами таблиц, <literal>col</literal> должен быть столбцом <literal>dest</literal>. Однако, <literal>foo</literal> и <literal>bar</literal> могут быть как переменными функции, так и столбцами <literal>src</literal>.</para>

   <para>По умолчанию, <application>PL/pgSQL</application> выдаст ошибку, если имя в операторе SQL может относиться как к переменной, так и к столбцу таблицы. Ситуацию можно исправить переименованием переменной, переименованием столбца, точной квалификацией неоднозначной ссылки или указанием <application>PL/pgSQL</application> машине, какую интерпретацию предпочесть.</para>

   <para>Самое простое решение — переименовать переменную или столбец. Общее правило кодирования предполагает использование различных соглашений о наименовании для переменных <application>PL/pgSQL</application> и столбцов таблиц. Например, если имена переменных всегда имеют вид <literal>v_<replaceable>имя</replaceable></literal>, а имена столбцов никогда не начинаются на <literal>v_</literal>, то конфликты исключены.</para>

   <para>В качестве альтернативы можно дополнить имена неоднозначных ссылок, чтобы сделать их точными. В приведённом выше примере <literal>src.foo</literal> однозначно бы определялась, как ссылка на столбец таблицы. Чтобы сделать однозначной ссылку на переменную, переменная должна быть объявлена в блоке с меткой, и далее нужно использовать эту метку (см. <xref remap="4" linkend="plpgsql-structure"/>). Например: <programlisting>&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;</programlisting> Здесь <literal>block.foo</literal> ссылается на переменную, даже если в таблице <literal>src</literal> есть столбец <literal>foo</literal>. Параметры функции, а также специальные переменные, такие как <literal>FOUND</literal>, могут быть дополнены именем функции, потому что они неявно объявлены во внешнем блоке, метка которого совпадает с именем функции.</para>

   <para>Иногда может быть не очень практичным исправлять таким способом все неоднозначные ссылки в большом куске <application>PL/pgSQL</application> кода. В таких случаях можно указать, чтобы <application>PL/pgSQL</application> разрешал неоднозначные ссылки в пользу переменных (это совместимо с <application>PL/pgSQL</application> до версии <productname>PostgreSQL</productname> 9.0), или в пользу столбцов таблицы (совместимо с некоторыми другими системами, такими как <productname>Oracle</productname>).</para>

   <indexterm><primary><varname>plpgsql.variable_conflict</varname> configuration parameter</primary></indexterm>

   <para>На уровне всей системы поведение <application>PL/pgSQL</application> регулируется установкой конфигурационного параметра <literal>plpgsql.variable_conflict</literal>, имеющего значения: <literal>error</literal>, <literal>use_variable</literal> или <literal>use_column</literal> (<literal>error</literal> устанавливается по умолчанию при установке системы). Изменение этого параметра влияет на все последующие компиляции операторов в функциях на <application>PL/pgSQL</application>, но не на операторы уже скомпилированные в текущей сессии. Так как изменение этого параметра может привести к неожиданным изменениям в поведении функций на <application>PL/pgSQL</application>, он может быть изменён только суперпользователем.</para>

   <para>Поведение <application>PL/pgSQL</application> можно изменять для каждой отдельной функции, если добавить в начало функции одну из этих специальных команд: <programlisting>#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column</programlisting> Эти команды влияют только на функцию, в которой они записаны и перекрывают действие <literal>plpgsql.variable_conflict</literal>. Пример: <programlisting>CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;</programlisting> В команде <literal>UPDATE</literal>, <literal>curtime</literal>, <literal>comment</literal> и <literal>id</literal> будут ссылаться на переменные и параметры функции вне зависимости от того, есть ли столбцы с такими именами в таблице <literal>users</literal>. Обратите внимание, что нужно дополнить именем таблицы ссылку на <literal>users.id</literal> в предложении <literal>WHERE</literal>, чтобы она ссылалась на столбец таблицы. При этом необязательно дополнять ссылку на <literal>comment</literal> в левой части списка <literal>UPDATE</literal>, так как синтаксически в этом месте должно быть имя столбца таблицы <literal>users</literal>. Эту функцию можно было бы записать и без зависимости от значения <literal>variable_conflict</literal>: <programlisting>CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;</programlisting></para>

   <para>Замена переменных не происходит в строке, исполняемой командой <command>EXECUTE</command> или её вариантом. Если нужно вставлять изменяющиеся значения в такую команду, то это делается либо при построении самой командной строки или с использованием <literal>USING</literal>, как показано в <xref remap="6" linkend="plpgsql-statements-executing-dyn"/>.</para>

   <para>Замена переменных в настоящее время работает только в командах <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</command>, потому что основная SQL машина допускает использование параметров запроса только в этих командах. Чтобы использовать изменяемые имена или значения в других типах операторов (обычно называются утилиты), необходимо построить текст команды в виде строки и выполнить её в <command>EXECUTE</command>.</para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
   <title>Кеширование плана</title>

   <para>Интерпретатор <application>PL/pgSQL</application> анализирует исходный текст функции и строит внутреннее бинарное дерево инструкций при первом вызове функции (для каждой сессии). В дерево инструкций полностью переводится вся структура операторов <application>PL/pgSQL</application>, но для выражений и команд <acronym>SQL</acronym>, используемых в функции, это происходит не сразу.</para>

   <para><indexterm><primary>preparing a query</primary> <secondary>in PL/pgSQL</secondary></indexterm> При первом выполнении в функции каждого выражения или команды <acronym>SQL</acronym> интерпретатор <application>PL/pgSQL</application> разбирает и анализирует команду для создания подготовленного к выполнению оператора с помощью функции <function>SPI_prepare</function> менеджера интерфейса программирования сервера. Последующие обращения к этому выражению или команде повторно используют подготовленный к выполнению оператор. Таким образом, <acronym>SQL</acronym>-команды, находящиеся в редко посещаемой ветке кода условного оператора, не несут накладных расходов на разбор команд, если они так и не будут выполнены в текущей сессии. Здесь есть недостаток, заключающийся в том, что ошибки в определённом выражении или команде не могут быть обнаружены, пока выполнение не дойдёт до этой части функции. (Тривиальные синтаксические ошибки обнаружатся в ходе первоначального разбора, но ничего более серьёзного не будет обнаружено до исполнения.)</para>

   <para>Кроме того, <application>PL/pgSQL</application> (точнее, менеджер интерфейса программирования сервера) будет пытаться кешировать план выполнения для любого подготовленного к исполнению оператора. При каждом вызове оператора, если не используется план из кеша, генерируется новый план выполнения, и текущие значения параметров (то есть значения переменных <application>PL/pgSQL</application>) могут быть использованы для оптимизации нового плана. Если оператор не имеет параметров или выполняется много раз, менеджер интерфейса программирования сервера рассмотрит вопрос о создании и кешировании (для повторного использования) общего плана, не зависящего от значений параметров. Как правило, это происходит в тех случаях, когда план выполнения не очень чувствителен к имеющимся ссылкам на значения переменных <application>PL/pgSQL</application>. В противном случае, выгоднее каждый раз формировать новый план. Более подробно поведение подготовленных операторов рассматривается в <xref remap="6" linkend="sql-prepare"/>.</para>

   <para>Чтобы <application>PL/pgSQL</application> мог сохранять подготовленные операторы и планы выполнения, команды SQL в коде <application>PL/pgSQL</application>, должны использовать одни и те же таблицы и столбцы при каждом исполнении. А это значит, что в SQL-командах нельзя использовать названия таблиц и столбцов в качестве параметров. Чтобы обойти это ограничение, нужно построить динамическую команду для оператора <application>PL/pgSQL</application> <command>EXECUTE</command> &mdash; ценой будет разбор и построение нового плана выполнения при каждом вызове.</para>

    <para>Изменчивая природа переменных типа <type>record</type> представляет ещё одну проблему в этой связи. Когда поля переменной типа <type>record</type> используются в выражениях или операторах, типы данных полей не должны меняться от одного вызова функции к другому, так как при анализе каждого выражения будет использоваться тот тип данных, который присутствовал при первом вызове. При необходимости можно использовать <command>EXECUTE</command> для решения этой проблемы.</para>

    <para>Если функция используется в качестве триггера более чем для одной таблицы, <application>PL/pgSQL</application> независимо подготавливает и кеширует операторы для каждой такой таблицы. То есть создаётся кеш для каждой комбинации триггерная функция + таблица, а не только для каждой функции. Это устраняет некоторые проблемы, связанные с различными типами данных. Например, триггерная функция сможет успешно работать со столбцом <literal>key</literal>, даже если в разных таблицах этот столбец имеет разные типы данных.</para>

    <para>Таким же образом, функции с полиморфными типами аргументов имеют отдельный кеш для каждой комбинации фактических типов аргументов, так что различия типов данных не вызывают неожиданных сбоев.</para>

   <para>Кеширование операторов иногда приводит к неожиданным эффектам при интерпретации чувствительных ко времени значений. Например, есть разница между тем, что делают эти две функции: <programlisting>CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;</programlisting> и <programlisting>CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;</programlisting></para>

    <para>В случае <function>logfunc1</function>, при анализе <command>INSERT</command>, основной анализатор <productname>&productname;</productname> знает, что строку <literal>'now'</literal> следует толковать как <type>timestamp</type>, потому что целевой столбец таблицы <classname>logtable</classname> имеет такой тип данных. Таким образом, <literal>'now'</literal> будет преобразовано в константу <type>timestamp</type> при анализе <command>INSERT</command>, а затем эта константа будет использоваться в последующих вызовах <function>logfunc1</function> в течение всей сессии. Разумеется, это не то, что хотел программист. Лучше было бы использовать функцию <literal>now()</literal> или <literal>current_timestamp</literal>.</para>

    <para>В случае <function>logfunc2</function>, основной анализатор <productname>&productname;</productname> не знает, какого типа будет <literal>'now'</literal> и поэтому возвращает значение типа <type>text</type>, содержащее строку <literal>now</literal>. При последующем присвоении локальной переменной <varname>curtime</varname> интерпретатор <application>PL/pgSQL</application> приводит эту строку к типу <type>timestamp</type>, вызывая функции <function>text_out</function> и <function>timestamp_in</function>. Таким образом, метка времени будет обновляться при каждом выполнении, как и ожидается программистом. И хотя всё работает как ожидалось, это ужасно неэффективно, поэтому использование функции <literal>now()</literal> по-прежнему значительно лучше.</para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
  <title>Советы по разработке на <application>PL/pgSQL</application></title>

   <para>Хороший способ разрабатывать на <application>PL/pgSQL</application> заключается в том, чтобы в одном окне с текстовым редактором по выбору создавать тексты функций, а в другом окне с <application>psql</application> загружать и тестировать эти функции. В таком случае удобно записывать функцию, используя <command>CREATE OR REPLACE FUNCTION</command>. Таким образом, можно легко загрузить файл для обновления определения функции. Например: <programlisting>CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;</programlisting></para>

   <para>В <application>psql</application>, можно загрузить или перезагрузить такой файл определения функции, выполнив: <programlisting>\i filename.sql</programlisting> а затем сразу выполнять команды SQL для тестирования функции.</para>

   <para>Ещё один хороший способ разрабатывать на <application>PL/pgSQL</application> связан с использованием GUI инструментов, облегчающих разработку на процедурном языке. Один из примеров такого инструмента <application>pgAdmin</application>, хотя есть и другие. Такие инструменты часто предоставляют удобные возможности, такие как экранирование одинарных кавычек, отладка и повторное создание функций.</para>

  <sect2 id="plpgsql-quote-tips">
   <title>Обработка кавычек</title>

   <para>Код функции на <application>PL/pgSQL</application> указывается в команде <command>CREATE FUNCTION</command> в виде строки. Если писать строку в обычном порядке, внутри одинарных кавычек, то любой символ одинарной кавычки должен быть удвоен, также как и должен быть удвоен каждый знак обратной косой черты (если используется синтаксис с экранированием в строках). Удвоение кавычек в лучшем случае утомительно, а в более сложных случаях код может стать совершенно непонятным, так как легко может потребоваться полудюжина или более кавычек идущих подряд. Вместо этого при создании тела функции рекомендуется использовать знаки доллара в качестве кавычек (см. <xref remap="4" linkend="sql-syntax-dollar-quoting"/>). При таком подходе никогда не потребуется дублировать кавычки, но придётся позаботиться о том, чтобы иметь разные долларовые разделители для каждого уровня вложенности. Например, команду <command>CREATE FUNCTION</command> можно записать так: <programlisting>CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;</programlisting> Внутри можно использовать кавычки для простых текстовых строк и <literal>$$</literal> для разграничения фрагментов SQL-команды, собираемой из отдельных строк. Если нужно взять в кавычки текст, который включает <literal>$$</literal>, можно использовать <literal>$Q$</literal>, и так далее.</para>

   <para>Следующая таблица показывает, как применяются знаки кавычек, если не используется экранирование долларами. Это может быть полезно при переводе кода, не использующего экранирование знаками доллара, в нечто более понятное.</para>

  <variablelist>
   <varlistentry>
    <term>1 кавычка</term>
    <listitem>
     <para>В начале и конце тела функции, например: <programlisting>CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;</programlisting> Внутри такой функции любая кавычка <emphasis>должна</emphasis> дублироваться.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>2 кавычки</term>
    <listitem>
     <para>Для строковых литералов внутри тела функции, например: <programlisting>a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';</programlisting> При использовании знаков доллара можно просто написать: <programlisting>a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';</programlisting> и именно это увидит исполнитель <application>PL/pgSQL</application> в обоих случаях.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>4 кавычки</term>
    <listitem>
     <para>Когда нужны одинарные кавычки в строковой константе внутри тела функции, например: <programlisting>a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''</programlisting> К <literal>a_output</literal> будет добавлено: <literal> AND name LIKE 'foobar' AND xyz</literal></para>
     <para>При использовании знаков доллара это записывается так: <programlisting>a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$</programlisting> будьте внимательны, при этом не должно быть внешнего долларового разделителя <literal>$$</literal>.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>6 кавычек</term>
    <listitem>
     <para>Когда нужны одинарные кавычки в строковой константе внутри тела функции, при этом кавычки находятся в конце строковой константы. Например: <programlisting>a_output := a_output || '' AND name LIKE ''''foobar''''''</programlisting> К <literal>a_output</literal> будет добавлено: <literal> AND name LIKE 'foobar'</literal>.</para>
     <para>При использовании знаков доллара это записывается так: <programlisting>a_output := a_output || $$ AND name LIKE 'foobar'$$</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>10 кавычек</term>
    <listitem>
     <para>Когда нужны две одиночные кавычки в строковой константе (это уже 8 кавычек), примыкающие к концу строковой константы (ещё 2). Вероятно, такое может понадобиться при разработке функции, которая генерирует другие функции, как показано в <xref remap="6" linkend="plpgsql-porting-ex2"/>. Например: <programlisting>a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';</programlisting> Значение <literal>a_output</literal> затем будет: <programlisting>if v_... like ''...'' then return ''...''; end if;</programlisting></para>
     <para>При использовании знаков доллара: <programlisting>a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;</programlisting> где предполагается, что нужны только одиночные кавычки в <literal>a_output</literal>, так как потребуется повторное взятие в кавычки перед использованием.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
  <sect2 id="plpgsql-extra-checks">
   <title>Дополнительные проверки во время компиляции</title>

   <para>Чтобы помочь найти и предупредить простые, но часто встречающиеся проблемы, <application>PL/PgSQL</application> предоставляет дополнительные <replaceable>проверки</replaceable>. Если они включены в конфигурации, то во время компиляции функций будут выдаваться дополнительные сообщения <literal>WARNING</literal> или ошибки <literal>ERROR</literal>. Функция, при компиляции которой выдавалось <literal>WARNING</literal>, при последующем выполнении не будет выдавать это сообщение и её можно протестировать в отдельной среде разработки.</para>

 <para>Для включения этих проверок используются параметры конфигурации <varname>plpgsql.extra_warnings</varname> для предупреждений и <varname>plpgsql.extra_errors</varname> для ошибок. Каждому из параметров можно присвоить список значений, разделённый через запятую, значение <literal>"none"</literal> или <literal>"all"</literal>. По умолчанию используется <literal>"none"</literal>. В настоящий момент доступна только одна проверка: <variablelist>
   <varlistentry>
    <term><varname>shadowed_variables</varname></term>
    <listitem>
     <para>Проверяет, что объявление новой переменной не скрывает ранее объявленную переменную.</para>
    </listitem>
   </varlistentry>
  </variablelist> Следующий пример показывает эффект от установки <varname>plpgsql.extra_warnings</varname> в значение <varname>shadowed_variables</varname>: <programlisting>SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION</programlisting></para>
 </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
  <title>Портирование из <productname>Oracle</productname> PL/SQL</title>

  <indexterm zone="plpgsql-porting"><primary>Oracle</primary> <secondary>портирование из PL/SQL в PL/pgSQL</secondary></indexterm>

  <indexterm zone="plpgsql-porting"><primary>PL/SQL (Oracle)</primary> <secondary>портирование в PL/pgSQL</secondary></indexterm>

  <para>В этом разделе рассматриваются различия между языками <productname>&productname;</productname> <application>PL/pgSQL</application> и Oracle <application>PL/SQL</application>, чтобы помочь разработчикам, переносящим приложения из <trademark class="registered">Oracle</trademark> в <productname>&productname;</productname>.</para>

  <para><application>PL/pgSQL</application> во многих аспектах похож на PL/SQL . Это блочно-структурированный, императивный язык, в котором все переменные должны объявляться. Присвоения, циклы, условные операторы в обоих языках похожи. Основные отличия, которые необходимо иметь в виду при портировании с <application>PL/SQL</application> в <application>PL/pgSQL</application>, следующие: <itemizedlist>
     <listitem>
      <para>Если имя, используемое в SQL-команде, может быть как именем столбца таблицы, так и ссылкой на переменную функции, то <application>PL/SQL</application> считает, что это имя столбца таблицы. Это соответствует поведению <application>PL/pgSQL</application> при <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>, что не является значением по умолчанию, как описано в <xref remap="6" linkend="plpgsql-var-subst"/>. В первую очередь, было бы правильно избегать таких двусмысленностей, но если требуется портировать большое количество кода, зависящее от данного поведения, то установка переменной <literal>variable_conflict</literal> может быть лучшим решением.</para>
     </listitem>

     <listitem>
      <para>В <productname>&productname;</productname> тело функции должно быть записано в виде строки. Поэтому нужно использовать знак доллара в качестве кавычек или экранировать одиночные кавычки в теле функции. (См. <xref remap="4" linkend="plpgsql-quote-tips"/>.)</para>
     </listitem>

     <listitem>
      <para>Имена типов данных часто требуют корректировки. Например, в Oracle строковые значения часто объявляются с типом <type>varchar2</type>, не являющимся стандартным типом SQL. В <productname>&productname;</productname> вместо него нужно использовать <type>varchar</type> или <type>text</type>. Подобным образом, тип <type>number</type> нужно заменять на <type>numeric</type> или другой числовой тип, если найдётся более подходящий.</para>
     </listitem>

     <listitem>
      <para>Для группировки функций вместо пакетов используются схемы.</para>
     </listitem>

     <listitem>
      <para>Так как пакетов нет, нет и пакетных переменных. Это несколько раздражает. Вместо этого можно хранить состояние каждого сеанса во временных таблицах.</para>
     </listitem>

     <listitem>
      <para>Целочисленные циклы <command>FOR</command> с указанием <literal>REVERSE</literal> работают по-разному. В <application>PL/SQL</application> значение счётчика уменьшается от второго числа к первому, в то время как в <application>PL/pgSQL</application> счётчик уменьшается от первого ко второму. Поэтому при портировании нужно менять местами границы цикла. Это печально, но вряд ли будет изменено. (См. <xref remap="4" linkend="plpgsql-integer-for"/>.)</para>
     </listitem>

     <listitem>
      <para>Циклы <command>FOR</command> по запросам (не курсорам) также работают по-разному. Переменная цикла должна быть объявлена, в то время как в <application>PL/SQL</application> она объявляется неявно. Преимущество в том, что значения переменных доступны и после выхода из цикла.</para>
     </listitem>

     <listitem>
      <para>Существуют некоторые отличия в нотации при использовании курсорных переменных.</para>
     </listitem>

    </itemizedlist></para>

  <sect2>
   <title>Примеры портирования</title>

   <para><xref linkend="pgsql-porting-ex1"/> показывает, как портировать простую функцию из <application>PL/SQL</application> в <application>PL/pgSQL</application>.</para>

   <example id="pgsql-porting-ex1">
    <title>Портирование простой функции из <application>PL/SQL</application> в <application>PL/pgSQL</application></title>

    <para>Функция <productname>Oracle</productname> <application>PL/SQL</application>: <programlisting>CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
                                                  v_version varchar2)
RETURN varchar2 IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;</programlisting></para>

    <para>Пройдемся по этой функции и посмотрим различия по сравнению с <application>PL/pgSQL</application>: <itemizedlist>
      <listitem>
       <para>Имя типа <type>varchar2</type> нужно сменить на <type>varchar</type> или <type>text</type>. В примерах данного раздела мы будем использовать <type>varchar</type>, но обычно лучше выбрать <type>text</type>, если не требуется ограничивать длину строк.</para>
      </listitem>

      <listitem>
       <para>Ключевое слово <literal>RETURN</literal> в прототипе функции (не в теле функции) заменяется на <literal>RETURNS</literal> в <productname>&productname;</productname>. Кроме того, <literal>IS</literal> становится <literal>AS</literal>, и нужно добавить предложение <literal>LANGUAGE</literal>, потому что <application>PL/pgSQL</application> — не единственный возможный язык.</para>
      </listitem>

      <listitem>
       <para>В <productname>&productname;</productname> тело функции является строкой, поэтому нужно использовать кавычки или знаки доллара. Это заменяет завершающий <literal>/</literal> в подходе Oracle.</para>
      </listitem>

      <listitem>
       <para>Команда <literal>show errors</literal> не существует в <productname>&productname;</productname> и не требуется, так как ошибки будут выводиться автоматически.</para>
      </listitem>
     </itemizedlist></para>

    <para>Вот как эта функция будет выглядеть после портирования в <productname>&productname;</productname>: <programlisting>CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;</programlisting></para>
   </example>

   <para><xref linkend="plpgsql-porting-ex2"/> показывает, как портировать функцию, которая создаёт другую функцию, и как обрабатывать проблемы с кавычками.</para>

   <example id="plpgsql-porting-ex2">
    <title>Портирование функции, создающей другую функцию, из <application>PL/SQL</application> в <application>PL/pgSQL</application></title>

    <para>Следующая процедура получает строки из <command>SELECT</command> и строит большую функцию, в целях эффективности возвращающую результат в операторах <literal>IF</literal>.</para>

    <para>Версия Oracle: <programlisting>CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;</programlisting></para>

    <para>В конечном итоге в <productname>&productname;</productname> эта функция может выглядеть так: <programlisting>CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;</programlisting> Обратите внимание, что тело функции строится отдельно, с использованием <literal>quote_literal</literal> для удвоения кавычек. Эта техника необходима, потому что мы не можем безопасно использовать знаки доллара при определении новой функции: мы не знаем наверняка, какие строки будут вставлены из <structfield>referrer_key.key_string</structfield>. (Мы предполагаем, что <structfield>referrer_key.kind</structfield> всегда имеет значение из списка: <literal>host</literal>, <literal>domain</literal> или <literal>url</literal>, но <structfield>referrer_key.key_string</structfield> может быть чем угодно, в частности, может содержать знаки доллара.) На самом деле, в этой функций есть улучшение по сравнению с оригиналом Oracle, потому что не будет генерироваться неправильный код, когда <structfield>referrer_key.key_string</structfield> или <structfield>referrer_key.referrer_type</structfield> содержат кавычки.</para>
   </example>

   <para><xref linkend="plpgsql-porting-ex3"/> показывает, как портировать функцию с выходными параметрами (<literal>OUT</literal>) и манипулирующую строками. В <productname>&productname;</productname> нет встроенной функции <function>instr</function>, но её можно создать, используя комбинацию других функций. В <xref linkend="plpgsql-porting-appendix"/> приведена реализации <function>instr</function> на <application>PL/pgSQL</application>, которая может быть полезна вам при портировании ваших функций.</para>

   <example id="plpgsql-porting-ex3">
    <title>Портирование из <application>PL/SQL</application> в <application>PL/pgSQL</application> процедуры, которая манипулирует строками и содержит <literal>OUT</literal> параметры</title>

    <para>Следующая процедура на языке <productname>Oracle</productname> PL/SQL разбирает URL и возвращает составляющие его элементы (сервер, путь и запрос).</para>

    <para>Версия Oracle: <programlisting>CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR2,
    v_host OUT VARCHAR2,  -- Возвращается обратно
    v_path OUT VARCHAR2,  -- И это тоже
    v_query OUT VARCHAR2) -- И это
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;</programlisting></para>

    <para>Вот возможная трансляция в <application>PL/pgSQL</application>: <programlisting>CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- Возвращается обратно
    v_path OUT VARCHAR,  -- И это возвращается
    v_query OUT VARCHAR) -- И это
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;</programlisting> Эту функцию можно использовать так: <programlisting>SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');</programlisting></para>
   </example>

   <para><xref linkend="plpgsql-porting-ex4"/> показывает, как портировать процедуру, использующую большое количество специфических для Oracle возможностей.</para>

   <example id="plpgsql-porting-ex4">
    <title>Портирование процедуры из <application>PL/SQL</application> в <application>PL/pgSQL</application></title>

    <para>Версия Oracle: <programlisting>CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<co id="co.plpgsql-porting-pragma"/>
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id="co.plpgsql-porting-locktable"/>

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- снять блокировку <co id="co.plpgsql-porting-commit"/>
        raise_application_error(-20000,
                 'Не удалось создать новое задание. Задание сейчас выполняется.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- ничего не делать, если задание уже есть
    END;
    COMMIT;
END;
/
show errors</programlisting></para>

   <para>Подобные процедуры легко преобразуются в функции <productname>&productname;</productname>, возвращающие <type>void</type>. На примере этой процедуры можно научиться следующему: <calloutlist>
     <callout arearefs="co.plpgsql-porting-pragma">
      <para>В <productname>&productname;</productname> нет оператора <literal>PRAGMA</literal>.</para>
     </callout>

     <callout arearefs="co.plpgsql-porting-locktable">
      <para>Если выполнить <command>LOCK TABLE</command> в <application>PL/pgSQL</application>, блокировка не будет снята, пока не завершится вызывающая транзакция.</para>
     </callout>

     <callout arearefs="co.plpgsql-porting-commit">
      <para>В функции на <application>PL/pgSQL</application> нельзя использовать <command>COMMIT</command>. Функция работает в рамках некоторой внешней транзакции, и поэтому <command>COMMIT</command> будет означать прекращение выполнения функции. Однако, в данном конкретном случае, в этом нет необходимости, потому что блокировка, полученная командой <command>LOCK TABLE</command>, будет снята при вызове ошибки.</para>
     </callout>
    </calloutlist></para>

   <para>В <application>PL/pgSQL</application> эту процедуру можно портировать так: <programlisting>CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        RAISE EXCEPTION 'Не удалось создать новое задание. Задание сейчас выполняется.';<co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN <co id="co.plpgsql-porting-exception"/>
            -- ничего не делать, если задание уже есть
    END;
END;
$$ LANGUAGE plpgsql;</programlisting> <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>Синтаксис <literal>RAISE</literal> существенно отличается от Oracle, хотя основной вариант <literal>RAISE</literal> <replaceable class="parameter">имя_исключения</replaceable> работает похоже.</para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>Имена исключений, поддерживаемые <application>PL/pgSQL</application>, отличаются от исключений в Oracle. Количество встроенных имён исключений значительно больше (см. <xref remap="4" linkend="errcodes-appendix"/>). В настоящее время нет способа задать пользовательское имя исключения, хотя вместо этого можно вызывать ошибку с заданным пользователем значением SQLSTATE.</para>
     </callout>
    </calloutlist> Основное функциональное отличие между этой процедурой и Oracle эквивалента в том, что монопольная блокировка таблицы <literal>cs_jobs</literal> будет продолжаться до окончания вызывающей транзакции. Кроме того, если впоследствии работа вызывающей программы прервётся (например из-за ошибки), произойдёт откат всех действий, выполненных в этой процедуре.</para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
   <title>На что ещё обратить внимание</title>

   <para>В этом разделе рассматриваются ещё несколько вещей, на которые нужно обращать внимание при портировании функций из Oracle <application>PL/SQL</application> в <productname>&productname;</productname>.</para>

   <sect3 id="plpgsql-porting-exceptions">
    <title>Неявный откат изменений после возникновения исключения</title>

    <para>В <application>PL/pgSQL</application> при перехвате исключения в секции <literal>EXCEPTION</literal> все изменения в базе данных с начала блока автоматически откатываются. В Oracle это эквивалентно следующему: <programlisting>BEGIN
    SAVEPOINT s1;
    ... здесь код ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... здесь код ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... здесь код ...
END;</programlisting> При портировании процедуры Oracle, которая использует <command>SAVEPOINT</command> и <command>ROLLBACK TO</command> в таком же стиле, задача простая: достаточно убрать операторы <command>SAVEPOINT</command> и <command>ROLLBACK TO</command>. Если же <command>SAVEPOINT</command> и <command>ROLLBACK TO</command> используются по-другому, то придётся подумать.</para>
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <para><application>PL/pgSQL</application> версия <command>EXECUTE</command> работает аналогично версии в <application>PL/SQL</application>, но нужно помнить об использовании <function>quote_literal</function> и <function>quote_ident</function>, как описано в <xref remap="6" linkend="plpgsql-statements-executing-dyn"/>. Без использования этих функций конструкции типа <literal>EXECUTE 'SELECT * FROM $1';</literal> будут работать ненадёжно.</para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
    <title>Оптимизация функций на <application>PL/pgSQL</application></title>

    <para>Для оптимизации исполнения <productname>&productname;</productname> предоставляет два модификатора при создании функции: <quote>изменчивость</quote> (будет ли функция всегда возвращать тот же результат при тех же аргументах) и <quote>строгость</quote> (возвращает ли функция NULL, если хотя бы один из аргументов NULL). Для получения подробной информации обратитесь к справочной странице <xref linkend="sql-createfunction"/>.</para>

    <para>При использовании этих атрибутов оптимизации оператор <command>CREATE FUNCTION</command> может выглядеть примерно так: <programlisting>CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;</programlisting></para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
   <title>Приложение</title>

   <para>Этот раздел содержит код для совместимых с Oracle функций <function>instr</function>, которые можно использовать для упрощения портирования.</para>

   <indexterm><primary>функция <function>instr</function></primary></indexterm>

<programlisting>--
-- instr functions that mimic Oracle's counterpart
-- Syntax: instr(string1, string2, [n], [m]) where [] denotes optional parameters.
--
-- Searches string1 beginning at the nth character for the mth occurrence
-- of string2.  If n is negative, search backwards.  If m is not passed,
-- assume 1 (search starts at first character).
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;</programlisting>
  </sect2>

 </sect1>

</chapter>
