<!-- doc/src/xml/xml2.xml -->

<sect1 id="xml2" xreflabel="xml2">
 <title>xml2</title>

 <indexterm zone="xml2"><primary>xml2</primary></indexterm>

 <para>Модуль <filename>xml2</filename> предоставляет функции для выполнения запросов XPath и преобразований XSLT.</para>

 <sect2>
  <title>Уведомление об актуальности</title>

  <para>Начиная с <productname>PostgreSQL</productname> 8.3, функциональность, связанная с XML, основана на стандарте SQL/XML и включена в ядро сервера. Эта функциональность охватывает проверку синтаксиса XML и запросы XPath, что в частности делает и этот модуль, но он имеет абсолютно несовместимый API. Этот модуль планируется удалить в будущей версии &productname; в пользу нового стандартного API, так что мы рекомендуем вам попробовать перевести свои приложения на новый API. Если вы обнаружите, что какая-то функциональность этого модуля не представлена новым API в подходящей форме, пожалуйста, напишите о вашем затруднении в <email>pgsql-hackers@postgresql.org</email>, чтобы этот недостаток был рассмотрен и, возможно, устранён.</para>
 </sect2>

 <sect2>
  <title>Описание функций</title>

  <para>Функции, предоставляемые этим модулем, перечислены в <xref remap="6" linkend="xml2-functions-table"/>. Эти функции позволяют выполнять простой разбор XML и запросы XPath. Все их аргументы имеют тип <type>text</type>, поэтому для краткости типы опущены.</para>

  <table id="xml2-functions-table">
   <title>Функции</title>
   <tgroup cols="3">
   <thead>
     <row>
      <entry>Функция</entry>
      <entry>Возвращает</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <function>xml_is_well_formed(document)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <para>Эта функция разбирает текст документа, переданный в параметре, и возвращает true, если это правильно сформированный XML. (Замечание: до PostgreSQL 8.2 эта функция называлась <function>xml_valid()</function>. Это имя было некорректным, так как понятия правильности формата (well-formed) и допустимости (valid) в XML различаются. Старое имя по-прежнему сохраняется, но считается устаревшим.)</para>
      </entry>
     </row>
     <row>
      <entry>
        <function>xpath_string(document, query)</function>
      </entry>
      <entry>
       <type>text</type>
      </entry>
      <entry morerows="2">
       <para>Эти функции обрабатывают запрос XPath для переданного документа и приводят результат к указанному типу.</para>
      </entry>
     </row>
     <row>
      <entry>
       <function>xpath_number(document, query)</function>
      </entry>
      <entry>
       <type>float4</type>
      </entry>
     </row>
     <row>
      <entry>
       <function>xpath_bool(document, query)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
     </row>
     <row>
      <entry>
        <function>xpath_nodeset(document, query, toptag, itemtag)</function>
      </entry>
      <entry>
       <type>text</type>
      </entry>
      <entry>
       <para>Эта функция обрабатывает запрос для документа и помещает результат внутрь XML-тегов. Если результат содержит несколько значений, она выдаст: <synopsis>
&lt;toptag&gt;
&lt;itemtag&gt;Значение 1, которое может быть фрагментом XML&lt;/itemtag&gt;
&lt;itemtag&gt;Значение 2....&lt;/itemtag&gt;
&lt;/toptag&gt;
</synopsis> Если <literal>toptag</literal> или <literal>itemtag</literal> — пустая строка, соответствующий тег опускается.</para>
      </entry>
     </row>
     <row>
      <entry>
        <function>xpath_nodeset(document, query)</function>
      </entry>
      <entry>
       <type>text</type>
      </entry>
      <entry>
       <para>Подобна <function>xpath_nodeset(document, query, toptag, itemtag)</function>, но выводит результат без обоих тегов.</para>
      </entry>
     </row>
     <row>
      <entry>
        <function>xpath_nodeset(document, query, itemtag)</function>
      </entry>
      <entry>
       <type>text</type>
      </entry>
      <entry>
       <para>Подобна <function>xpath_nodeset(document, query, toptag, itemtag)</function>, но выводит результат без <literal>toptag</literal>.</para>
      </entry>
     </row>
     <row>
      <entry>
        <function>xpath_list(document, query, separator)</function>
      </entry>
      <entry>
       <type>text</type>
      </entry>
      <entry>
       <para>Эта функция возвращает несколько значений, вставляя между ними заданный разделитель, например: <literal>Значение 1,Значение 2,Значение 3</literal>, если разделитель — знак <literal>,</literal>.</para>
      </entry>
     </row>
     <row>
      <entry>
        <function>xpath_list(document, query)</function>
      </entry>
      <entry>
       <type>text</type>
      </entry>
      <entry>Это обёртка предыдущей функции, устанавливающая в качестве разделителя знак <literal>,</literal>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
  <title><literal>xpath_table</literal></title>

  <indexterm><primary>xpath_table</primary></indexterm>

<synopsis>xpath_table(text key, text document, text relation, text xpaths, text criteria) returns setof record</synopsis>

  <para>Табличная функция <function>xpath_table</function> выполняет набор запросов XPath для каждого из набора документов и возвращает результаты в виде таблицы. В первом столбце результата возвращается первичный ключ из таблицы документов, так что результат оказывается готовым к применению в соединениях. Параметры функции описаны в <xref remap="6" linkend="xml2-xpath-table-parameters"/>.</para>

  <table id="xml2-xpath-table-parameters">
   <title>Параметры <function>xpath_table</function></title>
   <tgroup cols="2">
     <thead>
     <row>
      <entry>Параметр</entry>
      <entry>Описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><parameter>key</parameter></entry>
      <entry>
       <para>имя <quote>ключевого</quote> поля &mdash; содержимое этого поля просто окажется в первом столбце выходной таблицы, то есть оно указывает на запись, из которой была получена определённая выходная строка (см. замечание о нескольких значениях ниже)</para>
      </entry>
     </row>
     <row>
      <entry><parameter>document</parameter></entry>
      <entry>
       <para>имя поля, содержащего XML-документ</para>
      </entry>
     </row>
     <row>
      <entry><parameter>relation</parameter></entry>
      <entry>
       <para>имя таблицы (или представления), содержащей документы</para>
      </entry>
     </row>
     <row>
      <entry><parameter>xpaths</parameter></entry>
      <entry>
       <para>одно или несколько выражений XPath, разделённых символом <literal>|</literal></para>
      </entry>
     </row>
     <row>
      <entry><parameter>criteria</parameter></entry>
      <entry>
       <para>содержимое предложения WHERE. Оно не может быть пустым, так что если вам нужно обработать все строки в отношении, напишите <literal>true</literal> или <literal>1=1</literal></para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>Эти параметры (за исключением строк XPath) просто подставляются в обычный оператор SQL SELECT, так что у вас есть определённая гибкость &mdash; оператор выглядит так:</para>

  <para>
   <literal>SELECT &lt;key&gt;, &lt;document&gt; FROM &lt;relation&gt; WHERE &lt;criteria&gt;</literal>
  </para>

  <para>поэтому в этих параметрах можно передать <emphasis>всё</emphasis>, что будет корректно воспринято в этих позициях. Этот SELECT должен возвращать ровно два столбца (что и будет иметь место, если только вы не перечислите несколько полей в параметрах key или document). Будьте осторожны — при таком примитивном подходе обязательно нужно проверять все значения, получаемые от пользователя, во избежание атак с инъекцией SQL.</para>

  <para>Эта функция предназначена для использования в выражении <literal>FROM</literal>, с предложением <literal>AS</literal>, задающим выходные столбцы; например: <programlisting>SELECT * FROM
xpath_table('article_id',
            'article_xml',
            'articles',
            '/article/author|/article/pages|/article/title',
            'date_entered &gt; ''2003-01-01'' ')
AS t(article_id integer, author text, page_count integer, title text);</programlisting> Предложение <literal>AS</literal> определяет имена и типы столбцов в выходной таблице. Первым определяется <quote>ключевое</quote> поле, а за ним поля, соответствующие запросам XPath. Если запросов XPath больше, чем столбцов в результате, лишние запросы будут игнорироваться. Если же результирующих столбцов больше, чем запросов XPath, дополнительные столбцы принимают значение NULL.</para>

  <para>Заметьте, что в этом примере столбец результата <structname>page_count</structname> определён как целочисленный. Данная функция внутри имеет дело со строковыми значениями, так что, когда вы указываете, что в результате нужно получить целое число, она берёт текстовое представление результата XPath и, применяя функции ввода &productname;, преобразует её в целое число (или в тот тип, который указан в предложении <type>AS</type>). Если она не сможет сделать это, произойдёт ошибка &mdash; например, если результат пустой &mdash; так что если вы допускаете возможность таких проблем с данными, возможно, будет лучше просто оставить для столбца тип <type>text</type>.</para>

  <para>Вызывающий оператор <command>SELECT</command> не обязательно должен быть простым <literal>SELECT *</literal> &mdash; он может обращаться к выходным столбцам по именам и соединять их с другими таблицами. Эта функция формирует виртуальную таблицу, с которой вы можете выполнять любые операции, какие пожелаете (например, агрегировать, соединять, сортировать данные и т. д.). Поэтому возможен и такой запрос: <programlisting>SELECT t.title, p.fullname, p.email
FROM xpath_table('article_id', 'article_xml', 'articles',
                 '/article/title|/article/author/@id',
                 'xpath_string(article_xml,''/article/@date'') &gt; ''2003-03-20'' ')
       AS t(article_id integer, title text, author_id integer),
     tblPeopleInfo AS p
WHERE t.author_id = p.person_id;</programlisting> в качестве более сложного примера. Разумеется, для удобства вы можете завернуть весь этот запрос в представление.</para>

  <sect3>
   <title>Результаты с набором значений</title>

   <para>Функция <function>xpath_table</function> рассчитана на то, что результатом каждого запроса XPath может быть набор данных, так что количество возвращённых этой функцией строк может не совпадать с количеством входных документов. В первой строке возвращается первый результат каждого запроса, во второй — второй результат и т. д. Если один из запросов возвращает меньше значений, чем другие, вместо недостающих значений будет возвращаться NULL.</para>

   <para>В некоторых случаях пользователь знает, что некоторый запрос XPath будет возвращать только один результат (возможно, уникальный идентификатор документа) &mdash; если он используется рядом с запросом XPath, возвращающим несколько результатов, результат с одним значением будет выведен только в первой выходной строке. Чтобы исправить это, можно воспользоваться полем ключа и соединить результат с более простым запросом XPath. Например: <programlisting>CREATE TABLE test (
    id int PRIMARY KEY,
    xml text
);

INSERT INTO test VALUES (1, '&lt;doc num="C1"&gt;
&lt;line num="L1"&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;c&gt;3&lt;/c&gt;&lt;/line&gt;
&lt;line num="L2"&gt;&lt;a&gt;11&lt;/a&gt;&lt;b&gt;22&lt;/b&gt;&lt;c&gt;33&lt;/c&gt;&lt;/line&gt;
&lt;/doc&gt;');

INSERT INTO test VALUES (2, '&lt;doc num="C2"&gt;
&lt;line num="L1"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;
&lt;line num="L2"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;
&lt;/doc&gt;');

SELECT * FROM
  xpath_table('id','xml','test',
              '/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
              'true')
  AS t(id int, doc_num varchar(10), line_num varchar(10), val1 int, val2 int, val3 int)
WHERE id = 1 ORDER BY doc_num, line_num

 id | doc_num | line_num | val1 | val2 | val3
----+---------+----------+------+------+------
  1 | C1      | L1       |    1 |    2 |    3
  1 |         | L2       |   11 |   22 |   33</programlisting></para>

   <para>Чтобы получить <literal>doc_num</literal> в каждой строке, можно вызывать <function>xpath_table</function> дважды и соединить результаты: <programlisting>SELECT t.*,i.doc_num FROM
  xpath_table('id', 'xml', 'test',
              '/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
              'true')
    AS t(id int, line_num varchar(10), val1 int, val2 int, val3 int),
  xpath_table('id', 'xml', 'test', '/doc/@num', 'true')
    AS i(id int, doc_num varchar(10))
WHERE i.id=t.id AND i.id=1
ORDER BY doc_num, line_num;

 id | line_num | val1 | val2 | val3 | doc_num
----+----------+------+------+------+---------
  1 | L1       |    1 |    2 |    3 | C1
  1 | L2       |   11 |   22 |   33 | C1
(2 rows)</programlisting></para>
  </sect3>
 </sect2>

 <sect2>
  <title>Функции XSLT</title>

  <para>Если установлена libxslt, доступны следующие функции:</para>

  <sect3>
   <title><literal>xslt_process</literal></title>

  <indexterm><primary>xslt_process</primary></indexterm>

<synopsis>xslt_process(text document, text stylesheet, text paramlist) returns text</synopsis>

   <para>Эта функция применяет стиль XSL к документу и возвращает результат преобразования. В <literal>paramlist</literal> передаётся список присвоений значений параметрам, которые будут использоваться в преобразовании, в форме <literal>a=1,b=2</literal>. Учтите, что разбор параметров выполнен очень просто: значения параметров не могут содержать запятые!</para>

   <para>Есть также версия <function>xslt_process</function> с двумя аргументами, которая не передаёт никакие параметры преобразованию.</para>
  </sect3>
 </sect2>

 <sect2>
  <title>Автор</title>

  <para>Джон Грей <email>jgray@azuli.co.uk</email></para>

  <para>Разработку этого модуля спонсировала компания Torchbox Ltd. (www.torchbox.com). Этот модуль выпускается под той же лицензией BSD, что и &productname;.</para>
 </sect2>

</sect1>
