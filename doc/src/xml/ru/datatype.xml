<!-- doc/src/xml/datatype.xml -->

 <chapter id="datatype">
  <title>Типы данных</title>

  <indexterm zone="datatype"><primary>тип данных</primary></indexterm>

  <indexterm><primary>тип</primary> <see>тип данных</see></indexterm>

  <para><productname>&productname;</productname> предоставляет пользователям богатый ассортимент встроенных типов данных. Кроме того, пользователи могут создавать свои типы в <productname>&productname;</productname>, используя команду <xref linkend="sql-createtype"/>.</para>

  <para><xref linkend="datatype-table"/> содержит все встроенные типы данных общего пользования. Многие из альтернативных имён, приведённых в столбце <quote>Псевдонимы</quote>, используются внутри <productname>&productname;</productname> по историческим причинам. В этот список не включены некоторые устаревшие типы и типы для внутреннего применения.</para>

   <table id="datatype-table">
    <title>Типы данных</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Имя</entry>
       <entry>Псевдонимы</entry>
       <entry>Описание</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>знаковое целое из 8 байт</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>восьмибайтное целое с автоувеличением</entry>
      </row>

      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry/>
       <entry>битовая строка фиксированной длины</entry>
      </row>

      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit</type></entry>
       <entry>битовая строка переменной длины</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>логическое значение (true/false)</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry/>
       <entry>прямоугольник в плоскости</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry/>
       <entry>двоичные данные (<quote>массив байт</quote>)</entry>
      </row>

      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>символьная строка фиксированной длины</entry>
      </row>

      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>символьная строка переменной длины</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry/>
       <entry>сетевой адрес IPv4 или IPv6</entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry/>
       <entry>круг в плоскости</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry/>
       <entry>календарная дата (год, месяц, день)</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>число двойной точности с плавающей точкой (8 байт)</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry/>
       <entry>адрес узла IPv4 или IPv6</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>знаковое четырёхбайтное целое</entry>
      </row>

      <row>
       <entry><type>interval [ <replaceable>поля</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry/>
       <entry>интервал времени</entry>
      </row>

      <row>
       <entry><type>json</type></entry>
       <entry/>
       <entry>текстовые данные JSON</entry>
      </row>

      <row>
       <entry><type>jsonb</type></entry>
       <entry/>
       <entry>двоичные данные JSON, разобранные</entry>
      </row>

      <row>
       <entry><type>line</type></entry>
       <entry/>
       <entry>прямая в плоскости</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry/>
       <entry>отрезок в плоскости</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry/>
       <entry>MAC-адрес</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry/>
       <entry>денежная сумма</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>, <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>, <replaceable>s</replaceable>) ]</type></entry>
       <entry>вещественное число заданной точности</entry>
      </row>

      <row>
       <entry><type>path</type></entry>
       <entry/>
       <entry>геометрический путь в плоскости</entry>
      </row>

      <row>
       <entry><type>pg_lsn</type></entry>
       <entry/>
       <entry>Последовательный номер в журнале <productname>&productname;</productname></entry>
      </row>

      <row>
       <entry><type>point</type></entry>
       <entry/>
       <entry>геометрическая точка в плоскости</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry/>
       <entry>замкнутый геометрический путь в плоскости</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>число одинарной точности с плавающей точкой (4 байта)</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>знаковое двухбайтное целое</entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
       <entry>двухбайтное целое с автоувеличением</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>четырёхбайтное целое с автоувеличением</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry/>
       <entry>символьная строка переменной длины</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry/>
       <entry>время суток (без часового пояса)</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>время суток с учётом часового пояса</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry/>
       <entry>дата и время (без часового пояса)</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>дата и время с учётом часового пояса</entry>
      </row>

      <row>
       <entry><type>tsquery</type></entry>
       <entry/>
       <entry>запрос текстового поиска</entry>
      </row>

      <row>
       <entry><type>tsvector</type></entry>
       <entry/>
       <entry>документ для текстового поиска</entry>
      </row>

      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry/>
       <entry>снимок идентификатора транзакций</entry>
      </row>

      <row>
       <entry><type>uuid</type></entry>
       <entry/>
       <entry>универсальный уникальный идентификатор</entry>
      </row>

      <row>
       <entry><type>xml</type></entry>
       <entry/>
       <entry>XML-данные</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <title>Совместимость</title>
   <para>В стандарте <acronym>SQL</acronym> описаны следующие типы (или их имена): <type>bigint</type>, <type>bit</type>, <type>bit varying</type>, <type>boolean</type>, <type>char</type>, <type>character varying</type>, <type>character</type>, <type>varchar</type>, <type>date</type>, <type>double precision</type>, <type>integer</type>, <type>interval</type>, <type>numeric</type>, <type>decimal</type>, <type>real</type>, <type>smallint</type>, <type>time</type> (с часовым поясом и без), <type>timestamp</type> (с часовым поясом и без), <type>xml</type>.</para>
  </note>

  <para>Каждый тип данных имеет внутреннее представление, скрытое функциями ввода и вывода. При этом многие встроенные типы стандартны и имеют очевидные внешние форматы. Однако есть типы, уникальные для <productname>&productname;</productname>, например геометрические пути, и есть типы, которые могут иметь разные форматы, например, дата и время. Некоторые функции ввода и вывода не являются в точности обратными друг к другу, то есть результат функции вывода может не совпадать со входным значением из-за потери точности.</para>

  <sect1 id="datatype-numeric">
   <title>Числовые типы</title>

   <indexterm zone="datatype-numeric"><primary>тип данных</primary> <secondary>numeric</secondary></indexterm>

   <para>Числовые типы включают двух-, четырёх- и восьмибайтные целые, четырёх- и восьмибайтные числа с плавающей точкой, а также десятичные числа с задаваемой точностью. Все эти типы перечислены в <xref remap="6" linkend="datatype-numeric-table"/>.</para>

    <table id="datatype-numeric-table">
     <title>Числовые типы</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Размер</entry>
        <entry>Описание</entry>
        <entry>Диапазон</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>smallint</type></entry>
        <entry>2 байта</entry>
        <entry>целое в небольшом диапазоне</entry>
        <entry>-32768 .. +32767</entry>
       </row>
       <row>
        <entry><type>integer</type></entry>
        <entry>4 байта</entry>
        <entry>типичный выбор для целых чисел</entry>
        <entry>-2147483648 .. +2147483647</entry>
       </row>
       <row>
        <entry><type>bigint</type></entry>
        <entry>8 байт</entry>
        <entry>целое в большом диапазоне</entry>
        <entry>-9223372036854775808 .. 9223372036854775807</entry>
       </row>

       <row>
        <entry><type>decimal</type></entry>
        <entry>переменный</entry>
        <entry>вещественное число с указанной точностью</entry>
        <entry>до 131072 цифр до десятичной точки и до 16383 &mdash; после</entry>
       </row>
       <row>
        <entry><type>numeric</type></entry>
        <entry>переменный</entry>
        <entry>вещественное число с указанной точностью</entry>
        <entry>до 131072 цифр до десятичной точки и до 16383 &mdash; после</entry>
       </row>

       <row>
        <entry><type>real</type></entry>
        <entry>4 байта</entry>
        <entry>вещественное число с переменной точностью</entry>
        <entry>точность в пределах 6 десятичных цифр</entry>
       </row>
       <row>
        <entry><type>double precision</type></entry>
        <entry>8 байт</entry>
        <entry>вещественное число с переменной точностью</entry>
        <entry>точность в пределах 15 десятичных цифр</entry>
       </row>

       <row>
        <entry><type>smallserial</type></entry>
        <entry>2 байта</entry>
        <entry>небольшое целое с автоувеличением</entry>
        <entry>1 .. 32767</entry>
       </row>

       <row>
        <entry><type>serial</type></entry>
        <entry>4 байта</entry>
        <entry>целое с автоувеличением</entry>
        <entry>1 .. 2147483647</entry>
       </row>

       <row>
        <entry><type>bigserial</type></entry>
        <entry>8 байт</entry>
        <entry>большое целое с автоувеличением</entry>
        <entry>1 .. 9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Синтаксис констант числовых типов описан в <xref remap="6" linkend="sql-syntax-constants"/>. Для этих типов определён полный набор соответствующих арифметических операторов и функций. За дополнительными сведениями обратитесь к <xref remap="3" linkend="functions"/>. Подробнее эти типы описаны в следующих разделах.</para>

   <sect2 id="datatype-int">
    <title>Целочисленные типы</title>

    <indexterm zone="datatype-int"><primary>integer</primary></indexterm>

    <indexterm zone="datatype-int"><primary>smallint</primary></indexterm>

    <indexterm zone="datatype-int"><primary>bigint</primary></indexterm>

    <indexterm><primary>int4</primary> <see>integer</see></indexterm>

    <indexterm><primary>int2</primary> <see>smallint</see></indexterm>

    <indexterm><primary>int8</primary> <see>bigint</see></indexterm>

    <para>Типы <type>smallint</type>, <type>integer</type> и <type>bigint</type> хранят целые числа, то есть числа без дробной части, имеющие разные допустимые диапазоны. Попытка сохранить значение, выходящее за рамки диапазона, приведёт к ошибке.</para>

    <para>Чаще всего используется тип <type>integer</type>, как наиболее сбалансированный выбор ширины диапазона, размера и быстродействия. Тип <type>smallint</type> обычно применяется, только когда крайне важно уменьшить размер данных на диске. Тип <type>bigint</type> предназначен для тех случаев, когда числа не умещаются в диапазон типа <type>integer</type>.</para>

    <para>В <acronym>SQL</acronym> определены только типы <type>integer</type> (или <type>int</type>), <type>smallint</type> и <type>bigint</type>. Имена типов <type>int2</type>, <type>int4</type> и <type>int8</type> выходят за рамки стандарта, хотя могут работать и в некоторых других СУБД.</para>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
    <title>Числа с фиксированной точностью</title>

    <indexterm><primary>numeric (тип данных)</primary></indexterm>

   <indexterm><primary>числа с фиксированной точностью</primary></indexterm>

    <indexterm><primary>decimal</primary> <see>numeric</see></indexterm>

    <para>Тип <type>numeric</type> позволяет хранить числа с очень большим количеством цифр. Он особенно рекомендуется для хранения денежных сумм и других величин, где важна точность. Вычисления с типом <type>numeric</type> дают точные результаты, где это возможно, например, при сложении, вычитании и умножении. Однако операции со значениями <type>numeric</type> выполняются гораздо медленнее, чем с целыми числами или с типами с плавающей точкой, описанными в следующем разделе.</para>

    <para>Ниже мы используем следующие термины: <firstterm>масштаб</firstterm> значения <type>numeric</type> определяет количество десятичных цифр в дробной части, справа от десятичной точки, а <firstterm>точность</firstterm> &mdash; общее количество значимых цифр в числе, т. е. количество цифр по обе стороны десятичной точки. Например, число 23.5141 имеет точность 6 и масштаб 4. Целочисленные значения можно считать числами с масштабом 0.</para>

    <para>Для столбца типа <type>numeric</type> можно настроить и максимальную точность, и максимальный масштаб. Столбец типа <type>numeric</type> объявляется следующим образом: <programlisting>NUMERIC(<replaceable>точность</replaceable>, <replaceable>масштаб</replaceable>)</programlisting> Точность должна быть положительной, а масштаб положительным или равным нулю. Альтернативный вариант <programlisting>NUMERIC(<replaceable>точность</replaceable>)</programlisting> устанавливает масштаб 0. Форма: <programlisting>NUMERIC</programlisting> без указания точности и масштаба создаёт столбец, в котором можно сохранять числовые значения любой точности и масштаба в пределах, поддерживаемых системой. В столбце этого типа входные значения не будут приводиться к какому-либо масштабу, тогда как в столбцах <type>numeric</type> с явно заданным масштабом значения подгоняются под этот масштаб. (Стандарт <acronym>SQL</acronym> утверждает, что по умолчанию должен устанавливаться масштаб 0, т. е. значения должны приводиться к целым числам. Однако мы считаем это не очень полезным. Если для вас важна переносимость, всегда указывайте точность и масштаб явно.)</para>

    <note>
     <para>Максимально допустимая точность, которую можно указать в объявлении типа, равна 1000; если же использовать <type>NUMERIC</type> без указания точности, действуют ограничения, описанные в <xref remap="6" linkend="datatype-numeric-table"/>.</para>
    </note>

    <para>Если масштаб значения, которое нужно сохранить, превышает объявленный масштаб столбца, система округлит его до заданного количества цифр после точки. Если же после этого количество цифр слева в сумме с масштабом превысит объявленную точность, произойдёт ошибка.</para>

    <para>Числовые значения физически хранятся без каких-либо дополняющих нулей слева или справа. Таким образом, объявляемые точность и масштаб столбца определяют максимальный, а не фиксированный размер хранения. (В этом смысле тип <type>numeric</type> больше похож на тип <type>varchar(<replaceable>n</replaceable>)</type>, чем на <type>char(<replaceable>n</replaceable>)</type>.) Действительный размер хранения такого значения складывается из двух байт для каждой группы из четырёх цифр и дополнительных трёх-восьми байт.</para>

    <indexterm><primary>NaN</primary> <see>не число</see></indexterm>

    <indexterm><primary>не число</primary> <secondary>numeric (тип данных)</secondary></indexterm>

    <para>Помимо обычных чисел тип <type>numeric</type> позволяет сохранить специальное значение <literal>NaN</literal>, что означает <quote>not-a-number</quote> (не число). Любая операция c <literal>NaN</literal> выдаёт в результате тоже <literal>NaN</literal>. Записывая это значение в виде константы в команде SQL, его нужно заключать в апострофы, например так: <literal>UPDATE table SET x = 'NaN'</literal>. Регистр символов в строке <literal>NaN</literal> не важен.</para>

    <note>
     <para>В большинстве реализаций <quote>не-число</quote> (<literal>NaN</literal>) считается не равным любому другому значению (в том числе и самому <literal>NaN</literal>). Чтобы значения <type>numeric</type> можно было сортировать и использовать в древовидных индексах, <productname>&productname;</productname> считает, что значения <literal>NaN</literal> равны друг другу и при этом больше любых числовых значений (не <literal>NaN</literal>).</para>
    </note>

    <para>Типы <type>decimal</type> и <type>numeric</type> равнозначны. Оба эти типа описаны в стандарте <acronym>SQL</acronym>.</para>

    <para>При округлении значений тип <type>numeric</type> выдаёт число, большее по модулю, тогда как (на большинстве платформ) типы <type>real</type> и <type>double precision</type> выдают ближайшее чётное число. Например: <programlisting>SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)</programlisting></para>
   </sect2>


   <sect2 id="datatype-float">
    <title>Типы с плавающей точкой</title>

    <indexterm zone="datatype-float"><primary>real</primary></indexterm>

    <indexterm zone="datatype-float"><primary>double precision</primary></indexterm>

    <indexterm><primary>float4</primary> <see>real</see></indexterm>

    <indexterm><primary>float8</primary> <see>double precision</see></indexterm>

    <indexterm zone="datatype-float"><primary>floating point</primary></indexterm>

    <para>Типы данных <type>real</type> и <type>double precision</type> хранят приближённые числовые значения с переменной точностью. На практике эти типы обычно реализуют Стандарт <acronym>IEEE</acronym> 754 для двоичной арифметики с плавающей точкой (с одинарной и двойной точностью соответственно), в той мере, в какой его поддерживают процессор, операционная система и компилятор.</para>

    <para>Неточность здесь выражается в том, что некоторые значения, которые нельзя преобразовать во внутренний формат, сохраняются приближённо, так что полученное значение может несколько отличаться от записанного. Управление подобными ошибками и их распространение в процессе вычислений является предметом изучения целого раздела математики и компьютерной науки, и здесь не рассматривается. Мы отметим только следующее: <itemizedlist>
      <listitem>
       <para>Если вам нужна точность при хранении и вычислениях (например, для денежных сумм), используйте вместо этого тип <type>numeric</type>.</para>
      </listitem>

      <listitem>
       <para>Если вы хотите выполнять с этими типами сложные вычисления, имеющие большую важность, тщательно изучите реализацию операций в вашей среде и особенно поведение в крайних случаях (бесконечность, антипереполнение).</para>
      </listitem>

      <listitem>
       <para>Проверка равенства двух чисел с плавающей точкой может не всегда давать ожидаемый результат.</para>
      </listitem>
     </itemizedlist></para>

    <para>На большинстве платформ тип <type>real</type> может сохранить значения в пределах от 1E-37 до 1E+37 с точностью не меньше 6 десятичных цифр. Тип <type>double precision</type> предлагает диапазон значений от 1E-307 до 1E+308 и точностью не меньше 15 цифр. Попытка сохранить слишком большие или слишком маленькие значения приведёт к ошибке. Если точность вводимого числа слишком велика, оно будет округлено. При попытке сохранить число, близкое к 0, но непредставимое как отличное от 0, произойдёт ошибка антипереполнения.</para>

    <note>
     <para>Параметр <xref linkend="guc-extra-float-digits"/> определяет количество дополнительных значащих цифр при преобразовании значения с плавающей точкой в текст для вывода. Со значением по умолчанию (<literal>0</literal>) вывод будет одинаковым на всех платформах, поддерживаемых &productname;. При его увеличении выводимое значение числа будет более точно представлять хранимое, но от этого может пострадать переносимость.</para>
    </note>

    <indexterm><primary>не число</primary> <secondary>double precision</secondary></indexterm>

    <para>В дополнение к обычным числовым значениям типы с плавающей точкой могут содержать следующие специальные значения: <literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout> Они представляют особые значения, описанные в IEEE 754, соответственно <quote>бесконечность</quote>, <quote>минус бесконечность</quote> и <quote>не число</quote>. (На компьютерах, где арифметика с плавающей точкой не соответствует стандарту IEEE 754, эти значения, вероятно, не будут работать должным образом.) Записывая эти значения в виде констант в команде SQL, их нужно заключать в апострофы, например так: <literal>UPDATE table SET x = 'Infinity'</literal>. Регистр символов в этих строках не важен.</para>

    <note>
     <para>Согласно IEEE754, <literal>NaN</literal> не должно считаться равным любому другому значению с плавающей точкой (в том числе и самому <literal>NaN</literal>). Чтобы значения с плавающей точкой можно было сортировать и использовать в древовидных индексах, <productname>&productname;</productname> считает, что значения <literal>NaN</literal> равны друг другу, и при этом больше любых числовых значений (не <literal>NaN</literal>).</para>
    </note>

    <para><productname>&productname;</productname> также поддерживает форматы <type>float</type> и <type>float(<replaceable>p</replaceable>)</type>, оговорённые в стандарте SQL, для указания неточных числовых типов. Здесь <replaceable>p</replaceable> определяет минимально допустимую точность в <emphasis>двоичных</emphasis> цифрах. <productname>&productname;</productname> воспринимает запись от <type>float(1)</type> до <type>float(24)</type> как выбор типа <type>real</type>, а запись от <type>float(25)</type> до <type>float(53)</type> как выбор типа <type>double precision</type>. Значения <replaceable>p</replaceable> вне допустимого диапазона вызывают ошибку. Если <type>float</type> указывается без точности, подразумевается тип <type>double precision</type>.</para>

    <note>
     <para>Предположение, что типы <type>real</type> и <type>double precision</type> имеют в мантиссе 24 и 53 бита соответственно, справедливо для всех реализаций плавающей точки по стандарту IEEE. На платформах, не поддерживающих IEEE, размер мантиссы может несколько отличаться, но для простоты диапазоны <replaceable>p</replaceable> везде считаются одинаковыми.</para>
    </note>

   </sect2>

   <sect2 id="datatype-serial">
    <title>Последовательные типы</title>

    <indexterm zone="datatype-serial"><primary>smallserial</primary></indexterm>

    <indexterm zone="datatype-serial"><primary>serial</primary></indexterm>

    <indexterm zone="datatype-serial"><primary>bigserial</primary></indexterm>

    <indexterm zone="datatype-serial"><primary>serial2</primary></indexterm>

    <indexterm zone="datatype-serial"><primary>serial4</primary></indexterm>

    <indexterm zone="datatype-serial"><primary>serial8</primary></indexterm>

    <indexterm><primary>auto-increment</primary> <see>serial</see></indexterm>

    <indexterm><primary>sequence</primary> <secondary>и тип serial</secondary></indexterm>

    <para>Типы данных <type>smallserial</type>, <type>serial</type> и <type>bigserial</type> не являются настоящими типами, а представляют собой просто удобное средство для создания столбцов с уникальными идентификаторами (подобное свойству <literal>AUTO_INCREMENT</literal> в некоторых СУБД). В текущей реализации запись: <programlisting>CREATE TABLE <replaceable class="parameter">имя_таблицы</replaceable> (
    <replaceable class="parameter">имя_столбца</replaceable> SERIAL
);</programlisting> равнозначна следующим командам: <programlisting>CREATE SEQUENCE <replaceable class="parameter">имя_таблицы</replaceable>_<replaceable class="parameter">имя_столбца</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">имя_таблицы</replaceable> (
    <replaceable class="parameter">имя_столбца</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">имя_таблицы</replaceable>_<replaceable class="parameter">имя_столбца</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">имя_таблицы</replaceable>_<replaceable class="parameter">имя_столбца</replaceable>_seq OWNED BY <replaceable class="parameter">имя_таблицы</replaceable>.<replaceable class="parameter">имя_столбца</replaceable>;</programlisting> То есть при определении такого типа создаётся целочисленный столбец со значением по умолчанию, извлекаемым из генератора последовательности. Чтобы в столбец нельзя было вставить NULL, в его определение добавляется ограничение <literal>NOT NULL</literal>. (Во многих случаях также имеет смысл добавить для этого столбца ограничения <literal>UNIQUE</literal> или <literal>PRIMARY KEY</literal> для защиты от ошибочного добавления дублирующихся значений, но автоматически это не происходит.) Последняя команда определяет, что последовательность <quote>принадлежит</quote> столбцу, так что она будет удалена при удалении столбца или таблицы.</para>

    <note>
      <para>Так как типы <type>smallserial</type>, <type>serial</type> и <type>bigserial</type> реализованы через последовательности, в числовом ряду значений столбца могут образовываться пропуски (или "дыры"), даже если никакие строки не удалялись. Значение, выделенное из последовательности, считается "задействованным", даже если строку с этим значением не удалось вставить в таблицу. Это может произойти, например, при откате транзакции, добавляющей данные. См. описание <literal>nextval()</literal> в <xref remap="6" linkend="functions-sequence"/>.</para>
    </note>

    <para>Чтобы вставить в столбец <type>serial</type> следующее значение последовательности, ему нужно присвоить значение по умолчанию. Это можно сделать, либо исключив его из списка столбцов в операторе <command>INSERT</command>, либо с помощью ключевого слова <literal>DEFAULT</literal>.</para>

    <para>Имена типов <type>serial</type> и <type>serial4</type> равнозначны: они создают столбцы <type>integer</type>. Так же являются синонимами имена <type>bigserial</type> и <type>serial8</type>, но они создают столбцы <type>bigint</type>. Тип <type>bigserial</type> следует использовать, если за всё время жизни таблицы планируется использовать больше чем 2<superscript>31</superscript> значений. И наконец, синонимами являются имена типов <type>smallserial</type> и <type>serial2</type>, но они создают столбец <type>smallint</type>.</para>

    <para>Последовательность, созданная для столбца <type>serial</type>, автоматически удаляется при удалении связанного столбца. Последовательность можно удалить и отдельно от столбца, но при этом также будет удалено определение значения по умолчанию.</para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <title>Денежные типы</title>

   <para>Тип <type>money</type> хранит денежную сумму с фиксированной дробной частью; см. <xref remap="4" linkend="datatype-money-table"/>. Точность дробной части определяется на уровне базы данных параметром <xref linkend="guc-lc-monetary"/>. Для диапазона, показанного в таблице, предполагается, что число содержит два знака после запятой. Входные данные могут быть записаны по-разному, в том числе в виде целых и дробных чисел, а также в виде строки в денежном формате, например <literal>'$1,000.00'</literal>. Выводятся эти значения обычно в денежном формате, зависящем от региональных стандартов.</para>

    <table id="datatype-money-table">
     <title>Денежные типы</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Размер</entry>
        <entry>Описание</entry>
        <entry>Диапазон</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>money</entry>
        <entry>8 байт</entry>
        <entry>денежная сумма</entry>
        <entry>-92233720368547&#8203;758.08 .. +92233720368547&#8203;758.07</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Так как выводимые значения этого типа зависят от региональных стандартов, попытка загрузить данные типа <type>money</type> в базу данных с другим параметром <varname>lc_monetary</varname> может быть неудачной. Во избежание подобных проблем, прежде чем восстанавливать копию в новую базу данных, убедитесь в том, что параметр <varname>lc_monetary</varname> в этой базе данных имеет то же значение, что и в исходной.</para>

   <para>Значения типов <type>numeric</type>, <type>int</type> и <type>bigint</type> можно привести к типу <type>money</type>. Преобразования типов <type>real</type> и <type>double precision</type> так же возможны через тип <type>numeric</type>, например: <programlisting>SELECT '12.34'::float8::numeric::money;</programlisting> Однако использовать числа с плавающей точкой для денежных сумм не рекомендуется из-за возможных ошибок округления.</para>

   <para>Значение <type>money</type> можно привести к типу <type>numeric</type> без потери точности. Преобразование в другие типы может быть неточным и также должно выполняться в два этапа: <programlisting>SELECT '52093.89'::money::numeric::float8;</programlisting></para>

   <para>При делении значения типа <type>money</type> на целое число выполняется отбрасывание дробной части и получается целое, ближайшее к нулю. Чтобы получить результат с округлением, выполните деление значения с плавающей точкой или приведите значение типа <type>money</type> к <type>numeric</type> до деления, а затем приведите результат к типу <type>money</type>. (Последний вариант предпочтительнее, так как исключает риск потери точности.) Когда значение <type>money</type> делится на другое значение <type>money</type>, результатом будет значение типа <type>double precision</type> (то есть просто число, не денежная величина); денежные единицы измерения при делении сокращаются.</para>
  </sect1>


  <sect1 id="datatype-character">
   <title>Символьные типы</title>

   <indexterm zone="datatype-character"><primary>символьная строка</primary> <secondary>типы данных</secondary></indexterm>

   <indexterm><primary>строка</primary> <see>символьная строка</see></indexterm>

   <indexterm zone="datatype-character"><primary>character</primary></indexterm>

   <indexterm zone="datatype-character"><primary>character varying</primary></indexterm>

   <indexterm zone="datatype-character"><primary>text</primary></indexterm>

   <indexterm zone="datatype-character"><primary>char</primary></indexterm>

   <indexterm zone="datatype-character"><primary>varchar</primary></indexterm>

    <table id="datatype-character-table">
     <title>Символьные типы</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Описание</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
        <entry>строка ограниченной переменной длины</entry>
       </row>
       <row>
        <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type></entry>
        <entry>строка фиксированной длины, дополненная пробелами</entry>
       </row>
       <row>
        <entry><type>text</type></entry>
        <entry>строка неограниченной переменной длины</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <para>В <xref remap="6" linkend="datatype-character-table"/> перечислены символьные типы общего назначения, доступные в <productname>&productname;</productname>.</para>

   <para><acronym>SQL</acronym> определяет два основных символьных типа: <type>character varying(<replaceable>n</replaceable>)</type> и <type>character(<replaceable>n</replaceable>)</type>, где <replaceable>n</replaceable> &mdash; положительное число. Оба эти типа могут хранить текстовые строки длиной до <replaceable>n</replaceable> символов (не байт). Попытка сохранить в столбце такого типа более длинную строку приведёт к ошибке, если только все лишние символы не являются пробелами (тогда они будут усечены до максимально допустимой длины). (Это несколько странное исключение продиктовано стандартом <acronym>SQL</acronym>.) Если длина сохраняемой строки оказывается меньше объявленной, значения типа <type>character</type> будут дополнятся пробелами; а тип <type>character varying</type> просто сохранит короткую строку.</para>

   <para>При попытке явно привести значение к типу <type>character varying(<replaceable>n</replaceable>)</type> или <type>character(<replaceable>n</replaceable>)</type>, часть строки, выходящая за границу в <replaceable>n</replaceable> символов, удаляется, не вызывая ошибки. (Это также продиктовано стандартом <acronym>SQL</acronym>.)</para>

   <para>Записи <type>varchar(<replaceable>n</replaceable>)</type> и <type>char(<replaceable>n</replaceable>)</type> являются синонимами <type>character varying(<replaceable>n</replaceable>)</type> и <type>character(<replaceable>n</replaceable>)</type>, соответственно. Записи <type>character</type> без указания длины соответствует <type>character(1)</type>. Если же длина не указывается для <type>character varying</type>, этот тип будет принимать строки любого размера. Это поведение является расширением <productname>&productname;</productname>.</para>

   <para>Помимо этого, <productname>&productname;</productname> предлагает тип <type>text</type>, в котором можно хранить строки произвольной длины. Хотя тип <type>text</type> не описан в стандарте <acronym>SQL</acronym>, его поддерживают и некоторые другие СУБД SQL.</para>

   <para>Значения типа <type>character</type> физически дополняются пробелами до <replaceable>n</replaceable> символов и хранятся, а затем отображаются в таком виде. Однако при сравнении двух значений типа <type>character</type> дополняющие пробелы считаются незначащими и игнорируются. С правилами сортировки, где пробельные символы являются значащими, это поведение может приводить к неожиданным результатам, например <command>SELECT 'a '::CHAR(2) collate "C" &lt; E'a\n'::CHAR(2)</command> вернёт true (условие будет истинным), хотя в локали C символ пробела считается больше символа новой строки. При приведении значения <type>character</type> к другому символьному типу дополняющие пробелы отбрасываются. Заметьте, что эти пробелы <emphasis>несут</emphasis> смысловую нагрузку в типах <type>character varying</type> и <type>text</type> и в проверках по шаблонам, то есть в <literal>LIKE</literal> и регулярных выражениях.</para>

   <para>Для хранения короткой строки (до 126 байт) требуется дополнительный 1 байт плюс размер самой строки, включая дополняющие пробелы для типа <type>character</type>. Для строк длиннее требуется не 1, а 4 дополнительных байта. Система может автоматически сжимать длинные строки, так что физический размер на диске может быть меньше. Очень длинные текстовые строки переносятся в отдельные таблицы, чтобы они не замедляли работу с другими столбцами. В любом случае, максимально возможный размер строки составляет около 1 ГБ. (Допустимое значение <replaceable>n</replaceable> в объявлении типа данных меньше этого числа. Это объясняется тем, что в зависимости от кодировки каждый символ может занимать несколько байт. Если вы желаете сохранять строки без определённого предела длины, используйте типы <type>text</type> или <type>character varying</type> без указания длины, а не задавайте какое-либо большое максимальное значение.)</para>

   <tip>
    <para>По быстродействию эти три типа практически не отличаются друг от друга, не считая большего размера хранения для типа с дополняющими пробелами и нескольких машинных операций для проверки длины при сохранении строк в столбце с ограниченной длиной. Хотя в некоторых СУБД тип <type>character(<replaceable>n</replaceable>)</type> работает быстрее других, в <productname>&productname;</productname> это не так; на деле <type>character(<replaceable>n</replaceable>)</type> обычно оказывается медленнее остальных типов из-за большего размера данных и более медленной сортировки. В большинстве случаев вместо него лучше применять <type>text</type> или <type>character varying</type>.</para>
   </tip>

   <para>Подробнее синтаксис текстовых строк описан в <xref remap="6" linkend="sql-syntax-strings"/>, а доступные операторы и функции перечисляются в <xref remap="6" linkend="functions"/>. Кодировка, используемая для хранения текстовых строк, определяется набором символов, выбранным для базы данных. Подробнее это описано в <xref remap="6" linkend="multibyte"/>.</para>

   <example>
    <title>Использование символьных типов</title>

<programlisting>CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ОШИБКА:  значение не умещается в тип character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- явное усечение
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput></programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>Функция <function>char_length</function> рассматривается в <xref remap="6" linkend="functions-string"/>.</para>
     </callout>
    </calloutlist>
   </example>

   <para>В <productname>&productname;</productname> есть ещё два символьных типа фиксированной длины, приведённые в <xref remap="6" linkend="datatype-character-special-table"/>. Тип <type>name</type> создан <emphasis>только</emphasis> для хранения идентификаторов во внутренних системных таблицах и не предназначен для обычного применения пользователями. В настоящее время его длина составляет 64 байта (63 ASCII-символа плюс конечный знак), но в исходном коде <literal>C</literal> она задаётся константой <symbol>NAMEDATALEN</symbol>. Эта константа определяется во время компиляции (и её можно менять в особых случаях), а кроме того, максимальная длина по умолчанию может быть увеличена в следующих версиях. Тип <type>"char"</type> (обратите внимание на кавычки) отличается от <type>char(1)</type> тем, что он фактически хранится в одном байте. Он используется во внутренних системных таблицах для простых перечислений.</para>

    <table id="datatype-character-special-table">
     <title>Специальные символьные типы</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Размер</entry>
        <entry>Описание</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
        <entry>1 байт</entry>
        <entry>внутренний однобайтный тип</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
        <entry>64 байта</entry>
        <entry>внутренний тип для имён объектов</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <title>Двоичные типы данных</title>

  <indexterm zone="datatype-binary"><primary>двоичные данные</primary></indexterm>

  <indexterm zone="datatype-binary"><primary>bytea</primary></indexterm>

   <para>Для хранения двоичных данных предназначен тип <type>bytea</type>; см. <xref remap="4" linkend="datatype-binary-table"/>.</para>

   <table id="datatype-binary-table">
    <title>Двоичные типы данных</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Имя</entry>
       <entry>Размер</entry>
       <entry>Описание</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <entry>1 или 4 байта плюс сама двоичная строка</entry>
       <entry>двоичная строка переменной длины</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Двоичные строки представляют собой последовательность октетов (байт) и имеют два отличия от текстовых строк. Во-первых, в двоичных строках можно хранить байты с кодом 0 и другими <quote>непечатаемыми</quote> значениями (обычно это значения вне диапазона 32..126). В текстовых строках нельзя сохранять нулевые байты, а также значения и последовательности значений, не соответствующие выбранной кодировке базы данных. Во-вторых, в операциях с двоичными строками обрабатываются байты в чистом виде, тогда как текстовые строки обрабатываются в зависимости от языковых стандартов. То есть, двоичные строки больше подходят для данных, которые программист видит как <quote>просто байты</quote>, а символьные строки &mdash; для хранения текста.</para>

   <para>Тип <type>bytea</type> поддерживает два внешних формата ввода и вывода: традиционный для <productname>&productname;</productname> формат <quote>спецпоследовательностей</quote> и <quote>шестнадцатеричный</quote>. Входные данные принимаются в обоих форматах, а формат выходных данных зависит от параметра конфигурации <xref linkend="guc-bytea-output"/>; по умолчанию выбран шестнадцатеричный. (Заметьте, что шестнадцатеричный формат был введён в <productname>PostgreSQL</productname> 9.0; в ранних версиях и некоторых программах он не будет работать.)</para>

   <para>Стандарт <acronym>SQL</acronym> определяет другой тип двоичных данных, <type>BLOB</type> (<type>BINARY LARGE OBJECT</type>, большой двоичный объект). Его входной формат отличается от форматов <type>bytea</type>, но функции и операторы в основном те же.</para>

  <sect2>
   <title>Шестнадцатеричный формат <type>bytea</type></title>

   <para>В <quote>шестнадцатеричном</quote> формате двоичные данные кодируются двумя шестнадцатеричными цифрами на байт, при этом первая цифра соответствует старшим 4 битам. К полученной строке добавляется префикс <literal>\x</literal> (чтобы она отличалась от формата спецпоследовательности). В некоторых контекстах обратную косую черту нужно выделить, продублировав её, в тех же случаях это нужно сделать для формата спецпоследовательности; подробнее это описано ниже. Шестнадцатеричные цифры могут быть в любом регистре, а между парами цифр допускаются пробельные символы (но не внутри пары и не в начале последовательности <literal>\x</literal>). Этот формат совместим со множеством внешних приложений и протоколов, к тому же обычно преобразуется быстрее, поэтому предпочтительнее использовать его.</para>

   <para>Пример: <programlisting>SELECT E'\\xDEADBEEF';</programlisting></para>
  </sect2>

  <sect2>
   <title>Формат спецпоследовательностей <type>bytea</type></title>

   <para>Формат <quote>спецпоследовательностей</quote> традиционно использовался в <productname>&productname;</productname> для значений типа <type>bytea</type>. В нём двоичная строка представляется в виде последовательности ASCII-символов, а байты, непредставимые в виде ASCII-символов, передаются в виде спецпоследовательностей. Этот формат может быть удобен, если с точки зрения приложения представление байт в виде символов имеет смысл. Но на практике это обычно создаёт путаницу, так как двоичные и символьные строки могут выглядеть одинаково, а кроме того выбранный механизм спецпоследовательностей довольно неуклюж. Поэтому в новых приложениях этот формат обычно не стоит использовать.</para>

   <para>Передавая значения <type>bytea</type> в формате спецпоследовательности, байты с определёнными значениями <emphasis>необходимо</emphasis> записывать специальным образом, хотя так <emphasis>можно</emphasis> записывать и все значения. В общем виде для этого значение байта нужно преобразовать в трёхзначное восьмеричное число и добавить перед ним обратную косую черту (и продублировать её, если значение записывается в текстовой спецстроке). Саму обратную косую черту (символ с кодом 92) можно записать в виде двух таких символов. В <xref remap="6" linkend="datatype-binary-sqlesc"/> перечислены символы, которые нужно записывать спецпоследовательностями, и приведены альтернативные варианты записи там, где они возможны.</para>

   <table id="datatype-binary-sqlesc">
    <title>Спецпоследовательности записи значений <type>bytea</type></title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Десятичное значение байта</entry>
       <entry>Описание</entry>
       <entry>Спецпоследова-
тельность ввода</entry>
       <entry>Пример</entry>
       <entry>Выводимое представление</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>нулевой байт</entry>
       <entry><literal>E'\\000'</literal></entry>
       <entry><literal>SELECT E'\\000'::bytea;</literal></entry>
       <entry><literal>\000</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <entry>апостроф</entry>
       <entry><literal>''''</literal> или <literal>E'\\047'</literal></entry>
       <entry><literal>SELECT E'\''::bytea;</literal></entry>
       <entry><literal>'</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <entry>обратная косая черта</entry>
       <entry><literal>E'\\\\'</literal> или <literal>E'\\134'</literal></entry>
       <entry><literal>SELECT E'\\\\'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>от 0 до 31 и от 127 до 255</entry>
       <entry><quote>непечатаемые</quote> байты</entry>
       <entry><literal>E'\\<replaceable>xxx'</replaceable></literal> (значение байта)</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>Набор <emphasis>непечатаемых</emphasis> символов, которые нужно записывать спецпоследовательностями, определяется языковыми стандартами. В некоторых случаях можно оставить в буквальном виде и другие символы. Заметьте, что во всех примерах в <xref remap="6" linkend="datatype-binary-sqlesc"/> задаётся значение ровно одного байта, хотя выходное представление может состоять из нескольких символов.</para>

   <para>Необходимость дублирования обратных косых черт в записи спецпоследовательностей, показанного в <xref remap="6" linkend="datatype-binary-sqlesc"/>, объясняется тем, что строковая константа должна пройти два этапа разбора на сервере <productname>&productname;</productname>. Первая обратная косая черта из каждой пары воспринимается анализатором строки как спецсимвол (если используется синтаксис спецпоследовательностей) и таким образом пропускается, оставляя только вторую косую черту. (Для избавления от этой вложенности можно использовать строки в долларах.) Оставшаяся обратная косая черта затем распознаётся функцией ввода <type>bytea</type> как спецсимвол, предваряющий трёхзначное восьмеричное значение или следующий спецсимвол. Например, переданная серверу строковая константа <literal>E'\\001'</literal> преобразуется в <literal>\001</literal>, проходя через анализатор спецстрок. Затем строка <literal>\001</literal> передаётся функции ввода типа <type>bytea</type>, где она преобразуется в один байт с десятичным значением 1. Заметьте, что символ апостроф для функции ввода <type>bytea</type> не отличается от остальных, поэтому он записывается как обычно принято в строках. (См. также <xref remap="4" linkend="sql-syntax-strings"/>.)</para>

   <para>Данные <type>bytea</type> иногда выводятся также в спецпоследовательностях. При этом каждый <quote>непечатаемый</quote> байт представляется в виде трёхзначного восьмеричного значения после обратной косой черты. Большинство <quote>печатаемых</quote> байт представляются обычными символами из клиентского набора символов. Байт с десятичным кодом 92 (обратная косая черта) при выводе дублируется. Это иллюстрирует <xref linkend="datatype-binary-resesc"/>.</para>

   <table id="datatype-binary-resesc">
    <title>Спецпоследовательности выходных значений <type>bytea</type></title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Десятичное значение байта</entry>
       <entry>Описание</entry>
       <entry>Спецпоследовательность вывода</entry>
       <entry>Пример</entry>
       <entry>Выводимый результат</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <entry>обратная косая черта</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT E'\\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>от 0 до 31 и от 127 до 255</entry>
       <entry><quote>непечатаемые</quote> байты</entry>
       <entry><literal>\<replaceable>xxx</replaceable></literal> (значение байта)</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>от 32 до 126</entry>
       <entry><quote>печатаемые</quote> байты</entry>
       <entry>представление из клиентского набора символов</entry>
       <entry><literal>SELECT E'\\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>В зависимости от применяемой клиентской библиотеки <productname>&productname;</productname>, для преобразования значений <type>bytea</type> в спецстроки и обратно могут потребоваться дополнительные действия. Например, если приложение сохраняет в строках символы перевода строк, возможно их также нужно будет представить спецпоследовательностями.</para>
  </sect2>
 </sect1>


  <sect1 id="datatype-datetime">
   <title>Типы даты/времени</title>

   <indexterm zone="datatype-datetime"><primary>date</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>time</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>time without time zone</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>time with time zone</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>timestamp</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>timestamptz</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>timestamp with time zone</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>timestamp without time zone</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>interval</primary></indexterm>
   <indexterm zone="datatype-datetime"><primary>time span</primary></indexterm>

   <para><productname>&productname;</productname> поддерживает полный набор типов даты и времени <acronym>SQL</acronym>, показанный в <xref remap="6" linkend="datatype-datetime-table"/>. Операции, возможные с этими типами данных, описаны в <xref remap="6" linkend="functions-datetime"/>. Все даты считаются по Григорианскому календарю, даже для времени до его введения (за дополнительными сведениями обратитесь к <xref remap="3" linkend="datetime-units-history"/>).</para>

    <table id="datatype-datetime-table">
     <title>Типы даты/времени</title>
     <tgroup cols="6">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Размер</entry>
        <entry>Описание</entry>
        <entry>Наименьшее значение</entry>
        <entry>Наибольшее значение</entry>
        <entry>Точность</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 байт</entry>
        <entry>дата и время (без часового пояса)</entry>
        <entry>4713 до н. э.</entry>
        <entry>294276 н. э.</entry>
        <entry>1 микросекунда / 14 цифр</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8 байт</entry>
        <entry>дата и время (с часовым поясом)</entry>
        <entry>4713 до н. э.</entry>
        <entry>294276 н. э.</entry>
        <entry>1 микросекунда / 14 цифр</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <entry>4 байта</entry>
        <entry>дата (без времени суток)</entry>
        <entry>4713 до н. э.</entry>
        <entry>5874897 н. э.</entry>
        <entry>1 день</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 байт</entry>
        <entry>время суток (без даты)</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1 микросекунда / 14 цифр</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12 байт</entry>
        <entry>только время суток (с часовым поясом)</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1 микросекунда / 14 цифр</entry>
       </row>
       <row>
        <entry><type>interval [ <replaceable>поля</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>16 байт</entry>
        <entry>временной интервал</entry>
        <entry>-178000000 лет</entry>
        <entry>178000000 лет</entry>
        <entry>1 микросекунда / 14 цифр</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>Стандарт SQL требует, чтобы тип <type>timestamp</type> подразумевал <type>timestamp without time zone</type> (время без часового пояса), и <productname>&productname;</productname> следует этому. Для краткости <type>timestamp with time zone</type> можно записать как <type>timestamptz</type>; это расширение <productname>&productname;</productname>.</para>
   </note>

   <para>Типы <type>time</type>, <type>timestamp</type> и <type>interval</type> принимают необязательное значение точности <replaceable>p</replaceable>, определяющее, сколько знаков после запятой должно сохраняться в секундах. По умолчанию точность не ограничивается. Для типов <type>timestamp</type> и <type>interval</type> <replaceable>p</replaceable> может принимать значения от 0 до 6.</para>

   <note>
   <para>Когда значения <type>timestamp</type> хранятся в восьмибайтных целых (сейчас по умолчанию это так), на всём интервале значений обеспечивается точность в микросекундах. Если же значения этого типа сохраняются в числах двойной точности с плавающей точкой (устаревший вариант компиляции), фактический предел точности может быть меньше 6. Значения <type>timestamp</type> сохраняются в секундах до или после полуночи 1 января 2000 г. Когда при этом используются числа с плавающей точкой, микросекундная точность достигается для дат в пределах нескольких лет от этой даты, а при удалении от неё точность теряется. Однако заметьте, что даты в числах с плавающей точкой позволяют представить больший диапазон <type>timestamp</type>, чем было показано выше: от 4713 до н. э. до 5874897 н. э.</para>

   <para>В зависимости от того же варианта компиляции, типы <type>time</type> и <type>interval</type> могут сохраняться в виде чисел с плавающей точкой или в восьмибайтных целых. В случае с плавающей точкой при больших значениях <type>interval</type> точность уменьшается.</para>
   </note>

   <para>Для типа <type>time</type> <replaceable>p</replaceable> может принимать значения от 0 до 6 при хранении типа в восьмибайтном целом и от 0 до 10 при хранении в числе с плавающей точкой.</para>

   <para>Тип <type>interval</type> дополнительно позволяет ограничить набор сохраняемых поле следующими фразами: <literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout> Заметьте, что если указаны и <replaceable>поля</replaceable>, и точность <replaceable>p</replaceable>, указание <replaceable>поля</replaceable> должно включать <literal>SECOND</literal>, так как точность применима только к секундам.</para>

   <para>Тип <type>time with time zone</type> определён стандартом SQL, но в его определении описаны свойства сомнительной ценности. В большинстве случаев сочетание типов <type>date</type>, <type>time</type>, <type>timestamp without time zone</type> и <type>timestamp with time zone</type> удовлетворяет все потребности в функционале дат/времени, возникающие в приложениях.</para>

   <para>Типы <type>abstime</type> и <type>reltime</type> имеют меньшую точность и предназначены для внутреннего использования. Эти типы не рекомендуется использовать в обычных приложениях; их может не быть в будущих версиях.</para>

   <sect2 id="datatype-datetime-input">
    <title>Ввод даты/времени</title>

    <para>Значения даты и времени принимаются практически в любом разумном формате, включая ISO 8601, <acronym>SQL</acronym>-совместимый, традиционный формат <productname>POSTGRES</productname> и другие. В некоторых форматах порядок даты, месяца и года во вводимой дате неоднозначен и поэтому поддерживается явное определение формата. Для этого предназначен параметр <xref linkend="guc-datestyle"/>. Когда он имеет значение <literal>MDY</literal>, выбирается интерпретация месяц-день-год, значению <literal>DMY</literal> соответствует день-месяц-год, а <literal>YMD</literal> &mdash; год-месяц-день.</para>

    <para><productname>&productname;</productname> обрабатывает вводимые значения даты/времени более гибко, чем того требует стандарт <acronym>SQL</acronym>. Точные правила разбора даты/времени и распознаваемые текстовые поля, в том числе названия месяцев, дней недели и часовых поясов описаны в <xref remap="6" linkend="datetime-appendix"/>.</para>

    <para>Помните, что любые вводимые значения даты и времени нужно заключать в апострофы, как текстовые строки. За дополнительной информацией обратитесь к <xref remap="3" linkend="sql-syntax-constants-generic"/>. <acronym>SQL</acronym> предусматривает следующий синтаксис: <synopsis>
<replaceable>тип</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>значение</replaceable>'
</synopsis>Здесь <replaceable>p</replaceable> &mdash; необязательное указание точности, определяющее число знаков после точки в секундах. Точность может быть определена для типов <type>time</type>, <type>timestamp</type> и <type>interval</type> в пределах, описанных выше. Если в определении константы точность не указана, она считается равной точности значения в строке.</para>

    <sect3>
    <title>Даты</title>

    <indexterm><primary>date</primary></indexterm>

    <para>В <xref remap="6" linkend="datatype-datetime-date-table"/> приведены некоторые допустимые значения типа <type>date</type>.</para>

     <table id="datatype-datetime-date-table">
      <title>Вводимые даты</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Пример</entry>
         <entry>Описание</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO 8601; 8 января в любом режиме (рекомендуемый формат)</entry>
        </row>
        <row>
         <entry>January 8, 1999</entry>
         <entry>воспринимается однозначно в любом режиме <varname>datestyle</varname></entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
         <entry>8 января в режиме <literal>MDY</literal> и 1 августа в режиме <literal>DMY</literal></entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
         <entry>18 января в режиме <literal>MDY</literal>; недопустимая дата в других режимах</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
         <entry>2 января 2003 г. в режиме <literal>MDY</literal>; 1 февраля 2003 г. в режиме <literal>DMY</literal> и 3 февраля 2001 г. в режиме <literal>YMD</literal></entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
         <entry>8 января в любом режиме</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
         <entry>8 января в любом режиме</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
         <entry>8 января в любом режиме</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
         <entry>8 января в режиме <literal>YMD</literal>; ошибка в других режимах</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
         <entry>8 января; ошибка в режиме <literal>YMD</literal></entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
         <entry>8 января; ошибка в режиме <literal>YMD</literal></entry>
        </row>
        <row>
         <entry>19990108</entry>
         <entry>ISO 8601; 8 января 1999 в любом режиме</entry>
        </row>
        <row>
         <entry>990108</entry>
         <entry>ISO 8601; 8 января 1999 в любом режиме</entry>
        </row>
        <row>
         <entry>1999.008</entry>
         <entry>год и день года</entry>
        </row>
        <row>
         <entry>J2451187</entry>
         <entry>дата по юлианскому календарю</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>99 до н. э.</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3>
     <title>Время</title>

     <indexterm><primary>time</primary></indexterm>
     <indexterm><primary>time without time zone</primary></indexterm>
     <indexterm><primary>time with time zone</primary></indexterm>

     <para>Для хранения времени суток без даты предназначены типы <type>time [ (<replaceable>p</replaceable>) ] without time zone</type> и <type>time [ (<replaceable>p</replaceable>) ] with time zone</type>. Тип <type>time</type> без уточнения эквивалентен типу <type>time without time zone</type>.</para>

     <para>Допустимые вводимые значения этих типов состоят из записи времени суток и необязательного указания часового пояса. (См. <xref remap="4" linkend="datatype-datetime-time-table"/> и <xref remap="4" linkend="datatype-timezone-table"/>.) Если в значении для типа <type>time without time zone</type> указывается часовой пояс, он просто игнорируется. Так же будет игнорироваться дата, если её указать, за исключением случаев, когда в указанном часовом поясе принят переход на летнее время, например <literal>America/New_York</literal>. В данном случае указать дату необходимо, чтобы система могла определить, применяется ли обычное или летнее время. Соответствующее смещение часового пояса записывается в значении <type>time with time zone</type>.</para>

      <table id="datatype-datetime-time-table">
       <title>Вводимое время</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Пример</entry>
          <entry>Описание</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>то же, что и 04:05; AM не меняет значение времени</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>то же, что и 16:05; часы должны быть &lt;= 12</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>часовой пояс задаётся аббревиатурой</entry>
         </row>
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <entry>часовой пояс задаётся полным названием</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
       <title>Вводимый часовой пояс</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Пример</entry>
          <entry>Описание</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>PST</literal></entry>
          <entry>аббревиатура (Pacific Standard Time, Стандартное тихоокеанское время)</entry>
         </row>
         <row>
          <entry><literal>America/New_York</literal></entry>
          <entry>полное название часового пояса</entry>
         </row>
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>указание часового пояса в стиле POSIX</entry>
         </row>
         <row>
          <entry><literal>-8:00</literal></entry>
          <entry>смещение часового пояса PST по ISO-8601</entry>
         </row>
         <row>
          <entry><literal>-800</literal></entry>
          <entry>смещение часового пояса PST по ISO-8601</entry>
         </row>
         <row>
          <entry><literal>-8</literal></entry>
          <entry>смещение часового пояса PST по ISO-8601</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>принятое у военных сокращение UTC</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
          <entry>краткая форма <literal>zulu</literal></entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>Подробнее узнать о том, как указывается часовой пояс, можно в <xref remap="6" linkend="datatype-timezones"/>.</para>
    </sect3>

    <sect3>
    <title>Даты и время</title>

    <indexterm><primary>timestamp</primary></indexterm>

    <indexterm><primary>timestamp with time zone</primary></indexterm>

    <indexterm><primary>timestamp without time zone</primary></indexterm>

     <para>Допустимые значения типов timestamp состоят из записи даты и времени, после которого может указываться часовой пояс и необязательное уточнение <literal>AD</literal> или <literal>BC</literal>, определяющее эпоху до нашей эры и нашу эру соответственно. (<literal>AD</literal>/<literal>BC</literal> можно указать и перед часовым поясом, но предпочтительнее первый вариант.) Таким образом: <programlisting>1999-01-08 04:05:06</programlisting> и <programlisting>1999-01-08 04:05:06 -8:00</programlisting> допустимые варианты, соответствующие стандарту <acronym>ISO</acronym> 8601. В дополнение к этому поддерживается распространённый формат: <programlisting>January 8 04:05:06 1999 PST</programlisting></para>

     <para>Стандарт <acronym>SQL</acronym> различает константы типов <type>timestamp without time zone</type> и <type>timestamp with time zone</type> по знаку <quote>+</quote> или <quote>-</quote> и смещению часового пояса, добавленному после времени. Следовательно, согласно стандарту, записи <programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting> должен соответствовать тип <type>timestamp without time zone</type>, а <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting> тип <type>timestamp with time zone</type>. <productname>&productname;</productname> никогда не анализирует содержимое текстовой строки, чтобы определить тип значения, и поэтому обе записи будут обработаны как значения типа <type>timestamp without time zone</type>. Чтобы текстовая константа обрабатывалась как <type>timestamp with time zone</type>, укажите этот тип явно: <programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting> В константе типа <type>timestamp without time zone</type> <productname>&productname;</productname> просто игнорирует часовой пояс. То есть результирующее значение вычисляется только из полей даты/времени и не подстраивается под указанный часовой пояс.</para>

     <para>Значения <type>timestamp with time zone</type> внутри всегда хранятся в UTC (Universal Coordinated Time, Всемирное скоординированное время или время по Гринвичу, <acronym>GMT</acronym>). Вводимое значение, в котором явно указан часовой пояс, переводится в UTC с учётом смещения данного часового пояса. Если во входной строке не указан часовой пояс, подразумевается часовой пояс, заданный системным параметром <xref linkend="guc-timezone"/> и время так же пересчитывается в UTC со смещением <varname>timezone</varname>.</para>

     <para>Когда значение <type>timestamp with time zone</type> выводится, оно всегда преобразуется из UTC в текущий часовой пояс <varname>timezone</varname> и отображается как локальное время. Чтобы получить время для другого часового пояса, нужно либо изменить <varname>timezone</varname>, либо воспользоваться конструкцией <literal>AT TIME ZONE</literal> (см. <xref remap="4" linkend="functions-datetime-zoneconvert"/>).</para>

     <para>В преобразованиях между <type>timestamp without time zone</type> и <type>timestamp with time zone</type> обычно предполагается, что значение <type>timestamp without time zone</type> содержит местное время (для часового пояса <varname>timezone</varname>). Другой часовой пояс для преобразования можно задать с помощью <literal>AT TIME ZONE</literal>.</para>
    </sect3>

    <sect3>
     <title>Специальные значения</title>

     <indexterm><primary>время</primary> <secondary>константы</secondary></indexterm>

     <indexterm><primary>дата</primary> <secondary>константы</secondary></indexterm>

     <para><productname>&productname;</productname> для удобства поддерживает несколько специальных значений даты/времени, перечисленных в <xref remap="6" linkend="datatype-datetime-special-table"/>. Значения <literal>infinity</literal> и <literal>-infinity</literal> имеют особое представление в системе и они отображаются в том же виде, тогда как другие варианты при чтении преобразуются в значения даты/времени. (В частности, <literal>now</literal> и подобные строки преобразуются в актуальные значения времени в момент чтения.) Чтобы использовать эти значения в качестве констант в командах SQL, их нужно заключать в апострофы.</para>

      <table id="datatype-datetime-special-table">
       <title>Специальные значения даты/времени</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Вводимая строка</entry>
          <entry>Допустимые типы</entry>
          <entry>Описание</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00 (точка отсчёта времени в Unix)</entry>
         </row>
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>время после максимальной допустимой даты</entry>
         </row>
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>время до минимальной допустимой даты</entry>
         </row>
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>время начала текущей транзакции</entry>
         </row>
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>время начала текущих суток</entry>
         </row>
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>время начала следующих суток</entry>
         </row>
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>время начала предыдущих суток</entry>
         </row>
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>Для получения текущей даты/времени соответствующего типа можно также использовать следующие <acronym>SQL</acronym>-совместимые функции: <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>, <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal> и <literal>LOCALTIMESTAMP</literal>. Последние четыре функции принимают необязательное указание точности. (См. <xref remap="4" linkend="functions-datetime-current"/>.) Заметьте, что во входных строках эти SQL-функции <emphasis>не</emphasis> распознаются.</para>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <title>Вывод даты/времени</title>

    <indexterm><primary>дата</primary> <secondary>формат вывода</secondary> <seealso>форматирование</seealso></indexterm>

    <indexterm><primary>время</primary> <secondary>формат вывода</secondary> <seealso>форматирование</seealso></indexterm>

    <para>В качестве выходного формата типов даты/времени можно использовать один из четырёх стилей: ISO 8601, <acronym>SQL</acronym> (Ingres), традиционный формат <productname>POSTGRES</productname> (формат <application>date</application> в Unix) или German. По умолчанию выбран формат <acronym>ISO</acronym>. (Стандарт <acronym>SQL</acronym> требует, чтобы использовался именно ISO 8601. Другой формат называется <quote>SQL</quote> исключительно по историческим причинам.) Примеры всех стилей вывода перечислены в <xref remap="6" linkend="datatype-datetime-output-table"/>. Вообще со значениями типов <type>date</type> и <type>time</type> выводилась бы только часть даты или времени из показанных примеров, но со стилем <productname>POSTGRES</productname> значение даты без времени выводится в формате <acronym>ISO</acronym>.</para>

     <table id="datatype-datetime-output-table">
      <title>Стили вывода даты/время</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Стиль</entry>
         <entry>Описание</entry>
         <entry>Пример</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>ISO</literal></entry>
         <entry>ISO 8601, стандарт SQL</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
        <row>
         <entry><literal>SQL</literal></entry>
         <entry>традиционный стиль</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres</literal></entry>
         <entry>изначальный стиль</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
        <row>
         <entry><literal>German</literal></entry>
         <entry>региональный стиль</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <note>
     <para>ISO 8601 указывает, что дата должна отделяться от времени буквой <literal>T</literal> в верхнем регистре. <productname>&productname;</productname> принимает этот формат при вводе, но при выводе вставляет вместо <literal>T</literal> пробел, как показано выше. Это сделано для улучшения читаемости и для совместимости с RFC 3339 и другими СУБД.</para>
    </note>

    <para>В стилях <acronym>SQL</acronym> и POSTGRES день выводится перед месяцем, если установлен порядок DMY, а в противном случае месяц выводится перед днём. (Как этот параметр также влияет на интерпретацию входных значений, описано в <xref remap="6" linkend="datatype-datetime-input"/>) Соответствующие примеры показаны в <xref remap="6" linkend="datatype-datetime-output2-table"/>.</para>

     <table id="datatype-datetime-output2-table">
      <title>Соглашения о порядке компонентов даты</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Параметр <varname>datestyle</varname></entry>
         <entry>Порядок при вводе</entry>
         <entry>Пример вывода</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>SQL, DMY</literal></entry>
         <entry><replaceable>день</replaceable>/<replaceable>месяц</replaceable>/<replaceable>год</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</literal></entry>
         <entry><replaceable>месяц</replaceable>/<replaceable>день</replaceable>/<replaceable>год</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
         <entry><replaceable>день</replaceable>/<replaceable>месяц</replaceable>/<replaceable>год</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>Стиль даты/времени пользователь может выбрать с помощью команды <command>SET datestyle</command>, параметра <xref linkend="guc-datestyle"/> в файле конфигурации <filename>postgresql.conf</filename> или переменной окружения <envar>PGDATESTYLE</envar> на сервере или клиенте.</para>

    <para>Для большей гибкости при форматировании выводимой даты/времени можно использовать функцию <function>to_char</function> (см. <xref remap="4" linkend="functions-formatting"/>).</para>
   </sect2>

   <sect2 id="datatype-timezones">
    <title>Часовые пояса</title>

    <indexterm zone="datatype-timezones"><primary>часовой пояс</primary></indexterm>

   <para>Часовые пояса и правила их применения определяются, как вы знаете, не только по географическим, но и по политическим соображениям. Часовые пояса во всём мире были более-менее стандартизированы в начале прошлого века, но они продолжают претерпевать изменения, в частности это касается перехода на летнее время. Для расчёта времени в прошлом <productname>&productname;</productname> получает исторические сведения о правилах часовых поясов из распространённой базы данных IANA (Olson). Для будущего времени предполагается, что в заданном часовом поясе будут продолжать действовать последние принятые правила.</para>

    <para><productname>&productname;</productname> стремится к совместимости со стандартом <acronym>SQL</acronym> в наиболее типичных случаях. Однако стандарт <acronym>SQL</acronym> допускает некоторые странности при смешивании типов даты и времени. Две очевидные проблемы: <itemizedlist>
      <listitem>
       <para>Хотя для типа <type>date</type> часовой пояс указать нельзя, это можно сделать для типа <type>time</type>. В реальности это не очень полезно, так как без даты нельзя точно определить смещение при переходе на летнее время.</para>
      </listitem>

      <listitem>
       <para>По умолчанию часовой пояс задаётся постоянным смещением от <acronym>UTC</acronym>. Это также не позволяет учесть летнее время при арифметических операций с датами, пересекающими границы летнего времени.</para>
      </listitem>

     </itemizedlist></para>

    <para>Поэтому мы советуем использовать часовой пояс с типами, включающими и время, и дату. Мы <emphasis>не</emphasis> рекомендуем использовать тип <type>time with time zone</type> (хотя <productname>&productname;</productname> поддерживает его для старых приложений и совместимости со стандартом <acronym>SQL</acronym>). Для типов, включающих только дату или только время, в <productname>&productname;</productname> предполагается местный часовой пояс.</para>

    <para>Все значения даты и времени с часовым поясом представляются внутри в <acronym>UTC</acronym>, а при передаче клиентскому приложению они переводятся в местное время, при этом часовой пояс по умолчанию определяется параметром конфигурации <xref linkend="guc-timezone"/>.</para>

    <para><productname>&productname;</productname> позволяет задать часовой пояс тремя способами: <itemizedlist>
      <listitem>
       <para>Полное название часового пояса, например <literal>America/New_York</literal>. Все допустимые названия перечислены в представлении <literal>pg_timezone_names</literal> (см. <xref remap="4" linkend="view-pg-timezone-names"/>). Определения часовых поясов <productname>&productname;</productname> берёт из широко распространённой базы IANA, так что имена часовых поясов &productname; будут воспринимать и многие другие приложения.</para>
      </listitem>
      <listitem>
       <para>Аббревиатура часового пояса, например <literal>PST</literal>. Такое определение просто задаёт смещение от UTC, в отличие от полных названий поясов, которые кроме того подразумевают и правила перехода на летнее время. Распознаваемые аббревиатуры перечислены в представлении <literal>pg_timezone_abbrevs</literal> (см. <xref remap="4" linkend="view-pg-timezone-abbrevs"/>). Аббревиатуры можно использовать во вводимых значениях даты/времени и в операторе <literal>AT TIME ZONE</literal>, но не в параметрах конфигурации <xref linkend="guc-timezone"/> и <xref linkend="guc-log-timezone"/>.</para>
      </listitem>
      <listitem>
       <para>В дополнение к полным названиям и аббревиатурам часовых поясов <productname>&productname;</productname> принимает указания часового пояса в стиле POSIX: <replaceable>STD</replaceable><replaceable>смещение</replaceable> или <replaceable>STD</replaceable><replaceable>смещение</replaceable><replaceable>DST</replaceable>, где <replaceable>STD</replaceable> &mdash; аббревиатура пояса, <replaceable>смещение</replaceable> &mdash; разница с UTC, а <replaceable>DST</replaceable> &mdash; необязательное дополнение, обозначающее летнее время и добавляющее к смещению ещё один час. Например, если бы обозначение <literal>EST5EDT</literal> не являлось названием часового пояса, оно всё равно было бы воспринято и функционально соответствовало бы поясу североамериканского восточного времени. При такой записи аббревиатура пояса может быть набором букв или обычной строкой, заключённой в угловые скобки ((<literal>&lt;&gt;</literal>). Когда представлено название пояса с летним временем, при пересчёте времени будут использоваться правила перехода на летнее время, описанные в базе данных IANA в файле <filename>posixrules</filename>. В стандартной инсталляции <productname>&productname;</productname> файл <filename>posixrules</filename> соответствует описанию <literal>US/Eastern</literal>, так что для указаний часовых поясов в стиле POSIX применяются правила перехода на летнее время, принятые в США. При необходимости это можно изменить, заменив файл <filename>posixrules</filename>.</para>
      </listitem>
     </itemizedlist> Вкратце, различие между аббревиатурами и полными названиями заключаются в следующем: аббревиатуры представляют определённый сдвиг от UTC, а полное название подразумевает ещё и местное правило по переходу на летнее время, то есть, возможно, два сдвига от UTC. Например, <literal>2014-06-04 12:00 America/New_York</literal> представляет полдень по местному времени в Нью-Йорк, что для данного дня было бы летним восточным временем (EDT или UTC-4). Так что <literal>2014-06-04 12:00 EDT</literal> обозначает тот же момент времени. Но <literal>2014-06-04 12:00 EST</literal> задаёт стандартное восточное время (UTC-5), не зависящее о того, действовало ли летнее время в этот день.</para>

    <para>Мало того, в некоторых юрисдикциях одна и та же аббревиатура часового пояса означала разные сдвиги UTC в разное время; например, аббревиатура московского времени <literal>MSK</literal> несколько лет означала UTC+3, а затем стала означать UTC+4. <application>&productname;</application> обрабатывает такие аббревиатуры в соответствии с их значениями на заданную дату, но, как и с примером выше <literal>EST</literal>, это не обязательно будет соответствовать местному гражданскому времени в этот день.</para>

    <para>При этом следует использовать возможность указания часового пояса в стиле POSIX с осторожностью, так как при этом могут быть приняты заведомо неверные данные, потому что разумность аббревиатуры никак не проверяется. Например, команда <literal>SET TIMEZONE TO FOOBAR0</literal> будет работать и система примет эту довольно оригинальную аббревиатуру для UTC. Также следует учитывать, что в названиях часовых поясов POSIX положительные смещения соответствуют сдвигу <emphasis>к западу</emphasis> Гринвича. Во всех остальных формах <productname>&productname;</productname> следует соглашению ISO-8601, по которому положительным смещениям соответствует сдвиг <emphasis>к востоку</emphasis> от Гринвича.</para>

    <para>Независимо от формы, регистр в названиях и аббревиатурах часовых поясов не важен. (В <productname>PostgreSQL</productname> до версии 8.2 он где-то имел значение, а где-то нет.)</para>

    <para>Ни названия, ни аббревиатуры часовых поясов, не зашиты в самом сервере; они считываются из файлов конфигурации, находящихся в путях <filename>.../share/timezone/</filename> и <filename>.../share/timezonesets/</filename> относительно каталога установки (см. <xref remap="4" linkend="datetime-config-files"/>).</para>

    <para>Параметр конфигурации <xref linkend="guc-timezone"/> можно установить в <filename>postgresql.conf</filename> или любым другим стандартным способом, описанным в <xref remap="6" linkend="runtime-config"/>. Часовой пояс может быть также определён следующими специальными способами: <itemizedlist>
      <listitem>
       <para>Часовой пояс для текущего сеанса можно установить с помощью <acronym>SQL</acronym>-команды <command>SET TIME ZONE</command>. Это альтернативная запись команды <command>SET TIMEZONE TO</command>, более соответствующая SQL-стандарту.</para>
      </listitem>

      <listitem>
       <para>Если установлена переменная окружения <envar>PGTZ</envar>, клиенты <application>libpq</application> используют её значение, выполняя при подключении к серверу команду <command>SET TIME ZONE</command>.</para>
      </listitem>
     </itemizedlist></para>
   </sect2>

   <sect2 id="datatype-interval-input">
    <title>Ввод интервалов</title>

    <indexterm><primary>interval</primary></indexterm>

     <para>Значения типа <type>interval</type> могут быть записаны в следующей расширенной форме: <synopsis>
<optional>@</optional> <replaceable>количество</replaceable> <replaceable>единица</replaceable> <optional><replaceable>количество</replaceable> <replaceable>единица</replaceable>...</optional> <optional><replaceable>направление</replaceable></optional>
</synopsis> где <replaceable>количество</replaceable> &mdash; это число (возможно, со знаком); <replaceable>единица </replaceable> &mdash; одно из значений: <literal>microsecond</literal>, <literal>millisecond</literal>, <literal>second</literal>, <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>, <literal>week</literal>, <literal>month</literal>, <literal>year</literal>, <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal> (которые обозначают соответственно микросекунды, миллисекунды, секунды, минуты, часы, дни, недели, месяцы, годы, десятилетия, века и тысячелетия), либо эти же слова во множественном числе, либо их сокращения; <replaceable>направление</replaceable> может принимать значение <literal>ago</literal> (назад) или быть пустым. Знак <literal>@</literal> является необязательным. Все заданные величины различных единиц суммируются вместе с учётом знака чисел. Указание <literal>ago</literal> меняет знак всех полей на противоположный. Этот синтаксис также используется при выводе интервала, если параметр <xref linkend="guc-intervalstyle"/> имеет значение <literal>postgres_verbose</literal>.</para>

    <para>Количества дней, часов, минут и секунд можно определить, не указывая явно соответствующие единицы. Например, запись <literal>'1 12:59:10'</literal> равнозначна <literal>'1 day 12 hours 59 min 10 sec'</literal>. Сочетание года и месяца также можно записать через минус; например <literal>'200-10'</literal> означает то, же что и <literal>'200 years 10 months'</literal>. (На самом деле только эти краткие формы разрешены стандартом <acronym>SQL</acronym> и они используются при выводе, когда <varname>IntervalStyle</varname> имеет значение <literal>sql_standard</literal>.)</para>

    <para>Интервалы можно также записывать в виде, определённом в ISO 8601, либо в <quote>формате с кодами</quote>, описанном в разделе 4.4.3.2 этого стандарта, либо в <quote>альтернативном формате</quote>, описанном в разделе 4.4.3.3. Формат с кодами выглядит так: <synopsis>
P <replaceable>количество</replaceable> <replaceable>единица</replaceable> <optional> <replaceable>количество</replaceable> <replaceable>единица</replaceable> ...</optional> <optional> T <optional> <replaceable>количество</replaceable> <replaceable>единица</replaceable> ...</optional></optional>
</synopsis> Строка должна начинаться с символа <literal>P</literal> и может включать также <literal>T</literal> перед временем суток. Допустимые коды единиц перечислены в <xref remap="6" linkend="datatype-interval-iso8601-units"/>. Коды единиц можно опустить или указать в любом порядке, но компоненты времени суток должны идти после символа <literal>T</literal>. В частности, значение кода <literal>M</literal> зависит от того, располагается ли он до или после <literal>T</literal>.</para>

     <table id="datatype-interval-iso8601-units">
      <title>Коды единиц временных интервалов ISO 8601</title>
     <tgroup cols="2">
       <thead>
        <row>
         <entry>Код</entry>
         <entry>Значение</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Y</entry>
         <entry>годы</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>месяцы (в дате)</entry>
        </row>
        <row>
         <entry>W</entry>
         <entry>недели</entry>
        </row>
        <row>
         <entry>D</entry>
         <entry>дни</entry>
        </row>
        <row>
         <entry>H</entry>
         <entry>часы</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>минуты (во времени)</entry>
        </row>
        <row>
         <entry>S</entry>
         <entry>секунды</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     <para>В альтернативном формате: <synopsis>
P <optional> <replaceable>год</replaceable>-<replaceable>месяц</replaceable>-<replaceable>день</replaceable> </optional> <optional> T <replaceable>часы</replaceable>:<replaceable>минуты</replaceable>:<replaceable>секунды</replaceable> </optional>
</synopsis> строка должна начинаться с <literal>P</literal>, а <literal>T</literal> разделяет компоненты даты и времени. Значения выражаются числами так же, как и в датах ISO 8601.</para>

    <para>При записи интервальной константы с указанием <replaceable>полей</replaceable> или присвоении столбцу типа interval строки с <replaceable>полями</replaceable>, интерпретация непомеченных величин зависит от <replaceable>полей</replaceable>. Например, <literal>INTERVAL '1' YEAR</literal> воспринимается как 1 год, а <literal>INTERVAL '1'</literal> &mdash; как 1 секунда. Кроме того, значения <quote>справа</quote> от меньшего значащего поля, заданного в определении <replaceable>полей</replaceable>, просто отбрасываются. Например, в записи <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal> будут отброшены секунды, но не день.</para>

    <para>Согласно стандарту <acronym>SQL</acronym>, все компоненты значения interval должны быть одного знака, и ведущий минус применяется ко всем компонентам; например, минус в записи <literal>'-1 2:03:04'</literal> применяется и к дню, и к часам/минутам/секундам. <productname>&productname;</productname> позволяет задавать для разных компонентов разные знаки и традиционно обрабатывает знак каждого компонента в текстовом представлении отдельно от других, так что в данном случае часы/минуты/секунды будут считаться положительными. Если параметр <varname>IntervalStyle</varname> имеет значение <literal>sql_standard</literal>, ведущий знак применяется ко всем компонентам (но только если они не содержат знаки явно). В противном случае действуют традиционные правила <productname>&productname;</productname>. Во избежание неоднозначности рекомендуется добавлять знак к каждому компоненту с отрицательным значением.</para>

    <para>Тип <type>interval</type> представлен внутри в виде отдельных значений месяцев, дней и секунд. Это объясняется тем, что число дней в месяце может быть разным, а в сутках может быть и 23, и 25 часов в дни перехода на летнее/зимнее время. Значения месяцев и дней представлены целыми числами, а число секунд может быть дробным. Так как интервалы обычно получаются из строковых констант или при вычитании типов <type>timestamp</type>, этот способ хранения эффективен в большинстве случаев. Для корректировки числа дней и часов, когда они выходят за обычные границы, в <productname>PostgreSQL</productname> есть специальные функции <function>justify_days</function> и <function>justify_hours</function>.</para>

    <para>В расширенном формате ввода и в некоторых полях более компактных форматов значения компонентов могут иметь дробные части, например <literal>'1.5 week'</literal> или <literal>'01:02:03.45'</literal>. Такое значение при сохранении пересчитывается в соответствующее число месяцев, дней и секунд. Когда при этом остаётся дробная часть в месяцах или в днях, она переносится в младший компонент с допущением, что 1 месяц = 30 дней, а 1 день = 24 часа. Например, значение <literal>'1.5 month'</literal> будет преобразовано в 1 месяц и 15 дней. В виде дробного числа хранятся и выводятся только секунды.</para>

    <para>В <xref remap="6" linkend="datatype-interval-input-examples"/> показано несколько примеров допустимых вводимых значений типа <type>interval</type>.</para>

     <table id="datatype-interval-input-examples">
      <title>Ввод интервалов</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Пример</entry>
         <entry>Описание</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1-2</entry>
         <entry>Стандартный формат SQL: 1 год и 2 месяца</entry>
        </row>
        <row>
         <entry>3 4:05:06</entry>
         <entry>Стандартный формат SQL: 3 дня 4 часа 5 минут 6 секунд</entry>
        </row>
        <row>
         <entry>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
         <entry>Традиционный формат Postgres: 1 год 2 месяца 3 дня 4 часа 5 минут 6 секунд</entry>
        </row>
        <row>
         <entry>P1Y2M3DT4H5M6S</entry>
         <entry><quote>Формат с кодами</quote> ISO 8601: то же значение, что и выше</entry>
        </row>
        <row>
         <entry>P0001-02-03T04:05:06</entry>
         <entry><quote>Альтернативный формат</quote> ISO 8601: то же значение, что и выше</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

   </sect2>

   <sect2 id="datatype-interval-output">
    <title>Вывод интервалов</title>

    <indexterm><primary>интервал</primary> <secondary>формат вывода</secondary> <seealso>форматирование</seealso></indexterm>

    <para>Формат вывода типа interval может определяться одним из четырёх стилей: <literal>sql_standard</literal>, <literal>postgres</literal>, <literal>postgres_verbose</literal> и <literal>iso_8601</literal>. Выбрать нужный стиль позволяет команда <literal>SET intervalstyle</literal> (по умолчанию выбран <literal>postgres</literal>). Примеры форматов разных стилей показаны в <xref remap="6" linkend="interval-style-output-table"/>.</para>

    <para>Стиль <literal>sql_standard</literal> выдаёт результат, соответствующий стандарту SQL, если значение интервала удовлетворяет ограничениям стандарта (и содержит либо только год и месяц, либо только день и время, и при этом все его компоненты одного знака). В противном случае выводится год-месяц, за которым идёт дата-время, а в компоненты для однозначности явно добавляются знаки.</para>

    <para>Вывод в стиле <literal>postgres</literal> соответствует формату, который был принят в <productname>PostgreSQL</productname> до версии 8.4, когда параметр <xref linkend="guc-datestyle"/> имел значение <literal>ISO</literal>.</para>

    <para>Вывод в стиле <literal>postgres_verbose</literal> соответствует формату, который был принят в <productname>PostgreSQL</productname> до версии 8.4, когда значением параметром <varname>DateStyle</varname> было не <literal>ISO</literal>.</para>

    <para>Вывод в стиле <literal>iso_8601</literal> соответствует <quote>формату с кодами</quote> описанному в разделе 4.4.3.2 формата ISO 8601.</para>

     <table id="interval-style-output-table">
       <title>Примеры стилей вывода интервалов</title>
       <tgroup cols="4">
        <thead>
         <row>
          <entry>Стиль</entry>
          <entry>Интервал год-месяц</entry>
          <entry>Интервал день-время</entry>
          <entry>Смешанный интервал</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>sql_standard</literal></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres</literal></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres_verbose</literal></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
         <row>
          <entry><literal>iso_8601</literal></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3DT-4H-5M-6S</entry>
         </row>
        </tbody>
       </tgroup>
    </table>

   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <title>Логический тип</title>

   <indexterm zone="datatype-boolean"><primary>логический</primary> <secondary>тип данных</secondary></indexterm>

   <indexterm zone="datatype-boolean"><primary>true</primary></indexterm>

   <indexterm zone="datatype-boolean"><primary>false</primary></indexterm>

   <para>В <productname>&productname;</productname> есть стандартный <acronym>SQL</acronym>-тип <type>boolean</type>; см. <xref remap="4" linkend="datatype-boolean-table"/>. Тип <type>boolean</type> может иметь следующие состояния: <quote>true</quote>, <quote>false</quote> и третье состояние, <quote>unknown</quote>, которое представляется <acronym>SQL</acronym>-значением NULL.</para>

   <table id="datatype-boolean-table">
    <title>Логический тип данных</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Имя</entry>
       <entry>Размер</entry>
       <entry>Описание</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>boolean</type></entry>
       <entry>1 байт</entry>
       <entry>состояние: истина или ложь</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>Состояние <quote>true</quote> может задаваться следующими значениями: <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'on'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist> Для состояния <quote>false</quote> можно использовать следующие варианты: <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'off'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist> При этом пробелы в начале и конце строки игнорируются, и регистр так же не имеет значения. Предпочтительными (совместимыми с <acronym>SQL</acronym>) являются варианты <literal>TRUE</literal> и <literal>FALSE</literal>.</para>

   <para><xref linkend="datatype-boolean-example"/> показывает, что значения типа <type>boolean</type> при выводе представляются буквами <literal>t</literal> и <literal>f</literal>.</para>

   <example id="datatype-boolean-example">
    <title>Использование типа <type>boolean</type></title>

<programlisting>CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est</programlisting>
   </example>
  </sect1>

  <sect1 id="datatype-enum">
   <title>Типы перечислений</title>

   <indexterm zone="datatype-enum"><primary>тип данных</primary> <secondary>перечисление (enum)</secondary></indexterm>

   <indexterm zone="datatype-enum"><primary>типы перечислений</primary></indexterm>

   <para>Типы перечислений (enum) определяют статический упорядоченный набор значений, так же как и типы <type>enum</type>, существующие в ряде языков программирования. В качестве перечисления можно привести дни недели или набор состояний.</para>

   <sect2>
    <title>Объявление перечислений</title>

    <para>Тип перечислений создаются с помощью команды <xref linkend="sql-createtype"/>, например так: <programlisting>CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');</programlisting> Созданные типы enum можно использовать в определениях таблиц и функций, как и любые другие: <programlisting>CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood 
------+--------------
 Moe  | happy
(1 row)</programlisting></para>
    </sect2>

    <sect2>
     <title>Порядок</title>

     <para>Порядок значений в перечислении определяется последовательностью, в которой были указаны значения при создании типа. Перечисления поддерживаются всеми стандартными операторами сравнения и связанными агрегатными функциями. Например: <programlisting>INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood &gt; 'sad';
 name  | current_mood 
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood &gt; 'sad' ORDER BY current_mood;
 name  | current_mood 
-------+--------------
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name  
-------
 Larry
(1 row)</programlisting></para>
   </sect2>

   <sect2>
    <title>Безопасность типа</title>

    <para>Все типы перечислений считаются уникальными и поэтому значения разных типов нельзя сравнивать. Взгляните на этот пример: <programlisting>CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ОШИБКА:  неверное значение для перечисления happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ОШИБКА:  оператор не существует: mood = happiness</programlisting></para>

    <para>Если вам действительно нужно сделать что-то подобное, вы можете либо реализовать собственный оператор, либо явно преобразовать типы в запросе: <programlisting>SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks 
------+-----------
 Moe  |         4
(1 row)</programlisting></para>
   </sect2>

   <sect2>
    <title>Тонкости реализации</title>

    <para>Значение enum занимает на диске 4 байта. Длина текстовой метки значения ограничена параметром компиляции <symbol>NAMEDATALEN</symbol>; в стандартных сборках <productname>&productname;</productname> он ограничивает длину 63 байтами.</para>

    <para>В метках значений регистр имеет значение, т. е. <type>'happy'</type> и <type>'HAPPY'</type> &mdash; не одно и то же. Также в метках имеют значение пробелы.</para>

    <para>Сопоставления внутренних значений enum с текстовыми метками хранятся в системном каталоге <link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>. Он может быть полезен в ряде случаев.</para>

   </sect2>
  </sect1>

  <sect1 id="datatype-geometric">
   <title>Геометрические типы</title>

   <para>Геометрические типы данных представляют объекты в двумерном пространстве. Все существующие в <productname>&productname;</productname> геометрические типы перечислены в <xref remap="6" linkend="datatype-geo-table"/>.</para>

    <table id="datatype-geo-table">
     <title>Геометрические типы</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Размер</entry>
        <entry>Описание</entry>
        <entry>Представление</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>point</type></entry>
        <entry>16 байт</entry>
        <entry>Точка на плоскости</entry>
        <entry>(x,y)</entry>
       </row>
       <row>
        <entry><type>line</type></entry>
        <entry>32 байта</entry>
        <entry>Бесконечная прямая</entry>
        <entry>{A,B,C}</entry>
       </row>
       <row>
        <entry><type>lseg</type></entry>
        <entry>32 байта</entry>
        <entry>Отрезок</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>box</type></entry>
        <entry>32 байта</entry>
        <entry>Прямоугольник</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n байт</entry>
        <entry>Закрытый путь (подобный многоугольнику)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n байт</entry>
        <entry>Открытый путь</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n байт</entry>
        <entry>Многоугольник (подобный закрытому пути)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>circle</type></entry>
        <entry>24 байта</entry>
        <entry>Окружность</entry>
        <entry>&lt;(x,y),r&gt; (центр окружности и радиус)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Для выполнения различных геометрических операций, в частности масштабирования, вращения и определения пересечений, <productname>PostgreSQL</productname> предлагает богатый набор функций и операторов. Они рассматриваются в <xref remap="6" linkend="functions-geometry"/>.</para>

   <sect2>
    <title>Точки</title>

    <indexterm><primary>точка</primary></indexterm>

    <para>Точки &mdash; это основной элемент, на базе которого строятся все остальные геометрические типы. Значения типа <type>point</type> записываются в одном из двух форматов: <synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis> где <replaceable>x</replaceable> и <replaceable>y</replaceable> &mdash; координаты точки на плоскости, выраженные числами с плавающей точкой.</para>

    <para>Выводятся точки в первом формате.</para>
   </sect2>

   <sect2 id="datatype-line">
    <title>Прямые</title>

    <indexterm><primary>прямая</primary></indexterm>

    <para>Прямые представляются линейным уравнением <replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0, где <replaceable>A</replaceable> и <replaceable>B</replaceable> не равны 0. Значения типа <type>line</type> вводятся и выводятся в следующем виде: <synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis> Кроме того, для ввода может использоваться любая из этих форм: <synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal> &mdash; две различные точки на данной прямой.</para>
   </sect2>

   <sect2 id="datatype-lseg">
    <title>Отрезки</title>

    <indexterm><primary>lseg</primary></indexterm>

    <indexterm><primary>отрезок</primary></indexterm>

    <para>Отрезок представляется парой точек, определяющих концы отрезка. Значения типа <type>lseg</type> записываются в одной из следующих форм: <synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal> &mdash; концы отрезка.</para>

    <para>Выводятся отрезки в первом формате.</para>
   </sect2>

   <sect2>
    <title>Прямоугольники</title>

    <indexterm><primary>box (тип данных)</primary></indexterm>

    <indexterm><primary>прямоугольник</primary></indexterm>

    <para>Прямоугольник представляется двумя точками, находящимися в противоположных его углах. Значения типа <type>box</type> записываются в одной из следующих форм: <synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal> &mdash; противоположные углы прямоугольника.</para>

    <para>Выводятся прямоугольники во второй форме.</para>

    <para>Во вводимом значении могут быть указаны любые два противоположных угла, но затем они будут упорядочены, так что внутри сохранятся правый верхний и левый нижний углы, в таком порядке.</para>
   </sect2>

   <sect2>
    <title>Пути</title>

    <indexterm><primary>path (тип данных)</primary></indexterm>

    <para>Пути представляют собой списки соединённых точек. Пути могут быть <firstterm>закрытыми</firstterm>, когда подразумевается, что первая и последняя точка в списке соединены, или <firstterm>открытыми</firstterm>, в противном случае.</para>

    <para>Значения типа <type>path</type> записываются в одной из следующих форм: <synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis> где точки задают узлы сегментов, составляющих путь. Квадратные скобки (<literal>[]</literal>) указывают, что путь открытый, а круглые (<literal>()</literal>) &mdash; закрытый. Когда внешние скобки опускаются, как в показанных выше последних трёх формах, считается, что путь закрытый.</para>

    <para>Пути выводятся в первой или второй форме, в соответствии с типом.</para>
   </sect2>

   <sect2 id="datatype-polygon">
    <title>Многоугольники</title>

    <indexterm><primary>многоугольник</primary></indexterm>

    <para>Многоугольники представляются списками точек (вершин). Многоугольники похожи на закрытые пути, но хранятся в другом виде и для работы с ними предназначен отдельный набор функций.</para>

    <para>Значения типа <type>polygon</type> записываются в одной из следующих форм: <synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis> где точки задают узлы сегментов, образующих границу многоугольника.</para>

    <para>Выводятся многоугольники в первом формате.</para>
   </sect2>

   <sect2 id="datatype-circle">
    <title>Окружности</title>

    <indexterm><primary>круг</primary></indexterm>

    <para>Окружности задаются координатами центра и радиусом. Значения типа <type>circle</type> записываются в одном из следующих форматов: <synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis> где <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal> &mdash; центр окружности, а <replaceable>r</replaceable> &mdash; её радиус.</para>

    <para>Выводятся окружности в первом формате.</para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <title>Типы, описывающие сетевые адреса</title>

   <indexterm zone="datatype-net-types"><primary>сетевые адреса</primary> <secondary>типы данных</secondary></indexterm>

   <para><productname>&productname;</productname> предлагает типы данных для хранения адресов IPv4, IPv6 и MAC, показанные в <xref remap="6" linkend="datatype-net-types-table"/>. Для хранения сетевых адресов лучше использовать эти типы, а не простые текстовые строки, так как <productname>&productname;</productname> проверяет вводимые значения данных типов и предоставляет специализированные операторы и функции для работы с ними (см. <xref remap="4" linkend="functions-net"/>).</para>

    <table tocentry="1" id="datatype-net-types-table">
     <title>Типы, описывающие сетевые адреса</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Размер</entry>
        <entry>Описание</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
        <entry>7 или 19 байт</entry>
        <entry>Сети IPv4 и IPv6</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
        <entry>7 или 19 байт</entry>
        <entry>Узлы и сети IPv4 и IPv6</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
        <entry>6 байт</entry>
        <entry>MAC-адреса</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>При сортировке типов <type>inet</type> и <type>cidr</type>, адреса IPv4 всегда идут до адресов IPv6, в том числе адреса IPv4, включённые в IPv6 или сопоставленные с ними, например ::10.2.3.4 или ::ffff:10.4.3.2.</para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm><primary>inet (тип данных)</primary></indexterm>

    <para>Тип <type>inet</type> содержит IPv4- или IPv6-адрес узла и может также содержать его подсеть, всё в одном поле. Подсеть представляется числом бит, определяющих адрес сети в адресе узла (или <quote>маску сети</quote>). Если маска сети равна 32 для адреса IPv4, такое значение представляет не подсеть, а определённый узел. Адреса IPv6 имеют длину 128 бит, поэтому уникальный адрес узла задаётся с маской 128 бит. Заметьте, что когда нужно, чтобы принимались только адреса сетей, следует использовать тип <type>cidr</type>, а не <type>inet</type>.</para>

    <para>Вводимые значения такого типа должны иметь формат <replaceable class="parameter">IP-адрес/y</replaceable>, где <replaceable class="parameter">IP-адрес</replaceable> &mdash; адрес IPv4 или IPv6, а <replaceable class="parameter">y</replaceable> &mdash; число бит в маске сети. Если компонент <replaceable class="parameter">/y</replaceable> отсутствует, маска сети считается равной 32 для IPv4 и 128 для IPv6, так что это значение будет представлять один узел. При выводе компонент <replaceable class="parameter">/y</replaceable> опускается, если сетевой адрес определяет адрес одного узла.</para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</type></title>

    <indexterm><primary>cidr</primary></indexterm>

    <para>Тип <type>cidr</type> содержит определение сети IPv4 или IPv6. Входные и выходные форматы соответствуют соглашениям CIDR (Classless Internet Domain Routing, Бесклассовая межсетевая адресация). Определение сети записывается в формате <replaceable class="parameter">IP-адрес/y</replaceable>, где <replaceable class="parameter">IP-адрес</replaceable> &mdash; адрес сети IPv4 или IPv6, а <replaceable class="parameter">y</replaceable> &mdash; число бит в маске сети. Если <replaceable class="parameter">y</replaceable> не указывается, это значение вычисляется по старой классовой схеме нумерации сетей, но при этом оно может быть увеличено, чтобы в него вошли все байты введённого адреса. Если в сетевом адресе справа от маски сети окажутся биты со значением 1, он будет считаться ошибочным.</para>

    <para>В <xref remap="6" linkend="datatype-net-cidr-table"/> показаны несколько примеров адресов.</para>

     <table id="datatype-net-cidr-table">
      <title>Примеры допустимых значений типа <type>cidr</type></title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Вводимое значение <type>cidr</type></entry>
         <entry>Выводимое значение <type>cidr</type></entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:&#8203;d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:&#8203;d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:&#8203;d1f1</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
    <title>Различия <type>inet</type> и <type>cidr</type></title>

    <para>Существенным различием типов данных <type>inet</type> и <type>cidr</type> является то, что <type>inet</type> принимает значения с ненулевыми битами справа от маски сети, а <type>cidr</type> &mdash; нет.</para>

      <tip>
        <para>Если вас не устраивает выходной формат значений <type>inet</type> или <type>cidr</type>, попробуйте функции <function>host</function>, <function>text</function> и <function>abbrev</function>.</para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

    <indexterm><primary>macaddr (тип данных)</primary></indexterm>

    <indexterm><primary>MAC-адрес</primary> <see>macaddr</see></indexterm>

    <para>Тип <type>macaddr</type> предназначен для хранения MAC-адреса, примером которого является адрес сетевой платы Ethernet (хотя MAC-адреса применяются и для других целей). Вводимые значения могут задаваться в следующих форматах: <simplelist>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'0800-2b01-0203'</literal></member>
      <member><literal>'08002b010203'</literal></member>
     </simplelist> Все эти примеры определяют один и тот же адрес. Шестнадцатеричные цифры от <literal>a</literal> до <literal>f</literal> могут быть и в нижнем, и в верхнем регистре. Выводятся MAC-адреса всегда в первой форме.</para>

    <para>Стандарт IEEE 802-2001 считает канонической формой MAC-адресов вторую (с минусами), а в первой (с двоеточиями) предполагает обратный порядок бит, так что 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. В настоящее время этому соглашению практически никто не следует, и уместно оно было только для устаревших сетевых протоколов (таких как Token Ring). &productname; не меняет порядок бит и во всех принимаемых форматах подразумевается традиционный порядок LSB.</para>

    <para>Последние пять входных форматов не описаны ни в каком стандарте.</para>
   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
   <title>Битовые строки</title>

   <indexterm zone="datatype-bit"><primary>битовая строка</primary> <secondary>тип данных</secondary></indexterm>

   <para>Битовые строки представляют собой последовательности из 1 и 0. Их можно использовать для хранения или отображения битовых масок. В SQL есть два битовых типа: <type>bit(<replaceable>n</replaceable>)</type> и <type>bit varying(<replaceable>n</replaceable>)</type>, где <replaceable>n</replaceable> &mdash; положительное целое число.</para>

   <para>Длина значения типа <type>bit</type> должна в точности равняться <replaceable>n</replaceable>; при попытке сохранить данные длиннее или короче произойдёт ошибка. Данные типа <type>bit varying</type> могут иметь переменную длину, но не превышающую <replaceable>n</replaceable>; строки большей длины не будут приняты. Запись <type>bit</type> без указания длины равнозначна записи <literal>bit(1)</literal>, тогда как <type>bit varying</type> без указания длины подразумевает строку неограниченной длины.</para>

   <note>
    <para>При попытке привести значение битовой строки к типу <type>bit(<replaceable>n</replaceable>)</type>, оно будет усечено или дополнено нулями справа до длины ровно <replaceable>n</replaceable> бит, ошибки при этом не будет. Подобным образом, если явно привести значение битовой строки к типу <type>bit varying(<replaceable>n</replaceable>)</type>, она будет усечена справа, если её длина превышает <replaceable>n</replaceable> бит.</para>
   </note>

   <para>Синтаксис констант битовых строк описан в <xref remap="6" linkend="sql-syntax-bit-strings"/>, а все доступные битовые операторы и функции перечислены в <xref remap="6" linkend="functions-bitstring"/>.</para>

   <example>
    <title>Использование битовых строк</title>

<programlisting>CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ОШИБКА:  длина битовой строки (2) не соответствует типу bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput></programlisting>
   </example>

   <para>Для хранения битовой строки используется по 1 байту для каждой группы из 8 бит, плюс 5 или 8 байт дополнительно в зависимости от длины строки (но длинные строки могут быть сжаты или вынесены отдельно, как описано в <xref remap="6" linkend="datatype-character"/> применительно к символьным строкам).</para>
  </sect1>

  <sect1 id="datatype-textsearch">
   <title>Типы, предназначенные для текстового поиска</title>

   <indexterm zone="datatype-textsearch"><primary>полнотекстовый поиск</primary> <secondary>типы данных</secondary></indexterm>

   <indexterm zone="datatype-textsearch"><primary>текстовый поиск</primary> <secondary>типы данных</secondary></indexterm>

   <para><productname>&productname;</productname> предоставляет два типа данных для поддержки полнотекстового поиска. Текстовым поиском называется операция анализа набора <firstterm>документов</firstterm> с текстом на естественном языке, в результате которой находятся фрагменты, наиболее соответствующие <firstterm>запросу</firstterm>. Тип <type>tsvector</type> представляет документ в виде, оптимизированном для текстового поиска, а <type>tsquery</type> представляет запрос текстового поиска в подобном виде. Более подробно это описывается в <xref remap="6" linkend="textsearch"/>, а все связанные функции и операторы перечислены в <xref remap="6" linkend="functions-textsearch"/>.</para>

   <sect2 id="datatype-tsvector">
    <title><type>tsvector</type></title>

    <indexterm><primary>tsvector (тип данных)</primary></indexterm>

    <para>Значение типа <type>tsvector</type> содержит отсортированный список неповторяющихся <firstterm>лексем</firstterm>, т. е. слов, <firstterm>нормализованных</firstterm> так, что все словоформы сводятся к одной (подробнее это описано в <xref remap="6" linkend="textsearch"/>). Сортировка и исключение повторяющихся слов производится автоматически при вводе значения, как показано в этом примере: <programlisting>SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'</programlisting> Для представления в виде лексем пробелов или знаков препинания их нужно заключить в апострофы: <programlisting>SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector                  
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'</programlisting> (В данном и следующих примерах мы используем строку в долларах, чтобы не дублировать все апострофы в таких строках.) При этом включаемый апостроф или обратную косую черту нужно продублировать: <programlisting>SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector                    
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'</programlisting> Также для лексем можно указать их целочисленные <firstterm>позиции</firstterm>: <programlisting>SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11
  rat:12'::tsvector;
                                  tsvector
---------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12
  'sat':4</programlisting> Позиция обычно указывает положение исходного слова в документе. Информация о расположении слов затем может использоваться для <firstterm>оценки близости</firstterm>. Позиция может задаваться числом от 1 до 16383; большие значения просто заменяются на 16383. Если для одной лексемы дважды указывается одно положение, такое повторение отбрасывается.</para>

    <para>Лексемам, для которых заданы позиции, также можно назначить <firstterm>вес</firstterm>, выраженный буквами <literal>A</literal>, <literal>B</literal>, <literal>C</literal> или <literal>D</literal>. Вес <literal>D</literal> подразумевается по умолчанию и поэтому он не показывается при выводе: <programlisting>SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector          
----------------------------
 'a':1A 'cat':5 'fat':2B,4C</programlisting> Веса обычно применяются для отражения структуры документа, например для придания особого значения словам в заголовке по сравнению со словами в обычном тексте. Назначенным весам можно сопоставить числовые приоритеты в функциях ранжирования результатов.</para>

    <para>Важно понимать, что тип <type>tsvector</type> сам по себе не выполняет нормализацию слов; предполагается, что в сохраняемом значении слова уже нормализованы приложением. Например: <programlisting>SELECT 'The Fat Rats'::tsvector;
      tsvector      
--------------------
 'Fat' 'Rats' 'The'</programlisting> Для большинства англоязычных приложений приведённые выше слова будут считаться ненормализованными, но для <type>tsvector</type> это не важно. Поэтому исходный документ обычно следует обработать функцией <function>to_tsvector</function>, нормализующей слова для поиска: <programlisting>SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector   
-----------------
 'fat':2 'rat':3</programlisting> И это подробнее описано в <xref remap="6" linkend="textsearch"/>.</para>

   </sect2>

   <sect2 id="datatype-tsquery">
    <title><type>tsquery</type></title>

    <indexterm><primary>tsquery (тип данных)</primary></indexterm>

    <para>Значение <type>tsquery</type> содержит искомые лексемы, объединяемые логическими операторами <literal>&amp;</literal> (И), <literal>|</literal> (ИЛИ) и <literal>!</literal> (НЕ), а также оператором поиска фраз <literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ). Также допускается вариация оператора ПРЕДШЕСТВУЕТ вида <literal>&lt;<replaceable>N</replaceable>&gt;</literal>, где <replaceable>N</replaceable> — целочисленная константа, задающая расстояние между двумя искомыми лексемами. Запись оператора <literal>&lt;-&gt;</literal> равнозначна <literal>&lt;1&gt;</literal>.</para>

    <para>Для группировки операторов могут использоваться скобки. Без скобок эти операторы имеют разные приоритеты, в порядке убывания: <literal>!</literal> (НЕ), <literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ), <literal>&amp;</literal> (И) и <literal>|</literal> (ИЛИ).</para>

    <para>Несколько примеров: <programlisting>SELECT 'fat &amp; rat'::tsquery;
    tsquery    
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery          
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery         
------------------------
 'fat' &amp; 'rat' &amp; !'cat'</programlisting></para>

    <para>Лексемам в <type>tsquery</type> можно дополнительно сопоставить буквы весов, при этом они будут соответствовать только тем лексемам в <type>tsvector</type>, которые имеют какой-либо из этих весов: <programlisting>SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'</programlisting></para>

    <para>Кроме того, в лексемах <type>tsquery</type> можно использовать знак <literal>*</literal> для поиска по префиксу: <programlisting>SELECT 'super:*'::tsquery;
  tsquery  
-----------
 'super':*</programlisting> Этот запрос найдёт все слова в <type>tsvector</type>, начинающиеся с приставки <quote>super</quote>.</para>

    <para>Апострофы в лексемах этого типа можно использовать так же, как и в лексемах в <type>tsvector</type>; и так же, как и для типа <type>tsvector</type>, необходимая нормализация слова должна выполняться до приведения значения к типу <type>tsquery</type>. Для такой нормализации удобно использовать функцию <function>to_tsquery</function>: <programlisting>SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery    
------------------
 'fat':AB &amp; 'cat'</programlisting> Заметьте, что функция <function>to_tsquery</function> будет обрабатывать префиксы подобно другим словам, поэтому следующее сравнение возвращает true: <programlisting>SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
----------
 t</programlisting> так как <literal>postgres</literal> преобразуется стеммером в <literal>postgr</literal>: <programlisting>SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
---------------+------------
 'postgradu':1 | 'postgr':*</programlisting> и эта приставка находится в преобразованной форме слова <literal>postgraduate</literal>.</para>

   </sect2>

  </sect1>

  <sect1 id="datatype-uuid">
   <title>Тип <acronym>UUID</acronym></title>

   <indexterm zone="datatype-uuid"><primary>UUID</primary></indexterm>

   <para>Тип данных <type>uuid</type> сохраняет универсальные уникальные идентификаторы (Universally Unique Identifiers, UUID), определённые в RFC 4122, ISO/IEC 9834-8:2005 и связанных стандартах. (В некоторых системах это называется <indexterm><primary>GUID</primary></indexterm>GUID, глобальным уникальным идентификатором.) Этот идентификатор представляет собой 128-битное значение, генерируемое специальным алгоритмом, практически гарантирующим, что этим же алгоритмом оно не будет получено больше нигде в мире. Таким образом, эти идентификаторы будут уникальными и в распределённых системах, а не только в единственной базе данных, как значения генераторов последовательностей.</para>

   <para>UUID записывается в виде последовательности шестнадцатеричных цифр в нижнем регистре, разделённых знаками минуса на несколько групп, в таком порядке: группа из 8 цифр, за ней три группы из 4 цифр и, наконец, группа из 12 цифр, что в сумме составляет 32 цифры и представляет 128 бит. Пример UUID в этом стандартном виде: <programlisting>a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11</programlisting> <productname>&productname;</productname> также принимает альтернативные варианты: цифры в верхнем регистре, стандартную запись, заключённую в фигурные скобки, запись без минусов или с минусами, разделяющими любые группы из четырёх цифр. Например: <programlisting>A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}</programlisting> Выводится значение этого типа всегда в стандартном виде.</para>

   <para>В <productname>&productname;</productname> встроены функции хранения и сравнения идентификаторов UUID, но нет внутренней функции генерирования UUID, потому что не существует какого-то единственного алгоритма, подходящего для всех приложений. Сгенерировать UUID можно с помощью дополнительного модуля <xref linkend="uuid-ossp"/>, в котором реализованы несколько стандартных алгоритмов, а можно воспользоваться модулем <xref linkend="pgcrypto"/>, где тоже есть функция генерирования случайных UUID. Кроме того, можно сделать это в клиентском приложении или в другой библиотеке, подключённой на стороне сервера.</para>
  </sect1>

  <sect1 id="datatype-xml">
   <title>Тип <acronym>XML</acronym></title>

   <indexterm zone="datatype-xml"><primary>XML</primary></indexterm>

   <para>Тип <type>xml</type> предназначен для хранения XML-данных. Его преимущество по сравнению с обычным типом <type>text</type> в том, что он проверяет вводимые значения на допустимость по правилам XML и для работы с ним есть типобезопасные функции; см. <xref remap="4" linkend="functions-xml"/>. Для использования этого типа дистрибутив должен быть скомпилирован в конфигурации <command>configure --with-libxml</command>.</para>

   <para>Тип <type>xml</type> может сохранять правильно оформленные <quote>документы</quote>, в соответствии со стандартом XML, а также фрагменты <quote>содержимого</quote>, описанные как <literal>содержимое</literal> элементов в стандарте XML. Другими словами, это означает, что фрагменты содержимого могут содержать несколько элементов верхнего уровня или текстовых узлов. Определить, является ли определённое значение типа <type>xml</type> полным документом или фрагментом содержимого, позволяет выражение <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>.</para>

   <sect2>
    <title>Создание XML-значений</title>
   <para>Чтобы получить значение типа <type>xml</type> из текстовой строки, используйте функцию <function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm> <synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis> Примеры: <programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting> Хотя в стандарте SQL описан только один способ преобразования текстовых строк в XML-значения, специфический синтаксис &productname;: <programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting> тоже допустим.</para>

   <para>Тип <type>xml</type> не проверяет вводимые значения по схеме DTD (Document Type Declaration, Объявления типа документа),<indexterm><primary>DTD</primary></indexterm> даже если в них присутствуют ссылка на DTD. В настоящее время в <productname>PostgreSQL</productname> также нет встроенной поддержки других разновидностей схем, например XML Schema.</para>

   <para>Обратная операция, получение текстовой строки из <type>xml</type>, выполняется с помощью функции <function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm> <synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>значение</replaceable> AS <replaceable>тип</replaceable> )
</synopsis> Здесь допустимый <replaceable>тип</replaceable> &mdash; <type>character</type>, <type>character varying</type> или <type>text</type> (или их псевдонимы). И в данном случае стандарт SQL предусматривает только один способ преобразования <type>xml</type> в тип текстовых строк, но &productname; позволяет просто привести значение к нужному типу.</para>

   <para>При преобразовании текстовой строки в тип <type>xml</type> или наоборот без использования функций <type>XMLPARSE</type> и <type>XMLSERIALIZE</type>, выбор режима <literal>DOCUMENT</literal> или <literal>CONTENT</literal> определяется параметром конфигурации сеанса <quote>XML option</quote><indexterm><primary>XML option</primary></indexterm>, установить который можно следующей стандартной командой: <synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis> или такой командой в духе &productname;:<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis> По умолчанию этот параметр имеет значение <literal>CONTENT</literal>, так что допускаются все формы XML-данных.</para>

   <note>
    <para>Когда параметр XML option имеет значение по умолчанию, текстовые строки нельзя напрямую привести к типу <type>xml</type>, если они содержат объявление типа документа, так как такие объявления не допускаются во фрагментах. Для выполнения преобразования в таких случаях следует использовать <literal>XMLPARSE</literal> или изменить параметр XML option.</para>
   </note>

   </sect2>

   <sect2>
    <title>Обработка кодировки</title>
   <para>Если на стороне сервера и клиента и в XML-данных используются разные кодировки символов, с этим могут возникать проблемы. Когда запросы передаются на сервер, а их результаты возвращаются клиенту в обычном текстовом режиме, &productname; преобразует все передаваемые текстовые данные в кодировку для соответствующей стороны; см. <xref remap="4" linkend="multibyte"/>. В том числе это происходит и со строковыми представлениями XML-данных, подобными тем, что показаны в предыдущих примерах. Обычно это означает, что объявления кодировки, содержащиеся в XML-данных, могут не соответствовать действительности, когда текстовая строка преобразуется из одной кодировки в другую при передаче данных между клиентом и сервером, так как подобные включённые в данные объявления не будут изменены автоматически. Для решения этой проблемы объявления кодировки, содержащиеся в текстовых строках, вводимых в тип <type>xml</type>, просто <emphasis>игнорируются</emphasis> и предполагается, что XML-содержимое представлено в текущей кодировке сервера. Как следствие, для правильной обработки таких строк с XML-данными клиент должен передавать их в своей текущей кодировке. Для сервера не важно, будет ли клиент для этого преобразовывать документы в свою кодировку, или изменит её, прежде чем передавать ему данные. При выводе значения типа <type>xml</type> не содержат объявления кодировки, а клиент должен предполагать, что все данные поступают в его текущей кодировке.</para>

   <para>Если параметры запроса передаются на сервер и он возвращает результаты клиенту в двоичном режиме, кодировка символов не преобразуется, так что возникает другая ситуация. В этом случае объявление кодировки в XML принимается во внимание, а если его нет, то предполагается, что данные закодированы в UTF-8 (это соответствует стандарту XML; заметьте, что &productname; не поддерживает UTF-16). При выводе в данные будет добавлено объявление кодировки, выбранной на стороне клиента (но если это UTF-8, объявление будет опущено).</para>

   <para>Само собой, XML-данные в &productname; будут обрабатываться гораздо эффективнее, когда и в XML-данных, и на стороне клиента, и на стороне сервера используется одна кодировка. Так как внутри XML-данные представляются в UTF-8, оптимальный вариант, когда на сервере также выбрана кодировка UTF-8.</para>

   <caution>
    <para>Некоторые XML-функции могут вовсе не работать с данными не-ASCII, если кодировка сервера &mdash; не UTF-8. В частности, это известная особенность функции <function>xpath()</function>.</para>
   </caution>
   </sect2>

   <sect2>
   <title>Обращение к XML-значениям</title>

   <para>Тип <type>xml</type> отличается от других тем, что для него не определены никакие операторы сравнения, так как чётко определённого и универсального алгоритма сравнения XML-данных не существует. Одно из следствий этого &mdash; нельзя отфильтровать строки таблицы, сравнив столбец <type>xml</type> с искомым значением. Поэтому обычно XML-значения должны дополняться отдельным ключевым полем, например ID. Можно также сравнивать XML-значения, преобразовав их сначала в текстовые строки, но заметьте, что с учётом специфики XML-данных этот метод практически бесполезен.</para>

   <para>Из-за отсутствия операторов сравнения для типа <type>xml</type>, для столбца этого типа также нельзя создать индекс. Поэтому, когда требуется быстрый поиск в XML данных, обойти это ограничение можно, приведя данные к типу текстовой строки и проиндексировав эти строки, либо проиндексировав выражение XPath. Конечно сам запрос при этом следует изменить, чтобы поиск выполнялся по индексированному выражению.</para>

   <para>Для ускорения поиска в XML-данных также можно использовать функции полнотекстового поиска в &productname;. Однако это требует определённой подготовки данных, что дистрибутив &productname; пока не поддерживает.</para>
   </sect2>
  </sect1>

  &json;

  &array;

  &rowtypes;

  &rangetypes;

  <sect1 id="datatype-oid">
   <title>Идентификаторы объектов</title>

   <indexterm zone="datatype-oid"><primary>идентификатор объекта</primary> <secondary>тип данных</secondary></indexterm>

   <indexterm zone="datatype-oid"><primary>oid</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regproc</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regprocedure</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regoper</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regoperator</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regclass</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regtype</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regconfig</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>regdictionary</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>xid</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>cid</primary></indexterm>

   <indexterm zone="datatype-oid"><primary>tid</primary></indexterm>

   <para>Идентификатор объекта (Object Identifier, OID) используется внутри <productname>&productname;</productname> в качестве первичного ключа различных системных таблиц. В пользовательские таблицы столбец OID добавляется, только если при создании таблицы указывается <literal>WITH OIDS</literal> или включён параметр конфигурации <xref linkend="guc-default-with-oids"/>. Идентификатор объекта представляется в типе <type>oid</type>. Также для типа <type>oid</type> определены следующие псевдонимы: <type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, <type>regoperator</type>, <type>regclass</type>, <type>regtype</type>, <type>regrole</type>, <type>regnamespace</type>, <type>regconfig</type> и <type>regdictionary</type>. Обзор этих типов приведён в <xref remap="6" linkend="datatype-oid-table"/>.</para>

   <para>В настоящее время тип <type>oid</type> реализован как четырёхбайтное целое. Таким образом оно может быть недостаточно большим для обеспечения уникальности в базе данных или даже в отдельных больших таблицах. Поэтому в пользовательских таблицах использовать столбец типа OID в качестве первичного ключа не рекомендуется. Лучше всего ограничить применение этого типа обращениями к системным таблицам.</para>

   <para>Для самого типа <type>oid</type> помимо сравнения определены всего несколько операторов. Однако его можно привести к целому и затем задействовать в обычных целочисленных вычислениях. (При этом следует опасаться путаницы со знаковыми/беззнаковыми значениями.)</para>

   <para>Типы-псевдонимы OID сами по себе не вводят новых операций и отличаются только специализированными функциями ввода/вывода. Эти функции могут принимать и выводить не просто числовые значения, как тип <type>oid</type>, а символические имена системных объектов. Эти типы позволяют упростить поиск объектов по значениям OID. Например, чтобы выбрать из <structname>pg_attribute</structname> строки, относящиеся к таблице <literal>mytable</literal>, можно написать: <programlisting>SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;</programlisting> вместо: <programlisting>SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');</programlisting> Хотя второй вариант выглядит не таким уж плохим, но это лишь очень простой запрос. Если же потребуется выбрать правильный OID, когда таблица <literal>mytable</literal> есть в нескольких схемах, вложенный подзапрос будет гораздо сложнее. Преобразователь вводимого значения типа <type>regclass</type> находит таблицу согласно заданному пути поиска схем, так что он делает <quote>всё правильно</quote> автоматически. Аналогично, приведя идентификатор таблицы к типу <type>regclass</type>, можно получить символическое представление числового кода.</para>

    <table id="datatype-oid-table">
     <title>Идентификаторы объектов</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Ссылки</entry>
        <entry>Описание</entry>
        <entry>Пример значения</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</type></entry>
        <entry>any</entry>
        <entry>числовой идентификатор объекта</entry>
        <entry><literal>564182</literal></entry>
       </row>

       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>имя функции</entry>
        <entry><literal>sum</literal></entry>
       </row>

       <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>функция с типами аргументов</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>

       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>имя оператора</entry>
        <entry><literal>+</literal></entry>
       </row>

       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>оператор с типами аргументов</entry>
        <entry><literal>*(integer,integer)</literal> или <literal>-(NONE,integer)</literal></entry>
       </row>

       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
        <entry>имя отношения</entry>
        <entry><literal>pg_type</literal></entry>
       </row>

       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
        <entry>имя типа данных</entry>
        <entry><literal>integer</literal></entry>
       </row>

       <row>
        <entry><type>regrole</type></entry>
        <entry><structname>pg_authid</structname></entry>
        <entry>имя роли</entry>
        <entry><literal>smithee</literal></entry>
       </row>

       <row>
        <entry><type>regnamespace</type></entry>
        <entry><structname>pg_namespace</structname></entry>
        <entry>пространство имён</entry>
        <entry><literal>pg_catalog</literal></entry>
       </row>

       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
        <entry>конфигурация текстового поиска</entry>
        <entry><literal>english</literal></entry>
       </row>

       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
        <entry>словарь текстового поиска</entry>
        <entry><literal>simple</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Все типы псевдонимов OID для объектов, сгруппированных в пространство имён, принимают имена, дополненные именем схемы, и выводят имена со схемой, если данный объект нельзя будет найти в текущем пути поиска без имени схемы. Типы <type>regproc</type> и <type>regoper</type> принимают только уникальные вводимые имена (не перегруженные), что ограничивает их применимость; в большинстве случаев лучше использовать <type>regprocedure</type> или <type>regoperator</type>. Для типа <type>regoperator</type> в записи унарного оператора неиспользуемый операнд заменяется словом <literal>NONE</literal>.</para>

   <para>Дополнительным свойством большинства типов псевдонимов OID является образование зависимостей. Когда в сохранённом выражении фигурирует константа одного из этих типов (например, в представлении или в значении столбца по умолчанию), это создаёт зависимость от целевого объекта. Например, если значение по умолчанию определяется выражением <literal>nextval('my_seq'::regclass)</literal>, <productname>&productname;</productname> понимает, что это выражение зависит от последовательности <literal>my_seq</literal>, и не позволит удалить последовательность раньше, чем будет удалено это выражение. Единственным ограничением является тип <type>regrole</type>. Константы этого типа в таких выражениях не допускаются.</para>

   <note>
   <para>Типы псевдонимов OID не полностью следуют правилам изоляции транзакций. Планировщик тоже воспринимает их как простые константы, что может привести к неоптимальному планированию запросов.</para>
   </note>

   <para>Есть ещё один тип системных идентификаторов, <type>xid</type>, представляющий идентификатор транзакции (сокращённо <abbrev>xact</abbrev>). Этот тип имеют системные столбцы <structfield>xmin</structfield> и <structfield>xmax</structfield>. В <productname>&productname;</productname> идентификаторы транзакций реализованы как 64-битные счётчики, что позволяет предотвратить зацикливание идентификаторов. За подробностями обратитесь к <xref remap="3" linkend="vacuum-for-wraparound"/>.</para>

   <para>Третий тип идентификаторов, используемых в системе, &mdash; <type>cid</type>, идентификатор команды (command identifier). Этот тип данных имеют системные столбцы <structfield>cmin</structfield> и <structfield>cmax</structfield>. Идентификаторы команд &mdash; 32-битные числа.</para>

   <para>И наконец, последний тип системных идентификаторов &mdash; <type>tid</type>, идентификатор строки/кортежа (tuple identifier). Этот тип данных имеет системный столбец <structfield>ctid</structfield>. Идентификатор кортежа представляет собой пару (из номера блока и индекса кортежа в блоке), идентифицирующую физическое расположение строки в таблице.</para>

   <para>(Подробнее о системных столбцах рассказывается в <xref remap="6" linkend="ddl-system-columns"/>.)</para>
  </sect1>

  <sect1 id="datatype-pg-lsn">
   <title><acronym>Тип pg_lsn</acronym></title>

   <indexterm zone="datatype-pg-lsn"><primary>pg_lsn</primary></indexterm>

   <para>Тип данных <type>pg_lsn</type> может применяться для хранения значения LSN (последовательный номер в журнале, Log Sequence Number), которое представляет собой указатель на позицию в журнале транзакций (XLOG). Этот тип содержит <type>XLogRecPtr</type> и является внутренним системным типом <productname>&productname;</productname>.</para>

   <para>Технически LSN &mdash; это 64-битное целое, представляющее байтовое смещение в потоке журнала упреждающей записи. Он выводится в виде двух шестнадцатеричных чисел до 8 цифр каждое, через косую черту, например: <literal>16/B374D848</literal>. Тип <type>pg_lsn</type> поддерживает стандартные операторы сравнения, такие как <literal>=</literal> и <literal>&gt;</literal>. Можно также вычесть один LSN из другого с помощью оператора <literal>-</literal>; результатом будет число байт между этими двумя позициями в журнале транзакций.</para>
  </sect1>

  <sect1 id="datatype-pseudo">
   <title>Псевдотипы</title>

   <indexterm zone="datatype-pseudo"><primary>record</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>any</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>anyelement</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>anyarray</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>anynonarray</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>anyenum</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>anyrange</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>void</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>trigger</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>event_trigger</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>pg_ddl_command</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>language_handler</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>fdw_handler</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>index_am_handler</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>tsm_handler</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>cstring</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>internal</primary></indexterm>

   <indexterm zone="datatype-pseudo"><primary>opaque</primary></indexterm>

   <para>В систему типов <productname>&productname;</productname> включены несколько специальных элементов, которые в совокупности называются <firstterm>псевдотипами</firstterm>. Псевдотип нельзя использовать в качестве типа данных столбца, но можно объявить функцию с аргументом или результатом такого типа. Каждый из существующих псевдотипов полезен в ситуациях, когда характер функции не позволяет просто получить или вернуть определённый тип данных <acronym>SQL</acronym>. Все существующие псевдотипы перечислены в <xref remap="6" linkend="datatype-pseudotypes-table"/>.</para>

    <table id="datatype-pseudotypes-table">
     <title>Псевдотипы</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Имя</entry>
        <entry>Описание</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</type></entry>
        <entry>Указывает, что функция принимает любой вводимый тип данных.</entry>
       </row>

       <row>
        <entry><type>anyelement</type></entry>
        <entry>Указывает, что функция принимает любой тип данных (см. <xref remap="4" linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anyarray</type></entry>
        <entry>Указывает, что функция принимает любой тип массива (см. <xref remap="4" linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anynonarray</type></entry>
        <entry>Указывает, что функция принимает любой тип данных, кроме массивов (см. <xref remap="4" linkend="extend-types-polymorphic"/>).</entry>
       </row>

       <row>
        <entry><type>anyenum</type></entry>
        <entry>Указывает, что функция принимает любое перечисление (см. <xref remap="4" linkend="extend-types-polymorphic"/> и <xref remap="4" linkend="datatype-enum"/>).</entry>
       </row>

       <row>
        <entry><type>anyrange</type></entry>
        <entry>Указывает, что функция принимает любой диапазонный тип данных (см. <xref remap="4" linkend="extend-types-polymorphic"/> и <xref remap="4" linkend="rangetypes"/>).</entry>
       </row>

       <row>
        <entry><type>cstring</type></entry>
        <entry>Указывает, что функция принимает или возвращает строку в стиле C.</entry>
       </row>

       <row>
        <entry><type>internal</type></entry>
        <entry>Указывает, что функция принимает или возвращает внутренний серверный тип данных.</entry>
       </row>

       <row>
        <entry><type>language_handler</type></entry>
        <entry>Обработчик процедурного языка объявляется как возвращающий тип <type>language_handler</type>.</entry>
       </row>

       <row>
        <entry><type>fdw_handler</type></entry>
        <entry>Обработчик обёртки сторонних данных объявляется как возвращающий тип <type>fdw_handler</type>.</entry>
       </row>

       <row>
        <entry><type>index_am_handler</type></entry>
        <entry>Обработчик метода доступа индекса объявляется как возвращающий тип <type>index_am_handler</type>.</entry>
       </row>

       <row>
        <entry><type>tsm_handler</type></entry>
        <entry>Обработчик метода выборки из таблицы объявляется как возвращающий тип <type>tsm_handler</type>.</entry>
       </row>

       <row>
        <entry><type>record</type></entry>
        <entry>Указывает, что функция принимает или возвращает неопределённый тип строки.</entry>
       </row>

       <row>
        <entry><type>trigger</type></entry>
        <entry>Триггерная функция объявляется как возвращающая тип <type>trigger</type>.</entry>
       </row>

       <row>
        <entry><type>event_trigger</type></entry>
        <entry>Функция событийного триггера объявляется как возвращающая тип <type>event_trigger</type>.</entry>
       </row>

       <row>
        <entry><type>pg_ddl_command</type></entry>
        <entry>Обозначает представление команд DDL, доступное событийным триггерам.</entry>
       </row>

       <row>
        <entry><type>void</type></entry>
        <entry>Указывает, что функция не возвращает значение.</entry>
       </row>

       <row>
        <entry><type>opaque</type></entry>
        <entry>Устаревший тип, который раньше использовался во всех вышеперечисленных случаях.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>Функции, написанные на языке C (встроенные или динамически загружаемые), могут быть объявлены с параметрами или результатами любого из этих типов. Ответственность за безопасное поведение функции с аргументами таких типов ложится на разработчика функции.</para>

   <para>Функции, написанные на процедурных языках, могут использовать псевдотипы, только если это позволяет соответствующий язык. В настоящее время большинство процедурных языков запрещают использовать псевдотипы в качестве типа аргумента и позволяют использовать для результатов только типы <type>void</type> и <type>record</type> (и <type>trigger</type> или <type>event_trigger</type>, когда функция реализует триггер или событийный триггер). Некоторые языки также поддерживают полиморфные функции с типами <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type> и <type>anyrange</type>.</para>

   <para>Псевдотип <type>internal</type> используется в объявлениях функций, предназначенных только для внутреннего использования в СУБД, но не для прямого вызова в запросах <acronym>SQL</acronym>. Если у функции есть как хотя бы один аргумент типа <type>internal</type>, её нельзя будет вызывать из <acronym>SQL</acronym>. Чтобы сохранить типобезопасность при таком ограничении, следуйте важному правилу: не создавайте функцию, возвращающую результат типа <type>internal</type>, если у неё нет ни одного аргумента <type>internal</type>.</para>

  </sect1>

 </chapter>
