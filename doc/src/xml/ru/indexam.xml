<!-- doc/src/xml/indexam.xml -->

<chapter id="indexam">
 <title>Определение интерфейса для методов доступа индекса</title>

  <para>В этой главе описывается интерфейс между ядром системы <productname>&productname;</productname> и <firstterm>методами доступа индексов</firstterm>, которые управляют отдельными типами индексов. Ядро системы не знает об индексах ничего, кроме того, что описано здесь; благодаря этому можно реализовывать абсолютно новые типы индексов, разрабатывая код в виде расширения.</para>

  <para>Все индексы <productname>&productname;</productname> являются, говоря на техническом уровне, <firstterm>вторичными индексами</firstterm>; то есть, они физически отделены от файла таблицы, к которой относятся. Каждый индекс хранится в собственном отдельном физическом <firstterm>отношении</firstterm> и описывается в отдельной записи в каталоге <structname>pg_class</structname>. Содержимое индекса находится полностью под контролем соответствующего метода доступа. На практике все методы доступа индексов делят индексы на страницы стандартного размера, чтобы для обращения к содержимому индекса можно было задействовать обычный менеджер хранилища и менеджер буферов. (Более того, большинство существующих методов доступа используют одну структуру страницы, описанную в <xref remap="6" linkend="storage-page-layout"/>, и одинаковый формат заголовков кортежей индекса; но эти решения методам доступа не навязываются.)</para>

  <para>Индекс по сути представляет собой сопоставление некоторых значений ключей данных с <firstterm>идентификаторами кортежей</firstterm>, <acronym>TID</acronym> (Tuple Identifier), или версиями строк в основной таблице индекса. TID состоит из номера блока и номера записи в этом блоке (см. <xref remap="4" linkend="storage-page-layout"/>). Этой информации достаточно, чтобы выбрать определённую версию строки из таблицы. Индексы сами по себе не знают, что в модели MVCC у одной логической строки может быть несколько существующих версий; для индекса каждый кортеж — независимый объект, которому нужна своя запись в индексе. Таким образом, при изменении строки для неё всегда заново создаются новые записи индекса, даже если значения ключа не изменились. (Кортежи HOT представляют собой исключение из этого утверждения; но индексы всё равно не имеют с этим дела.) Записи индексов для мёртвых кортежей высвобождаются (при очистке), когда высвобождаются сами мёртвые кортежи.</para>

 <sect1 id="index-api">
  <title>Базовая структура API для индексов</title>

  <para>Каждый метод доступа индекса описывается строкой в системном каталоге <link linkend="catalog-pg-am"><structname>pg_am</structname></link>. В записи <structname>pg_am</structname> указывается имя и <firstterm>функция-обработчик</firstterm> для метода доступа. Эти записи могут создаваться и удаляться командами SQL <xref linkend="sql-create-access-method"/> и <xref linkend="sql-drop-access-method"/>.</para>

  <para>Функция-обработчик метода доступа должна объявляться как принимающая один аргумент типа <type>internal</type> и возвращающая псевдотип <type>index_am_handler</type>. Аргумент в данном случае фиктивный, и нужен только для того, чтобы эту функцию нельзя было вызывать непосредственно из команд SQL. Возвращать эта функция должна структуру типа <structname>IndexAmRoutine</structname> (в памяти palloc), содержащую всё, что нужно знать коду ядра, чтобы использовать этот метод доступа. Структура <structname>IndexAmRoutine</structname>, также называемая <firstterm>структурой API</firstterm> метода доступа, содержит поля, задающие разнообразные предопределённые свойства метода доступа, например, поддерживает ли он составные индексы. Что более важно, она содержит указатели на опорные функции для метода доступа. Это обычные функции на C и они не видны и не могут быть вызваны на уровне SQL. Опорные функции описаны в <xref remap="6" linkend="index-functions"/>.</para>

  <para>Структура <structname>IndexAmRoutine</structname> определяется так: <programlisting>typedef struct IndexAmRoutine
{
    NodeTag     type;

    /*
     * Общее число стратегий (операторов), с которыми возможен поиск/применение
     * этого метода доступа (МД).  Ноль, если у этого МД нет фиксированного набора назначенных стратегий.
     */
    uint16      amstrategies;
    /* общее число опорных функций, используемых этим МД */
    uint16      amsupport;
    /* поддерживает ли МД упорядочивание (ORDER BY) значений индексированного столбца? */
    bool        amcanorder;
    /* поддерживает ли МД упорядочивание (ORDER BY) результата оператора с индексированным столбцом? */
    bool        amcanorderbyop;
    /* поддерживает ли МД сканирование в обратном направлении? */
    bool        amcanbackward;
    /* поддерживает ли МД уникальные индексы (UNIQUE)? */
    bool        amcanunique;
    /* поддерживает ли МД индексы с несколькими столбцами? */
    bool        amcanmulticol;
    /* требуется ли для сканирования с МД ограничение первого столбца индекса? */
    bool        amoptionalkey;
    /* воспринимает ли МД условия ScalarArrayOpExpr? */
    bool        amsearcharray;
    /* воспринимает ли МД условия IS NULL/IS NOT NULL? */
    bool        amsearchnulls;
    /* может ли тип, хранящийся в индексе, отличаться от типа столбца? */
    bool        amstorage;
    /* возможна ли кластеризация по индексу этого типа? */
    bool        amclusterable;
    /* МД обрабатывает предикатные блокировки? */
    bool        ampredlocks;
    /* поддерживает ли МД включённые колонки, задаваемые в INCLUDE? */
    bool    amcaninclude;
    /* тип данных, хранящихся в индексе, либо InvalidOid, если он переменный */
    Oid         amkeytype;

    /* интерфейсные функции */
    ambuild_function ambuild;
    ambuildempty_function ambuildempty;
    aminsert_function aminsert;
    ambulkdelete_function ambulkdelete;
    amvacuumcleanup_function amvacuumcleanup;
    amcanreturn_function amcanreturn;   /* может быть NULL */
    amcostestimate_function amcostestimate;
    amoptions_function amoptions;
    amproperty_function amproperty;     /* может быть NULL */
    amvalidate_function amvalidate;
    ambeginscan_function ambeginscan;
    amrescan_function amrescan;
    amgettuple_function amgettuple;     /* может быть NULL */
    amgetbitmap_function amgetbitmap;   /* может быть NULL */
    amendscan_function amendscan;
    ammarkpos_function ammarkpos;       /* может быть NULL */
    amrestrpos_function amrestrpos;     /* может быть NULL */
} IndexAmRoutine;</programlisting></para>

  <para>Чтобы метод доступа индекса применялся, необходимо также определить <firstterm>семейства операторов</firstterm> и <firstterm>классы операторов</firstterm> в <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>, <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>, <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link> и <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>. Эти записи позволяют планировщику понять, для каких видов условий запросов могут применяться индексы с данными методом доступа. Семейства и классы операторов описываются в <xref remap="6" linkend="xindex"/>; этот материал необходимо изучить, прежде чем читать данную главу.</para>

  <para>Отдельный индекс определяется записью в <link linkend="catalog-pg-class"><structname>pg_class</structname></link>, описывающей его как физическое отношение, и записью в <link linkend="catalog-pg-index"><structname>pg_index</structname></link>, представляющей логическое содержание индекса &mdash; то есть, набор столбцов индекса и семантическое значение этих столбцов, установленное соответствующими классами операторов. Столбцами индекса (значениями ключа) могут быть либо простые столбцы нижележащей таблицы, либо выражения, вычисляемые по строкам таблицы. Для метода доступа индекса обычно не важно, откуда поступают значения ключа индекса (они всегда поступают в вычисленном виде), но очень важна информация о классе операторов в каталоге <structname>pg_index</structname>. Обе эти записи каталогов представлены в составе структуры данных <structname>Relation</structname>, которая передаётся всем функциям, реализующим операции с индексом.</para>

  <para>С некоторыми полями флагов в <structname>IndexAmRoutine</structname> связаны неочевидные следствия. Требования индексов с <structfield>amcanunique</structfield> описаны в <xref remap="6" linkend="index-unique-checks"/>. Флаг <structfield>amcanmulticol</structfield> показывает, что метод доступа поддерживает составные индексы, а <structfield>amoptionalkey</structfield> обозначает, что метод позволяет выполнить сканирование при отсутствии индексируемого ограничивающего условия для первого столбца индекса. Когда <structfield>amcanmulticol</structfield> равен false, <structfield>amoptionalkey</structfield> по сути говорит, поддерживает ли метод доступа полное сканирование по индексу без ограничивающего условия. Методы доступа, поддерживающие индексы по нескольким столбцам, <emphasis>должны</emphasis> поддерживать сканирования при отсутствии ограничений любых или всех столбцов после первого; однако они могут требовать присутствия какого-либо ограничения для первого столбца индекса, и это требование отмечается значением false флага <structfield>amoptionalkey</structfield>. В <structfield>amoptionalkey</structfield> для метода доступа может устанавливаться false, например, когда этот метод доступа не индексирует значения. Так как большинство индексируемых операторов — строгие, и поэтому не могут вернуть true для операндов NULL, на первый взгляд кажется заманчивой идея не хранить записи индекса для значений NULL: они всё равно никак не могут быть прочитаны при сканировании индекса. Однако этот аргумент отпадает, когда при сканировании индекса вовсе отсутствует ограничение данного столбца индекса. На практике это означает, что индексы с установленным флагом <structfield>amoptionalkey</structfield> должны индексировать значения NULL, так как планировщик может склониться к использованию этого индекса вообще без ключей. С этим связано ещё одно ограничение — метод доступа индекса, поддерживающий составные индексы, <emphasis>должен</emphasis> поддерживать индексирование значений NULL в столбцах после первого, так как планировщик будет полагать, что индекс можно применять для запросов, в которых эти столбцы не ограничиваются. Например, рассмотрим индекс по (a,b) и запрос с ограничением <literal>WHERE a = 4</literal>. Система будет полагать, что по этому индексу можно просканировать строки с <literal>a = 4</literal>, но это будет неверно, если индекс исключит строки, в которых <literal>b</literal> — NULL. Однако, этот индекс вполне может исключить строки, в которых первый столбец содержит NULL. Метод индекса, который индексирует значения NULL, может также установить флаг <structfield>amsearchnulls</structfield>, отметив тем самым, что он поддерживает в качестве условий поиска <literal>IS NULL</literal> и <literal>IS NOT NULL</literal>.</para>

 </sect1>

 <sect1 id="index-functions">
  <title>Функции для метода доступа индекса</title>

  <para>Метод доступа индекса должен определить в <structname>IndexAmRoutine</structname> следующие функции построения и обслуживания индексов:</para>

  <para><programlisting>IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);</programlisting> Строит новый индекс. Отношение индекса уже физически создано, но пока пусто. Оно должно быть наполнено фиксированными данными, которые требуются методу доступа, и записями для всех кортежей, уже существующих в таблице. Обычно функция <function>ambuild</function> вызывает <function>IndexBuildHeapScan()</function> для поиска в таблице существующих кортежей и для вычисления ключей, которые должны вставляться в этот индекс. Эта функция должна возвращать структуру, выделенную вызовом palloc и содержащую статистику нового индекса.</para>

  <para><programlisting>void
ambuildempty (Relation indexRelation);</programlisting> Создаёт пустой индекс и записывает его в слой инициализации (<symbol>INIT_FORKNUM</symbol>) данного отношения. Этот метод вызывается только для нежурналируемых индексов; пустой индекс, записанный в слой инициализации, будет копироваться в основной слой отношения при каждом перезапуске сервера.</para>

  <para><programlisting>bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique);</programlisting> Вставляет новый кортеж в существующий индекс. В массивах <literal>values</literal> и <literal>isnull</literal> передаются значения ключа, которые должны быть проиндексированы, а в <literal>heap_tid</literal> — идентификатор индексируемого кортежа (TID). Если метод доступа поддерживает уникальные индексы (флаг <structfield>amcanunique</structfield> установлен), параметр <literal>checkUnique</literal> указывает, какая проверка уникальности должна выполняться. Это зависит от того, является ли ограничение уникальности откладываемым; за подробностями обратитесь к <xref remap="3" linkend="index-unique-checks"/>. Обычно параметр <literal>heapRelation</literal> нужен методу доступа только для проверки уникальности (так как он должен обратиться к основным данным, чтобы убедиться в актуальности кортежа).</para>

  <para>Возвращаемый функцией булевский результат имеет значение, только когда параметр <literal>checkUnique</literal> равен <literal>UNIQUE_CHECK_PARTIAL</literal>. В этом случае результат TRUE означает, что новая запись признана уникальной, тогда как FALSE означает, что она может быть неуникальной (и требуется назначить отложенную проверку уникальности). В других случаях рекомендуется возвращать постоянный результат FALSE.</para>

  <para>Некоторые индексы могут индексировать не все кортежи. Если кортеж не будет индексирован, <function>aminsert</function> должна просто завершиться, не делая ничего.</para>

  <para><programlisting>IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);</programlisting> Удаляет кортеж(и) из индекса. Это операция <quote>массового удаления</quote>, которая предположительно будет реализована путём сканирования всего индекса и проверки для каждой записи, должна ли она удаляться. Переданная функция <literal>callback</literal> должна вызываться в стиле <literal>callback(<replaceable>TID</replaceable>, callback_state)</literal> с результатом bool, который говорит, должна ли удаляться запись индекса, на которую указывает передаваемый TID. Возвращать эта функция должна NULL или структуру, выделенную вызовом palloc и содержащую статистику результата удаления. NULL можно вернуть, если никакая информация не должна передаваться в <function>amvacuumcleanup</function>.</para>

  <para>Из-за ограничения <varname>maintenance_work_mem</varname> процедура <function>ambulkdelete</function> может вызываться несколько раз, когда удалению подлежит большое количество кортежей. В аргументе <literal>stats</literal> передаётся результат предыдущего вызова для данного индекса (при первом вызове в ходе операции <command>VACUUM</command> он содержит NULL). Это позволяет методу доступа накапливать статистику в процессе всей операции. Обычно <function>ambulkdelete</function> модифицирует и возвращает одну и ту же структуру, если в <literal>stats</literal> передаётся не NULL.</para>

  <para><programlisting>IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);</programlisting> Провести очистку после операции <command>VACUUM</command> (до этого <function>ambulkdelete</function> могла вызываться несколько или ноль раз). От этой функции не требуется ничего, кроме как выдать статистику по индексу, но она может произвести массовую очистку, например, высвободить пустые страницы индекса. В <literal>stats</literal> ей передаётся структура, возвращённая при последнем вызове <function>ambulkdelete</function>, либо NULL, если <function>ambulkdelete</function> не вызывалась, так как никакие кортежи удалять не требовалось. Эта функция должна возвращать NULL или структуру, выделенную вызовом palloc. Содержащаяся в этой структуре статистика будет отражена в записи в <structname>pg_class</structname> и попадёт в вывод команды <command>VACUUM</command>, если она выполнялась с указанием <literal>VERBOSE</literal>. NULL может возвращаться, если индекс вовсе не изменился в процессе операции <command>VACUUM</command>, но в противном случае должна возвращаться корректная статистика.</para>

  <para>Начиная с <productname>PostgreSQL</productname> версии 8.4, <function>amvacuumcleanup</function> также вызывается в конце операции <command>ANALYZE</command>. В этом случае <literal>stats</literal> всегда NULL и любое возвращаемое значение игнорируется. Этот вариант вызова можно распознать, проверив поле <literal>info-&gt;analyze_only</literal>. При таком вызове методу доступа рекомендуется ничего не делать, кроме как провести очистку после добавления данных, и только в рабочем процессе автоочистки.</para>

  <para><programlisting>bool
amcanreturn (Relation indexRelation, int attno);</programlisting> Проверяет, поддерживается ли <link linkend="indexes-index-only-scans"><firstterm>сканирование только индекса</firstterm></link> для заданного столбца, когда для записи индекса возвращаются значения индексируемых столбцов в виде <structname>IndexTuple</structname>. Атрибуты нумеруются с 1, то есть для первого столбца attno равен 1. Возвращает TRUE, если такое сканирование поддерживается, а иначе FALSE. Если метод доступа индекса в принципе не поддерживает сканирование только индекса, в поле <structfield>amcanreturn</structfield> его структуры <structname>IndexAmRoutine</structname> можно записать NULL.</para>

  <para><programlisting>void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);</programlisting> Рассчитывает примерную стоимость сканирования индекса. Эта функция полностью описывается ниже в <xref remap="6" linkend="index-cost-estimation"/>.</para>

  <para><programlisting>bytea *
amoptions (ArrayType *reloptions,
           bool validate);</programlisting> Разбирает и проверяет массив параметров для индекса. Эта функция вызывается, только когда для индекса задан отличный от NULL массив reloptions. Массив <parameter>reloptions</parameter> состоит из элементов типа <type>text</type>, содержащих записи вида <replaceable>имя</replaceable><literal>=</literal><replaceable>значение</replaceable>. Данная функция должна получить значение типа <type>bytea</type>, которое будет скопировано в поле <structfield>rd_options</structfield> записи индекса в relcache. Содержимое этого значения <type>bytea</type> определяется самим методом доступа; большинство стандартных методов доступа помещают в него структуру <structname>StdRdOptions</structname>. Когда параметр <parameter>validate</parameter> равен true, эта функция должна выдать подходящее сообщение об ошибке, если какие-либо параметры нераспознаны или имеют недопустимые значения; если же <parameter>validate</parameter> равен false, некорректные записи должны просто игнорироваться. (В <parameter>validate</parameter> передаётся false, когда параметры уже загружены в <structname>pg_catalog</structname>; при этом неверная запись может быть обнаружена, только если в методе доступа поменялись правила обработки параметров, и в этом случае стоит просто игнорировать такие записи.) NULL можно вернуть, когда нужно получить поведение по умолчанию.</para>

  <para><programlisting>bool
amproperty (Oid index_oid, int attno,
            IndexAMProperty prop, const char *propname,
            bool *res, bool *isnull);</programlisting> Процедура <function>amproperty</function> позволяет методам доступа индексов переопределять стандартное поведение функции <function>pg_index_column_has_property</function> и связанных с ней. Если метод доступа не проявляет никаких особенностей при запросе свойств индексов, поле <structfield>amproperty</structfield> в структуре <structname>IndexAmRoutine</structname> может содержать NULL. В противном случае процедура <function>amproperty</function> будет вызываться с нулевыми параметрами <parameter>index_oid</parameter> и <parameter>attno</parameter> при вызове <function>pg_indexam_has_property</function>, либо с корректным <parameter>index_oid</parameter> и нулевым <parameter>attno</parameter> при вызове <function>pg_index_has_property</function>, либо с корректным <parameter>index_oid</parameter> и положительным <parameter>attno</parameter> при вызове <function>pg_index_column_has_property</function>. В <parameter>prop</parameter> передаётся значение перечисления, указывающее на проверяемое значение, а в <parameter>propname</parameter> — строка с именем свойства. Если код ядра не распознаёт имя свойства, в <parameter>prop</parameter> передаётся <literal>AMPROP_UNKNOWN</literal>. Методы доступа могут воспринимать нестандартные имена свойств, проверяя <parameter>propname</parameter> на совпадение (для согласованности с кодом ядра используйте для проверки <function>pg_strcasecmp</function>); для имён, известных коду ядра, лучше проверять <parameter>prop</parameter>. Если процедура <structfield>amproperty</structfield> возвращает <literal>true</literal>, это значит, что она установила результат проверки свойства: она должна задать в <literal>*res</literal> возвращаемое булевское значение или установить в <literal>*isnull</literal> значение <literal>true</literal>, чтобы возвратить NULL. (Перед вызовом обе упомянутые переменные инициализируются значением <literal>false</literal>.) Если <structfield>amproperty</structfield> возвращает <literal>false</literal>, код ядра переключается на обычную логику определения результата проверки свойства.</para>

  <para>Методы доступа, поддерживающие операторы упорядочивания, должны реализовывать проверку свойства <literal>AMPROP_DISTANCE_ORDERABLE</literal>, так как код ядра не знает, как это сделать и возвращает NULL. Также может быть полезно реализовать проверку <literal>AMPROP_RETURNABLE</literal>, если это можно сделать проще, чем обращаясь к индексу и вызывая <structfield>amcanreturn</structfield> (что делает код ядра по умолчанию). Для всех остальных стандартных свойств поведение ядра по умолчанию можно считать удовлетворительным.</para>

  <para><programlisting>bool
amvalidate (Oid opclassoid);</programlisting> Проверяет записи в каталоге для заданного класса операторов, насколько это может сделать метод доступа. Например, это может включать проверку, все ли необходимые опорные функции реализованы. Функция <function>amvalidate</function> должна вернуть false, если класс операторов непригоден к использованию. Сообщения о проблеме следует выдать через <function>ereport</function>.</para>


  <para>Цель индекса, конечно, в том, чтобы поддерживать поиск кортежей, соответствующих индексируемому условию <literal>WHERE</literal>, по <firstterm>ограничению</firstterm> или <firstterm>ключу поиска</firstterm>. Сканирование индекса описывается более полно ниже, в <xref remap="6" linkend="index-scanning"/>. Метод доступа индекса может поддерживать <quote>простое</quote> сканирование, сканирование по <quote>битовой карте</quote> или и то, и другое. Метод доступа должен или может реализовывать следующие функции, связанные со сканированием:</para>

  <para><programlisting>IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);</programlisting> Подготавливает метод к сканированию индекса. В параметрах <literal>nkeys</literal> и <literal>norderbys</literal> задаётся количество операторов условия и сортировки, которые будут задействованы при сканировании; это может быть полезно для выделения памяти. Заметьте, что фактические значения ключей сканирования в этот момент ещё не предоставляются. В результате функция должна выдать структуру, выделенную средствами palloc. В связи с особенностями реализации, метод доступа <emphasis>должен</emphasis> создать эту структуру, вызвав <function>RelationGetIndexScan()</function>. В большинстве случаев все действия <function>ambeginscan</function> сводятся только к выполнению этого вызова и, возможно, получению блокировок; всё самое интересное при запуске сканирования индекса происходит в <function>amrescan</function>.</para>

  <para><programlisting>void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);</programlisting> Запускает или перезапускает сканирование индекса, возможно, с новыми ключами сканирования. (Для перезапуска сканирования с ранее переданными ключами в <literal>keys</literal> и/или <literal>orderbys</literal> передаётся NULL.) Заметьте, что количество ключей или операторов сортировки не может превышать значения, поступившие в <function>ambeginscan</function>. На практике возможность перезапуска используется, когда в соединении со вложенным циклом выбирается новый внешний кортеж, так что требуется сравнение с новым ключом, но структура ключей сканирования не меняется.</para>

  <para><programlisting>boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);</programlisting> Выбирает следующий кортеж в ходе данного сканирования, с передвижением по индексу в заданном направлении (вперёд или назад). Возвращает TRUE, если кортеж был получен, или FALSE, если подходящих кортежей не осталось. В случае успеха в структуре <literal>scan</literal> сохраняется TID кортежа. Заметьте, что под <quote>успехом</quote> здесь подразумевается только, что индекс содержит запись, соответствующую ключам сканирования, а не то, что данный кортеж обязательно существует в данных или оказывается видимым в снимке вызывающего субъекта. При положительном результате <function>amgettuple</function> должна также установить для свойства <literal>scan-&gt;xs_recheck</literal> значение TRUE или FALSE. FALSE будет означать, что запись индекса точно соответствует ключам сканирования, а TRUE, что есть сомнение в этом, так что условия, представленные ключами сканирования, необходимо ещё раз перепроверить для фактического кортежа, когда он будет получен. Это свойство введено для поддержки <quote>неточных</quote> операторов индексов. Заметьте, что такая перепроверка касается только условий сканирования; предикат частичного индекса (если он имеется) никогда не перепроверяется кодом, вызывающим <function>amgettuple</function>.</para>

  <para>Если индекс поддерживает <link linkend="indexes-index-only-scans">сканирование только индекса</link> (то есть, <function>amcanreturn</function> для него равен TRUE), то в случае успеха метод доступа должен также проверить флаг <literal>scan-&gt;xs_want_itup</literal>, и, если он установлен, должен вернуть исходные индексированные данные для этой записи индекса, в виде указателя на <structname>IndexTuple</structname>, сохранённого в <literal>scan-&gt;xs_itup</literal>, и дескриптор кортежа <literal>scan-&gt;xs_itupdesc</literal>. (Контролировать структуру данных, на которую указывает этот указатель, должен сам метод доступа. Она должна сохраняться в рабочем состоянии как минимум до следующего вызова <function>amgettuple</function>, <function>amrescan</function> или <function>amendscan</function> в текущем сканировании.)</para>

  <para>Функция <function>amgettuple</function> должна быть реализована, только если метод доступа поддерживает <quote>простое</quote> сканирование индекса. В противном случае поле <structfield>amgettuple</structfield> в структуре <structname>IndexAmRoutine</structname> должно содержать NULL.</para>

  <para><programlisting>int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);</programlisting> Выбирает все кортежи для данного сканирования и добавляет их в передаваемую вызывающим кодом структуру <type>TIDBitmap</type> (то есть, получает логическое объединение множества TID выбранных кортежей с множеством, уже записанным в битовой карте). Возвращает эта функция число полученных кортежей (это может быть только приблизительная оценка; например, некоторые методы доступа не учитывают повторяющиеся значения). Добавляя идентификаторы кортежей в битовую карту, <function>amgetbitmap</function> может обозначить, что для этих кортежей нужно перепроверить условия сканирования. Для этого так же, как и в <function>amgettuple</function>, устанавливается выходной параметр <literal>xs_recheck</literal>. Замечание: в текущей реализации эта возможность увязывается с возможностью неточного хранения самих битовых карт, таким образом вызывающий код перепроверяет для отмеченных кортежей и условия сканирования, и предикат частичного индекса (если он имеется). Однако так может быть не всегда. Функции <function>amgetbitmap</function> и <function>amgettuple</function> не могут использоваться в одном сканировании индекса; есть и другие ограничения в применении <function>amgetbitmap</function>, описанные в <xref remap="6" linkend="index-scanning"/>.</para>

  <para>Функция <function>amgetbitmap</function> должна быть реализована, только если метод доступа поддерживает сканирование индекса <quote>по битовой карте</quote>. В противном случае поле <structfield>amgetbitmap</structfield> в структуре <structname>IndexAmRoutine</structname> должно содержать NULL.</para>

  <para><programlisting>void
amendscan (IndexScanDesc scan);</programlisting> Завершает сканирование и освобождает ресурсы. Саму структуру <literal>scan</literal> освобождать не следует, но любые блокировки или закрепления объектов, установленные внутри метода доступа, должны быть сняты.</para>

  <para><programlisting>void
ammarkpos (IndexScanDesc scan);</programlisting> Помечает текущую позицию сканирования. Метод доступа должен поддерживать сохранение только одной позиции в процессе сканирования.</para>

  <para>Функция <function>ammarkpos</function> должна быть реализована, только если метод доступа поддерживает сканирование по порядку. Если это не так, в поле <structfield>ammarkpos</structfield> в структуре <structname>IndexAmRoutine</structname> можно записать NULL.</para>

  <para><programlisting>void
amrestrpos (IndexScanDesc scan);</programlisting> Восстанавливает позицию сканирования, отмеченную последней.</para>

  <para>Функция <function>amrestrpos</function> должна быть реализована, только если метод доступа поддерживает сканирование по порядку. Если это не так, в поле <structfield>amrestrpos</structfield> в структуре <structname>IndexAmRoutine</structname> можно записать NULL.</para>
 </sect1>

 <sect1 id="index-scanning">
  <title>Сканирование индекса</title>

  <para>В процессе сканирования метод доступа индекса отвечает только за выдачу идентификаторов всех кортежей, которые по его представлению соответствуют <firstterm>ключам сканирования</firstterm>. Метод доступа <emphasis>не</emphasis> участвует в самой процедуре выборки этих кортежей из основной таблицы и не определяет, удовлетворяют ли эти кортежи условиям видимости или другим ограничениям.</para>

  <para>Ключом сканирования является внутреннее представление предложения <literal>WHERE</literal> в виде <replaceable>ключ_индекса</replaceable> <replaceable>оператор</replaceable> <replaceable>константа</replaceable>, где ключ индекса — один из столбцов индекса, а оператор — один из членов семейства операторов, связанного с типом данного столбца. При сканировании по индексу могут задаваться несколько или ноль ключей сканирования, результаты поиска которых должны неявно объединяться операцией AND &mdash; ожидается, что возвращаемые кортежи будут удовлетворять всем заданным условиям.</para>

  <para>Метод доступа для конкретного запроса может сообщить, что индекс является <firstterm>неточным</firstterm> или, другими словами, требует перепроверки. Это подразумевает, что при сканировании индекса будут возвращены все записи, соответствующие ключу сканирования, плюс, возможно, дополнительные записи, которые ему не соответствуют. Внутренний механизм сканирования затем повторно применит условия индекса к кортежу данных, чтобы проверить, нужно ли его выбирать на самом деле. Если признак перепроверки не установлен, при сканировании индекса должны возвращаться только соответствующие ключам записи.</para>

  <para>Заметьте, что именно метод доступа должен гарантировать, что корректно будут найдены все и только те записи, которые соответствуют всем переданным ключам сканирования. Также учтите, что ядро системы просто передаёт все предложения <literal>WHERE</literal> с подходящими ключами индекса и семействами операторов, не проводя семантический анализ на предмет их избыточности или противоречивости. Например, с условием <literal>WHERE x &gt; 4 AND x &gt; 14</literal>, где <literal>x</literal> — столбец с индексом-B-деревом, именно самой функции <function>amrescan</function> в методе B-дерева предоставляется возможность понять, что первый ключ сканирования избыточный и может быть отброшен. Объём предварительной обработки, которую нужно произвести для этого в <function>amrescan</function>, зависит от того, до какой степени метод доступа должен сводить ключи к <quote>нормализованной</quote> форме.</para>

  <para>Некоторые методы доступа возвращают записи индекса в чётко определённом порядке, в отличие от других. Фактически есть два различных варианта реализации упорядоченного вывода некоторым методом доступа: <itemizedlist>
     <listitem>
      <para>Для методов доступа, которые всегда возвращают записи в порядке их естественной сортировки (как например, в B-дереве), устанавливается признак <structfield>amcanorder</structfield>. В настоящее время операторам проверки равенства и упорядочивания при этом должны назначаться номера соответствующих стратегий B-дерева.</para>
     </listitem>
     <listitem>
      <para>Для методов доступа, которые поддерживают операторы упорядочивания, устанавливается признак <structfield>amcanorderbyop</structfield>. Он показывает, что индекс может возвращать записи в порядке, определяемом предложением <literal>ORDER BY</literal> <replaceable>ключ_индекса</replaceable> <replaceable>оператор</replaceable> <replaceable>константа</replaceable>. Модификаторы для такого сканирования могут передаваться в <function>amrescan</function>, как описывалось ранее.</para>
     </listitem>
    </itemizedlist></para>

  <para>У функции <function>amgettuple</function> есть аргумент <literal>direction</literal>, который может принимать значение <literal>ForwardScanDirection</literal> (обычный вариант, сканирование вперёд) или <literal>BackwardScanDirection</literal> (сканирование назад). Если в первом вызове после <function>amrescan</function> указывается <literal>BackwardScanDirection</literal>, то множество соответствующих записей индекса сканируется от конца к началу, а не в обычном направлении от начала к концу. В этом случае <function>amgettuple</function> должна вернуть последний соответствующий кортеж индекса, а не первый как обычно. (Это распространяется только на методы доступа с установленным признаком <structfield>amcanorder</structfield>.) После первого вызова <function>amgettuple</function> должна быть готова продолжать сканирование в любом направлении от записи, выданной последней до этого. (Но если признак <structfield>amcanbackward</structfield> не установлен, при всех последующих вызовах должно сохраняться то же направление, что было в первом.)</para>

  <para>Методы доступа, которые поддерживают упорядоченное сканирование, должны уметь <quote>помечать</quote> позицию сканирования и затем возвращаться к помеченной позиции (возможно, несколько раз к одной и той же позиции). Но запоминаться должна только одна позиция в ходе сканирования; последующий вызов <function>ammarkpos</function> переопределяет ранее сохранённую позицию. Метод доступа, не поддерживающий упорядоченное сканирование, не должен определять функции <function>ammarkpos</function> и <function>amrestrpos</function> в <structname>IndexAmRoutine</structname>; достаточно записать в эти указатели NULL.</para>

  <para>И позиция сканирования, и отмеченная позиция (при наличии) должны поддерживаться в согласованном состоянии с учётом одновременных добавлений или удалений записей в индексе. Не будет ошибкой, если только что вставленная запись не будет выдана при сканировании, которое могло бы найти эту запись, если бы она существовала до его начала, либо если сканирование выдаст такую запись после перезапуска или возврата, даже если она не была выдана в первый раз. Подобным образом, параллельное удаление может отражаться, а может и не отражаться в результатах сканирования. Важно только, чтобы при таких операциях добавления или удаления не происходило потерь или дублирования записей, которые в этих операциях не участвовали.</para>

  <para>Если индекс сохраняет исходные индексируемые значения данных (а не их искажённое представление), обычно полезно поддержать <link linkend="indexes-index-only-scans">сканирование только индекса</link>, при котором индекс возвращает фактические данные, а не только TID кортежа данных. Это позволит соптимизировать ввод/вывод, только если карта видимости показывает, что TID относится к полностью видимой странице; в противном случае всё равно придётся посетить кортеж, чтобы проверить его видимость для MVCC. Но это не является заботой метода доступа.</para>

  <para>Вместо <function>amgettuple</function>, сканирование индекса может осуществляться функцией <function>amgetbitmap</function>, которая выбирает все кортежи за один вызов. Это может быть значительно эффективнее <function>amgettuple</function>, так как позволяет избежать циклов блокировки/разблокировки в методе доступа. В принципе, <function>amgetbitmap</function> должна давать тот же эффект, что и многократные вызовы <function>amgettuple</function>, но простоты ради мы накладываем ряд дополнительных ограничений. Во-первых, <function>amgetbitmap</function> возвращает все кортежи сразу и не поддерживает пометку позиций и возвращение к ним. Во-вторых, кортежи, возвращаемые в битовой карте, не упорядочиваются каким-либо определённым образом, поэтому <function>amgetbitmap</function> не принимает аргумент <literal>direction</literal>. (И операторы упорядочивания никогда не будут передаваться для такого сканирования.) Кроме того, сканирование только индекса с <function>amgetbitmap</function> неосуществимо, так как нет никакой возможности возвратить содержимое кортежей индекса. Наконец, <function>amgetbitmap</function> не гарантирует, что будут установлены какие-либо блокировки для возвращаемых кортежей, и следствия этого описаны в <xref remap="6" linkend="index-locking"/>.</para>

  <para>Заметьте, что метод доступа может реализовывать только функцию <function>amgetbitmap</function>, но не <function>amgettuple</function>, и наоборот, если его внутренняя реализация несовместима с одной из этих функций.</para>

 </sect1>

 <sect1 id="index-locking">
  <title>Замечания о блокировке с индексами</title>

  <para>Методы доступа индекса должны справляться с параллельными операциями обновления индекса, производимыми несколькими процессами. Ядро системы <productname>&productname;</productname> получает блокировку <literal>AccessShareLock</literal> для индекса в процессе сканирования и <literal>RowExclusiveLock</literal> при модификации индекса (включая и обычную очистку командой <command>VACUUM</command>). Так как эти типы блокировок не конфликтуют, метод доступа должен сам устанавливать более тонкие блокировки, которые ему могут потребоваться. Исключительная блокировка индекса в целом устанавливается только при создании и уничтожении индекса или операции <command>REINDEX</command>.</para>

  <para>Реализация типа индекса, поддерживающего параллельные изменения, обычно требует глубокого и всестороннего анализа требуемого поведения. Для общего представления вы можете узнать о конструктивных решениях, принятых при реализации B-дерева и индекса по хешу, обратившись к <filename>src/backend/access/nbtree/README</filename> и <filename>src/backend/access/hash/README</filename>.</para>

  <para>Помимо собственных внутренних требований индексов к целостности, при параллельном обновлении данных возникают вопросы согласованности родительской таблицы (<firstterm>основных данных</firstterm>) и индекса. Вследствие того, что <productname>&productname;</productname> отделяет чтение и изменение основных данных от чтения и изменения индекса, образуются временные интервалы, в которых индекс может быть несогласованным с данными. Мы решаем эту проблему, применяя следующие правила: <itemizedlist>
     <listitem>
      <para>Новая запись в области данных добавляется до того, как для неё будут созданы записи в индексах. (Таким образом, при параллельном сканировании индекса эта запись в данных скорее всего не будет замечена. Это не проблема, так как читателю индекса всё равно не нужны незафиксированные строки. Но учтите написанное в <xref remap="6" linkend="index-unique-checks"/>.)</para>
     </listitem>
     <listitem>
      <para>Когда запись данных удаляется (командой <command>VACUUM</command>), сначала должны удалиться все созданные для неё записи в индексах.</para>
     </listitem>
     <listitem>
      <para>Сканирование индекса должно закрепить страницу индекса, на которой находится элемент, возвращённый последним вызовом <function>amgettuple</function>, а <function>ambulkdelete</function> не должна удалять записи со страниц, закреплённых другими процессами. Чем обосновано это правило, описывается ниже.</para>
     </listitem>
    </itemizedlist> Без третьего правила читатель индекса мог бы увидеть запись индекса за мгновение до того, как она была удалена процедурой <command>VACUUM</command>, а затем обратиться к соответствующей записи данных после того, как <command>VACUUM</command> удалит и её. Это не приведёт к серьёзным проблемам, если данный элемент остаётся незадействованным, когда к нему обращается читатель, так как пустой слот будет игнорироваться функцией <function>heap_fetch()</function>. Но как быть, если третий процесс уже занял этот слот какими-то своими данными? Когда применяется снимок, совместимый с MVCC, и это не проблема, так как эти данные определённо окажутся слишком новыми при проверке видимости для данного снимка. Однако, для снимка несовместимого с MVCC (например, снимка <literal>SnapshotAny</literal>), может так получиться, что будет возвращена строка, на самом деле не соответствующая ключам сканирования. Мы можем защититься от такого исхода, потребовав, чтобы ключи сканирования всегда перепроверялись для строки данных, но это слишком дорогостоящее решение. Вместо этого, мы закрепляем страницу индекса как промежуточный объект, показывающий, что читатель может всё ещё быть <quote>в пути</quote> от записи индекса к соответствующей строке данных. Благодаря тому, что <function>ambulkdelete</function> блокируется при обращении к этой закреплённой странице, процедура <command>VACUUM</command> не сможет удалить строку данных, пока её извлечение не закончит читатель. Это решение оказывается очень недорогим по времени выполнения, а издержки блокирования привносятся только в редких случаях, когда действительно возникает конфликт.</para>

  <para>Такое решение требует, чтобы сканирования индексов выполнялись <quote>синхронно</quote>: мы должны выбирать каждый следующий кортеж данных сразу после того получили соответствущую запись индекса. Это оказывается невыгодно по ряду причин. <quote>Асинхронное</quote> сканирование, при котором мы собираем множество TID из индекса, и обращаемся за кортежами данных только после этого, влечёт гораздо меньше издержек с блокировками и позволяет обращаться к данным более эффективным образом. Согласно проведённому выше анализу, мы должны использовать синхронный подход для снимков, несовместимых с MVCC, но для запросов со снимками MVCC будет работать и асинхронное сканирование.</para>

  <para>При сканировании индекса с <function>amgetbitmap</function>, метод доступа не закрепляет страницы индекса ни для каких из возвращаемых кортежей. Поэтому такое сканирование можно безопасно применять только со снимками MVCC.</para>

  <para>Когда флаг <structfield>ampredlocks</structfield> не установлен, любое сканирование с данным методом доступа в сериализуемой транзакции будет получать неблокирующую предикатную блокировку для всего индекса. Это будет приводить к конфликту чтения-записи при добавлении любого кортежа в этот индекс параллельной сериализуемой транзакцией. Если среди набора параллельных сериализуемых транзакций выявляются определённые варианты конфликтов чтения-записи, одна из этих транзакций может быть отменена для сохранения целостности данных. Когда данный флаг установлен, это означает, что метод доступа реализует более точную предикатную блокировку, что способствует сокращению частоты отмены транзакций по этой причине.</para>

 </sect1>

 <sect1 id="index-unique-checks">
  <title>Проверки уникальности в индексе</title>

  <para><productname>&productname;</productname> реализует ограничения уникальности SQL, применяя <firstterm>уникальные индексы</firstterm>, то есть такие индексы, которые не принимают несколько записей с одинаковыми ключами. Для метода доступа, поддерживающего это свойство, устанавливается признак <structfield>amcanunique</structfield>. (В настоящее время это поддерживают только В-деревья.) Столбцы, указанные в предложении <literal>INCLUDE</literal>, не учитываются при контроле уникальности.</para>

  <para>Вследствие особенностей MVCC, всегда необходимо допускать физическое сосуществование в индексе дублирующихся записей: такие записи могут относиться к последовательным версиям одной логической строки. На самом деле мы хотим добиться только того, чтобы никакой снимок MVCC не мог содержать две строки с одинаковыми ключами индекса. Из этого вытекают следующие ситуации, которые необходимо отследить, добавляя новую строку в уникальный индекс: <itemizedlist>
     <listitem>
      <para>Если конфликтующая строка была удалена текущей транзакцией, это не проблема. (В частности из-за того, что UPDATE всегда удаляет старую версию строки, прежде чем вставлять новую, операцию UPDATE можно выполнять со строкой, не меняя её ключ.)</para>
     </listitem>
     <listitem>
      <para>Если конфликтующая строка была добавлена ещё не зафиксированной транзакцией, запрос, претендующий на добавление новой строки, должен подождать, пока эта транзакция не будет зафиксирована. Если она откатывается, конфликт исчезает. Если она фиксируется и при этом оставляет конфликтующую строку, возникает нарушение уникальности. (На практике мы просто ждём завершения другой транзакции и затем пересматриваем проверку видимости.)</para>
     </listitem>
     <listitem>
      <para>Подобным образом, если конфликтующая строка была удалена ещё не зафиксированной транзакцией, запрос, претендующий на добавление новой строки, должен дождаться фиксации или отката этой транзакции, а затем повторить проверку.</para>
     </listitem>
    </itemizedlist></para>

  <para>Более того, непосредственно перед тем как сообщать о нарушении уникальности согласно вышеприведённым правилам, метод доступа должен перепроверить, продолжает ли существовать добавляемая строка. Если она признана &laquo;мёртвой&raquo;, о предвиденном нарушении он сообщать не должен. (Такого не должно быть при обычном сценарии добавления строки текущей транзакцией, однако это может произойти в процессе <command>CREATE UNIQUE INDEX CONCURRENTLY</command>.)</para>

  <para>Мы требуем, чтобы метод доступа выполнял эти проверки сам, и это означает, что он должен обратиться к основным данным и проверить состояние фиксации всех строк, которые согласно содержимого индекса содержат дублирующиеся ключи. Это без сомнения некрасивый и немодульный подход, но он избавляет от излишней работы: если бы мы делали отдельную пробу, то поиск конфликтующей строки по индексу пришлось бы по сути повторять, пытаясь найти место, куда вставить запись для новой строки. Более того, не представляется возможным избежать условий гонки, если проверка конфликта не будет неотъемлемой частью процедуры добавления новой записи индекса.</para>

  <para>Если ограничение уникальности откладываемое, возникает дополнительная сложность: нам нужна возможность добавлять запись индекса для новой строки, но отложить выводы о нарушении уникальности до конца оператора или даже позже. Чтобы избежать ненужного повторного поиска по индексу, метод доступа должен произвести предварительную проверку уникальности во время изначального добавления строк. Если при этом окажется, что никакие кортежи не конфликтуют, на этом проверка заканчивается. В противном случае мы планируем перепроверку на время, когда это ограничение начинает действовать. Если во время перепроверки продолжают существовать и вставленный кортеж, и какой-либо другой с тем же ключом, должна выдаваться ошибка. (Заметьте, что в данном случае под <quote>существованием</quote> понимается <quote>существование любого кортежа в цепочке HOT записей индекса</quote>.) Для реализации этой схемы в <function>aminsert</function> передаётся параметр <literal>checkUnique</literal>, принимающий одно из следующих значений: <itemizedlist>
     <listitem>
      <para><literal>UNIQUE_CHECK_NO</literal> указывает, что проверка уникальности не должна выполняться (это не уникальный индекс).</para>
     </listitem>
     <listitem>
      <para><literal>UNIQUE_CHECK_YES</literal> указывает, что это неоткладываемый уникальный индекс и проверку уникальности нужно выполнить немедленно, как описано выше.</para>
     </listitem>
     <listitem>
      <para><literal>UNIQUE_CHECK_PARTIAL</literal> указывает, что это откладываемое ограничение уникальности. <productname>&productname;</productname> выбирает этот режим для добавления записи индекса для каждой строки. Метод доступа должен допускать добавление в индекс дублирующихся записей и сообщать о возможных конфликтах, возвращая FALSE из <function>aminsert</function>. Для каждой такой строки (для которой возвращается FALSE) будет запланирована отложенная перепроверка.</para>

      <para>Метод доступа должен отметить все строки, которые могут нарушать ограничение уникальности, но не будет ошибкой, если он допустит ложное срабатывание. Это позволяет произвести проверку, не дожидаясь завершения других транзакций; конфликты, выявленные на этой стадии, не считаются ошибками и будут перепроверены позже, когда они могут быть уже исчерпаны.</para>
     </listitem>
     <listitem>
      <para><literal>UNIQUE_CHECK_EXISTING</literal> указывает, что это отложенная перепроверка строки, которая была отмечена как возможно нарушающая ограничение. Хотя для этой проверки вызывается <function>aminsert</function>, метод доступа <emphasis>не</emphasis> должен добавлять новую запись индекса в данном случае, так как эта запись уже существует. Вместо этого, метод доступа должен проверить, нет ли в индексе другой такой же записи. Если она находится и соответствующая ей строка продолжает существовать, должна выдаваться ошибка.</para>

      <para>Для варианта <literal>UNIQUE_CHECK_EXISTING</literal> в методе доступа рекомендуется дополнительно проверить, что для целевой строки действительно имеется запись в индексе и сообщить об ошибке, если это не так. Это хорошая идея, так как значения кортежа индекса, передаваемые в <function>aminsert</function>, будут рассчитаны заново. Если в определении индекса задействованы функции, которые на самом деле не постоянные, мы можем проверять неправильную область индекса. Дополнительно убедившись в существовании целевой строки при перепроверке, мы можем быть уверены, что сканируются те же значения кортежа, что передавались при изначальном добавлении строки.</para>
     </listitem>
    </itemizedlist></para>

 </sect1>

 <sect1 id="index-cost-estimation">
  <title>Функции оценки стоимости индекса</title>

  <para>Функции <function>amcostestimate</function> даётся информация, описывающая возможное сканирование индекса, включая списки предложений WHERE и ORDER BY, которые были выбраны как применимые с данным индексом. Она должна вернуть оценки стоимости обращения к индексу и избирательность предложений WHERE (то есть, процент строк основной таблицы, который будет получен в ходе сканирования индекса). Для простых случаев почти всю работу оценщика стоимости можно произвести, вызывая стандартные процедуры оптимизатора; смысл существования функции <function>amcostestimate</function> в том, чтобы методы доступа индексов могли поделиться знаниями, специфичными для типа индекса, когда это может помочь улучшить стандартные оценки.</para>

  <para>Каждая функция <function>amcostestimate</function> должна иметь такую сигнатуру: <programlisting>void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);</programlisting> Первые три параметра передают входные значения: <variablelist>
    <varlistentry>
     <term><parameter>root</parameter></term>
     <listitem>
      <para>Информация планировщика о выполняемом запросе.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>path</parameter></term>
     <listitem>
      <para>Рассматриваемый путь доступа к индексу. В нём действительны все поля, кроме значений стоимости и избирательности.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>loop_count</parameter></term>
     <listitem>
      <para>Число повторений сканирования индекса, которое должно приниматься во внимание при оценке стоимости. Обычно оно будет больше одного, когда при соединении со вложенным циклом планируется параметризованное сканирование. Заметьте, что оценки стоимости, тем не менее, должны рассчитываться для всего одного сканирования; большие значения <parameter>loop_count</parameter> лишь дают основания предположить, что при многократном сканировании положительное влияние может оказать кеширование.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>Последние четыре параметра — указатели на переменные для выходных значений: <variablelist>
    <varlistentry>
     <term><parameter>*indexStartupCost</parameter></term>
     <listitem>
      <para>Стоимость выполнения запуска индекса</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexTotalCost</parameter></term>
     <listitem>
      <para>Общая стоимость использования индекса</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexSelectivity</parameter></term>
     <listitem>
      <para>Избирательность индекса</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexCorrelation</parameter></term>
     <listitem>
      <para>Коэффициент корреляции между порядком сканирования индекса и порядком записей в нижележащей таблице</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>Заметьте, что функции оценки стоимости должны разрабатываться на C, а не на SQL или другом доступном процедурном языке, так как они должны обращаться к внутренним структурам данным планировщика/оптимизатора.</para>

  <para>Стоимости обращения к индексу следует вычислять с использованием параметров, объявленных в <filename>src/backend/optimizer/path/costsize.c</filename>: последовательная выборка дискового блока имеет стоимость <varname>seq_page_cost</varname>, непоследовательная выборка — <varname>random_page_cost</varname>, а стоимостью обработки одной строки индекса обычно принимается <varname>cpu_index_tuple_cost</varname>. Кроме того, за каждый оператор сравнения, вызываемый при обработке индекса, должна взиматься цена <varname>cpu_operator_cost</varname> (особенно за вычисление собственно условий индекса).</para>

  <para>Стоимость доступа должна включать стоимости всех дисковых и процессорных ресурсов, требующихся для сканирования самого индекса, <emphasis>но</emphasis> не стоимости извлечения или обработки строк основной таблицы, с которой связан индекс.</para>

  <para><quote>Стоимость запуска</quote> составляет часть общей стоимости сканирования, которая должна быть потрачена, прежде чем можно будет начать чтение первой строки. Для большинства индексов она может считаться нулевой, но для типов индексов с высокими затратами на запуск она может быть больше нуля.</para>

  <para>Значение в <parameter>indexSelectivity</parameter> должно показывать, какой процент строк основной таблицы ожидается получить при сканировании таблицы. В случае неточного запроса это обычно будет больше процента строк, действительно удовлетворяющих заданным ограничивающим условиям.</para>

  <para>В <parameter>indexCorrelation</parameter> записывается корреляция (в диапазоне от -1.0 до 1.0) между порядком записей в индексе и в таблице. Это значение будет корректировать оценку стоимости выборки строк из основной таблицы.</para>

  <para>Когда <parameter>loop_count</parameter> больше нуля, возвращаться должны средние значения, ожидаемые для одного сканирования индекса.</para>

  <procedure>
   <title>Оценка стоимости</title>
   <para>Типичная процедура оценки выглядит следующим образом:</para>

   <step>
    <para>Рассчитать и вернуть процент строк родительской таблицы, которые будут посещены при заданных ограничивающих условиях. В отсутствие каких-либо знаний, специфичных для типа индекса, использовать стандартную функцию оптимизатора <function>clauselist_selectivity()</function>: <programlisting>*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);</programlisting></para>
   </step>

   <step>
    <para>Оценить число строк индекса, которые будут посещены при сканировании. Для многих типов индексов это будет произведение <parameter>indexSelectivity</parameter> и числа строк в индексе, но оно может быть и больше. (Заметьте, что размер индекса в страницах и строках можно узнать из структуры <literal>path-&gt;indexinfo</literal>.)</para>
   </step>

   <step>
    <para>Рассчитать число страниц индекса, которые будут получены при сканировании. Это может быть просто произведение <parameter>indexSelectivity</parameter> и размера индекса в страницах.</para>
   </step>

   <step>
    <para>Вычислить стоимость обращения к индексу. Универсальный оценщик может сделать следующее: <programlisting>/*
 * Вообще предполагается, что страницы индекса будут считываться последовательно,
 * так что стоимость их чтения cost seq_page_cost, а не random_page_cost.
 * Также мы добавляем стоимость за вычисление условия индекса для каждой строки.
 * Все стоимости считаются пропорционально возрастающими при сканировании.
 */
cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
*indexStartupCost = index_qual_cost.startup;
*indexTotalCost = seq_page_cost * numIndexPages +
    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;</programlisting> Однако при таком расчёте не учитывается амортизация чтения индекса при повторном сканировании.</para>
   </step>

   <step>
    <para>Оценить корреляцию индекса. Для простого упорядоченного индекса по одному полю её можно получить из pg_statistic. Если корреляция неизвестна, вернуть консервативную оценку — ноль (корреляция отсутствует).</para>
   </step>
  </procedure>

  <para>Примеры функций оценки стоимости можно найти в <filename>src/backend/utils/adt/selfuncs.c</filename>.</para>
 </sect1>
</chapter>
