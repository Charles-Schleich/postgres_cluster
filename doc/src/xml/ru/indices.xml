<!-- doc/src/xml/indices.xml -->

<chapter id="indexes">
 <title>Индексы</title>

 <indexterm zone="indexes"><primary>индекс</primary></indexterm>

 <para>Индексы &mdash; это традиционное средство увеличения производительности БД. Используя индекс, сервер баз данных может находить и извлекать нужные строки гораздо быстрее, чем без него. Однако с индексами связана дополнительная нагрузка на СУБД в целом, поэтому применять их следует обдуманно.</para>


 <sect1 id="indexes-intro">
  <title>Введение</title>

  <para>Предположим, что у нас есть такая таблица: <programlisting>CREATE TABLE test1 (
    id integer,
    content varchar
);</programlisting> и приложение выполняет много подобных запросов: <programlisting>SELECT content FROM test1 WHERE id = <replaceable>константа</replaceable>;</programlisting> Если система не будет заранее подготовлена, ей придётся сканировать всю таблицу <structname>test1</structname>, строку за строкой, чтобы найти все подходящие записи. Когда таблица <structname>test1</structname> содержит большое количество записей, а этот запрос должен вернуть всего несколько (возможно, одну или ноль), такое сканирование, очевидно, неэффективно. Но если создать в системе индекс по полю <structfield>id</structfield>, она сможет находить строки гораздо быстрее. Возможно, для этого ей понадобится опуститься всего на несколько уровней в дереве поиска.</para>

  <para>Подобный подход часто используется в технической литературе: термины и понятия, которые могут представлять интерес, собираются в алфавитном указателе в конце книги. Читатель может просмотреть этот указатель довольно быстро и затем перейти сразу к соответствующей странице, вместо того, чтобы пролистывать всю книгу в поисках нужного материала. Так же, как задача автора предугадать, что именно будут искать в книге читатели, задача программиста баз данных &mdash; заранее определить, какие индексы будут полезны.</para>

  <para>Создать индекс для столбца <structfield>id</structfield> рассмотренной ранее таблицы можно с помощью следующей команды: <programlisting>CREATE INDEX test1_id_index ON test1 (id);</programlisting> Имя индекса <structname>test1_id_index</structname> может быть произвольным, главное, чтобы оно позволяло понять, для чего этот индекс.</para>

  <para>Для удаления индекса используется команда <command>DROP INDEX</command>. Добавлять и удалять индексы можно в любое время.</para>

  <para>Когда индекс создан, никакие дополнительные действия не требуются: система сама будет обновлять его при изменении данных в таблице и сама будет использовать его в запросах, где, по её мнению, это будет эффективнее, чем сканирование всей таблицы. Вам, возможно, придётся только периодически запускать команду <command>ANALYZE</command> для обновления статистических данных, на основе которых планировщик запросов принимает решения. В <xref remap="6" linkend="performance-tips"/> вы можете узнать, как определить, используется ли определённый индекс и при каких условиях планировщик может решить <emphasis>не</emphasis> использовать его.</para>

  <para>Индексы могут быть полезны также при выполнении команд <command>UPDATE</command> и <command>DELETE</command> с условиями поиска. Кроме того, они могут применяться в поиске с соединением. То есть, индекс, определённый для столбца, участвующего в условии соединения, может значительно ускорить запросы с JOIN.</para>

  <para>Создание индекса для большой таблицы может занимать много времени. По умолчанию <productname>&productname;</productname> позволяет параллельно с созданием индекса выполнять чтение (операторы <command>SELECT</command>) таблицы, но операции записи (<command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</command>) блокируются до окончания построения индекса. Для производственной среды это ограничение часто бывает неприемлемым. Хотя есть возможность разрешить запись параллельно с созданием индексов, при этом нужно учитывать ряд оговорок &mdash; они описаны в подразделе <xref linkend="sql-createindex-concurrently" endterm="sql-createindex-concurrently-title"/>.</para>

  <para>После создания индекса система должна поддерживать его в состоянии, соответствующем данным таблицы. С этим связаны неизбежные накладные расходы при изменении данных. Таким образом, индексы, которые используются в запросах редко или вообще никогда, должны быть удалены.</para>
 </sect1>


 <sect1 id="indexes-types">
  <title>Типы индексов</title>

  <para><productname>&productname;</productname> поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Для разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы запросов. По умолчанию команда <command>CREATE INDEX</command> создаёт индексы типа B-дерево, эффективные в большинстве случаев.</para>

  <para><indexterm><primary>индекс</primary> <secondary>B-дерево</secondary></indexterm> <indexterm><primary>B-дерево</primary> <see>индекс</see></indexterm> B-деревья могут работать в условиях на равенство и в проверках диапазонов с данными, которые можно отсортировать в некотором порядке. Точнее, планировщик запросов <productname>&productname;</productname> может задействовать индекс-B-дерево, когда индексируемый столбец участвует в сравнении с одним из следующих операторов: <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist> При обработке конструкций, представимых как сочетание этих операторов, например <literal>BETWEEN</literal> и <literal>IN</literal>, так же может выполняться поиск по индексу-B-дереву. Кроме того, такие индексы могут использоваться и в условиях <literal>IS NULL</literal> и <literal>IS NOT NULL</literal> по индексированным столбцам.</para>

  <para>Также оптимизатор может использовать эти индексы в запросах с операторами сравнения по шаблону <literal>LIKE</literal> и <literal>~</literal>, <emphasis>если</emphasis> этот шаблон определяется константой и он привязан к началу строки &mdash; например, <literal>col LIKE 'foo%'</literal> или <literal>col ~ '^foo'</literal>, но не <literal>col LIKE '%bar'</literal>. Но если ваша база данных использует не локаль C, для поддержки индексирования запросов с шаблонами вам потребуется создать индекс со специальным классом операторов; см. <xref remap="4" linkend="indexes-opclass"/>. Индексы-B-деревья можно использовать и для <literal>ILIKE</literal> и <literal>~*</literal>, но только если шаблон начинается не с алфавитных символов, то есть символов, не подверженных преобразованию регистра.</para>

  <para>B-деревья могут также применяться для получения данных, отсортированных по порядку. Это не всегда быстрее простого сканирования и сортировки, но иногда бывает полезно.</para>

  <para><indexterm><primary>индекс</primary> <secondary>по хешу</secondary></indexterm> <indexterm><primary>хеш</primary> <see>индекс</see></indexterm> Хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором <literal>=</literal>. Создать такой индекс можно следующей командой: <synopsis>
CREATE INDEX <replaceable>имя</replaceable> ON <replaceable>таблица</replaceable> USING HASH (<replaceable>столбец</replaceable>);
</synopsis></para>

  <caution>
   <para>Операции с хеш-индексами в настоящее время не проходят через WAL, так что после аварийной остановки базы данных может потребоваться перестроить хеш-индексы командой <command>REINDEX</command>. Кроме того, изменения в хеш-индексах после начальной копии не переносятся при потоковой или файловой репликации, так что в последующих запросах они будут давать неправильные ответы. По этим причинам настоятельно рекомендуется не использовать их.</para>
  </caution>

  <para><indexterm><primary>индекс</primary> <secondary>GiST</secondary></indexterm> <indexterm><primary>GiST</primary> <see>индекс</see></indexterm> GiST-индексы представляют собой не просто разновидность индексов, а инфраструктуру, позволяющую реализовать много разных стратегий индексирования. Как следствие, GiST-индексы могут применяться с разными операторами, в зависимости от стратегии индексирования (<firstterm>класса операторов</firstterm>). Например, стандартный дистрибутив <productname>&productname;</productname> включает классы операторов GiST для нескольких двумерных типов геометрических данных, что позволяет применять индексы в запросах с операторами: <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist> (Эти операторы описаны в <xref remap="6" linkend="functions-geometry"/>.) Классы операторов GiST, включённые в стандартный дистрибутив, описаны в <xref remap="6" linkend="gist-builtin-opclasses-table"/>. В коллекции <literal>contrib</literal> можно найти и другие классы операторов GiST, реализованные как отдельные проекты. За дополнительными сведениями обратитесь к <xref remap="3" linkend="gist"/>.</para>

  <para>GiST-индексы также могут оптимизировать поиск <quote>ближайшего соседа</quote>, например такой: <programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting> который возвращает десять расположений, ближайших к заданной точке. Возможность такого применения индекса опять же зависит от класса используемого оператора. Операторы, которые можно использовать таким образом, перечислены в <xref remap="6" linkend="gist-builtin-opclasses-table"/>, в столбце <quote>Операторы сортировки</quote>.</para>

  <para><indexterm><primary>индекс</primary> <secondary>SP-GiST</secondary></indexterm> <indexterm><primary>SP-GiST</primary> <see>индекс</see></indexterm> Индексы SP-GiST, как и GiST, предоставляют инфраструктуру, поддерживающие различные типы поиска. SP-GiST позволяет организовывать на диске самые разные несбалансированные структуры данных, такие как деревья квадрантов, k-мерные и префиксные деревья. Например, стандартный дистрибутив <productname>&productname;</productname> включает классы операторов SP-GiST для точек в двумерном пространстве, что позволяет применять индексы в запросах с операторами: <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>&lt;^</literal></member>
    <member><literal>&gt;^</literal></member>
   </simplelist> (Эти операторы описаны в <xref remap="6" linkend="functions-geometry"/>.) Классы операторов SP-GiST, включённые в стандартный дистрибутив, описаны в <xref remap="6" linkend="spgist-builtin-opclasses-table"/>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="spgist"/>.</para>

  <para><indexterm><primary>индекс</primary> <secondary>GIN</secondary></indexterm> <indexterm><primary>GIN</primary> <see>индекс</see></indexterm> GIN-индексы представляют собой <quote>инвертированные индексы</quote>, в которых могут содержаться значения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно работать в запросах, проверяющих присутствие определённых значений компонентов.</para>

  <para>Подобно GiST и SP-GiST, индексы GIN могут поддерживать различные определённые пользователем стратегии и в зависимости от них могут применяться с разными операторами. Например, стандартный дистрибутив <productname>&productname;</productname> включает классы операторов GIN для одномерных массивов, что позволяет применять индексы в запросах с операторами: <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist> (Эти операторы описаны в <xref remap="6" linkend="functions-array"/>.) Классы операторов GIN, включённые в стандартный дистрибутив, описаны в <xref remap="6" linkend="gin-builtin-opclasses-table"/>. В коллекции <literal>contrib</literal> можно найти и другие классы операторов GIN, реализованные как отдельные проекты. За дополнительными сведениями обратитесь к <xref remap="3" linkend="gin"/>.</para>

  <para><indexterm><primary>индекс</primary> <secondary>BRIN</secondary></indexterm> <indexterm><primary>BRIN</primary> <see>индекс</see></indexterm> BRIN-индексы (сокращение от Block Range INdexes, Индексы зон блоков) хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы. Подобно GiST, SP-GiST и GIN, индексы BRIN могут поддерживать определённые пользователем стратегии, и в зависимости от них применяться с разными операторами. Для типов данных, имеющих линейный порядок сортировки, записям в индексе соответствуют минимальные и максимальные значения данных в столбце для каждой зоны блоков. Это позволяет поддерживать запросы со следующими операторами: <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist> Классы операторов BRIN, включённые в стандартный дистрибутив, описаны в <xref remap="6" linkend="brin-builtin-opclasses-table"/>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="brin"/>.</para>
 </sect1>


 <sect1 id="indexes-multicolumn">
  <title>Составные индексы</title>

  <indexterm zone="indexes-multicolumn"><primary>индекс</primary> <secondary>составной</secondary></indexterm>

  <para>Индексы можно создавать и по нескольким столбцам таблицы. Например, если у вас есть таблица: <programlisting>CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);</programlisting> (предположим, что вы поместили в неё содержимое каталога <filename class="directory">/dev</filename>) и вы часто выполняете запросы вида: <programlisting>SELECT name FROM test2 WHERE major = <replaceable>константа</replaceable> AND minor = <replaceable>константа</replaceable>;</programlisting> тогда имеет смысл определить индекс, покрывающий оба столбца <structfield>major</structfield> и <structfield>minor</structfield>. Например: <programlisting>CREATE INDEX test2_mm_idx ON test2 (major, minor);</programlisting></para>

  <para>В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Число столбцов в индексе ограничивается 32. (Этот предел можно изменить при компиляции <productname>&productname;</productname>; см. файл <filename>pg_config_manual.h</filename>.)</para>

  <para>Составной индекс-B-дерево может применяться в условиях с любым подмножеством столбцов индекса, но наиболее эффективен он при ограничениях по ведущим (левым) столбцам. Точное правило состоит в том, что сканируемая область индекса определяется условиями равенства с ведущими столбцами и условиями неравенства с первым столбцом, не участвующим в условии равенства. Ограничения столбцов правее них также проверяются по индексу, так что обращение к таблице откладывается, но на размер сканируемой области индекса это уже не влияет. Например, если есть индекс по столбцам <literal>(a, b, c)</literal> и условие <literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</literal>, индекс будет сканироваться от первой записи <literal>a</literal> = 5 и <literal>b</literal> = 42 до последней с <literal>a</literal> = 5. Записи индекса, в которых <literal>c</literal> &gt;= 77, не будут учитываться, но, тем не менее, будут просканированы. Этот индекс в принципе может использоваться в запросах с ограничениями по <literal>b</literal> и/или <literal>c</literal>, без ограничений столбца <literal>a</literal>, но при этом будет просканирован весь индекс, так что в большинстве случаев планировщик предпочтёт использованию индекса полное сканирование таблицы.</para>

  <para>Составной индекс GiST может применяться в условиях с любым подмножеством столбцов индекса. Условия с дополнительными столбцами ограничивают записи, возвращаемые индексом, но в первую очередь сканируемая область индекса определяется ограничением первого столбца. GiST-индекс будет относительно малоэффективен, когда первый его столбец содержит только несколько различающихся значений, даже если дополнительные столбцы дают множество различных значений.</para>

  <para>Составной индекс GIN может применяться в условиях с любым подмножеством столбцов индекса. В отличие от индексов GiST или B-деревьев, эффективность поиска по нему не меняется в зависимости от того, какие из его столбцов используются в условиях запроса.</para>

  <para>Составной индекс BRIN может применяться в условиях запроса с любым подмножеством столбцов индекса. Подобно индексу GIN и в отличие от B-деревьев или GiST, эффективность поиска по нему не меняется в зависимости от того, какие из его столбцов используются в условиях запроса. Единственное, зачем в одной таблице могут потребоваться несколько индексов BRIN вместо одного составного индекса — это затем, чтобы применялись разные параметры хранения <literal>pages_per_range</literal>.</para>

  <para>При этом, разумеется, каждый столбец должен использоваться с операторами, соответствующими типу индекса; ограничения с другими операторами рассматриваться не будут.</para>

  <para>Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному столбцу будет работать достаточно хорошо и сэкономит время и место. Индексы по более чём трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно. Описание достоинств различных конфигураций индексов можно найти в <xref remap="6" linkend="indexes-bitmap-scans"/> и <xref remap="6" linkend="indexes-index-only-scans"/>.</para>
 </sect1>


 <sect1 id="indexes-ordering">
  <title>Индексы и предложения <literal>ORDER BY</literal></title>

  <indexterm zone="indexes-ordering"><primary>индекс</primary> <secondary>и <literal>ORDER BY</literal></secondary></indexterm>

  <para>Помимо простого поиска строк для выдачи в результате запроса, индексы также могут применяться для сортировки строк в определённом порядке. Это позволяет учесть предложение <literal>ORDER BY</literal> в запросе, не выполняя сортировку дополнительно. Из всех типов индексов, которые поддерживает <productname>&productname;</productname>, сортировать данные могут только B-деревья &mdash; индексы других типов возвращают строки в неопределённом, зависящем от реализации порядке.</para>

  <para>Планировщик может выполнить указание <literal>ORDER BY</literal>, либо просканировав существующий индекс, подходящий этому указанию, либо просканировав таблицу в физическом порядке и выполнив сортировку явно. Для запроса, требующего сканирования большой части таблицы, явная сортировка скорее всего будет быстрее, чем применение индекса, так как при последовательном чтении она потребует меньше операций ввода/вывода. Важный особый случай представляет <literal>ORDER BY</literal> в сочетании с <literal>LIMIT</literal> <replaceable>n</replaceable>: при явной сортировке системе потребуется обработать все данные, чтобы выбрать первые <replaceable>n</replaceable> строк, но при наличии индекса, соответствующего столбцам в <literal>ORDER BY</literal>, первые <replaceable>n</replaceable> строк можно получить сразу, не просматривая остальные вовсе.</para>

  <para>По умолчанию элементы B-дерева хранятся в порядке возрастания, при этом значения NULL идут в конце. Это означает, что при прямом сканировании индекса по столбцу <literal>x</literal> порядок оказывается соответствующим указанию <literal>ORDER BY x</literal> (или точнее, <literal>ORDER BY x ASC NULLS LAST</literal>). Индекс также может сканироваться в обратную сторону, и тогда порядок соответствует указанию <literal>ORDER BY x DESC</literal> (или точнее, <literal>ORDER BY x DESC NULLS FIRST</literal>, так как для <literal>ORDER BY DESC</literal> подразумевается <literal>NULLS FIRST</literal>).</para>

  <para>Вы можете изменить порядок сортировки элементов B-дерева, добавив уточнения <literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS FIRST</literal> и/или <literal>NULLS LAST</literal> при создании индекса; например: <programlisting>CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);</programlisting> Индекс, в котором элементы хранятся в порядке возрастания и значения NULL идут первыми, может удовлетворять указаниям <literal>ORDER BY x ASC NULLS FIRST</literal> или <literal>ORDER BY x DESC NULLS LAST</literal>, в зависимости от направления просмотра.</para>

  <para>У вас может возникнуть вопрос, зачем нужны все четыре варианта при создании индексов, когда и два варианта с учётом обратного просмотра покрывают все виды <literal>ORDER BY</literal>. Для индексов по одному столбцу это и в самом деле излишне, но для индексов по многим столбцам это может быть полезно. Рассмотрим индекс по двум столбцам <literal>(x, y)</literal>: он может удовлетворять указанию <literal>ORDER BY x, y</literal> при прямом сканировании или <literal>ORDER BY x DESC, y DESC</literal> при обратном. Но вполне возможно, что приложение будет часто выполнять <literal>ORDER BY x ASC, y DESC</literal>. В этом случае получить такую сортировку от простого индекса нельзя, но можно получить подходящий индекс, определив его как <literal>(x ASC, y DESC)</literal> или <literal>(x DESC, y ASC)</literal>.</para>

  <para>Очевидно, что индексы с нестандартными правилами сортировки весьма специфичны, но иногда они могут кардинально ускорить определённые запросы. Стоит ли вводить такие индексы, зависит от того, как часто выполняются запросы с необычным порядком сортировки.</para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
  <title>Объединение нескольких индексов</title>

  <indexterm zone="indexes-bitmap-scans"><primary>индекс</primary> <secondary>объединение нескольких индексов</secondary></indexterm>

  <indexterm zone="indexes-bitmap-scans"><primary>сканирование по битовой карте</primary></indexterm>

  <para>При простом сканировании индекса могут обрабатываться только те предложения в запросе, в которых применяются операторы его класса и объединяет их <literal>AND</literal>. Например, для индекса <literal>(a, b)</literal> условие запроса <literal>WHERE a = 5 AND b = 6</literal> сможет использовать этот индекс, а запрос <literal>WHERE a = 5 OR b = 6</literal> &mdash; нет.</para>

  <para>К счастью, <productname>&productname;</productname> способен соединять несколько индексов (и в том числе многократно применять один индекс) и охватывать также случаи, когда сканирования одного индекса недостаточно. Система может сформировать условия <literal>AND</literal> и <literal>OR</literal> за несколько проходов индекса. Например, запрос <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</literal> можно разбить на четыре сканирования индекса по <literal>x</literal>, по сканированию для каждой части условия. Затем результаты этих сканирований будут логически сложены (OR) вместе и дадут конечный результат. Другой пример &mdash; если у нас есть отдельные индексы по <literal>x</literal> и <literal>y</literal>, запрос <literal>WHERE x = 5 AND y = 6</literal> можно выполнить, применив индексы для соответствующих частей запроса, а затем вычислив логическое произведение (AND) для найденных строк, которое и станет конечным результатом.</para>

  <para>Выполняя объединение нескольких индексов, система сканирует все необходимые индексы и создаёт в памяти <firstterm>битовую карту</firstterm> расположения строк таблицы, которые удовлетворяют условиям каждого индекса. Затем битовые карты объединяются операциями AND и OR, как того требуют условия в запросе. Наконец система обращается к соответствующим отмеченным строкам таблицы и возвращает их данные. Строки таблицы просматриваются в физическом порядке, как они представлены в битовой карте; это означает, что порядок сортировки индексов при этом теряется и в запросах с предложением <literal>ORDER BY</literal> сортировка будет выполняться отдельно. По этой причине, а также потому, что каждое сканирование индекса занимает дополнительное время, планировщик иногда выбирает простое сканирование индекса, несмотря на то, что можно было бы подключить и дополнительные индексы.</para>

  <para>В большинстве приложений (кроме самых простых) полезными могут оказаться различные комбинации индексов, поэтому разработчик баз данных, определяя набор индексов, должен искать компромиссное решение. Иногда оказываются хороши составные индексы, а иногда лучше создать отдельные индексы и положиться на возможности объединения индексов. Например, если типичную нагрузку составляют запросы иногда с условием только по столбцу <literal>x</literal>, иногда только по <literal>y</literal>, а иногда по обоим столбцам, вы можете ограничиться двумя отдельными индексами по <literal>x</literal> и <literal>y</literal>, рассчитывая на то, что при обработке условий с обоими столбцами эти индексы будут объединяться. С другой стороны, вы можете создать один составной индекс по <literal>(x, y)</literal>. Этот индекс скорее всего будет работать эффективнее, чем объединение индексов, в запросах с двумя столбцами, но как говорилось в <xref remap="6" linkend="indexes-multicolumn"/>, он будет практически бесполезен для запросов с ограничениями только по <literal>y</literal>, так что одного этого индекса будет недостаточно. Выигрышным в этом случае может быть сочетание составного индекса с отдельным индексом по <literal>y</literal>. В запросах, где задействуется только <literal>x</literal>, может применяться составной индекс, хотя он будет больше и, следовательно, медленнее индекса по одному <literal>x</literal>. Наконец, можно создать все три индекса, но это будет оправдано, только если данные в таблице изменяются гораздо реже, чем выполняется поиск в таблице, при этом частота запросов этих трёх типов примерно одинакова. Если запросы какого-то одного типа выполняются гораздо реже других, возможно лучше будет оставить только два индекса, соответствующих наиболее частым запросам.</para>

 </sect1>


 <sect1 id="indexes-unique">
  <title>Уникальные индексы</title>

  <indexterm zone="indexes-unique"><primary>индекс</primary> <secondary>уникальный</secondary></indexterm>

  <para>Индексы также могут обеспечивать уникальность значения в столбце или уникальность сочетания значений в нескольких столбцах. <synopsis>
CREATE UNIQUE INDEX <replaceable>имя</replaceable> ON <replaceable>таблица</replaceable> (<replaceable>столбец</replaceable> <optional>, ...</optional>)
<optional>INCLUDE (<replaceable>столбец</replaceable> <optional>, ...</optional>)</optional>;
</synopsis> В настоящее время уникальными могут быть только индексы-B-деревья.</para>

  <para>Если индекс создаётся как уникальный, в таблицу нельзя будет добавить несколько строк с одинаковыми значениями ключа индекса. При этом значения NULL считаются не равными друг другу. Составной уникальный индекс не принимает только те строки, в которых все индексируемые столбцы содержат одинаковые значения. Столбцы, включённые предложением <literal>INCLUDE</literal>, не учитываются при контроле ограничений (UNIQUE, PRIMARY KEY и т. д.).</para>

  <para>Когда для таблицы определяется ограничение уникальности или первичный ключ, <productname>&productname;</productname> автоматически создаёт уникальный индекс по всем столбцам, составляющим это ограничение или первичный ключ (индекс может быть составным). Такой индекс и является механизмом, который обеспечивает выполнение ограничения.</para>

  <note>
   <para>Для уникальных столбцов не нужно вручную создавать отдельные индексы — они просто продублируют индексы, созданные автоматически.</para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
  <title>Индексы по выражениям</title>

  <indexterm zone="indexes-expressional"><primary>индекс</primary> <secondary sortas="expressions">по выражению</secondary></indexterm>

  <para>Индекс можно создать не только по столбцу нижележащей таблицы, но и по функции или скалярному выражению с одним или несколькими столбцами таблицы. Это позволяет быстро находить данные в таблице по результатам вычислений.</para>

  <para>Например, для сравнений без учёта регистра символов часто используется функция <function>lower</function>: <programlisting>SELECT * FROM test1 WHERE lower(col1) = 'value';</programlisting> Этот запрос сможет использовать индекс, определённый для результата функции <literal>lower(col1)</literal> так: <programlisting>CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));</programlisting></para>

  <para>Если мы объявим этот индекс уникальным (<literal>UNIQUE</literal>), он не даст добавить строки, в которых значения <literal>col1</literal> различаются только регистром, как и те, в которых значения <literal>col1</literal> действительно одинаковые. Таким образом, индексы по выражениям можно использовать ещё и для обеспечения ограничений, которые нельзя записать как простые ограничения уникальности.</para>

  <para>Если же часто выполняются запросы вида: <programlisting>SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';</programlisting> тогда, возможно, стоит создать такой индекс: <programlisting>CREATE INDEX people_names ON people ((first_name || ' ' || last_name));</programlisting></para>

  <para>Синтаксис команды <command>CREATE INDEX</command> обычно требует заключать индексные выражения в скобки, как показано во втором примере. Если же выражение представляет собой просто вызов функции, как в первом примере, дополнительные скобки можно опустить.</para>

  <para>Поддержка индексируемых выражений обходится довольно дорого, так как эти выражения должны вычисляться при добавлении каждой строки и при каждом последующем изменении. Однако при поиске по индексу индексируемое выражение <emphasis>не</emphasis> вычисляется повторно, так как его результат уже сохранён в индексе. В рассмотренных выше случаях система видит запрос как <literal>WHERE столбец_индекса = 'константа'</literal> и поэтому поиск выполняется так же быстро, как и с простым индексом. Таким образом, индексы по выражениям могут быть полезны, когда скорость извлечения данных гораздо важнее скорости добавления и изменения.</para>
 </sect1>


 <sect1 id="indexes-partial">
  <title>Частичные индексы</title>

  <indexterm zone="indexes-partial"><primary>индекс</primary> <secondary>частичный</secondary></indexterm>

  <para><firstterm>Частичный индекс</firstterm> &mdash; это индекс, который строится по подмножеству строк таблицы, определяемому условным выражением (оно называется <firstterm>предикатом</firstterm> частичного индекса). Такой индекс содержит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно специфичны, но в ряде ситуаций они могут быть очень полезны.</para>

  <para>Частичные индексы могут быть полезны, во-первых, тем, что позволяют избежать индексирования распространённых значений. Так как при поиске распространённого значения (такого, которое содержится в значительном проценте всех строк) индекс всё равно не будет использоваться, хранить эти строки в индексе нет смысла. Исключив их из индекса, можно уменьшить его размер, а значит и ускорить запросы, использующие этот индекс. Это также может ускорить операции изменения данных в таблице, так как индекс будет обновляться не всегда. Возможное применение этой идеи проиллюстрировано в <xref remap="6" linkend="indexes-partial-ex1"/>.</para>

  <example id="indexes-partial-ex1">
   <title>Настройка частичного индекса, исключающего распространённые значения</title>

   <para>Предположим, что вы храните в базе данных журнал обращений к корпоративному сайту. Большая часть обращений будет происходить из диапазона IP-адресов вашей компании, а остальные могут быть откуда угодно (например, к нему могут подключаться внешние сотрудники с динамическими IP). Если при поиске по IP вас обычно интересуют внешние подключения, IP-диапазон внутренней сети компании можно не включать в индекс.</para>

   <para>Пусть у вас есть такая таблица: <programlisting>CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);</programlisting></para>

   <para>Создать частичный индекс для нашего примера можно так: <programlisting>CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');</programlisting></para>

   <para>Так будет выглядеть типичный запрос, использующий этот индекс: <programlisting>SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';</programlisting> А следующий запрос не будет использовать этот индекс: <programlisting>SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';</programlisting></para>

   <para>Заметьте, что при таком определении частичного индекса необходимо, чтобы распространённые значения были известны заранее, так что такие индексы лучше использовать, когда распределение данных не меняется. Хотя такие индексы можно пересоздавать время от времени, подстраиваясь под новое распределение, это значительно усложняет поддержку.</para>
  </example>

  <para>Во-вторых, частичные индексы могут быть полезны тем, что позволяют исключить из индекса значения, которые обычно не представляют интереса; это проиллюстрировано в <xref remap="6" linkend="indexes-partial-ex2"/>. При этом вы получаете те же преимущества, что и в предыдущем случае, но система не сможет извлечь <quote>неинтересные</quote> значения по этому индексу, даже если сканирование индекса может быть эффективным. Очевидно, настройка частичных индексов в таких случаях требует тщательного анализа и тестирования.</para>

  <example id="indexes-partial-ex2">
   <title>Настройка частичного индекса, исключающего неинтересные значения</title>

   <para>Если у вас есть таблица, в которой хранятся и оплаченные, и неоплаченные счета, и при этом неоплаченные счета составляют только небольшую часть всей таблицы, но представляют наибольший интерес, производительность запросов можно увеличить, создав индекс только по неоплаченным счетам. Сделать это можно следующей командой: <programlisting>CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;</programlisting></para>

   <para>Этот индекс будет применяться, например в таком запросе: <programlisting>SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;</programlisting> Однако он также может применяться в запросах, где <structfield>order_nr</structfield> вообще не используется, например: <programlisting>SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;</programlisting> Конечно, он будет не так эффективен, как мог бы быть частичный индекс по столбцу <structfield>amount</structfield>, так как системе придётся сканировать его целиком. Тем не менее, если неоплаченных счетов сравнительно мало, выиграть при поиске неоплаченного счёта можно и с таким частичным индексом.</para>

   <para>Заметьте, что в таком запросе этот индекс не будет использоваться: <programlisting>SELECT * FROM orders WHERE order_nr = 3501;</programlisting> Счёт с номером 3501 может оказаться, как в числе неоплаченных, так и оплаченных.</para>
  </example>

  <para><xref linkend="indexes-partial-ex2"/> также показывает, что индексируемый столбец не обязательно должен совпадать со столбцом, используемым в предикате. <productname>&productname;</productname> поддерживает частичные индексы с произвольными предикатами &mdash; главное, чтобы в них фигурировали только столбцы индексируемой таблицы. Однако не забывайте, что предикат должен соответствовать условиям запросов, для оптимизации которых предназначается данный индекс. Точнее, частичный индекс будет применяться в запросе, только если система сможет понять, что условие <literal>WHERE</literal> данного запроса математически сводится к предикату индекса. Но учтите, что <productname>&productname;</productname> не умеет доказывать математические утверждения об эквивалентности выражений, записанных в разных формах. (Составить программу для таких доказательств крайне сложно, и если даже это удастся, скорость её будет неприемлема для применения на практике.) Система может выявить только самые простые следствия с неравенствами; например, понять, что из <quote>x &lt; 1</quote> следует <quote>x &lt; 2</quote>; во всех остальных случаях условие предиката должно точно совпадать с условием в предложении <literal>WHERE</literal>, иначе индекс будет считаться неподходящим. Сопоставление условий происходит во время планирования запросов, а не во время выполнения. Как следствие, запросы с параметрами не будут работать с частичными индексами. Например, условие с параметром <quote>x &lt; ?</quote> в подготовленном запросе никогда не будет сведено к <quote>x &lt; 2</quote> при всех возможных значениях параметра.</para>

  <para>Третье возможное применение частичных индексов вообще не связано с использованием индекса в запросах. Идея заключается в том, чтобы создать уникальный индекс по подмножеству строк таблицы, как в <xref remap="6" linkend="indexes-partial-ex3"/>. Это обеспечит уникальность среди строк, удовлетворяющих условию предиката, но никак не будет ограничивать остальные.</para>

  <example id="indexes-partial-ex3">
   <title>Настройка частичного уникального индекса</title>

   <para>Предположим, что у нас есть таблица с результатами теста. Мы хотим, чтобы для каждого сочетания предмета и целевой темы была только одна запись об успешном результате, а неудачных попыток могло быть много. Вот как можно этого добиться: <programlisting>CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</programlisting> Это подход будет особенно эффективным, когда неудачных попыток будет намного больше, чем удачных.</para>
  </example>

  <para>Наконец, с помощью частичных индексов можно также переопределять выбираемый системой план запроса. Возможно, что для данных с неудачным распределением система решит использовать индекс, тогда как на самом деле это неэффективно. В этом случае индекс можно настроить так, чтобы в подобных запросах он не работал. Обычно <productname>&productname;</productname> принимает разумные решения относительно применения индексов (т. е. старается не использовать их для получения распространённых значений, так что частичный индекс в вышеприведённом примере помог только уменьшить размер индекса, для отказа от использования индекса он не требовался), поэтому крайне неэффективный план может быть поводом для сообщения об ошибке.</para>

  <para>Помните, что настраивая частичный индекс, вы тем самым заявляете, что знаете о данных гораздо больше, чем планировщик запросов. В частности, вы знаете, когда такой индекс может быть полезен. Это знание обязательно должно подкрепляться опытом и пониманием того, как работают индексы в <productname>&productname;</productname>. В большинстве случаев преимущества частичных индексов по сравнению с обычными будут минимальными.</para>

  <para>Узнать о частичных индексах больше можно в следующих источниках: <xref linkend="ston89b"/>, <xref linkend="olson93"/> и <xref linkend="seshadri95"/>.</para>
 </sect1>


 <sect1 id="indexes-opclass">
  <title>Семейства и классы операторов</title>

  <indexterm zone="indexes-opclass"><primary>класс операторов</primary></indexterm>

  <indexterm zone="indexes-opclass"><primary>семейство операторов</primary></indexterm>

  <para>В определении индекса можно указать <firstterm>класс операторов</firstterm> для каждого столбца индекса. <synopsis>
CREATE INDEX <replaceable>имя</replaceable> ON <replaceable>таблица</replaceable> (<replaceable>столбец</replaceable> <replaceable>класс_операторов</replaceable> <optional><replaceable>параметры сортировки</replaceable></optional> <optional>, ...</optional>);
</synopsis> Класс операторов определяет, какие операторы будет использовать индекс для этого столбца. Например, индекс-B-дерево по столбцу <type>int4</type> будет использовать класс <literal>int4_ops</literal>; этот класс операторов включает операции со значениями типа <type>int4</type>. На практике часто достаточно принять класс операторов, назначенный для типа столбца классом по умолчанию. Однако для некоторых типов данных могут иметь смысл несколько разных вариантов индексирования и реализовать их как раз позволяют разные классы операторов. Например, комплексные числа можно сортировать как по вещественной части, так и по модулю. Получить два варианта индексов для них можно, определив два класса операторов для данного типа и выбрав соответствующий класс при создании индекса. Выбранный класс операторов задаст основной порядок сортировки данных (его можно уточнить, добавив параметры <literal>COLLATE</literal>, <literal>ASC</literal>/<literal>DESC</literal> и/или <literal>NULLS FIRST</literal>/<literal>NULLS LAST</literal>).</para>

  <para>Помимо классов операторов по умолчанию есть ещё несколько встроенных: <itemizedlist>
    <listitem>
     <para>Классы операторов <literal>text_pattern_ops</literal>, <literal>varchar_pattern_ops</literal> и <literal>bpchar_pattern_ops</literal> поддерживают индексы-B-деревья для типов <type>text</type>, <type>varchar</type> и <type>char</type>, соответственно. От стандартных классов операторов они отличаются тем, что сравнивают значения по символам, не применяя правила сортировки, определённые локалью. Благодаря этому они подходят для запросов с поиском по шаблону (с <literal>LIKE</literal> и регулярными выражениями POSIX), когда локаль базы данных не стандартная <quote>C</quote>. Например, вы можете проиндексировать столбец <type>varchar</type> так: <programlisting>CREATE INDEX test_index ON test_table (col varchar_pattern_ops);</programlisting> Заметьте, что при этом также следует создать индекс с классом операторов по умолчанию, если вы хотите ускорить запросы с обычными сравнениями <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> и <literal>&gt;=</literal> за счёт применения индексов. Классы операторов <literal><replaceable>xxx</replaceable>_pattern_ops</literal> не подходят для таких сравнений. (Однако для проверки равенств эти классы операторов вполне пригодны.) В подобных случаях для одного столбца можно создать несколько индексов с разными классами операторов. Если же вы используете локаль C, классы операторов <literal><replaceable>xxx</replaceable>_pattern_ops</literal> вам не нужны, так как для поиска по шаблону в локали C будет достаточно индексов с классом операторов по умолчанию.</para>
    </listitem>
   </itemizedlist></para>

  <para>Следующий запрос выводит список всех существующих классов операторов: <programlisting>SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;</programlisting></para>

  <para>Класс операторов на самом деле является всего лишь подмножеством большой структуры, называемой <firstterm>семейством операторов</firstterm>. В случаях, когда несколько типов данных ведут себя одинаково, часто имеет смысл определить операторы так, чтобы они могли использоваться с индексами сразу нескольких типов. Сделать это можно, сгруппировав классы операторов для этих типов в одном семействе операторов. Такие многоцелевые операторы, являясь членами семейства, не будут связаны с каким-либо одним его классом.</para>

  <para>Расширенная версия предыдущего запроса показывает семью операторов, к которой принадлежит каждый класс операторов: <programlisting>SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opf.opfname AS opfamily_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc, pg_opfamily opf
    WHERE opc.opcmethod = am.oid AND
          opc.opcfamily = opf.oid
    ORDER BY index_method, opclass_name;</programlisting></para>

  <para>Этот запрос выводит все существующие семейства операторов и все операторы, включённые в эти семейства: <programlisting>SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;</programlisting></para>
 </sect1>


 <sect1 id="indexes-collations">
  <title>Индексы и правила сортировки</title>

  <para>Один индекс может поддерживать только одно правило сортировки для индексируемого столбца. Поэтому при необходимости применять разные правила сортировки могут потребоваться несколько индексов.</para>

  <para>Рассмотрим следующие операторы: <programlisting>CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);</programlisting> Этот индекс автоматически использует правило сортировки нижележащего столбца. И запрос вида <programlisting>SELECT * FROM test1c WHERE content &gt; <replaceable>константа</replaceable>;</programlisting> сможет использовать этот индекс, так как при сравнении по умолчанию будет действовать правило сортировки столбца. Однако этот индекс не поможет ускорить запросы с каким-либо другим правилом сортировки. Поэтому, если интерес представляют также и запросы вроде <programlisting>SELECT * FROM test1c WHERE content &gt; <replaceable>константа</replaceable> COLLATE "y";</programlisting> для них можно создать дополнительный индекс, поддерживающий правило сортировки <literal>"y"</literal>, примерно так: <programlisting>CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");</programlisting></para>
 </sect1>


 <sect1 id="indexes-index-only-scans">
  <title>Сканирование только индекса</title>

  <indexterm zone="indexes-index-only-scans"><primary>индекс</primary> <secondary>сканирование только индекса</secondary></indexterm>
  <indexterm zone="indexes-index-only-scans"><primary>сканирование только индекса</primary></indexterm>

  <para>Все индексы в <productname>&productname;</productname> являются <firstterm>вторичными</firstterm>, что значит, что каждый индекс хранится вне области основных данных таблицы (которая в терминологии <productname>&productname;</productname> называется <firstterm>кучей</firstterm> таблицы). Это значит, что при обычном сканировании индекса для извлечения каждой строки необходимо прочитать данные и из индекса, и из кучи. Более того, тогда как элементы индекса, соответствующие заданному условию <literal>WHERE</literal>, обычно находятся в индексе рядом, строки таблицы могут располагаться в куче произвольным образом. Таким образом, обращение к куче при поиске по индексу влечёт множество операций произвольного чтения кучи, которые могут обойтись недёшево, особенно на традиционных вращающихся носителях. (Как описано в <xref remap="6" linkend="indexes-bitmap-scans"/>, сканирование по битовой карте пытается снизить стоимость этих операций, упорядочивая доступ к куче, но не более того.)</para>

  <para>Чтобы решить эту проблему с производительностью, <productname>&productname;</productname> поддерживает <firstterm>сканирование только индекса</firstterm>, при котором результат запроса может быть получен из самого индекса, без обращения к куче. Основная идея такого сканирования в том, чтобы выдавать значения непосредственно из элемента индекса, и не обращаться к соответствующей записи в куче. Для применения этого метода есть два фундаментальных ограничения: <orderedlist>
    <listitem>
     <para>Тип индекса должен поддерживать сканирование только индекса. Индексы-B-деревья поддерживают его всегда. Индексы GiST и SP-GiST могут поддерживать его с одними классами операторов и не поддерживать с другими. Другие индексы такое сканирование не поддерживают. Суть нижележащего требования в том, что индекс должен физически хранить или каким-то образом восстанавливать исходное значение данных для каждого элемента индекса. В качестве контрпримера, индексы GIN неспособны поддерживать сканирование только индекса, так как в элементах индекса обычно хранится только часть исходного значения данных.</para>
    </listitem>

    <listitem>
     <para>Запрос должен обращаться только к столбцам, сохранённым в индексе. Например, если в таблице построен индекс по столбцам <literal>x</literal> и <literal>y</literal>, и в ней есть также столбец <literal>z</literal>, такие запросы будут использовать сканирование только индекса: <programlisting>SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;</programlisting> А эти запросы не будут: <programlisting>SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;</programlisting> (Индексы по выражениям и частичные индексы усложняют это правило, как описано ниже.)</para>
    </listitem>
   </orderedlist></para>

  <para>Если два этих фундаментальных ограничения выполняются, то все данные, требуемые для выполнения запроса, содержатся в индексе, так что сканирование только по индексу физически возможно. Но в <productname>&productname;</productname> существует и ещё одно требование для сканирования таблицы: необходимо убедиться, что все возвращаемые строки <quote>видны</quote> в снимке MVCC запроса, как описано в <xref remap="6" linkend="mvcc"/>. Информация о видимости хранится не в элементах индекса, а только в куче; поэтому на первый взгляд может показаться, что для получения данных каждой строки всё равно необходимо обращаться к куче. И это в самом деле так, если в таблице недавно произошли изменения. Однако для редко меняющихся данных есть возможность обойти эту проблему. <productname>&productname;</productname> отслеживает для каждой страницы в куче таблицы, являются ли все строки в этой странице достаточно старыми, чтобы их видели все текущие и будущие транзакции. Это отражается в битах в <firstterm>карте видимости</firstterm> таблицы. Процедура сканирования только индекса, найдя потенциально подходящую запись в индексе, проверяет бит в карте видимости для соответствующей страницы в куче. Если он установлен, значит эта строка видна, и данные могут быть возвращены сразу. В противном случае придётся посетить запись строки в куче и проверить, видима ли она, так что никакого выигрыша по сравнению с обычным сканированием индекса не будет. И даже в благоприятном случае обращение к кучи не исключается совсем, а заменяется обращением к карте видимости; но так как карта видимости на четыре порядка меньше соответствующей ей области кучи, для работы с ней требуется много меньше операций физического ввода/вывода. В большинстве ситуаций карта видимости просто всё время находится в памяти.</para>

  <para>Таким образом, тогда как сканирование только по индексу возможно лишь при выполнении двух фундаментальных требований, оно даст выигрыш, только если для значительной части страниц в куче таблицы установлены биты полной видимости. Но таблицы, в которых меняется лишь небольшая часть строк, встречаются достаточно часто, чтобы этот тип сканирования был весьма полезен на практике.</para>

  <para>Чтобы эффективно применять возможность сканирования только индекса, можно создать индексы, в которых только первые столбцы будут соответствовать предложениям <literal>WHERE</literal>, а остальные столбцы будут содержать полезные данные, возвращаемые запросом. Например, если вы часто выполняете запросы вида: <programlisting>SELECT y FROM tab WHERE x = 'key';</programlisting> при традиционном подходе к ускорению таких запросов можно было бы создать индекс только по <literal>x</literal>. Однако индекс по <literal>(x, y)</literal> дал бы возможность выполнения этого запроса со сканированием только индекса. Как говорилось ранее, такой индекс был бы объёмнее и дороже в обслуживании, чем индекс только по <literal>x</literal>, так что этот вариант предпочтителен, только для таблиц в основном статических. Заметьте, что в объявлении индекса важно указать столбцы <literal>(x, y)</literal>, а не <literal>(y, x)</literal>, так как для большинства типов индексов (а именно, B-деревьев) поиск, при котором не ограничиваются значения ведущих столбцов индекса, не будет эффективным.</para>

  <para>В принципе сканирование только индекса может применяться и с индексами по выражениям. Например, при наличии индекса по <literal>f(x)</literal>, где <literal>x</literal> — столбец таблицы, должно быть возможно выполнить <programlisting>SELECT f(x) FROM tab WHERE f(x) &lt; 1;</programlisting> как сканирование только индекса; и это очень заманчиво, если <literal>f()</literal> — сложная для вычисления функция. Однако планировщик <productname>&productname;</productname> в настоящее время может вести себя не очень разумно. Он считает, что запрос может выполняться со сканированием только по индексу, только когда из индекса могут быть получены все <emphasis>столбцы</emphasis>, требующиеся для запроса. В этом примере <literal>x</literal> фигурирует только в контексте <literal>f(x)</literal>, но планировщик не замечает этого и решает, что сканирование только по индексу невозможно. Если сканирование только по индексу заслуживает того, эту проблему можно обойти, объявив индекс по <literal>(f(x), x)</literal>, где второй столбец может не использоваться на практике, но нужен для того, чтобы убедить планировщик, что сканирование только по индексу возможно. Если это делается ради того, чтобы избежать вычислений <literal>f(x)</literal>, надо также заметить, что планировщик не обязательно свяжет с использованием индекса упоминания <literal>f(x)</literal>, фигурирующие не в индексируемых предложениях <literal>WHERE</literal> со столбцом индекса. Обычно он это делает правильно в простых запросах, вроде показанного выше, но не в запросах с соединениями. Эти недостатки могут быть устранены в будущих версиях <productname>&productname;</productname>.</para>

  <para>С использованием частичных индексов при сканировании только по индексу тоже связаны интересные особенности. Предположим, что у нас есть частичный индекс, показанный в <xref remap="6" linkend="indexes-partial-ex3"/>: <programlisting>CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</programlisting> В принципе с ним мы можем произвести сканирование только по индексу при выполнении запроса <programlisting>SELECT target FROM tests WHERE subject = 'some-subject' AND success;</programlisting> Но есть одна проблема: предложение <literal>WHERE</literal> обращается к столбцу <literal>success</literal>, который отсутствует в результирующих столбцах индекса. Тем не менее, сканирование только индекса возможно, так как плану не нужно перепроверять эту часть предложения <literal>WHERE</literal> во время выполнения: у всех записей, найденных в индексе, значение <literal>success = true</literal>, так что в плане его не нужно проверять явно. <productname>&productname;</productname> версий 9.6 и новее распознает такую ситуацию и сможет произвести сканирование только по индексу, но старые версии неспособны на это.</para>
 </sect1>


 <sect1 id="indexes-examine">
  <title>Контроль использования индексов</title>

  <indexterm zone="indexes-examine"><primary>индексы</primary> <secondary>контроль использования</secondary></indexterm>

  <para>Хотя индексы в <productname>&productname;</productname> не требуют какого-либо обслуживания или настройки, это не избавляет от необходимости проверять, как и какие индексы используются на самом деле в реальных условиях. Узнать, как отдельный запрос использует индексы, можно с помощью команды <xref linkend="sql-explain"/>; её применение для этих целей описывается в <xref remap="6" linkend="using-explain"/>. Также возможно собрать общую статистику об использовании индексов на работающем сервере, как описано в <xref remap="6" linkend="monitoring-stats"/>.</para>

  <para>Вывести универсальную формулу, определяющую, какие индексы нужно создавать, довольно сложно, если вообще возможно. В предыдущих разделах рассматривались некоторые типовые ситуации, иллюстрирующие подходы к этому вопросу. Часто найти ответ на него помогают эксперименты. Ниже приведены ещё несколько советов:</para>

  <itemizedlist>
   <listitem>
    <para>Всегда начинайте исследование с <xref linkend="sql-analyze"/>. Эта команда собирает статистические данные о распределении значений в таблице, которые необходимы для оценивания числа строк, возвращаемых запросов. А это число, в свою очередь, нужно планировщику, чтобы оценить реальные затраты для всевозможных планов выполнения запроса. Не имея реальной статистики, планировщик будет вынужден принять некоторые значения по умолчанию, которые почти наверняка не будут соответствовать действительности. Поэтому понять, как индекс используется приложением без предварительного запуска <command>ANALYZE</command>, практически невозможно. Подробнее это рассматривается в <xref remap="6" linkend="vacuum-for-statistics"/> и <xref remap="6" linkend="autovacuum"/>.</para>
   </listitem>

   <listitem>
    <para>Используйте в экспериментах реальные данные. Анализируя работу системы с тестовыми данными, вы поймёте, какие индексы нужны для тестовых данных, но не более того.</para>

    <para>Особенно сильно искажают картину очень маленькие наборы тестовых данных. Тогда как для извлечения 1000 строк из 100000 может быть применён индекс, для выбора 1 из 100 он вряд ли потребуется, так как 100 строк скорее всего уместятся в одну страницу данных на диске и никакой другой план не будет лучше обычного сканирования 1 страницы.</para>

    <para>Тем не менее, пока приложение не эксплуатируется, создавать какие-то тестовые данные всё равно нужно, и это нужно делать обдуманно. Если вы наполняете базу данных очень близкими, или наоборот, случайными значениями, либо добавляете строки в отсортированном порядке, вы получите совсем не ту статистику распределения, что дадут реальные данные.</para>
   </listitem>

   <listitem>
    <para>Когда индексы не используются, ради тестирования может быть полезно подключить их принудительно. Для этого можно воспользоваться параметрами выполнения, позволяющими выключать различные типы планов (см. <xref remap="4" linkend="runtime-config-query-enable"/>). Например, выключив наиболее простые планы: последовательное сканирование (<varname>enable_seqscan</varname>) и соединения с вложенными циклами (<varname>enable_nestloop</varname>), вы сможете заставить систему выбрать другой план. Если же система продолжает выполнять сканирование или соединение с вложенными циклами, вероятно, у неё есть более серьёзная причина не использовать индекс; например, индекс может не соответствовать условию запроса. (Какие индексы работают в запросах разных типов, обсуждалось в предыдущих разделах.)</para>
   </listitem>

   <listitem>
    <para>Если система начинает использовать индекс только под принуждением, тому может быть две причины: либо система права и применять индекс в самом деле неэффективно, либо оценка стоимости применения индекса не соответствует действительности. В этом случае вам следует замерить время выполнения запроса с индексами и без них. В анализе этой ситуации может быть полезна команда <command>EXPLAIN ANALYZE</command>.</para>
   </listitem>

   <listitem>
    <para>Если выясняется, что оценка стоимости неверна, это может иметь тоже два объяснения. Общая стоимость вычисляется как произведение цены каждого узла плана для одной строки и оценки избирательности узла плана. Цены узлов при необходимости можно изменить параметрами выполнения (описанными в <xref remap="6" linkend="runtime-config-query-constants"/>). С другой стороны, оценка избирательности может быть неточной из-за некачественной статистики. Улучшить её можно, настроив параметры сбора статистики (см. <xref remap="4" linkend="sql-altertable"/>).</para>

    <para>Если ваши попытки скорректировать стоимость планов не увенчаются успехом, возможно вам останется только явно заставить систему использовать нужный индекс. Вероятно, имеет смысл также связаться с разработчиками <productname>&productname;</productname>, чтобы прояснить ситуацию.</para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
