<!-- doc/src/xml/xindex.xml -->

<sect1 id="xindex">
 <title>Интерфейсы расширений для индексов</title>

 <indexterm zone="xindex"><primary>индекс</primary> <secondary>для пользовательского типа данных</secondary></indexterm>

  <para>Описанные до этого процедуры позволяли определять новые типы, функции и операторы. Однако, мы ещё не можем определить индекс по столбцу нового типа данных. Для этого нам потребуется создать <firstterm>класс операторов</firstterm> для нового типа данных. Далее в этом разделе мы продемонстрируем эту концепцию на примере: мы создадим новый класс операторов для метода индекса-B-дерева, в котором будут храниться комплексные числа и сортироваться по возрастанию абсолютного значения.</para>

  <para>Классы операторов могут объединяться в <firstterm>семейства операторов</firstterm>, выражающие зависимости между семантически совместимыми классами. Когда вводится один тип данных, достаточно класса операторов, так что мы начнём с него, а к семействам операторов вернёмся позже.</para>

 <sect2 id="xindex-opclass">
  <title>Методы индексов и классы операторов</title>

  <para>В системном каталоге есть таблица <classname>pg_am</classname>, содержащая записи для каждого метода индекса (внутри называемого методом доступа). Поддержка обычного доступа к таблицам встроена в <productname>&productname;</productname>, но все методы доступа описываются в <classname>pg_am</classname>. Система позволяет добавлять новые методы доступа — для этого нужно написать необходимый код, а затем добавить запись в <classname>pg_am</classname>, но это выходит за рамки данной главы (см. <xref remap="4" linkend="indexam"/>).</para>

  <para>Процедуры метода индекса непосредственно ничего не знают о типах данных, с которыми будет применяться этот метод. Вместо этого, набор операций, которые нужны методу индекса для работы с конкретным типом данных, определяется <firstterm>классом операторов</firstterm><indexterm><primary>класс операторов</primary></indexterm>. Классы операторов называются так потому, что они определяют множество операторов в предложении <literal>WHERE</literal>, которые могут использоваться с индексом (т. е. могут быть сведены к сканированию индекса). В классе операторов могут также определяться некоторые <firstterm>опорные процедуры</firstterm>, которые нужны для внутренних операций метода индекса, но они не соответствуют напрямую каким-либо операторам предложения <literal>WHERE</literal>, которые могут обрабатываться с индексом.</para>

  <para>Для одного типа данных и метода индекса можно определить несколько классов операторов. Благодаря этому, для одного типа данных можно использовать несколько семантически разных вариантов индексирования. Например, индекс-B-дерево требует, чтобы для каждого типа данных, с которым он работает, определялся порядок сортировки. Для типа комплексных чисел может быть полезен класс операторов B-дерева, сортирующий данные по модулю комплексного числа, и ещё один, сортирующий по вещественной части, и т. п. Обычно предполагается, что один из классов операторов будет применяться чаще других, и тогда он помечается как класс по умолчанию для данного типа и метода индекса.</para>

  <para>Одно и то же имя класса операторов может использоваться для разных методов индекса (например, для методов индекса-B-дерева или хеш-индекса применяются классы операторов <literal>int4_ops</literal>), но все такие классы являются независимыми и должны определяться отдельно.</para>
 </sect2>

 <sect2 id="xindex-strategies">
  <title>Стратегии методов индексов</title>

  <para>Операторам, которые связываются с классом операторов, назначаются <quote>номера стратегий</quote>, определяющие роль каждого оператора в контексте его класса. Например, в B-дереве должен быть строгий порядок ключей с отношениями меньше/больше, так что в данном контексте представляют интерес операторы <quote>меньше</quote> и <quote>больше или равно</quote>. Так как <productname>&productname;</productname> позволяет пользователям определять операторы произвольным образом, <productname>&productname;</productname> не может просто посмотреть на имя оператора (<literal>&lt;</literal> или <literal>&gt;=</literal>) и сказать, какое сравнение он выполняет. Вместо этого для метода индекса определяется набор <quote>стратегий</quote>, которые можно считать обобщёнными операторами. Каждый класс операторов устанавливает, какие фактические операторы соответствуют стратегиям для определённого типа данных и интерпретации семантики индекса.</para>

  <para>Для метода индекса-B-дерева определены пять стратегий, описанных в <xref remap="6" linkend="xindex-btree-strat-table"/>.</para>

   <table tocentry="1" id="xindex-btree-strat-table">
    <title>Стратегии B-дерева</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Операция</entry>
       <entry>Номер стратегии</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>меньше</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>меньше или равно</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>равно</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>больше или равно</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>больше</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Индексы по хешу поддерживают только сравнение на равенство, так что они используют только одну стратегию, показанную в <xref remap="6" linkend="xindex-hash-strat-table"/>.</para>

   <table tocentry="1" id="xindex-hash-strat-table">
    <title>Стратегии хеша</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Операция</entry>
       <entry>Номер стратегии</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>равно</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Индексы GiST более гибкие: для них вообще нет фиксированного набора стратегий. Вместо этого опорная процедура <quote>согласованности</quote> каждого конкретного класса операторов GiST интерпретирует номера стратегий как ей угодно. Например, некоторые из встроенных классов операторов для индексов GiST индексируют двумерные геометрические объекты, и реализуют стратегии <quote>R-дерева</quote>, показанные в <xref remap="6" linkend="xindex-rtree-strat-table"/>. Четыре из них являются истинно двумерными проверками (overlaps, same, contains, contained by); другие четыре учитывают только ординаты, а ещё четыре проводят же проверки только с абсциссами.</para>

   <table tocentry="1" id="xindex-rtree-strat-table">
    <title>Стратегии двумерного <quote>R-дерева</quote> индекса GiST</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Операция</entry>
       <entry>Номер стратегии</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>строго слева от</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>не простирается правее</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>пересекается с</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>не простирается левее</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>строго справа от</entry>
       <entry>5</entry>
      </row>
      <row>
       <entry>одинаковы</entry>
       <entry>6</entry>
      </row>
      <row>
       <entry>содержит</entry>
       <entry>7</entry>
      </row>
      <row>
       <entry>содержится в</entry>
       <entry>8</entry>
      </row>
      <row>
       <entry>не простирается выше</entry>
       <entry>9</entry>
      </row>
      <row>
       <entry>строго ниже</entry>
       <entry>10</entry>
      </row>
      <row>
       <entry>строго выше</entry>
       <entry>11</entry>
      </row>
      <row>
       <entry>не простирается ниже</entry>
       <entry>12</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Индексы SP-GiST такие же гибкие, как и индексы GiST: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <xref remap="6" linkend="xindex-spgist-point-strat-table"/> приведены номера стратегий, установленные для встроенных классов операторов для точек.</para>

   <table tocentry="1" id="xindex-spgist-point-strat-table">
    <title>Стратегии SP-GiST для точек</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Операция</entry>
       <entry>Номер стратегии</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>строго слева от</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>строго справа от</entry>
       <entry>5</entry>
      </row>
      <row>
       <entry>одинаковы</entry>
       <entry>6</entry>
      </row>
      <row>
       <entry>содержится в</entry>
       <entry>8</entry>
      </row>
      <row>
       <entry>строго ниже</entry>
       <entry>10</entry>
      </row>
      <row>
       <entry>строго выше</entry>
       <entry>11</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Индексы GIN такие же гибкие, как и индексы GiST и SP-GiST: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <xref remap="6" linkend="xindex-gin-array-strat-table"/> приведены номера стратегий, установленные для встроенных классов операторов для массивов.</para>

   <table tocentry="1" id="xindex-gin-array-strat-table">
    <title>Стратегии GIN для массивов</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Операция</entry>
       <entry>Номер стратегии</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>пересекается с</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>содержит</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>содержится в</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>равно</entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Индексы BRIN такие же гибкие, как и индексы GiST, SP-GiST и GIN: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <xref remap="6" linkend="xindex-brin-minmax-strat-table"/> приведены номера стратегий, используемые встроенными классами операторов <literal>Minmax</literal>.</para>

   <table tocentry="1" id="xindex-brin-minmax-strat-table">
    <title>Стратегии BRIN Minmax</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Операция</entry>
       <entry>Номер стратегии</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>меньше</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>меньше или равно</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry>равно</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry>больше или равно</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>больше</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Заметьте, что все вышеперечисленные операторы возвращают булевы значения. На практике все операторы, определённые как операторы поиска для метода индекса, должны возвращать тип <type>boolean</type>, так как они должны находиться на верхнем уровне предложения <literal>WHERE</literal>, чтобы для них применялся индекс. (Некоторые методы доступа по индексу также поддерживают <firstterm>операторы упорядочивания</firstterm>, которые обычно не возвращают булевы значения; это обсуждается в <xref remap="6" linkend="xindex-ordering-ops"/>.)</para>
 </sect2>

 <sect2 id="xindex-support">
  <title>Опорные процедуры метода индекса</title>

  <para>Стратегии обычно не дают системе достаточно информации, чтобы понять, как использовать индекс. На практике, чтобы методы индекса работали, необходимы дополнительные опорные процедуры. Например, метод индекса-B-дерева должен уметь сравнивать два ключа и определять, больше, равен или меньше ли первый второго. Аналогично, метод индекса по хешу должен уметь сравнивать хеш-коды значений ключа. Эти операции не соответствуют операторам, которые применяются в условиях в командах SQL; это внутрисистемные подпрограммы, используемые методами индекса.</para>

  <para>Так же, как и со стратегиями, класс операторов определяет, какие конкретные функции должны играть каждую из ролей для определённого типа данных и интерпретации семантики индекса. Для метода индекса определяется набор нужных ему функций, а класс оператора выбирает нужные функции для применения, назначая им <quote>номера опорных функций</quote>, определяемые методом индекса.</para>

  <para>Для B-деревьев требуется одна опорная функция, а вторая задаётся по выбору автора класса операторов, как показано в <xref remap="6" linkend="xindex-btree-support-table"/>.</para>

   <table tocentry="1" id="xindex-btree-support-table">
    <title>Опорные функции B-деревьев</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Номер опорной функции</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>Сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше нуля, показывающее, что первый ключ меньше, равен или больше второго</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>Возвращает адрес вызываемой из C функции(й), поддерживающей сортировку, как описано в <filename>utils/sortsupport.h</filename> (необязательно)</entry>
       <entry>2</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Для хеш-индексов требуется одна опорная функция, указанная в <xref remap="6" linkend="xindex-hash-support-table"/>.</para>

   <table tocentry="1" id="xindex-hash-support-table">
    <title>Опорные функции хеша</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Номер опорной функции</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>Вычисляет значение хеша для ключа</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Для индексов GiST требуются девять опорных функций, две из которых необязательны; они описаны в <xref remap="6" linkend="xindex-gist-support-table"/>. (За дополнительными сведениями обратитесь к <xref remap="3" linkend="gist"/>.)</para>

   <table tocentry="1" id="xindex-gist-support-table">
    <title>Опорные функции GiST</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Описание</entry>
       <entry>Номер опорной функции</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>consistent</function></entry>
       <entry>определяет, удовлетворяет ли ключ условию запроса</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>union</function></entry>
       <entry>вычисляет объединение набора ключей</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>compress</function></entry>
       <entry>вычисляет сжатое представление ключа или индексируемого значения</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>decompress</function></entry>
       <entry>вычисляет развёрнутое представление сжатого ключа</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry><function>penalty</function></entry>
       <entry>вычисляет стоимость добавления нового ключа в поддерево с заданным ключом</entry>
       <entry>5</entry>
      </row>
      <row>
       <entry><function>picksplit</function></entry>
       <entry>определяет, какие записи страницы должны быть перемещены в новую страницу, и вычисляет ключи объединения для результирующих страниц</entry>
       <entry>6</entry>
      </row>
      <row>
       <entry><function>equal</function></entry>
       <entry>сравнивает два ключа и возвращает true, если они равны</entry>
       <entry>7</entry>
      </row>
      <row>
       <entry><function>distance</function></entry>
       <entry>определяет дистанцию от ключа до искомого значения (необязательно)</entry>
       <entry>8</entry>
      </row>
      <row>
       <entry><function>fetch</function></entry>
       <entry>вычисляет исходное представление сжатого ключа для сканирования только по индексу (необязательно)</entry>
       <entry>9</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Для индексов SP-GiST требуются пять опорных функций, описанных в <xref remap="6" linkend="xindex-spgist-support-table"/>. (За дополнительными сведениями обратитесь к <xref remap="3" linkend="spgist"/>.)</para>

   <table tocentry="1" id="xindex-spgist-support-table">
    <title>Опорные функции SP-GiST</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Описание</entry>
       <entry>Номер опорной функции</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>config</function></entry>
       <entry>предоставляет основную информацию о классе операторов</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>choose</function></entry>
       <entry>определяет, как вставить новое значение во внутренний элемент</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>picksplit</function></entry>
       <entry>определяет, как разделить множество значений</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>inner_consistent</function></entry>
       <entry>определяет, в каких внутренних ветвях нужно искать заданное значение</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry><function>leaf_consistent</function></entry>
       <entry>определяет, удовлетворяет ли ключ условию запроса</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Для индексов GIN требуются шесть опорных функций, три из которых необязательны; они описаны в <xref remap="6" linkend="xindex-gin-support-table"/>. (За дополнительными сведениями обратитесь к <xref remap="3" linkend="gin"/>.)</para>

   <table tocentry="1" id="xindex-gin-support-table">
    <title>Опорные функции GIN</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Описание</entry>
       <entry>Номер опорной функции</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>compare</function></entry>
       <entry>сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше нуля, показывающее, что первый ключ меньше, равен или больше второго</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>extractValue</function></entry>
       <entry>извлекает ключи из индексируемого значения</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>extractQuery</function></entry>
       <entry>извлекает ключи из условия запроса</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>consistent</function></entry>
       <entry>определяет, соответствует ли значение условию запроса (булевская вариация) (не требуется, если присутствует опорная функция 6)</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry><function>comparePartial</function></entry>
       <entry>сравнивает частичный ключ из запроса с ключом из индекса и возвращает целое число меньше нуля, ноль или больше нуля, показывающее, что GIN должен игнорировать эту запись индекса, принять её как соответствующую или прекратить сканирование индекса (необязательно)</entry>
       <entry>5</entry>
      </row>
      <row>
       <entry><function>triConsistent</function></entry>
       <entry>определяет, соответствует ли значение условию запроса (троичная вариация) (не требуется, если присутствует опорная функция 4)</entry>
       <entry>6</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>Для индексов BRIN требуются четыре базовые опорные функции, перечисленные в <xref remap="6" linkend="xindex-brin-support-table"/>; для этих базовых функций может потребоваться предоставить дополнительные опорные функции. (За дополнительными сведениями обратитесь к <xref remap="3" linkend="brin-extensibility"/>.)</para>

   <table tocentry="1" id="xindex-brin-support-table">
    <title>Опорные функции BRIN</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Функция</entry>
       <entry>Описание</entry>
       <entry>Номер опорной функции</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>opcInfo</function></entry>
       <entry>возвращает внутреннюю информацию, описывающую сводные данные по индексированным столбцам</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>add_value</function></entry>
       <entry>добавляет новое значение в существующий сводный кортеж индекса</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>consistent</function></entry>
       <entry>определяет, удовлетворяет ли значение условию запроса</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>union</function></entry>
       <entry>вычисляет объединение двух обобщающих кортежей</entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>В отличие от операторов поиска, опорные функции возвращают тот тип данных, который ожидает конкретный метод индекса; например, функция сравнения для B-деревьев возвращает знаковое целое. Количество и типы аргументов для каждой опорной функции так же зависят от метода индекса. Для методов B-дерева и хеша функции сравнения и хеширования принимают те же типы данных, что и операторы, включённые в класс операторов, но для большинства опорных функций GiST, SP-GiST, GIN и BRIN это не так.</para>
 </sect2>

 <sect2 id="xindex-example">
  <title>Пример</title>

  <para>Теперь, когда мы познакомились с основными идеями, мы можем перейти к обещанному примеру создания нового класса операторов. (Рабочую копию этого примера можно найти в <filename>src/tutorial/complex.c</filename> и <filename>src/tutorial/complex.sql</filename> в пакете исходного кода.) Класс операторов включает операторы, сортирующие комплексные числа по порядку абсолютных значений, поэтому мы выбрали для него имя <literal>complex_abs_ops</literal>. Во-первых, нам понадобится набор операторов. Процедура определения операторов была рассмотрена в <xref remap="6" linkend="xoper"/>. Для класса операторов B-деревьев нам понадобятся операторы: <itemizedlist spacing="compact">
    <listitem><simpara>абсолютное-значение меньше (стратегия 1)</simpara></listitem>
    <listitem><simpara>абсолютное-значение меньше-или-равно (стратегия 2)</simpara></listitem>
    <listitem><simpara>абсолютное-значение равно (стратегия 3)</simpara></listitem>
    <listitem><simpara>абсолютное-значение больше-или-равно (стратегия 4)</simpara></listitem>
    <listitem><simpara>абсолютное-значение больше (стратегия 5)</simpara></listitem>
   </itemizedlist></para>

  <para>Чтобы не провоцировать ошибки при определении связанного набора операторов сравнения, лучше всего сначала написать вспомогательную функцию сравнения для B-дерева, а затем написать другие функции как однострочные оболочки этой вспомогательной функции. Это уменьшит вероятность получения несогласованных результатов в исключительных случаях. Следуя этому подходу, мы сначала напишем: <programlisting><![CDATA[
#define Mag(c)  ((c)->x*(c)->x + (c)->y*(c)->y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag < bmag)
        return -1;
    if (amag > bmag)
        return 1;
    return 0;
}
]]>
</programlisting> Теперь функция &laquo;меньше&raquo; будет выглядеть так: <programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) < 0);
}
]]>
</programlisting> Остальные четыре функции отличаются от неё только тем, как сравнивают результат внутренней функции с нулём.</para>

  <para>Затем мы объявим в SQL функции и операторы на основе этих функций: <programlisting>CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<replaceable>имя_файла</replaceable>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);</programlisting> Важно правильно определить обратные и коммутирующие операторы, а также подходящие функции избирательности ограничения и соединения; иначе оптимизатор не сможет использовать наш индекс эффективно. Заметьте, что для случаев меньше, равно и больше следует использовать другие функции оценки избирательности.</para>

  <para>Здесь также стоит обратить внимание на следующее: <itemizedlist>
   <listitem>
    <para>Учтите, что может быть только один оператор с именем, например, <literal>=</literal>, который будет принимать тип <type>complex</type> с двух сторон. В этом случае у нас не будет другого оператора <literal>=</literal> для <type>complex</type>, но если мы создаём практически полезный тип данных, вероятно, мы захотим, чтобы оператор <literal>=</literal> проверял обычное равенство двух комплексных чисел (а не равенство их абсолютных значений). В этом случае, для <function>complex_abs_eq</function> нужно выбрать какое-то другое имя оператора.</para>
   </listitem>

   <listitem>
    <para>Хотя в <productname>&productname;</productname> разные функции могут иметь одинаковые имена SQL, если у них различные типы аргументов, в C только одна глобальная функция может иметь заданное имя. Поэтому не следует давать функции на C имя вроде <filename>abs_eq</filename>. Во избежание конфликтов с функциями для других типов данных, в имя функции на C обычно включается имя конкретного типа данных.</para>
   </listitem>

   <listitem>
    <para>Мы могли быть дать нашей функции имя <filename>abs_eq</filename> в SQL, рассчитывая на то, что <productname>&productname;</productname> отличит её от любых других одноимённых функций SQL по типам аргументов. Но в данном случае для упрощения примера мы дали ей одинаковые имена на уровне C и уровне SQL.</para>
   </listitem>
  </itemizedlist></para>

  <para>На следующем этапе регистрируется опорная процедура, необходимая для B-деревьев. В нашем примере код C, реализующий её, находится в том же файле, что и функции операторов. Мы объявляем эту процедуру так: <programlisting>CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<replaceable>имя_файла</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;</programlisting></para>

  <para>Теперь, когда мы объявили требуемые операторы и опорную функцию, мы наконец можем создать класс операторов: <programlisting><![CDATA[
CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        4       >= ,
        OPERATOR        5       > ,
        FUNCTION        1       complex_abs_cmp(complex, complex);
]]>
</programlisting></para>

  <para>Вот и всё! Теперь должно быть возможно создавать и использовать индексы-B-деревья по столбцам <type>complex</type>.</para>

  <para>Операторы можно было записать более многословно, например, так: <programlisting>        OPERATOR        1       &lt; (complex, complex) ,</programlisting> но в этом необходимости, так как эти операторы принимают тот же тип данных, для которого определяется класс операторов.</para>

  <para>В приведённом примере предполагается, что этот класс операторов будет классом операторов B-дерева по умолчанию для типа <type>complex</type>. Если вам это не нужно, просто опустите слово <literal>DEFAULT</literal>.</para>
 </sect2>

 <sect2 id="xindex-opfamily">
  <title>Семейства и классы операторов</title>

  <para>До этого мы неявно полагали, что класс операторов работает только с одним типом данных. Хотя в конкретном индексируемом столбце, определённо, может быть только один тип данных, часто бывает полезно индексировать операции, сравнивающие значение столбца со значением другого типа. Также, если в сочетании с классом операторов возможно применение оператора, работающего с двумя типами, для другого типа данных обычно тоже создаётся собственный класс. В таких случаях полезно установить явную связь между связанными классами, так как это поможет планировщику оптимизировать SQL-запросы (особенно для классов операторов B-дерева, потому что планировщик хорошо знает, как работать с ними).</para>

  <para>Для удовлетворения этих потребностей в <productname>&productname;</productname> введена концепция <firstterm>семейства операторов</firstterm><indexterm><primary>семейство операторов</primary></indexterm>. Семейство операторов содержит один или несколько классов операторов и может также содержать индексируемые операторы и соответствующие опорные функции, принадлежащие к семейству в целом, но не к какому-то одному классу в нём. Мы называем такую связь операторов и функций с семейством <quote>слабой</quote>, в отличие от обычной связи с определённым классом. Как правило, классы содержат операторы с операндами одного типа, тогда как межтиповые операторы слабо связываются с семейством.</para>

  <para>Все операторы и функции в семействе операторов должны иметь совместимую семантику; требования к совместимости устанавливаются методом индекса. Вы можете спросить, зачем в таком случае вообще выделять конкретные подмножества семейства в виде классов операторов; и на самом деле во многих случаях деление на классы не имеет значения, важно только связывание с семейством. Смысл классов операторов в том, что они определяют, какая часть семейства необходима для поддержки некоторого индекса. Если существует индекс, использующий класс операторов, этот класс нельзя будет удалить, не удалив индекс &mdash; но другие части семейства, а именно, другие классы операторов и слабосвязанные операторы, удалить можно. Таким образом, класс операторов должен определяться так, чтобы он содержал минимальный набор операторов и функций, обоснованно требующихся для работы с индексом по определённому типу данных, а связанные, но не существенные операторы могут добавляться в качестве слабосвязанных членов в семейство операторов.</para>

  <para>В качестве примера, в <productname>&productname;</productname> есть встроенное семейство операторов B-дерева <literal>integer_ops</literal>, включающее классы операторов <literal>int8_ops</literal>, <literal>int4_ops</literal> и <literal>int2_ops</literal> для индексов по столбцам <type>bigint</type> (<type>int8</type>), <type>integer</type> (<type>int4</type>) и <type>smallint</type> (<type>int2</type>), соответственно. В этом семействе также содержатся операторы межтипового сравнения, позволяющие сравнивать значения любых двух этих типов, так что индексом по любому из этих типов можно пользоваться, выполняя сравнение с другим типом. Это семейство можно представить такими определениями: <programlisting><![CDATA[
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- standard int8 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- standard int4 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -- standard int2 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- cross-type comparisons int8 vs int2
  OPERATOR 1 < (int8, int2) ,
  OPERATOR 2 <= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 >= (int8, int2) ,
  OPERATOR 5 > (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- cross-type comparisons int8 vs int4
  OPERATOR 1 < (int8, int4) ,
  OPERATOR 2 <= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 >= (int8, int4) ,
  OPERATOR 5 > (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- cross-type comparisons int4 vs int2
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- cross-type comparisons int4 vs int8
  OPERATOR 1 < (int4, int8) ,
  OPERATOR 2 <= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 >= (int4, int8) ,
  OPERATOR 5 > (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- cross-type comparisons int2 vs int8
  OPERATOR 1 < (int2, int8) ,
  OPERATOR 2 <= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 >= (int2, int8) ,
  OPERATOR 5 > (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- cross-type comparisons int2 vs int4
  OPERATOR 1 < (int2, int4) ,
  OPERATOR 2 <= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 >= (int2, int4) ,
  OPERATOR 5 > (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;
]]>
</programlisting> Заметьте, что в определении семейства <quote>перегружаются</quote> номера стратегий операторов и опорных функций: каждый номер фигурирует в семействе неоднократно. Это допускается, если для каждого экземпляра определённого номера задаются свои типы данных. Экземпляры, у которых оба входных типа совпадают с входным типом класса операторов, являются первичными операторами и опорными функциями для этого класса, и в большинстве случаев они должны объявляться в составе класса операторов, а не быть слабосвязанными членами семейства.</para>

  <para>В семействе операторов B-дерева все операторы должны быть совместимыми в контексте сортировки, то есть для всех типов данных, поддерживаемых семейством, должны действовать транзитивные законы: <quote>если A = B и B = C, то A = C</quote>, и <quote>если A &lt; B и B &lt; C, то A &lt; C</quote>. Более того, неявное или двоичное приведение типов, представленных в семействе операторов, не должно влиять на порядок сортировки. Для каждого оператора в семействе должна существовать опорная функция, принимающая на вход те же два типа, что и оператор. Семейство рекомендуется делать полным, то есть включить в него все операторы для каждого сочетания типов данных. В классы операторов следует включать только однотиповые операторы и опорные функции для определённого типа данных.</para>

  <para>Чтобы создать семейство операторов хеширования для нескольких типов данных, необходимо создать совместимые функции поддержки хеша для каждого типа данных, который будет поддерживать семейство. Здесь под совместимостью понимается гарантия получения одного хеш-кода для любых двух значений, которые операторы сравнения в этом семействе считают равными, даже если они имеют разные типы. Обычно это сложно осуществить, когда типы имеют разное физическое представление, но в некоторых случаях всё же возможно. Более того, преобразование значения одного типа данных, представленного в семействе операторов, к другому типу, также представленному в этом семействе, путём неявного или двоичного сведения не должно менять значение вычисляемого хеша. Заметьте, что единственная опорная функция задаётся для типа данных, а не для оператора равенства. Семейство рекомендуется делать полным, то есть включить в него оператор равенства для всех сочетаний типов данных. В классы операторов следует включать только однотиповый оператор равенства и опорную функция для определённого типа данных.</para>

  <para>В индексах GiST, SP-GiST и GIN межтиповые операции явно не выражены. Множество поддерживаемых операторов определяется только теми операциями, которые могут выполнять основные опорные функции заданного класса операторов.</para>

  <para>В BRIN требования зависят от инфраструктуры, предоставляющей классы операторов. Для классов операторов, построенных на инфраструктуре <literal>minmax</literal>, требуется то же поведение, что и для семейств операторов B-дерева: все операторы в семействе должны поддерживать совместимый порядок, а приведения не должны влиять на установленный порядок сортировки.</para>

  <note>
   <para>До версии 8.3 в <productname>PostgreSQL</productname> не было понятия семейства операторов, поэтому любые межтиповые операторы, предназначенные для применения с индексом, должны были привязываться непосредственно к классу оператора индекса. Хотя этот подход по-прежнему работает, он считается устаревшим, потому что он создаёт слишком много зависимостей для индекса, а также потому, что планировщик может выполнять межтиповые сравнения более эффективно, когда для обоих типов данных определены операторы в одном семействе.</para>
  </note>
 </sect2>

 <sect2 id="xindex-opclass-dependencies">
  <title>Системные зависимости от классов операторов</title>

   <indexterm><primary>оператор упорядочивания</primary></indexterm>

  <para><productname>&productname;</productname> использует классы операторов для наделения операторов такими свойствами, которые могут быть полезны не только для индексов. Поэтому классы операторов могут быть полезны, даже если вы не намерены индексировать столбцы со значениями определённого вами типа.</para>

  <para>В частности, это касается SQL-конструкций <literal>ORDER BY</literal> и <literal>DISTINCT</literal>, для которых требуется сравнивать и упорядочивать значения. Чтобы эти конструкции работали с определённым пользователем типом данных, <productname>&productname;</productname> задействует класс операторов B-дерева по умолчанию для этого типа. Член <quote>равно</quote> этого класса определяет, как система будет понимать равенство значений для <literal>GROUP BY</literal> и <literal>DISTINCT</literal>, а порядок сортировки, задаваемый классом операторов, определяет порядок <literal>ORDER BY</literal> по умолчанию.</para>

  <para>Сравнение массивов пользовательских типов также зависит от семантики, определённой классом операторов B-дерева по умолчанию.</para>

  <para>Если класс операторов B-дерева по умолчанию для типа данных не определён, система будет искать класс операторов хеша по умолчанию. Но так как этот вид класса поддерживает только равенство, на практике его достаточно только для проверки равенства массивов.</para>

  <para>Если для типа не определён класс операторов по умолчанию, попытавшись использовать эти конструкции SQL с данным типом, вы получите ошибку вида <quote>не удалось найти оператор сортировки</quote>.</para>

   <note>
    <para>До версии <productname>PostgreSQL</productname> 7.4, в операциях сортировки и группировки неявно использовались операторы с именами <literal>=</literal>, <literal>&lt;</literal> и <literal>&gt;</literal>. С новым подходом, опирающимся на классы операторов по умолчанию, система не делает никаких предположений о поведении операторов по их именам.</para>
   </note>

  <para>Также важно отметить, что оператор, указанный в семействе операторов хеширования, является кандидатом для применения при слиянии и агрегации по хешу, а также связанной оптимизации. В данном случае от семейства операторов зависит, какую функцию хеширования использовать.</para>
 </sect2>

 <sect2 id="xindex-ordering-ops">
  <title>Операторы упорядочивания</title>

  <para>Некоторые методы доступа индексов (в настоящее время только GiST) поддерживают концепцию <firstterm>операторов упорядочивания</firstterm>. Операторы, которые мы обсуждали до этого, были <firstterm>операторами поиска</firstterm>. Оператором поиска называется такой оператор, для которого можно выполнить поиск по индексу и найти все строки, удовлетворяющие условию <literal>WHERE</literal> <replaceable>индексированный_столбец</replaceable> <replaceable>оператор</replaceable> <replaceable>константа</replaceable>. Заметьте, что при этом ничего не говорится о порядке, в котором будут возвращены подходящие строки. Оператор упорядочивания, напротив, не ограничивает набор возвращаемых строк, но определяет их порядок. С таким оператором, просканировав индекс, можно получить строки в порядке, заданным указанием <literal>ORDER BY</literal> <replaceable>индексированный_столбец</replaceable> <replaceable>оператор</replaceable> <replaceable>константа</replaceable>. Такое определение объясняется тем, что оно поддерживает поиск ближайшего соседа, если этот оператор вычисляет расстояние. Например, запрос <programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting> находит десять ближайших к заданной точке мест. Индекс GiST по столбцу location может сделать это эффективно, так как <literal>&lt;-&gt;</literal> — это оператор упорядочивания.</para>

  <para>Тогда как операторы поиска должны возвращать булевские результаты, операторы упорядочивания обычно возвращают другой тип, например, float или numeric для расстояний. Этот тип, как правило, отличается от типа индексируемых данных. Чтобы избежать жёстко запрограммированных предположений о поведении различных типов данных, при объявлении оператора упорядочивания должно указываться семейство операторов B-дерева, определяющее порядок сортировки результирующего типа данных. Как было отмечено в предыдущем разделе, семейства операторов B-дерева определяют понятие упорядочивания для <productname>&productname;</productname>, так что такое объявление оказывается естественным. Так как оператор <literal>&lt;-&gt;</literal> для точек возвращает <type>float8</type>, его можно включить в команду создания класса операторов так: <programlisting><![CDATA[
OPERATOR 15    <-> (point, point) FOR ORDER BY float_ops
]]>
</programlisting> где <literal>float_ops</literal> — встроенное семейство операторов, включающее операции с <type>float8</type>. Это объявление означает, что индекс может возвращать строки в порядке увеличения значений оператора <literal>&lt;-&gt;</literal>.</para>
 </sect2>

 <sect2 id="xindex-opclass-features">
  <title>Особенности классов операторов</title>

  <para>Есть ещё две особенности классов операторов, которые мы до этого не обсуждали, в первую очередь потому, что они не востребованы для наиболее часто применяемых методов индексов.</para>

  <para>Обычно объявление оператора в качестве члена класса операторов (или семейства) означает, что метод индекса может получить точно набор строк, который удовлетворяет условию <literal>WHERE</literal> с этим оператором. Например, запрос: <programlisting>SELECT * FROM table WHERE integer_column &lt; 4;</programlisting> может быть удовлетворён в точности индексом-B-деревом по целочисленному столбцу. Но бывают случаи, когда индекс полезен как приблизительный указатель на соответствующие строки. Например, если индекс GiST хранит только прямоугольники, описанные вокруг геометрических объектов, он не может точно удовлетворить условие <literal>WHERE</literal>, которое проверяет пересечение не прямоугольных объектов, а например, многоугольников. Однако этот индекс можно применить, чтобы найти объекты, для которых описанные вокруг прямоугольники пересекаются с прямоугольником, описанным вокруг целевого объекта, а затем провести точную проверку пересечения только для найденных по индексу объектов. Если это имеет место, такой индекс называется <quote>неточным</quote> для оператора. Для реализации поиска по неточному индексу метод индекса возвращает флаг <firstterm>recheck</firstterm> (перепроверить), когда строка может действительно удовлетворять, а может не удовлетворять условию запроса. Затем исполнитель запроса перепроверяет полученную строку по исходному условию запроса и определяет, должна ли она выдаваться как действительно соответствующая ему. Этот подход работает, если индекс гарантированно выдаёт все требуемые строки плюс, возможно, дополнительные строки, которые можно исключить, вызвав первоначальный оператор. Методы индексов, поддерживающие неточный поиск (в настоящее время, GiST, SP-GiST и GIN), позволяют устанавливать флаг recheck опорным функциям отдельных классов операторов, так что по сути это особенность класса операторов.</para>

  <para>Вернёмся к ситуации, когда мы храним в индексе только прямоугольник, описанный вокруг сложного объекта, такого как многоугольник. В этом случае нет большого смысла хранить в элементе индекса весь многоугольник &mdash; мы можем с тем же успехом хранить более простой объект типа <type>box</type>. Это отклонение выражается указанием <literal>STORAGE</literal> в команде <command>CREATE OPERATOR CLASS</command>, которое записывается примерно так: <programlisting>CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;</programlisting> В настоящее время, только методы индексов GiST, GIN и BRIN позволяют задать в <literal>STORAGE</literal> тип, отличный от типа данных столбца. В GiST преобразованием данных, связанным с использованием <literal>STORAGE</literal>, должны заниматься опорные процедуры <function>compress</function> и <function>decompress</function>. В GIN тип <literal>STORAGE</literal> определяет тип значений <quote>ключа</quote>, который обычно отличается от типа индексируемого столбца &mdash; например, в классе операторов для столбцов с целочисленным массивом ключами могут быть просто целые числа. За извлечение ключей из индексированных значений в GIN отвечают опорные функции <function>extractValue</function> и <function>extractQuery</function>. BRIN похож на GIN: в нём тип <literal>STORAGE</literal> определяет тип хранимых обобщённых значений, а опорные процедуры классов операторов отвечают за правильное прочтение этих значений.</para>
 </sect2>

</sect1>
