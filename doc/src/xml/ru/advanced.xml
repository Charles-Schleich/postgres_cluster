<!-- doc/src/xml/advanced.xml -->

 <chapter id="tutorial-advanced">
  <title>Расширенные возможности</title>

  <sect1 id="tutorial-advanced-intro">
   <title>Введение</title>

   <para>В предыдущей главе мы изучили азы использования <acronym>SQL</acronym> для хранения и обработки данных в <productname>&productname;</productname>. Теперь мы обсудим более сложные возможности <acronym>SQL</acronym>, помогающие управлять данными и предотвратить их потерю или порчу. В конце главы мы рассмотрим некоторые расширения <productname>&productname;</productname>.</para>

   <para>В этой главе мы будем время от времени ссылаться на примеры, приведённые в <xref remap="6" linkend="tutorial-sql"/> и изменять или развивать их, поэтому будет полезно сначала прочитать предыдущую главу. Некоторые примеры этой главы также можно найти в файле <filename>advanced.sql</filename> в каталоге tutorial. Кроме того, этот файл содержит пример данных для загрузки (здесь она повторно не рассматривается). Если вы не знаете, как использовать этот файл, обратитесь к <xref remap="3" linkend="tutorial-sql-intro"/>.</para>
  </sect1>


  <sect1 id="tutorial-views">
   <title>Представления</title>

   <indexterm zone="tutorial-views"><primary>представление</primary></indexterm>

   <para>Вспомните запросы, с которыми мы имели дело в <xref remap="6" linkend="tutorial-join"/>. Предположим, что вас интересует составной список из погодных записей и координат городов, но вы не хотите каждый раз вводить весь этот запрос. Вы можете создать <firstterm>представление</firstterm> по данному запросу, фактически присвоить имя запросу, а затем обращаться к нему как к обычной таблице: <programlisting>CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;</programlisting></para>

   <para>Активное использование представлений &mdash; это ключевой аспект хорошего проектирования баз данных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые могут меняться по мере развития приложения, за надёжными интерфейсами.</para>

   <para>Представления можно использовать практически везде, где можно использовать обычные таблицы. И довольно часто представления создаются на базе других представлений.</para>
  </sect1>


  <sect1 id="tutorial-fk">
   <title>Внешние ключи</title>

   <indexterm zone="tutorial-fk"><primary>внешний ключ</primary></indexterm>

   <indexterm zone="tutorial-fk"><primary>ссылочная целостность</primary></indexterm>

   <para>Вспомните таблицы <classname>weather</classname> и <classname>cities</classname> из <xref remap="2" linkend="tutorial-sql"/>. Давайте рассмотрим следующую задачу: вы хотите добиться, чтобы никто не мог вставить в таблицу <classname>weather</classname> строки, для которых не находится соответствующая строка в таблице <classname>cities</classname>. Это называется обеспечением <firstterm>ссылочной целостности</firstterm> данных. В простых СУБД это пришлось бы реализовать (если это вообще возможно) так: сначала явно проверить, есть ли соответствующие записи в таблице <classname>cities</classname>, а затем отклонить или вставить новые записи в таблицу <classname>weather</classname>. Этот подход очень проблематичен и неудобен, поэтому всё это <productname>&productname;</productname> может сделать за вас.</para>

   <para>Новое объявление таблицы будет выглядеть так: <programlisting>CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);</programlisting> Теперь попробуйте вставить недопустимую запись: <programlisting>INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');</programlisting> <screen>
ОШИБКА:  INSERT или UPDATE в таблице "weather" нарушает ограничение внешнего
  ключа "weather_city_fkey"
ПОДРОБНОСТИ:  Ключ (city)=(Berkeley) отсутствует в таблице "cities".
</screen></para>

   <para>Поведение внешних ключей можно подстроить согласно требованиям вашего приложения. Мы не будем усложнять этот простой пример в данном введении, но вы можете обратиться за дополнительной информацией к <xref remap="3" linkend="ddl"/>. Правильно применяя внешние ключи, вы определённо создадите более качественные приложения, поэтому мы настоятельно рекомендуем изучить их.</para>
  </sect1>


  <sect1 id="tutorial-transactions">
   <title>Транзакции</title>

   <indexterm zone="tutorial-transactions"><primary>транзакция</primary></indexterm>

   <para><firstterm>Транзакции</firstterm> &mdash; это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объединяет последовательность действий в одну операцию "всё или ничего". Промежуточные состояния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.</para>

   <para>Например, рассмотрим базу данных банка, в которой содержится информация о счетах клиентов, а также общие суммы по отделениям банка. Предположим, что мы хотим перевести 100 долларов со счёта Алисы на счёт Боба. Простоты ради, соответствующие SQL-команды можно записать так: <programlisting>UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');</programlisting></para>

   <para>Точное содержание команд здесь не важно, важно лишь то, что для выполнения этой довольно простой операции потребовалось несколько отдельных действий. При этом с точки зрения банка необходимо, чтобы все эти действия выполнились вместе, либо не выполнились совсем. Если Боб получит 100 долларов, но они не будут списаны со счёта Алисы, объяснить это сбоем системы определённо не удастся. И наоборот, Алиса вряд ли будет довольна, если она переведёт деньги, а до Боба они не дойдут. Нам нужна гарантия, что если что-то помешает выполнить операцию до конца, ни одно из действий не оставит следа в базе данных. И мы получаем эту гарантию, объединяя действия в одну <firstterm>транзакцию</firstterm>. Говорят, что транзакция <firstterm>атомарна</firstterm>: с точки зрения других транзакций она либо выполняется и фиксируется полностью, либо не фиксируется совсем.</para>

   <para>Нам также нужна гарантия, что после завершения и подтверждения транзакции системой баз данных, её результаты в самом деле сохраняются и не будут потеряны, даже если вскоре произойдёт авария. Например, если мы списали сумму и выдали её Бобу, мы должны исключить возможность того, что сумма на его счёте восстановится, как только он выйдет за двери банка. Транзакционная база данных гарантирует, что все изменения записываются в постоянное хранилище (например, на диск) до того, как транзакция будет считаться завершённой.</para>

   <para>Другая важная характеристика транзакционных баз данных тесно связана с атомарностью изменений: когда одновременно выполняется множество транзакций, каждая из них не видит незавершённые изменения, произведённые другими. Например, если одна транзакция подсчитывает баланс по отделениям, будет неправильно, если она посчитает расход в отделении Алисы, но не учтёт приход в отделении Боба, или наоборот. Поэтому свойство транзакций "всё или ничего" должно определять не только, как изменения сохраняются в базе данных, но и как они видны в процессе работы. Изменения, производимые открытой транзакцией, невидимы для других транзакций, пока она не будет завершена, а затем они становятся видны все сразу.</para>

   <para>В <productname>&productname;</productname> транзакция определяется набором SQL-команд, окружённым командами <command>BEGIN</command> и <command>COMMIT</command>. Таким образом, наша банковская транзакция должна была бы выглядеть так: <programlisting>BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- ...
COMMIT;</programlisting></para>

   <para>Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её изменения (например, потому что оказалось, что баланс Алисы стал отрицательным), мы можем выполнить команду <command>ROLLBACK</command> вместо <command>COMMIT</command>, и все наши изменения будут отменены.</para>

   <para><productname>&productname;</productname> на самом деле отрабатывает каждый SQL-оператор как транзакцию. Если вы не вставите команду <command>BEGIN</command>, то каждый отдельный оператор будет неявно окружён командами <command>BEGIN</command> и <command>COMMIT</command> (в случае успешного завершения). Группу операторов, окружённых командами <command>BEGIN</command> и <command>COMMIT</command> иногда называют <firstterm>блоком транзакции</firstterm>.</para>

   <note>
    <para>Некоторые клиентские библиотеки добавляют команды <command>BEGIN</command> и <command>COMMIT</command> автоматически и неявно создают за вас блоки транзакций. Подробнее об этом вы можете узнать в документации интересующего вас интерфейса.</para>
   </note>

   <para>Операторами в транзакции можно также управлять на более детальном уровне, используя <firstterm>точки сохранения</firstterm>. Точки сохранения позволяют выборочно отменять некоторые части транзакции и фиксировать все остальные. Определив точку сохранения с помощью <command>SAVEPOINT</command>, при необходимости вы можете вернуться к ней с помощью команды <command>ROLLBACK TO</command>. Все изменения в базе данных, произошедшие после точки сохранения и до момента отката, отменяются, но изменения, произведённые ранее, сохраняются.</para>

   <para>Когда вы возвращаетесь к точке сохранения, она продолжает существовать, так что вы можете откатываться к ней несколько раз. С другой стороны, если вы уверены, что вам не придётся откатываться к определённой точке сохранения, её можно удалить, чтобы система высвободила ресурсы. Помните, что при удалении или откате к точке сохранения все точки сохранения, определённые после неё, автоматически уничтожаются.</para>

   <para>Всё это происходит в блоке транзакции, так что в других сеансах работы с базой данных этого не видно. Совершённые действия становятся видны для других сеансов все сразу, только когда вы фиксируете транзакцию, а отменённые действия не видны вообще никогда.</para>

   <para>Вернувшись к банковской базе данных, предположим, что мы списываем 100 долларов со счёта Алисы, добавляем их на счёт Боба, и вдруг оказывается, что деньги нужно было перевести Уолли. В данном случае мы можем применить точки сохранения: <programlisting>BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- ошибочное действие... забыть его и использовать счёт Уолли
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;</programlisting></para>

   <para>Этот пример, конечно, несколько надуман, но он показывает, как можно управлять выполнением команд в блоке транзакций, используя точки сохранения. Более того, <command>ROLLBACK TO</command> &mdash; это единственный способ вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии из-за ошибки системы, не считая возможности полностью отменить её и начать снова.</para>

  </sect1>


  <sect1 id="tutorial-window">
   <title>Оконные функции</title>

   <indexterm zone="tutorial-window"><primary>оконная функция</primary></indexterm>

   <para><firstterm>Оконная функция</firstterm> выполняет вычисления для набора строк, некоторым образом связанных с текущей строкой. Можно сравнить её с агрегатной функцией, но, в отличие от обычной агрегатной функции, при использовании оконной функции несколько строк не группируются в одну, а продолжают существовать отдельно. Внутри же, оконная функция, как и агрегатная, может обращаться не только к текущей строке результата запроса.</para>

   <para>Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его отдела: <programlisting>SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)
  FROM empsalary;</programlisting> <screen>
  depname  | empno | salary |          avg          
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</screen> Первые три столбца извлекаются непосредственно из таблицы <structname>empsalary</structname>, при этом для каждой строки таблицы есть строка результата. В четвёртом столбце оказалось среднее значение, вычисленное по всем строкам, имеющим то же значение <structfield>depname</structfield>, что и текущая строка. (Фактически среднее вычисляет та же функция <function>avg</function>, которую мы знаем как агрегатную, но предложение <literal>OVER</literal> превращает её в оконную, так что она обрабатывает лишь заданный набор строк.)</para>

   <para>Вызов оконной функции всегда содержит предложение <literal>OVER</literal>, следующее за названием и аргументами оконной функции. Это синтаксически отличает её от обычной или агрегатной функции. Предложение <literal>OVER</literal> определяет, как именно нужно разделить строки запроса для обработки оконной функцией. Предложение <literal>PARTITION BY</literal>, дополняющее <literal>OVER</literal>, указывает, что строки нужно разделить по группам или разделам, объединяя одинаковые значения выражений <literal>PARTITION BY</literal>. Оконная функция вычисляется по строкам, попадающим в один раздел с текущей строкой.</para>

   <para>Вы можете также определять порядок, в котором строки будут обрабатываться оконными функциями, используя <literal>ORDER BY</literal> в <literal>OVER</literal>. (Порядок <literal>ORDER BY</literal> для окна может даже не совпадать с порядком, в котором выводятся строки.) Например: <programlisting>SELECT depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;</programlisting><screen>
  depname  | empno | salary | rank 
-----------+-------+--------+------
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</screen> Как показано здесь, функция <function>rank</function> выдаёт порядковый номер в разделе текущей строки для каждого уникального значения, по которому выполняет сортировку предложение <literal>ORDER BY</literal>. У функции <function>rank</function> нет параметров, так как её поведение полностью определяется предложением <literal>OVER</literal>.</para>

   <para>Строки, обрабатываемые оконной функцией, представляют собой <quote>виртуальные таблицы</quote>, созданные из предложения <literal>FROM</literal> и затем прошедшие через фильтрацию и группировку <literal>WHERE</literal> и <literal>GROUP BY</literal> и, возможно, условие <literal>HAVING</literal>. Например, строка, отфильтрованная из-за нарушения условия <literal>WHERE</literal>, не будет видна для оконных функций. Запрос может содержать несколько оконных функций, разделяющих данные по-разному с помощью разных предложений <literal>OVER</literal>, но все они будут обрабатывать один и тот же набор строк этой виртуальной таблицы.</para>

   <para>Мы уже видели, что <literal>ORDER BY</literal> можно опустить, если порядок строк не важен. Также возможно опустить <literal>PARTITION BY</literal>, в этом случае будет только один раздел, содержащий все строки.</para>

   <para>Есть ещё одно важное понятие, связанное с оконными функциями: для каждой строки существует набор строк в её разделе, называемый <firstterm>рамкой окна</firstterm>. По умолчанию, с указанием <literal>ORDER BY</literal> рамка состоит из всех строк от начала раздела до текущей строки и строк, равных текущей по значению выражения <literal>ORDER BY</literal>. Без <literal>ORDER BY</literal> рамка по умолчанию состоит из всех строк раздела. <footnote>
      <para>Рамки окна можно определять и другими способами, но в этом введении они не рассматриваются. Узнать о них подробнее вы можете в <xref remap="6" linkend="syntax-window-functions"/>.</para>
     </footnote> Посмотрите на пример использования <function>sum</function>:</para>

<programlisting>SELECT salary, sum(salary) OVER () FROM empsalary;</programlisting>

<screen> salary |  sum  
--------+-------
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)</screen>

   <para>Так как в этом примере нет указания <literal>ORDER BY</literal> в предложении <literal>OVER</literal>, рамка окна содержит все строки раздела, а он, в свою очередь, без предложения <literal>PARTITION BY</literal> включает все строки таблицы; другими словами, сумма вычисляется по всей таблице и мы получаем один результат для каждой строки результата. Но если мы добавим <literal>ORDER BY</literal>, мы получим совсем другие результаты:</para>

<programlisting>SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;</programlisting>

<screen> salary |  sum  
--------+-------
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)</screen>

   <para>Здесь в сумме накапливаются зарплаты от первой (самой низкой) до текущей, включая повторяющиеся текущие значения (обратите внимание на результат в строках с одинаковой зарплатой).</para>

   <para>Оконные функции разрешается использовать в запросе только в списке <literal>SELECT</literal> и предложении <literal>ORDER BY</literal>. Во всех остальных предложениях, включая <literal>GROUP BY</literal>, <literal>HAVING</literal> и <literal>WHERE</literal>, они запрещены. Это объясняется тем, что логически они выполняются после обычных агрегатных функций, а значит агрегатную функцию можно вызвать из оконной, но не наоборот.</para>

   <para>Если вам нужно отфильтровать или сгруппировать строки после вычисления оконных функций, вы можете использовать вложенный запрос. Например: <programlisting>SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
    rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
   FROM empsalary
  ) AS ss
WHERE pos &lt; 3;</programlisting> Данный запрос покажет только те строки внутреннего запроса, у которых <literal>rank</literal> (порядковый номер) меньше 3.</para>

   <para>Когда в запросе вычисляются несколько оконных функций для одинаково определённых окон, конечно можно написать для каждой из них отдельное предложение <literal>OVER</literal>, но при этом оно будет дублироваться, что неизбежно будет провоцировать ошибки. Поэтому лучше определение окна выделить в предложение <literal>WINDOW</literal>, а затем ссылаться на него в <literal>OVER</literal>. Например: <programlisting>SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);</programlisting></para>

   <para>Подробнее об оконных функциях можно узнать в <xref remap="6" linkend="syntax-window-functions"/>, <xref remap="6" linkend="functions-window"/>, <xref remap="6" linkend="queries-window"/> и в справке <xref linkend="sql-select"/>.</para>
  </sect1>


  <sect1 id="tutorial-inheritance">
   <title>Наследование</title>

   <indexterm zone="tutorial-inheritance"><primary>наследование</primary></indexterm>

   <para>Наследование &mdash; это концепция, взятая из объектно-ориентированных баз данных. Она открывает множество интересных возможностей при проектировании баз данных.</para>

   <para>Давайте создадим две таблицы: <classname>cities</classname> (города) и <classname>capitals</classname> (столицы штатов). Естественно, столицы штатов также являются городами, поэтому нам нужно явным образом добавлять их в результат, когда мы хотим просмотреть все города. Если вы проявите смекалку, вы можете предложить, например, такое решение: <programlisting>CREATE TABLE capitals (
  name       text,
  population real,
  altitude   int,    -- (высота в футах)
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
  altitude   int     -- (высота в футах)
);

CREATE VIEW cities AS
  SELECT name, population, altitude FROM capitals
    UNION
  SELECT name, population, altitude FROM non_capitals;</programlisting> Оно может устраивать, пока мы извлекаем данные, но если нам потребуется изменить несколько строк, это будет выглядеть некрасиво.</para>

   <para>Поэтому есть лучшее решение: <programlisting>CREATE TABLE cities (
  name       text,
  population real,
  altitude   int     -- (высота в футах)
);

CREATE TABLE capitals (
  state      char(2)
) INHERITS (cities);</programlisting></para>

   <para>В данном случае строка таблицы <classname>capitals</classname> <firstterm>наследует</firstterm> все столбцы (<structfield>name</structfield>, <structfield>population</structfield> и <structfield>altitude</structfield>) от <firstterm>родительской таблицы</firstterm> <classname>cities</classname>. Столбец <structfield>name</structfield> имеет тип <type>text</type>, собственный тип <productname>&productname;</productname> для текстовых строк переменной длины. А в таблицу столиц добавлен дополнительный столбец <structfield>state</structfield>, в котором будет указан штат. В <productname>&productname;</productname> таблица может наследоваться от нуля или нескольких других таблиц.</para>

   <para>Например, следующий запрос выведет названия всех городов, включая столицы, находящихся выше 500 футов над уровнем моря: <programlisting>SELECT name, altitude
  FROM cities
  WHERE altitude &gt; 500;</programlisting> Результат его выполнения: <screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
(3 rows)
</screen></para>

   <para>А следующий запрос находит все города, которые не являются столицами штатов, но также находятся выше 500 футов: <programlisting>SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;</programlisting> <screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
(2 rows)
</screen></para>

   <para>Здесь слово <literal>ONLY</literal> перед названием таблицы <literal>cities</literal> указывает, что запрос следует выполнять только для строк таблицы <classname>cities</classname>, не включая таблицы, унаследованные от <classname>cities</classname>. Многие операторы, которые мы уже обсудили &mdash; <command>SELECT</command>, <command>UPDATE</command> и <command>DELETE</command> &mdash; поддерживают указание <literal>ONLY</literal>.</para>

   <note>
    <para>Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями уникальности и внешними ключами, что ограничивает его применимость. Подробнее это описывается в <xref remap="6" linkend="ddl-inherit"/>.</para>
   </note>
  </sect1>


  <sect1 id="tutorial-conclusion">
   <title>Заключение</title>

   <para><productname>&productname;</productname> имеет множество возможностей, не затронутых в этом кратком введении, рассчитанном на начинающих пользователей <acronym>SQL</acronym>. Эти возможности будут рассмотрены в деталях в продолжении книги.</para>

   <para>Если вам необходима дополнительная вводная информация, посетите <ulink url="https://www.postgresql.org">сайт PostgreSQL</ulink>, там вы найдёте ссылки на другие ресурсы.</para>
  </sect1>
 </chapter>
