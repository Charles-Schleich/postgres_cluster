<!-- doc/src/xml/arch-dev.xml -->

 <chapter id="overview">
  <title>Обзор внутреннего устройства &productname;</title>

  <note>
   <title>Автор</title>
   <para>Основой этой главы послужил материал дипломной работы <xref linkend="sim98"/>, написанной Стефаном Симковичем (Stefan Simkovics) в Венском техническом университете под руководством профессора Георга Готлоба (Georg Gottlob) и его ассистентки Катрин Сейр (Katrin Seyr).</para>
  </note>

  <para>В этой главе даётся обзор внутренней организации сервера <productname>&productname;</productname>. Прочитав следующие разделы, вы получите представление о том, как обрабатывается запрос. Здесь мы не стремились подробно описывать внутренние операции <productname>&productname;</productname>, так как это заняло бы слишком большой объём. Основная цель этой главы другая — помочь читателю понять общую последовательность действий, выполняемых сервером с момента получения запроса до момента выдачи результатов клиенту.</para>

  <sect1 id="query-path">
   <title>Путь запроса</title>

   <para>Ниже мы кратко опишем этапы, которые проходит запрос для получения результата.</para>

   <procedure>
    <step>
     <para>Прикладная программа устанавливает подключение к серверу <productname>&productname;</productname>. Эта программа передаёт запрос на сервер и ждёт от него результатов.</para>
    </step>

    <step>
     <para>На <firstterm>этапе разбора запроса</firstterm> сервер выполняет синтаксическую проверку запроса, переданного прикладной программой, и создаёт <firstterm>дерево запроса</firstterm>.</para>
    </step>

    <step>
     <para><firstterm>Система правил</firstterm> принимает дерево запроса, созданное на стадии разбора, и ищет в <firstterm>системных каталогах</firstterm> <firstterm>правила</firstterm> для применения к этому дереву. Обнаружив подходящие правила, она выполняет преобразования, заданные в <firstterm>теле правил</firstterm>.</para>

     <para>Одно из применений системы правил заключается в реализации <firstterm>представлений</firstterm>. Когда выполняется запрос к представлению (т. е. <firstterm>виртуальной таблице</firstterm>), система правил преобразует запрос пользователя в запрос, обращающийся не к представлению, а к <firstterm>базовым таблицам</firstterm> из <firstterm>определения представления</firstterm>.</para>
    </step>

    <step>
     <para><firstterm>Планировщик/оптимизатор</firstterm> принимает дерево запроса (возможно, переписанное) и создаёт <firstterm>план запроса</firstterm>, который будет передан <firstterm>исполнителю</firstterm>.</para>

     <para>Он выбирает план, сначала рассматривая все возможные варианты получения одного и того же результата. Например, если для обрабатываемого отношения создан индекс, прочитать отношение можно двумя способами. Во-первых, можно выполнить простое последовательное сканирование, а во-вторых, можно использовать индекс. Затем оценивается стоимость каждого варианта и выбирается самый дешёвый. Затем выбранный вариант разворачивается в полноценный план, который сможет использовать исполнитель.</para>
    </step>

    <step>
     <para>Исполнитель рекурсивно проходит по <firstterm>дереву плана</firstterm> и получает строки тем способом, который указан в плане. Он сканирует отношения, обращаясь к <firstterm>системе хранения</firstterm>, выполняет <firstterm>сортировку</firstterm> и <firstterm>соединения</firstterm>, вычисляет <firstterm>условия фильтра</firstterm> и, наконец, возвращает полученные строки.</para>
    </step>
   </procedure>

   <para>В следующих разделах мы более подробно рассмотрим каждый из этих этапов, чтобы дать представление о внутренних механизмах и структурах данных <productname>&productname;</productname>.</para>
  </sect1>

  <sect1 id="connect-estab">
   <title>Как устанавливаются соединения</title>

   <para><productname>&productname;</productname> реализует простую клиент-серверную модель по схеме <quote>процесс для пользователя</quote>. В такой схеме один <firstterm>клиентский процесс</firstterm> подключается к одному отдельному <firstterm>серверному процессу</firstterm>. Так как мы не знаем заранее, сколько подключений будет, нам нужен <firstterm>главный процесс</firstterm>, который будет запускать новый процесс при каждом запросе подключения. Главный процесс называется <literal>postgres</literal> и принимает входящие подключения в заданном порту TCP/IP. Получив запрос на подключение, процесс <literal>postgres</literal> порождает новый серверный процесс. Серверные задачи взаимодействуют между собой через <firstterm>семафоры</firstterm> и <firstterm>разделяемую память</firstterm>, чтобы обеспечить целостность данных при одновременном обращении к ним.</para>

   <para>Клиентским процессом может быть любая программа, которая понимает протокол <productname>&productname;</productname>, описанный в <xref remap="6" linkend="protocol"/>. Многие клиенты базируются на библиотеке <application>libpq</application> для языка C, но есть и другие независимые реализации этого протокола, например, драйвер <application>JDBC</application> для Java.</para>

   <para>Установив подключение, клиентский процесс может передать запрос серверу. Запрос передаётся в обычном текстовом виде, клиент не занимается его анализом. Сервер разбирает запрос, строит <firstterm>план выполнения</firstterm>, выполняет его и возвращает полученные строки клиенту, передавая их через установленное подключение.</para>
  </sect1>

  <sect1 id="parser-stage">
   <title>Этап разбора</title>

   <para><firstterm>Этап разбора</firstterm> разделяется на две части: <itemizedlist>
     <listitem>
      <para><firstterm>Разбор</firstterm>, алгоритм которого описан в <filename>gram.y</filename> и <filename>scan.l</filename>, а программный код генерируется инструментами Unix <application>bison</application> и <application>flex</application>.</para>
     </listitem>
     <listitem>
      <para><firstterm>Преобразование</firstterm>, в процессе которого модифицируются и дополняются структуры данных, полученные после разбора запроса.</para>
     </listitem>
    </itemizedlist></para>

   <sect2>
    <title>Разбор</title>

    <para>При разборе проверяется сначала синтаксис строки запроса (поступающей в виде неструктурированного текста). Если он правильный, строится <firstterm>дерево запроса</firstterm> и передаётся дальше, в противном случае возвращается ошибка. Лексический и синтаксический анализ реализован с применением хорошо известных средств Unix <application>bison</application> и <application>flex</application>.</para>

    <para><firstterm>Лексическая структура</firstterm> определяется в файле <filename>scan.l</filename> и описывает <firstterm>идентификаторы</firstterm>, <firstterm>ключевые слова SQL</firstterm> и т. д. Для каждого найденного ключевого слова или идентификатора генерируется <firstterm>символ языка</firstterm>, который затем передаётся синтаксическому анализатору.</para>

    <para>Синтаксис языка определён в файле <filename>gram.y</filename> в виде набора <firstterm>грамматических правил</firstterm> и <firstterm>действий</firstterm>, которые должны выполняться при срабатывании правил. Для построения дерева разбора используется код действий (это действительно код на C).</para>

    <para>Файл <filename>scan.l</filename> преобразуется в программу на C <filename>scan.c</filename> с помощью <application>flex</application>, а <filename>gram.y</filename> — в <filename>gram.c</filename> с помощью <application>bison</application>. После этих преобразований исполняемый код анализатора создаётся обычным компилятором C. Никогда не вносите коррективы в сгенерированные файлы C, так как они будут перезаписаны при следующем вызове <application>flex</application> или <application>bison</application>. <note>
      <para>Упомянутые преобразования и компиляция обычно производятся автоматически сборочными файлами <firstterm>Makefile</firstterm>, поставляемыми в составе дистрибутива <productname>&productname;</productname>.</para>
     </note></para>

    <para>Подробное описание <application>bison</application> и грамматических правил в <filename>gram.y</filename> выходит за рамки данной главы. Узнать больше о <application>flex</application> и <application>bison</application> можно из книг и документации. Изучение грамматики, описанной в <filename>gram.y</filename>, следует начать со знакомства с <application>bison</application>, иначе будет трудно понять, что там происходит.</para>

   </sect2>

   <sect2>
     <title>Преобразование</title>

    <para>На этой стадии дерево разбора создаётся только с фиксированными знаниями о синтаксической структуре SQL. При его создании не просматриваются системные каталоги, что не даёт возможность понять конкретную семантику запрошенной операции. После этого выполняется <firstterm>процедура преобразования</firstterm>, которая принимает дерево разбора от анализатора и выполняет семантический анализ, необходимый для понимания, к каким именно таблицам, функциям и операторам обращается запрос. Структура данных, которая создаётся для представления этой информации, называется <firstterm>деревом запроса</firstterm>.</para>

    <para>Синтетический разбор отделён от семантического анализа, потому что обращаться к системным каталогам можно только внутри транзакции, а начинать транзакцию сразу после получения строки с запросом нежелательно. Синтетического разбора достаточно, чтобы распознать команды управления транзакциями (<command>BEGIN</command>, <command>ROLLBACK</command> и т. д.), поэтому их можно выполнить без дальнейшего анализа. Убедившись, что мы имеем дело с собственно запросом (например, <command>SELECT</command> или <command>UPDATE</command>), можно начинать транзакцию, если она ещё не начата. Только после этого можно переходить к процедуре преобразования.</para>

    <para>Дерево запроса, создаваемое процедурой преобразования, по структуре во многом похоже на дерево разбора, но отличается во многих деталях. Например, узел <structname>FuncCall</structname> в дереве разбора представляет то, что по синтаксису похоже на вызов функции. Этот узел может быть преобразован в узел <structname>FuncExpr</structname> или <structname>Aggref</structname> в зависимости от того, какой (обычной или агрегатной) окажется функция с заданным именем. Кроме того, в дерево запроса добавляется информация о фактических типах данных столбцов и результатов выражений.</para>
   </sect2>
  </sect1>

  <sect1 id="rule-system">
   <title>Система правил <productname>&productname;</productname></title>

   <para><productname>&productname;</productname> поддерживает мощную <firstterm>систему правил</firstterm> для создания <firstterm>представлений</firstterm> и возможности <firstterm>изменения представлений</firstterm>. Система правил <productname>&productname;</productname> претерпела две реализации: <itemizedlist>
     <listitem>
      <para>Первый вариант производил обработку на <firstterm>уровне строк</firstterm> и был внедрён глубоко в <firstterm>исполнителе</firstterm>. Этот обработчик правил вызывался при обращении к каждой отдельной строке. Эта реализация была ликвидирована в 1995 г., когда последний официальный выпуск <productname>Berkeley Postgres</productname> превратился в <productname>Postgres95</productname>.</para>
     </listitem>

     <listitem>
      <para>Во втором воплощении системы правил применили так называемое <firstterm>переписывание запроса</firstterm>. <firstterm>Система переписывания</firstterm> реализована в механизме, внедрённом между <firstterm>анализатором</firstterm> и <firstterm>планировщиком/оптимизатором</firstterm>. Этот механизм работает и сегодня.</para>
     </listitem>
    </itemizedlist></para>

   <para>Механизм переписывания запросов подробно обсуждается в <xref remap="6" linkend="rules"/>, так что здесь мы его не рассматриваем. Мы только отметим, что и на входе, и на выходе у него деревья запросов, то есть представление или уровень семантической детализации он не меняет. Переписывание запроса можно считать формой расширения макросов.</para>

  </sect1>

  <sect1 id="planner-optimizer">
   <title>Планировщик/оптимизатор</title>

   <para>Задача <firstterm>планировщика/оптимизатора</firstterm> — построить наилучший план выполнения. Определённый SQL-запрос (а значит, и дерево запроса) на самом деле можно выполнить самыми разными способами, при этом получая одни и те же результаты. Если это не требует больших вычислений, оптимизатор запросов будет перебирать все возможные варианты планов, чтобы в итоге выбрать тот, который должен выполниться быстрее остальных.</para>

   <note>
    <para>В некоторых ситуациях рассмотрение всех возможных вариантов выполнения запросов занимает слишком много времени и памяти. В частности, это имеет место при выполнении запросов с большим количеством операций соединения. Поэтому, чтобы выбрать разумный (но не обязательно наилучший) план запроса за приемлемое время, <productname>&productname;</productname> использует <firstterm>генетический оптимизатор запросов</firstterm> (см. <xref remap="4" linkend="geqo"/>), когда количество соединений превышает некоторый предел (см. <xref remap="4" linkend="guc-geqo-threshold"/>).</para>
   </note>

   <para>Процедура поиска лучшего плана на самом деле работает со структурами данных, называемыми <firstterm>путями</firstterm>, которые представляют собой упрощённые схемы планов, содержащие минимум информации, необходимый планировщику для принятия решений. Когда наиболее выгодный план выбран, строится полноценное <firstterm>дерево плана</firstterm>, которое и передаётся исполнителю. Оно описывает желаемый план выполнения достаточно подробно, чтобы исполнитель мог обработать его. В продолжении этого раздела мы будем считать, что планы и пути по сути одно и то же.</para>

   <sect2>
    <title>Выработка возможных планов</title>

    <para>Сначала планировщик/оптимизатор вырабатывает планы для сканирования каждого отдельного отношения (таблицы), используемого в запросе. Множество возможных планов определяется в зависимости от наличия индексов в каждом отношении. Произвести последовательное сканирование отношения можно в любом случае, так что план последовательного сканирования создаётся всегда. Предположим, что для отношения создан индекс (например, индекс-B-дерево) и запрос содержит ограничение <literal>отношение.атрибут ОПЕР константа</literal>. Если окажется, что <literal>отношение.атрибут</literal> совпадает с ключом индекса-B-дерева и <literal>ОПЕР</literal> — один из операторов, входящих в <firstterm>класс операторов</firstterm> индекса, создаётся ещё один план, c использованием индекса-B-дерева для чтения отношения. Если находятся другие индексы, ключи которых соответствуют ограничениям запроса, могут добавиться и другие планы. Планы сканирования индекса также создаются для индексов, если их порядок сортировки соответствует предложению <literal>ORDER BY</literal> (если оно есть), или этот порядок может быть полезен для соединения слиянием (см. ниже).</para>

    <para>Если в запросе требуется соединить два или несколько отношений, после того, как будут определены все подходящие планы сканирования отдельных отношений, рассматриваются планы соединения. При этом возможны три стратегии соединения: <itemizedlist>
      <listitem>
       <para><firstterm>соединение с вложенным циклом</firstterm>: Правое отношение сканируется один раз для каждой строки, найденной в левом отношении. Эту стратегию легко реализовать, но она может быть очень трудоёмкой. (Однако, если правое отношение можно сканировать по индексу, эта стратегия может быть удачной. Тогда значения из текущей строки левого отношения могут использоваться как ключи для сканирования по индексу справа.)</para>
      </listitem>

      <listitem>
       <para><firstterm>соединение слиянием</firstterm>: Каждое отношение сортируется по атрибутам соединения до начала соединения. Затем два отношения сканируются параллельно и соответствующие строки, объединяясь, формируют строки соединения. Этот тип соединения более привлекательный, так как каждое отношение сканируется только один раз. Требуемый порядок сортировки можно получить, либо добавив явный этап сортировки, либо просканировав отношение в нужном порядке, используя индекс по ключу соединения.</para>
      </listitem>

      <listitem>
       <para><firstterm>соединение по хешу</firstterm>: сначала сканируется правое отношение и формируется хеш-таблица, ключ в которой вычисляется по атрибутам соединения. Затем сканируется левое отношение и по тем же атрибутам в каждой строке вычисляется ключ для поиска в этой хеш-таблице соответствующих строк справа.</para>
      </listitem>
     </itemizedlist></para>

    <para>Когда в запросе задействованы более двух отношений, окончательный результат должен быть получен из дерева с узлами соединения, имеющими по два входа. Планировщик рассматривает все возможные последовательности соединения и выбирает самую выгодную.</para>

    <para>Если число задействованных в запросе отношений меньше <xref linkend="guc-geqo-threshold"/>, для поиска оптимальной последовательности соединений производится практически полный перебор. Планировщик отдаёт предпочтение соединениям между двумя отношениями, для которых есть соответствующее предложение соединения в условии <literal>WHERE</literal> (то есть, для которых находится ограничение вида <literal>where табл1.атр1=табл2.атр2</literal>). Пары соединения без подобного предложения рассматриваются, только если нет другого выбора, то есть когда для определённого отношения не находятся предложения соединения с каким-либо другим отношением. Планировщик рассматривает все возможные планы для каждой пары соединения и выбирает самый выгодный из них (по его оценке).</para>

    <para>Если <varname>geqo_threshold</varname> превышается, последовательность соединений выбирается эвристическим путём, как описано в <xref remap="6" linkend="geqo"/>. В остальном процесс планирования тот же.</para>

    <para>Законченное дерево плана содержит узлы сканирования по индексу или последовательного сканирования базовых отношений, плюс узлы соединения с вложенным циклом, соединения слиянием или соединения по хешу (если требуется), плюс, возможно, узлы дополнительных действий, например, сортировки или вычисления агрегатных функций. Большинство из этих узлов могут дополнительно производить <firstterm>отбор</firstterm> (отбрасывать строки, не удовлетворяющие заданному логическому условию) и <firstterm>расчёты</firstterm> (вычислять производный набор столбцов по значениям заданных столбцов, то есть вычислять скалярные выражения). Одна из задач планировщика — добавить условия отбора из предложения <literal>WHERE</literal> и вычисления требуемых выходных выражений к наиболее подходящим узлам дерева плана.</para>
   </sect2>
  </sect1>

  <sect1 id="executor">
   <title>Исполнитель</title>

   <para><firstterm>Исполнитель</firstterm> принимает план, созданный планировщиком/исполнителем и обрабатывает его рекурсивно, чтобы получить требуемый набор строк. Обработка выполняется по конвейеру, с получением данных по требованию. При вызове любого узла плана он должен выдать очередную строку, либо сообщить, что выдача строк завершена.</para>

   <para>В качестве более конкретного примера, давайте предположим, что верхним узлом плана оказался узел <literal>MergeJoin</literal>. Для того чтобы выполнить какое-либо соединение, необходимо выбрать две строки (одну из каждого вложенного плана). Поэтому исполнитель рекурсивно вызывает себя для обработки вложенных планов (он начинает с плана <literal>левого дерева</literal>). Новый верхний узел (верхний узел левого вложенного плана) может быть, например, узлом <literal>Sort</literal>, и тогда для получения входной строки снова требуется рекурсия. Дочерним узлом <literal>Sort</literal> может быть узел <literal>SeqScan</literal>, представляющий собственно чтение таблицы. В результате выполнения этого узла исполнитель выбирает одну строку из таблицы и возвращает её вызывающему узлу. Узел <literal>Sort</literal>, в свою очередь, будет продолжать вызывать дочерний узел, пока не получит все строки для сортировки. Когда строки закончатся (дочерний узел сообщит об этом, возвратив NULL вместо строки), узел <literal>Sort</literal> выполнит сортировку, и наконец сможет выдать свою первую строку, а именно строку первую по порядку сортировки. Остальные строки будут сохраняться в нём, чтобы он мог выдавать их по порядку при последующих вызовах.</para>

   <para>Узел <literal>MergeJoin</literal> подобным образом затребует первую строку и у вложенного плана справа. Затем он сравнивает две строки и определяет, можно ли их соединить; если да, он возвращает соединённую строки вызывающему узлу. При следующем вызове, или немедленно, если он не может соединить текущую пару поступивших строк, он переходит к следующей строке в одном отношении или в другом (в зависимости от результата сравнения) и снова проверяет соответствие. В конце концов, данные в одном или другом вложенном плане заканчиваются и узел <literal>MergeJoin</literal> возвращает NULL, показывая тем самым, что другие строки соединения получить нельзя.</para>

   <para>Сложные запросы могут содержать много уровней вложенности узлов плана, но общий подход тот же: каждый узел вычисляет и возвращает следующую полученную строку при очередном вызове. Каждый узел также должен производить отбор и расчёты, которые были назначены ему планировщиком.</para>

   <para>Механизм исполнителя применяется для обработки всех четырёх основных типов SQL-запросов: <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</command>. С <command>SELECT</command> код исполнителя верхнего уровня должен только выдать клиенту все строки, полученные от дерева плана запроса. С <command>INSERT</command> все полученные строки вставляются в целевую таблицу <command>INSERT</command>. Эта операция выполняется в специальном узле на верхнем уровне плана запроса, называемом <literal>ModifyTable</literal>. (Простая команда <command>INSERT ... VALUES</command> создаёт простейшее дерево плана, состоящее из одного узла <literal>Result</literal>, который вычисляет одну строку результата, и узла <literal>ModifyTable</literal> над ним, который осуществляет добавление. Но с <command>INSERT ... SELECT</command> могут быть востребованы все возможности механизма исполнителя.) С <command>UPDATE</command> планировщик делает так, чтобы каждая вычисленная строка включала значения всех изменённых столбцов плюс <firstterm>TID</firstterm> (Tuple ID, идентификатор кортежа) исходной целевой строки; эти данные подаются в узел <literal>ModifyTable</literal>, который использует эту информацию, чтобы создать новую изменённую строку и пометить старую строку как удалённую. С <command>DELETE</command> план фактически возвращает только один столбец, TID, а узел <literal>ModifyTable</literal> использует значение TID, чтобы найти каждую целевую строку и пометить её как удалённую.</para>

  </sect1>

 </chapter>
