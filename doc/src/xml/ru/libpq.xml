<!-- doc/src/xml/libpq.xml -->

<chapter id="libpq">
 <title><application>libpq</application> — библиотека для языка C</title>

 <indexterm zone="libpq"><primary>libpq</primary></indexterm>

 <indexterm zone="libpq"><primary>C</primary></indexterm>

 <para><application>libpq</application> — это интерфейс <productname>&productname;</productname> для программирования приложений на языке <acronym>C</acronym>. Библиотека <application>libpq</application> содержит набор функций, используя которые клиентские программы могут передавать запросы серверу <productname>&productname;</productname> и принимать результаты этих запросов.</para>

 <para><application>libpq</application> также является базовым механизмом для нескольких других прикладных интерфейсов <productname>&productname;</productname>, включая те, что написаны для C++, Perl, Python, Tcl и <application>ECPG</application>. Поэтому некоторые аспекты поведения <application>libpq</application> будут важны для вас, если вы используете один из этих пакетов. В частности, <xref linkend="libpq-envars"/>, <xref linkend="libpq-pgpass"/> и <xref linkend="libpq-ssl"/> описывают поведение, видимое пользователю любого приложения, использующего <application>libpq</application>.</para>

 <para>В конце этой главы включены короткие программы (<xref linkend="libpq-example"/>), показывающие, как писать программы, которые используют <application>libpq</application>. В каталоге <filename>src/test/examples</filename> дистрибутивного комплекта исходных текстов приведено несколько завершённых примеров приложений <application>libpq</application>.</para>

 <para>Клиентские программы, которые используют <application>libpq</application>, должны включать заголовочный файл <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</primary></indexterm> и должны компоноваться с библиотекой <application>libpq</application>.</para>

 <sect1 id="libpq-connect">
  <title>Функции управления подключением к базе данных</title>

  <para>Следующие функции имеют дело с созданием подключения к серверу <productname>&productname;</productname>. Прикладная программа может иметь несколько подключений к серверу, открытых одновременно. (Одна из причин этого заключается в необходимости доступа к более чем одной базе данных.) Каждое соединение представляется объектом <structname>PGconn</structname><indexterm><primary>PGconn</primary></indexterm>, который можно получить от функций <function>PQconnectdb</function>, <function>PQconnectdbParams</function> или <function>PQsetdbLogin</function>. Обратите внимание, что эти функции всегда возвратят ненулевой указатель на объект, если только, возможно, не осталось слишком мало памяти даже для того, чтобы выделить её для объекта <structname>PGconn</structname>. Прежде чем передавать запросы через объект подключения, следует вызвать функцию <function>PQstatus</function> для проверки возвращаемого значения в случае успешного подключения. <warning>
    <para>В системе Unix создание дочернего процесса на основе процесса, уже имеющего открытые подключения с помощью libpq, может привести к непредсказуемым результатам, потому что родительский и дочерний процессы совместно используют одни и те же сокеты и ресурсы операционной системы. По этой причине подобный подход не рекомендуется. Однако использование системного вызова <function>exec</function> из дочернего процесса для загрузки нового исполняемого файла является безопасным.</para>
   </warning> <note>
    <para>В системе Windows существует способ повышения производительности, при котором единственное соединение с базой данных повторно стартует и останавливается. На внутреннем уровне libpq вызывает <function>WSAStartup()</function> и <function>WSACleanup()</function> для старта и остановки соединения соответственно. <function>WSAStartup()</function> увеличивает на единицу внутренний счётчик ссылок в библиотеке Windows, который уменьшается на единицу при вызове <function>WSACleanup()</function>. Когда счётчик ссылок равен единице, вызов <function>WSACleanup()</function> освобождает все ресурсы, и все библиотеки DLL выгружаются. Это дорогостоящая операция. Для её избежания приложение может "вручную" вызвать <function>WSAStartup()</function>, чтобы ресурсы не были освобождены, когда закрыто последнее соединение с базой данных.</para>
   </note> <variablelist>
    <varlistentry id="libpq-pqconnectdbparams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</primary></indexterm></term>
     <listitem>
      <para>Создаёт новое подключение к серверу баз данных. <synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis></para>

      <para>Эта функция открывает новое соединение с базой данных, используя параметры, содержащиеся в двух массивах, завершающихся символом <symbol>NULL</symbol>. Первый из них, <literal>keywords</literal>, определяется как массив строк, каждая из которых представляет собой ключевое слово. Второй, <literal>values</literal>, даёт значение для каждого ключевого слова. В отличие от <function>PQsetdbLogin</function>, описываемой ниже, набор параметров может быть расширен без изменения сигнатуры функции, поэтому использование данной функции (или её неблокирующих аналогов <function>PQconnectStartParams</function> и <function>PQconnectPoll</function>) является предпочтительным при разработке новых приложений.</para>

      <para>Ключевые слова-параметры, распознаваемые в настоящее время, приведены в <xref remap="6" linkend="libpq-paramkeywords"/>.</para>

      <para>Когда <literal>expand_dbname</literal> имеет ненулевое значение, тогда в качестве значения, соответствующего ключевому слову <parameter>dbname</parameter>, может быть указана строка подключения. Только первый экземпляр <parameter>dbname</parameter> расширяется таким образом, а все последующие значения <parameter>dbname</parameter> будут обработаны как обычные имена базы данных. Дополнительные сведения о возможных форматах строки подключения можно найти в <xref remap="6" linkend="libpq-connstring"/>.</para>

      <para>Передаваемые массивы могут быть пустыми. В этом случае используются все параметры по умолчанию. Массивы могут также содержать один или более элементов и должны быть согласованы по длине. Обработка прекращается, когда найден первый элемент со значением <symbol>NULL</symbol> в массиве <literal>keywords</literal>.</para>

      <para>Если какой-либо параметр имеет значение <symbol>NULL</symbol> или содержит пустую строку, проверяется значение соответствующей переменной окружения (см. <xref remap="4" linkend="libpq-envars"/>). Если и переменная окружения не установлена, используется встроенное значение по умолчанию.</para>

      <para>В общем случае ключевые слова обрабатываются в индексном порядке, начиная с начала этих массивов. Вследствие такого подхода, когда ключевые слова повторяются, сохраняется последнее обработанное значение. Следовательно, за счёт соответствующего расположения ключевого слова <parameter>dbname</parameter> можно регулировать, что может быть переопределено строкой <parameter>conninfo</parameter>, а что не может.</para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</primary></indexterm></term>
     <listitem>
      <para>Создаёт новое подключение к серверу баз данных. <synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis></para>

      <para>Эта функция открывает новое соединение с базой данных, используя параметры, полученные из строки <literal>conninfo</literal>.</para>

      <para>Передаваемая строка может быть пустой. В этом случае используются все параметры по умолчанию. Она также может содержать одно или более значений параметров, разделённых пробелами, или <acronym>URI</acronym>. За подробностями обратитесь к <xref remap="3" linkend="libpq-connstring"/>.</para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdblogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</primary></indexterm></term>
     <listitem>
      <para>Создаёт новое подключение к серверу баз данных. <synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis></para>

       <para>Это предшественница функции <function>PQconnectdb</function> с фиксированным набором параметров. Она имеет такую же функциональность, за исключением того, что непереданные параметры всегда принимают значения по умолчанию. Подставьте <symbol>NULL</symbol> или пустую строку в качестве любого из фиксированных параметров, которые должны принять значения по умолчанию.</para>

      <para>Если параметр <parameter>dbName</parameter> содержит знак <symbol>=</symbol> или имеет допустимый префикс <acronym>URI</acronym> для подключения, то он воспринимается в качестве строки <parameter>conninfo</parameter> точно таким же образом, как если бы он был передан функции <function>PQconnectdb</function>, а оставшиеся параметры затем применяются, как указано для <function>PQconnectdbParams</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</primary></indexterm></term>
     <listitem>
      <para>Создаёт новое подключение к серверу баз данных. <synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis></para>

     <para>Это макрос, который вызывает <function>PQsetdbLogin</function> с нулевыми указателями в качестве значений параметров <parameter>login</parameter> и <parameter>pwd</parameter>. Обеспечивает обратную совместимость с очень старыми программами.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectstartparams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</primary></indexterm></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</primary></indexterm></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</primary></indexterm></term>
     <listitem>
      <para><indexterm><primary>неблокирующее соединение</primary></indexterm> Создают подключение к серверу баз данных неблокирующим способом. <synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis></para>

      <para>Три эти функции используются для того, чтобы открыть подключение к серверу баз данных таким образом, чтобы поток исполнения вашего приложения не был заблокирован при выполнении удалённой операции ввода/вывода в процессе подключения. Суть этого подхода в том, чтобы ожидание завершения операций ввода/вывода могло происходить в главном цикле приложения, а не в внутри функций <function>PQconnectdbParams</function> или <function>PQconnectdb</function>, с тем, чтобы приложение могло управлять этой операцией параллельно с другой работой.</para>

      <para>С помощью функции <function>PQconnectStartParams</function> подключение к базе данных выполняется, используя параметры, взятые из массивов <literal>keywords</literal> и <literal>values</literal>, а управление осуществляется с помощью <literal>expand_dbname</literal>, как описано выше для <function>PQconnectdbParams</function>.</para>

      <para>С помощью функции <function>PQconnectStart</function> подключение к базе данных выполняется, используя параметры, взятые из строки <literal>conninfo</literal>, как описано выше для <function>PQconnectdb</function>.</para>

      <para>Ни <function>PQconnectStartParams</function>, ни <function>PQconnectStart</function>, ни <function>PQconnectPoll</function> не заблокируются до тех пор, пока выполняется ряд ограничений: <itemizedlist>
        <listitem>
         <para>Параметры <literal>hostaddr</literal> и <literal>host</literal> используются надлежащим образом, чтобы прямой и обратный DNS-запросы не выполнялись. Подробнее эти параметры описаны в <xref remap="6" linkend="libpq-paramkeywords"/>.</para>
        </listitem>

        <listitem>
         <para>Если вы вызываете <function>PQtrace</function>, обеспечьте, чтобы поток, в который выводится трассировочная информация, не заблокировался.</para>
        </listitem>

        <listitem>
         <para>Вы обеспечиваете, чтобы сокет находился в соответствующем состоянии перед вызовом <function>PQconnectPoll</function>, как описано ниже.</para>
        </listitem>
       </itemizedlist></para>

      <para>Примечание: использование <function>PQconnectStartParams</function> аналогично использованию <function>PQconnectStart</function>, показанному ниже.</para>

      <para>Чтобы начать неблокирующий запрос на подключение, вызовите <literal>conn = PQconnectStart("<replaceable>connection_info_string</replaceable>")</literal>. Если значение <varname>conn</varname> пустое, то, значит, <application>libpq</application> не смогла распределить память для новой структуры <structname>PGconn</structname>. В противном случае будет возвращён корректный указатель <structname>PGconn</structname> (хотя ещё и не представляющий действительного подключения к базе данных). После возврата из <function>PQconnectStart</function> вызовите <literal>status = PQstatus(conn)</literal>. Если <varname>status</varname> имеет значение <symbol>CONNECTION_BAD</symbol>, то, значит, вызов <function>PQconnectStart</function> завершился сбоем.</para>

      <para>Если вызов <function>PQconnectStart</function> был успешным, теперь нужно опросить <application>libpq</application>, чтобы она могла возобновить процесс подключения. Используйте <function>PQsocket(conn)</function> для получения дескриптора сокета, через который установлено соединение с базой данных. Организуйте цикл так: если <function>PQconnectPoll(conn)</function> в последний раз возвратила <symbol>PGRES_POLLING_READING</symbol>, то подождите, пока сокет не станет готовым к выполнению операции чтения (это покажет функция <function>PQselect()</function> или <function>PQselectExtended()</function>). Затем снова вызовите <function>PQconnectPoll(conn)</function>. И наоборот, если <function>PQconnectPoll(conn)</function> в последний раз возвратила <symbol>PGRES_POLLING_WRITING</symbol>, то подождите, пока сокет не станет готовым к выполнению операции записи, затем вызовите <function>PQconnectPoll(conn)</function> снова. Если вам всё же приходится вызвать <function>PQconnectPoll</function>, то есть сразу после вызова <function>PQconnectStart</function>, поступайте так, как будто она в последний раз возвратила <symbol>PGRES_POLLING_WRITING</symbol>. Продолжайте этот цикл до тех пор, пока <function>PQconnectPoll(conn)</function> не возвратит <symbol>PGRES_POLLING_FAILED</symbol>, показывая, что процедура подключения завершилась сбоем, или <symbol>PGRES_POLLING_OK</symbol>, показывая, что соединение было успешно установлено.</para>

      <para>В любое время в процессе подключения его состояние можно проверить, вызвав <function>PQstatus</function>. Если этот вызов возвратит <symbol>CONNECTION_BAD</symbol>, значит, процедура подключения завершилась сбоем; если вызов возвратит <function>CONNECTION_OK</function>, значит, соединение готово. Оба эти состояния можно определить на основе возвращаемого значения функции <function>PQconnectPoll</function>, описанной выше. Другие состояния могут также иметь место в течение (и только в течение) асинхронной процедуры подключения. Они показывают текущую стадию процедуры подключения и могут быть полезны, например, для предоставления обратной связи пользователю. Вот эти состояния: <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>Ожидание, пока соединение будет установлено.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>Соединение установлено; ожидание отправки.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>Ожидание ответа от сервера.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>Аутентификация получена; ожидание завершения запуска серверной части.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>Согласование SSL-шифрования.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>Согласование значений параметров, зависящих от программной среды.</para>
         </listitem>
        </varlistentry>
       </variablelist> Заметьте, что, хотя эти константы и сохранятся (для поддержания совместимости), приложение никогда не должно полагаться на то, что они появятся в каком-то конкретном порядке или вообще появятся, а также на то, что состояние всегда примет одно из этих документированных значений. Приложение может сделать что-то наподобие: <programlisting>switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Подключение...";
            break;

        case CONNECTION_MADE:
            feedback = "Подключён к серверу...";
            break;
.
.
.
        default:
            feedback = "Подключение...";
}</programlisting></para>

      <para>Параметр подключения <literal>connect_timeout</literal> игнорируется, когда используется <function>PQconnectPoll</function>; именно приложение отвечает за принятие решения о том, является ли истекшее время чрезмерным. В противном случае вызов <function>PQconnectStart</function> с последующим вызовом <function>PQconnectPoll в цикле</function> будут эквивалентны вызову <function>PQconnectdb</function>.</para>

      <para>Заметьте, что если <function>PQconnectStart</function> возвращает ненулевой указатель, вы должны вызвать <function>PQfinish</function> для завершения, чтобы ликвидировать структуру и любые связанные с ней блоки памяти. Это должно быть сделано, даже если попытка подключения не была успешной или была прекращена.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</primary></indexterm></term>
     <listitem>
      <para>Возвращает значения по умолчанию для параметров подключения. <synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* Ключевое слово для данного параметра */
    char   *envvar;    /* Имя альтернативной переменной окружения */
    char   *compiled;  /* Альтернативное значение по умолчанию, назначенное при компиляции */
    char   *val;       /* Текущее значение параметра или NULL */
    char   *label;     /* Обозначение этого поля в диалоге подключения */
    char   *dispchar;  /* Показывает, как отображать это поле
                          в диалоге подключения. Значения следующие:
                          ""        Отображать введённое значение "как есть"
                          "*"       Поле пароля — скрывать значение
                          "D"       Параметр отладки — не показывать по умолчанию */
    int     dispsize;  /* Размер поля в символах для диалога */
} PQconninfoOption;
</synopsis></para>

      <para>Возвращает массив параметров подключения. Он может использоваться для определения всех возможных параметров <function>PQconnectdb</function> и их текущих значений по умолчанию. Возвращаемое значение указывает на массив структур <structname>PQconninfoOption</structname>, который завершается элементом, имеющим нулевой указатель <structfield>keyword</structfield>. Если выделить память не удалось, то возвращается нулевой указатель. Обратите внимание, что текущие значения по умолчанию (поля <structfield>val</structfield>) будут зависеть от переменных среды и другого контекста. Отсутствующий или неверный сервисный файл будет молча проигнорирован. Вызывающие функции должны рассматривать данные параметров по умолчанию как "только для чтения".</para>

      <para>После обработки массива параметров освободите память, передав его функции <function>PQconninfoFree</function>. Если этого не делать, то при каждом вызове функции <function>PQconndefaults</function> будут происходить небольшие "утечки" памяти.</para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</primary></indexterm></term>
     <listitem>
      <para>Возвращает параметры подключения, используемые действующим соединением. <synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis></para>

      <para>Возвращает массив параметров подключения. Он может использоваться для определения всех возможных параметров <function>PQconnectdb</function> и значений, которые были использованы для подключения к серверу. Возвращаемое значение указывает на массив структур <structname>PQconninfoOption</structname>, который завершается элементом, имеющим нулевой указатель <structfield>keyword</structfield>. Все замечания, приведённые выше для <function>PQconndefaults</function>, также справедливы и для результата <function>PQconninfo</function>.</para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-pqconninfoparse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</primary></indexterm></term>
     <listitem>
      <para>Возвращает разобранные параметры подключения, переданные в строке подключения. <synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis></para>

      <para>Разбирает строку подключения и возвращает результирующие параметры в виде массива; возвращает <symbol>NULL</symbol>, если возникают проблемы при разборе строки подключения. Эту функцию можно использовать для извлечения параметров функции <function>PQconnectdb</function> из предоставленной строки подключения. Возвращаемое значение указывает на массив структур <structname>PQconninfoOption</structname>, который завершается элементом, имеющим нулевой указатель <structfield>keyword</structfield>.</para>

      <para>Все разрешённые параметры будут присутствовать в результирующем массиве, но <literal>PQconninfoOption</literal> для любого параметра, не присутствующего в строке подключения, будет иметь значение <literal>NULL</literal> в поле <literal>val</literal>; значения по умолчанию не подставляются.</para>

      <para>Если <literal>errmsg</literal> не равно <symbol>NULL</symbol>, тогда в случае успеха <literal>*errmsg</literal> присваивается <symbol>NULL</symbol>, а в противном случае -- адрес строки сообщения об ошибке, объясняющего проблему. Память для этой строки выделяет функция <function>malloc</function>. (Также возможна ситуация, когда <literal>*errmsg</literal> будет установлено в <symbol>NULL</symbol>, и при этом функция возвращает <symbol>NULL</symbol>. Это указывает на нехватку памяти.)</para>

      <para>После обработки массива параметров освободите память, передав его функции <function>PQconninfoFree</function>. Если этого не делать, тогда некоторое количество памяти будет утекать при каждом вызове <function>PQconninfoParse</function>. И наоборот, если произошла ошибка и <literal>errmsg</literal> не равно <symbol>NULL</symbol>, обязательно освободите память, занимаемую строкой сообщения об ошибке, используя <function>PQfreemem</function>.</para>

   </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</primary></indexterm></term>
     <listitem>
      <para>Закрывает соединение с сервером. Также освобождает память, используемую объектом <structname>PGconn</structname>. <synopsis>
void PQfinish(PGconn *conn);
</synopsis></para>

      <para>Обратите внимание, что даже если попытка подключения к серверу потерпела неудачу (как показывает <function>PQstatus</function>), приложение все равно должно вызвать <function>PQfinish</function>, чтобы освободить память, используемую объектом <structname>PGconn</structname>. Указатель <structname>PGconn</structname> не должен использоваться повторно после того, как была вызвана функция <function>PQfinish</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</primary></indexterm></term>
     <listitem>
      <para>Переустанавливает канал связи с сервером. <synopsis>
void PQreset(PGconn *conn);
</synopsis></para>

      <para>Эта функция закроет подключение к серверу, а потом попытается восстановить подключение к тому же серверу, используя все те же параметры, которые использовались прежде. Это может быть полезным для восстановления после ошибки, если работающее соединение оказалось потерянным.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresetstart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</primary></indexterm></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</primary></indexterm></term>
     <listitem>
      <para>Переустанавливает канал связи с сервером неблокирующим способом. <synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis></para>

      <para>Эти функции закроют подключение к серверу, а потом попытаются восстановить подключение к тому же серверу, используя все те же параметры, которые использовались прежде. Это может быть полезным для восстановления после ошибки, если работающее соединение оказалось потерянным. Они отличаются от <function>PQreset</function> (см. выше) тем, что действуют неблокирующим способом. На эти функции налагаются те же ограничения, что и на <function>PQconnectStartParams</function>, <function>PQconnectStart</function> и <function>PQconnectPoll</function>.</para>

      <para>Чтобы приступить к переустановке подключения, вызовите <function>PQresetStart</function>. Если она возвратит 0, переустановка завершилась неудачно. Если она возвратит 1, опросите результат переустановки, используя <function>PQresetPoll</function>, точно таким же образом, как если бы вы создавали подключение, используя <function>PQconnectPoll</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpingparams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</primary></indexterm></term>
     <listitem>
      <para><function>PQpingParams</function> сообщает состояние сервера. Она принимает параметры подключения, идентичные тем, что получает функция <function>PQconnectdbParams</function>, описанная выше. Нет необходимости предоставлять корректные имя пользователя, пароль или имя базы данных, чтобы получить состояние сервера. Однако, если предоставлены некорректные значения, сервер занесёт в журнал неудачную попытку подключения.<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis> Функция возвращает одно из следующих значений: <variablelist>
        <varlistentry id="libpq-pqpingparams-pqping-ok">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>Сервер работает и, по-видимому, принимает подключения.</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-reject">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>Сервер работает, но находится в состоянии, которое запрещает подключения (запуск, завершение работы или восстановление после аварийного отказа).</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-response">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>Контакт с сервером не удался. Это может указывать на то, что сервер не запущен или что-то не в порядке с параметрами данного подключения (например, неверный номер порта), или имеет место проблема с возможностью соединения по сети (например, брандмауэр блокирует запрос на подключение).</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-attempt">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>Никакой попытки установить контакт с сервером сделано не было, поскольку предоставленные параметры были явно некорректными, или имела место какая-то проблема на стороне клиента (например, нехватка памяти).</para>
         </listitem>
        </varlistentry>
       </variablelist></para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqping">
     <term><function>PQping</function><indexterm><primary>PQping</primary></indexterm></term>
     <listitem>
      <para><function>PQping</function> сообщает состояние сервера. Она принимает параметры подключения, идентичные тем, что получает функция <function>PQconnectdb</function>, описанная выше. Нет необходимости предоставлять корректные имя пользователя, пароль или имя базы данных, чтобы получить состояние сервера. Однако, если предоставлены некорректные значения, сервер занесёт в журнал неудачную попытку подключения. <synopsis>
PGPing PQping(const char *conninfo);
</synopsis></para>

      <para>Возвращаемые значения такие же, как и для <function>PQpingParams</function>.</para>

     </listitem>
    </varlistentry>

   </variablelist></para>

  <sect2 id="libpq-connstring">
   <title>Строки параметров подключения</title>

   <indexterm zone="libpq-connstring"><primary><literal>conninfo</literal></primary></indexterm>

   <indexterm zone="libpq-connstring"><primary><literal>URI</literal></primary></indexterm>

   <para>Несколько функций <application>libpq</application> занимаются разбором строки, заданной пользователем, чтобы получить параметры подключения. Для этих строк существует два общепринятых формата: простые строки вида <literal>keyword = value</literal> и URI в соответствии с <ulink url="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</ulink>.</para>

   <sect3>
    <title>Строки параметров подключения вида "ключ/значение"</title>

   <para>Согласно первому формату, установка каждого параметра выполняется в форме <literal>keyword = value</literal>. Пробелы вокруг знака равенства не являются обязательными. Для записи пустого значения или значения, содержащего пробелы, заключите его в одинарные кавычки, например, <literal>keyword = 'a value'</literal>. Одинарные кавычки и символы обратной косой черты внутри значения нужно обязательно экранировать с помощью символа обратной косой черты, т. е., <literal>\'</literal> и <literal>\\</literal>.</para>

   <para>Пример: <programlisting>host=localhost port=5432 dbname=mydb connect_timeout=10</programlisting></para>

   <para>Ключевые слова-параметры, распознаваемые в настоящее время, приведены в <xref remap="6" linkend="libpq-paramkeywords"/>.</para>
   </sect3>

   <sect3>
    <title>URI для подключения</title>

   <para>Общая форма <acronym>URI</acronym> для подключения такова: <synopsis>
postgresql://[user[:password]@][netloc][:port][,netloc[:port]...][/dbname][?param1=value1&amp;...]
</synopsis></para>

   <para>В качестве обозначения схемы <acronym>URI</acronym> может использоваться либо <literal>postgresql://</literal>, либо <literal>postgres://</literal>. Каждая из частей <acronym>URI</acronym> является необязательной. В следующих примерах показано правильное использование синтаксиса <acronym>URI</acronym>: <programlisting>postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://node1,node2:5433,node3:4432,node4/mydb?hostorder=random&amp;target_server_type=any</programlisting> Компоненты иерархической части <acronym>URI</acronym> можно также передавать в виде параметров. Например: <programlisting>postgresql:///mydb?host=localhost&amp;port=5433</programlisting></para>

   <para>Для включения символов, имеющих специальное значение, в любой части <acronym>URI</acronym> можно применять URL-кодирование (с использованием символа %).</para>

   <para>Любые параметры соединения, не соответствующие ключевым словам, приведённым в <xref remap="6" linkend="libpq-paramkeywords"/>, игнорируются, а предупреждающее сообщение об этом направляется на <filename>stderr</filename>.</para>

   <para>Для улучшения совместимости с теми <acronym>URI</acronym>, которые используются для подключений JDBC, все вхождения параметра <literal>ssl=true</literal> заменяются на <literal>sslmode=require</literal> и <literal>loadBalanceHosts=true</literal> на <literal>hostorder=random</literal>.</para>

   <para>Сервер можно представить либо доменным именем, либо IP-адресом. При использовании протокола IPv6 нужно заключить адрес в квадратные скобки: <synopsis format="linespecific ">postgresql://[2001:db8::1234]/database
</synopsis></para>
   <para>В этой строке можно задать несколько имён узлов (с номером порта, при необходимости), разделяя их запятыми.</para>

   <para>Компонент "host" интерпретируется в соответствии с описанием параметра <xref linkend="libpq-connect-host"/>. В частности, если этот компонент пуст или начинается с символа косой черты, выбирается соединение через доменные сокеты Unix, а в противном случае инициируется соединение по TCP/IP. Обратите внимание, однако, что символ косой черты в иерархической части URI является зарезервированным. Поэтому, чтобы указать нестандартный каталог Unix-сокета, нужно поступить одним из двух способов: не задавать сервер в URI и указать сервер в качестве параметра, либо закодировать путь в компоненте "host" с процентами: <programlisting>postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname</programlisting></para>
   </sect3>
  </sect2>

  <sect2 id="libpq-paramkeywords">
   <title>Ключевые слова-параметры</title>

   <para>Ключевые слова-параметры, распознаваемые в настоящее время, следующие: <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
      <term><literal>host</literal></term>
      <listitem>
       <para>Имя компьютера для подключения.<indexterm><primary>имя компьютера</primary></indexterm> Если оно начинается с косой черты, то тогда предписывается установление связи через домен Unix, а не посредством TCP/IP; значением является имя каталога, в котором создаётся файл сокета. По умолчанию, когда <literal>host</literal> не указан, подключение производится к доменному сокету Unix <indexterm><primary>доменный сокет Unix</primary></indexterm> в каталоге <filename>/tmp</filename> (или в том каталоге, который был назначен при сборке <productname>&productname;</productname>). В системах, не поддерживающих доменные сокеты Unix, подключение по умолчанию производится к <literal>localhost</literal>.</para>
       <para>В строке подключения может быть задано несколько параметров <literal>host</literal>. В этом случае заданные узлы будут считаться альтернативными серверами, обслуживающими одну базу данных, и если подключиться к первому не удаётся, выполняется попытка подключения ко второму, и так далее. Это может применяться для обеспечения высокой степени доступности и балансировки нагрузки. См. описание параметра <xref linkend="libpq-connect-hostorder"/>. Эта функциональность поддерживается только с TCP/IP.</para>
       <para>Сетевое имя узла может быть дополнено номером порта (после двоеточия). Указанный номер порта будет использоваться только при подключении к этому узлу. В отсутствие этого указания будет использоваться номер порта, заданный в параметре <xref linkend="libpq-connect-port"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
       <para>Числовой IP-адрес компьютера для подключения. Он должен быть представлен в стандартном формате адресов IPv4, например, <literal>172.28.40.9</literal>. Если ваша машина поддерживает IPv6, вы можете использовать и эти адреса. Связь по протоколу TCP/IP используется всегда, когда в качестве этого параметра передана непустая строка.</para>

       <para>Использование <literal>hostaddr</literal> вместо <literal>host</literal> позволяет приложению избежать поиска на сервере имён, что может быть важно для приложений, имеющих временные ограничения. Однако, имя компьютера требуется для методов аутентификации GSSAPI или SSPI, а также для проверки полномочий на основе SSL-сертификатов в режиме <literal>verify-full</literal>. Используются следующие правила: <itemizedlist>
         <listitem>
          <para>Если <literal>host</literal> указан, а <literal>hostaddr</literal> не указан, тогда выполняется поиск на сервере имён.</para>
         </listitem>
         <listitem>
          <para>Если указан <literal>hostaddr</literal>, а <literal>host</literal> не указан, тогда значение <literal>hostaddr</literal> даёт сетевой адрес сервера. Попытка подключения завершится неудачей, если метод аутентификации требует наличия имени компьютера.</para>
         </listitem>
         <listitem>
          <para>Если указаны как <literal>host</literal>, так и <literal>hostaddr</literal>, тогда значение <literal>hostaddr</literal> даёт сетевой адрес сервера, а значение <literal>host</literal> игнорируется, если только метод аутентификации его не потребует. В таком случае оно будет использоваться в качестве имени компьютера.</para>
         </listitem>
        </itemizedlist> Заметьте, что аутентификация может завершится неудачей, если <literal>host</literal> не является именем сервера, имеющего сетевой адрес <literal>hostaddr</literal>. Заметьте также, что <literal>host</literal>, а не <literal>hostaddr</literal> используется для того, чтобы идентифицировать соединение в <filename>~/.pgpass</filename> (см. <xref remap="4" linkend="libpq-pgpass"/>).</para>
       <para>Если не указаны ни имя компьютера, ни его адрес, <application>libpq</application> будет производить подключение, используя локальный доменный сокет Unix; в системах, не поддерживающих сокеты Unix, она будет пытаться подключиться к <literal>localhost</literal>.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-hostorder" xreflabel="hostorder">
       <term><literal>hostorder</literal></term>
       <listitem>
       <para>Указывает, как должен выбираться сервер из списка доступных серверов, указанном в параметре <xref linkend="libpq-connect-host"/>.</para>
       <para>Если значение этого аргумента — <literal>sequential</literal> (по умолчанию), подключения к серверам будут осуществляться в том порядке, в котором они указаны.</para>
       <para>Со значением <literal>random</literal> сервер для подключения выбирается из списка случайным образом. Это позволяет организовать балансировку нагрузки между несколькими узлами кластера. Однако в настоящее время PostgreSQL не поддерживает кластеры с несколькими ведущими серверами. Поэтому без применения сторонних продуктов распределение нагрузки возможно только для подключений, не производящих запись. (См. <xref remap="4" linkend="libpq-connect-target-server-type"/>.)</para>
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-target-server-type" xreflabel="target_server_type">
       <term><literal>target_server_type</literal></term>
        <listitem>
        <para>Если значение этого параметра — <literal>master</literal>, при успешном подключении выполняется проверка, не находится ли целевой сервер в состоянии восстановления. Если это так, выполняется попытка подключения к следующему серверу в строке подключения. Если он имеет значение <literal>any</literal>, подходящими будут считаться и подключения к ведомым серверам.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-port" xreflabel="port">
       <term><literal>port</literal></term>
       <listitem>
       <para>Номер порта для подключения на сервере или расширение имени файла-сокета для подключений на основе домена Unix.<indexterm><primary>port</primary></indexterm></para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
      <para>Имя базы данных. По умолчанию оно совпадает с именем пользователя. В определённых контекстах это значение проверяется на соответствие расширенным форматам; см. <xref remap="4" linkend="libpq-connstring"/> для получения подробной информации.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
      <para>Имя пользователя <productname>&productname;</productname>, используемое для подключения. По умолчанию используется то же имя, которое имеет в операционной системе пользователь, от лица которого выполняется приложение.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
      <para>Пароль, используемый в случае, когда сервер требует аутентификации по паролю.</para>
      </listitem>
     </varlistentry>
     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
      <para>Максимальный период ожидания подключения, в секундах (записывается в виде строки, представляющей десятичное целое число).</para>
      </listitem>
     </varlistentry>
     <varlistentry id="libpq-connect-falover-timeout" xreflabel="failover_timeout">
      <term><literal>failover_timeout</literal></term>
      <listitem>
      <para>Максимальное время для циклического перебора всех узлов в строке подключения (десятичное целое, задающее число секунд). Если не указано, все узлы перебираются только один раз.</para>
      <para>Если в кластере с репликацией отказывает ведущий сервер, может потребоваться некоторое время, чтобы один из ведомых узлов стал новым ведущим. Поэтому клиенты, которые столкнулись с ошибкой подключения к ведущему, могут прекратить попытки повторного подключения до того, как в работу включится новый ведущий сервер.</para>
      <para>Задайте в этом параметре значение, определяющее, сколько времени потребуется для переноса роли ведущего сервера, чтобы клиент продолжал подключаться к серверам, пока не появится новый ведущий сервер.</para>
      </listitem>
     </varlistentry>
     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
      <para>Этим устанавливается конфигурационный параметр <varname>client_encoding</varname> для данного подключения. В дополнение к значениям, которые принимает соответствующий параметр сервера, вы можете использовать значение <literal>auto</literal>. В этом случае правильная кодировка определяется на основе текущей локали на стороне клиента (в системах Unix это переменная системного окружения <envar>LC_CTYPE</envar>).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
       <para>Задаёт параметры командной строки, которые будут отправлены серверу при установлении соединения. Например, значение <literal>-c geqo=off</literal> установит для параметра сеанса <varname>geqo</varname> значение <literal>off</literal>. Пробелы в этой строке считаются разделяющими аргументы командной строки, если только перед ними не стоит обратная косая черта (<literal>\</literal>); чтобы записать собственно обратную косую черту, её нужно продублировать (<literal>\\</literal>). Подробное описание возможных параметров можно найти в <xref remap="6" linkend="runtime-config"/>.</para>
      </listitem>
     </varlistentry>



     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
       <para>Устанавливает значение для конфигурационного параметра <xref linkend="guc-application-name"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
       <para>Устанавливает альтернативное значение для конфигурационного параметра <xref linkend="guc-application-name"/>. Это значение будет использоваться, если для параметра <literal>application_name</literal> не было передано никакого значения с помощью параметров подключения или переменной системного окружения <envar>PGAPPNAME</envar>. Задание альтернативного имени полезно для универсальных программ-утилит, которые желают установить имя приложения по умолчанию, но позволяют пользователю изменить его.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
       <para>Управляет использованием сообщений keepalive протокола TCP на стороне клиента. Значение по умолчанию равно 1, что означает использование сообщений. Вы можете изменить его на 0, если эти сообщения не нужны. Для соединений, установленных через доменный сокет Unix, этот параметр игнорируется.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
       <para>Управляет длительностью периода отсутствия активности, выраженного числом секунд, по истечении которого TCP должен отправить сообщение keepalive серверу. При значении 0 действует системное значение. Этот параметр игнорируется, если подключение выполнено через доменный сокет Unix или если сообщения keepalive отключены. Он поддерживается только в системах, воспринимающих параметр сокета <symbol>TCP_KEEPIDLE</symbol> или равнозначный, и в Windows; в других системах он не оказывает влияния.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
       <para>Управляет количеством секунд, по прошествии которых сообщение keepalive протокола TCP, получение которого не подтверждено сервером, должно быть отправлено повторно. При значении 0 действует системное значение. Этот параметр игнорируется в сеансах, подключённых через доменные сокеты Unix, или если сообщения keepalive отключены. Он поддерживается только в системах, воспринимающих параметр сокета <symbol>TCP_KEEPINTVL</symbol> или равнозначный, и в Windows; в других системах он не оказывает влияния.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
       <para>Управляет количеством сообщений keepalive протокола TCP, которые могут быть потеряны, прежде чем соединение клиента с сервером будет признано неработающим. Нулевое значение этого параметра указывает, что будет использоваться системное значение по умолчанию. Этот параметр игнорируется для соединений, установленных через доменные сокеты Unix, или если сообщения keepalive отключены. Он поддерживается только в системах, воспринимающих параметр сокета <symbol>TCP_KEEPCNT</symbol> или равнозначный; в других системах он не оказывает влияния.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-tty" xreflabel="tty">
      <term><literal>tty</literal></term>
      <listitem>
      <para>Игнорируется (прежде он указывал, куда направить вывод отладочных сообщений сервера).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
       <para>Этот параметр определяет, будет ли согласовываться с сервером защищённое <acronym>SSL</acronym>-соединение по протоколу TCP/IP, и если да, то в какой очередности. Всего предусмотрено шесть режимов: <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>следует пытаться установить только соединение без использования <acronym>SSL</acronym></para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>сначала следует попытаться установить соединение без использования <acronym>SSL</acronym>; если попытка будет неудачной, нужно попытаться установить <acronym>SSL</acronym>-соединение</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (по умолчанию)</term>
          <listitem>
           <para>сначала следует попытаться установить <acronym>SSL</acronym>-соединение; если попытка будет неудачной, нужно попытаться установить соединение без использования <acronym>SSL</acronym></para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>следует попытаться установить только <acronym>SSL</acronym>-соединение. Если присутствует файл корневого центра сертификации, то нужно верифицировать сертификат таким же способом, как будто был указан параметр <literal>verify-ca</literal></para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>следует попытаться установить только <acronym>SSL</acronym>-соединение, при этом проконтролировать, чтобы сертификат сервера был выпущен доверенным центром сертификации (<acronym>CA</acronym>)</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>следует попытаться установить только <acronym>SSL</acronym>-соединение, при этом проконтролировать, чтобы сертификат сервера был выпущен доверенным центром сертификации (<acronym>CA</acronym>) и чтобы имя запрошенного сервера соответствовало имени в сертификате</para>
          </listitem>
         </varlistentry>
        </variablelist> В <xref remap="6" linkend="libpq-ssl"/> приведено подробное описание работы этих режимов.</para>

       <para><literal>sslmode</literal> игнорируется при использовании доменных сокетов Unix. Если <productname>&productname;</productname> скомпилирован без поддержки SSL, использование параметров <literal>require</literal>, <literal>verify-ca</literal> или <literal>verify-full</literal> приведёт к ошибке, в то время как параметры <literal>allow</literal> и <literal>prefer</literal> будут приняты, но <application>libpq</application> в действительности не будет пытаться установить <acronym>SSL</acronym>-соединение.<indexterm><primary>SSL</primary> <secondary sortas="libpq">с libpq</secondary></indexterm></para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
       <para>Использовать этот параметр не рекомендуется, в качестве замены предлагается установить <literal>sslmode</literal>.</para>

       <para>Если установлено значение 1, то требуется <acronym>SSL</acronym>-соединение с сервером (это эквивалентно <literal>sslmode</literal> <literal>require</literal>). <application>libpq</application> в таком случае откажется подключаться, если сервер не принимает <acronym>SSL</acronym>-соединений. Если установлено значение 0 (по умолчанию), тогда <application>libpq</application> будет согласовывать тип подключения с сервером (эквивалентно <literal>sslmode</literal> <literal>prefer</literal>). Этот параметр доступен, если только <productname>&productname;</productname> скомпилирован с поддержкой SSL.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
       <para>Если установлено значение 1 (по умолчанию), данные, пересылаемые через SSL-соединения, будут сжиматься (это требует <productname>OpenSSL</productname> версии 0.9.8 или более поздней). Если установлено значение 0, сжатие будет отключено (это требует <productname>OpenSSL</productname> версии 1.0.0 или более поздней). Этот параметр игнорируется, если выполнено подключение без SSL, или если используемая версия <productname>OpenSSL</productname> не поддерживает его.</para>
       <para>Сжатие требует процессорного времени, но может улучшить пропускную способность, если узким местом является сеть. Отключение сжатия может улучшить время отклика и пропускную способность, если ограничивающим фактором является производительность CPU.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
       <para>Этот параметр предписывает имя файла для SSL-сертификата клиента, заменяющего файл по умолчанию <filename> ~/.postgresql/postgresql.crt</filename>. Этот параметр игнорируется, если SSL-подключение не выполнено.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
       <para>Этот параметр предписывает местоположение секретного ключа, используемого для сертификата клиента. Он может либо указывать имя файла, которое будет использоваться вместо имени по умолчанию <filename> ~/.postgresql/postgresql.key</filename>, либо он может указывать ключ, полученный от внешнего <quote>криптомодуля</quote> (криптомодули — это загружаемые модули <productname>OpenSSL</productname>). Спецификация внешнего криптомодуля должна состоять из имени модуля и ключевого идентификатора, зависящего от конкретного модуля, разделённых двоеточием. Этот параметр игнорируется, если SSL-подключение не выполнено.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
       <para>Этот параметр указывает имя файла, содержащего SSL-сертификаты, выданные Центром сертификации (<acronym>CA</acronym>). Если файл существует, сертификат сервера будет проверен на предмет его подписания одним из этих центров. Имя по умолчанию — <filename> ~/.postgresql/root.crt</filename>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
       <para>Этот параметр указывает имя файла, содержащего список отозванных SSL-сертификатов (CRL). Сертификаты, перечисленные в этом файле, если он существует, будут отвергаться при попытке установить подлинность сертификата сервера. Имя по умолчанию такое <filename>~/.postgresql/root.crl</filename>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
       <para>Этот параметр указывает имя пользователя операционной системы, предназначенное для сервера, например, <literal>requirepeer=postgres</literal>. При создании подключения через доменный сокет Unix, если этот параметр установлен, клиент проверяет в самом начале процедуры подключения, что серверный процесс запущен от имени указанного пользователя; если это не так, соединение аварийно прерывается с ошибкой. Этот параметр можно использовать, чтобы обеспечить аутентификацию сервера, подобную той, которая доступна с помощью SSL-сертификатов при соединениях по протоколу TCP/IP. (Заметьте, что если доменный сокет Unix находится в каталоге <filename>/tmp</filename> или в другом каталоге, запись в который разрешена всем пользователям, тогда любой пользователь сможет запустить сервер, прослушивающий сокет в том каталоге. Используйте этот параметр, чтобы гарантировать, что вы подключены к серверу, запущенному доверенным пользователем.) Он поддерживается только на платформах, для которых реализован метод аутентификации <literal>peer</literal>; см. <xref remap="4" linkend="auth-peer"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
       <para>Имя сервиса Kerberos, предназначенное для использования при аутентификации на основе GSSAPI. Оно должно соответствовать имени сервиса, указанному в конфигурации сервера, чтобы аутентификация на основе Kerberos прошла успешно. (См. также <xref remap="4" linkend="gssapi-auth"/>.)</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
       <para>Библиотека GSS, предназначенная для использования при аутентификации на основе GSSAPI. Используется только в системе Windows. Назначьте значение <literal>gssapi</literal>, чтобы заставить libpq использовать для аутентификации библиотеку GSSAPI вместо SSPI, применяемого по умолчанию.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
       <para>Имя сервиса, используемое для задания дополнительных параметров. Оно указывает имя сервиса в файле <filename>pg_service.conf</filename>, который содержит дополнительные параметры подключения. Это позволяет приложениям указывать только имя сервиса, поскольку параметры подключения могут поддерживаться централизованно. См. <xref remap="4" linkend="libpq-pgservice"/>.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>
 </sect1>

 <sect1 id="libpq-status">
  <title>Функции, описывающие текущее состояние подключения</title>

  <para>Эти функции могут использоваться для опроса состояния объекта, описывающего существующее подключение к базе данных.</para>

  <tip>
   <para><indexterm><primary>libpq-fe.h</primary></indexterm> <indexterm><primary>libpq-int.h</primary></indexterm> Разработчики приложений на основе <application>libpq</application> должны тщательно поддерживать абстракцию <structname>PGconn</structname>. Следует использовать функции доступа, описанные ниже, для получения содержимого <structname>PGconn</structname>. Обращение напрямую к внутренним полям <structname>PGconn</structname>, используя сведения из <filename>libpq-int.h</filename>, не рекомендуется, поскольку они могут измениться в будущем.</para>
  </tip>

  <para>Следующие функции возвращают значения параметров, установленные при подключении. Эти значения фиксированы на время жизни объекта <structname>PGconn</structname>. <variablelist>
    <varlistentry id="libpq-pqdb">
     <term>
      <function>PQdb</function>
      <indexterm><primary>PQdb</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает имя базы данных, с которой установлено соединение. <synopsis>
char *PQdb(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pquser">
     <term>
      <function>PQuser</function>
      <indexterm><primary>PQuser</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает имя пользователя, который установил соединение.<synopsis>
char *PQuser(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpass">
     <term>
      <function>PQpass</function>
      <indexterm><primary>PQpass</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает пароль, использованный для подключения.<synopsis>
char *PQpass(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqhost">
     <term>
      <function>PQhost</function>
      <indexterm><primary>PQhost</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает имя сервера для текущего соединения. Это может быть имя компьютера, IP-адрес или путь к каталогу, если подключение установлено через сокет Unix. (Подключение к сокету можно распознать, потому что путь всегда абсолютный и начинается с <literal>/</literal>.) <synopsis>
char *PQhost(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqport">
     <term>
      <function>PQport</function>
      <indexterm><primary>PQport</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает номер порта, на котором установлено соединение.<synopsis>
char *PQport(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtty">
     <term>
      <function>PQtty</function>
      <indexterm><primary>PQtty</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает имя отладочного терминала (<acronym>TTY</acronym>), связанного с данным соединением. (Это устаревшая функция, поскольку сервер более не обращает внимания на установку <acronym>TTY</acronym>, но она остаётся для обеспечения обратной совместимости.) <synopsis>
char *PQtty(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoptions">
     <term>
      <function>PQoptions</function>
      <indexterm><primary>PQoptions</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает параметры командной строки, переданные в запросе на подключение.<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>Следующие функции возвращают данные статуса, который может измениться в процессе выполнения операций на объекте <structname>PGconn</structname>. <variablelist>
    <varlistentry id="libpq-pqstatus">
     <term>
      <function>PQstatus</function>
      <indexterm><primary>PQstatus</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает состояние подключения.<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis></para>

      <para>Статус может принимать одно из ряда значений. Однако, только два из них видны извне процедуры асинхронного подключения: <literal>CONNECTION_OK</literal> и <literal>CONNECTION_BAD</literal>. Успешное подключение к базе данных имеет статус <literal>CONNECTION_OK</literal>. О неудачной попытке подключения сигнализирует статус <literal>CONNECTION_BAD</literal>. Обычно статус OK остаётся таковым до вызова <function>PQfinish</function>, но сбой в коммуникации может привести к тому, что статус изменится на <literal>CONNECTION_BAD</literal> преждевременно. В таком случае приложение может попытаться восстановиться, вызвав <function>PQreset</function>.</para>

      <para>См. статьи, посвященные <function>PQconnectStartParams</function>, <function>PQconnectStart</function> и <function>PQconnectPoll</function>, относительно других кодов статуса, которые могут быть возвращены этими функциями.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtransactionstatus">
     <term>
      <function>PQtransactionStatus</function>
      <indexterm><primary>PQtransactionStatus</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает текущий статус сервера, отражающий процесс выполнения транзакций. <synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis> Статус может быть одним из <literal>PQTRANS_IDLE</literal> (в настоящее время не занят обработкой транзакции), <literal>PQTRANS_ACTIVE</literal> (команда в процессе обработки), <literal>PQTRANS_INTRANS</literal> (не выполняет работу, но находится в рамках действительной транзакции) или <literal>PQTRANS_INERROR</literal> (не выполняет работу, но находится в рамках транзакции, завершившейся сбоем). Статус принимает значение <literal>PQTRANS_UNKNOWN</literal>, если соединение не работает. Статус принимает значение <literal>PQTRANS_ACTIVE</literal> только тогда, когда запрос был отправлен серверу, но ещё не завершён.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparameterstatus">
     <term>
      <function>PQparameterStatus</function>
      <indexterm><primary>PQparameterStatus</primary></indexterm>
     </term>

     <listitem>
      <para>Отыскивает текущее значение параметра сервера. <synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis> Значения определённых параметров сервер сообщает автоматически в начале процедуры подключения или тогда, когда их значения изменяются. <function>PQparameterStatus</function> можно использовать, чтобы запросить эти значения. Функция возвращает текущее значение параметра, если оно известно, или <symbol>NULL</symbol>, если параметр неизвестен.</para>

      <para>Параметры, значения которых сообщает сервер, в текущей версии включают <varname>server_version</varname>, <varname>server_encoding</varname>, <varname>client_encoding</varname>, <varname>application_name</varname>, <varname>is_superuser</varname>, <varname>session_authorization</varname>, <varname>DateStyle</varname>, <varname>IntervalStyle</varname>, <varname>TimeZone</varname>, <varname>integer_datetimes</varname> и <varname>standard_conforming_strings</varname>. (Значения параметров <varname>server_encoding</varname>, <varname>TimeZone</varname> и <varname>integer_datetimes</varname> сервер до версии 8.0 не сообщал; <varname>standard_conforming_strings</varname> сервер до версии 8.1 не сообщал; <varname>IntervalStyle</varname> сервер до версии 8.4 не сообщал; <varname>application_name</varname> сервер до версии 9.0 не сообщал.) Учтите, что <varname>server_version</varname>, <varname>server_encoding</varname> и <varname>integer_datetimes</varname> нельзя изменить после запуска.</para>

      <para>Серверы, поддерживающие протокол только до версии 3.0, не могут сообщать установки параметров, но <application>libpq</application> включает средства, чтобы получить значения для <varname>server_version</varname> и <varname>client_encoding</varname> в любом случае. Поощряется использование в приложениях <function>PQparameterStatus</function>, а не специально написанного (<foreignphrase>ad hoc</foreignphrase>) кода, для определения этих значений. (Примите к сведению, однако, что в соединениях, основанных на протоколе версии до 3.0, изменение <varname>client_encoding</varname> посредством команды <command>SET</command> после начала процедуры подключения не будет отражаться функцией <function>PQparameterStatus</function>.) Сведения о <varname>server_version</varname> приведены также в описании функции <function>PQserverVersion</function>, возвращающей информацию в числовой форме, в которой гораздо легче выполнять сравнение.</para>

      <para>Если для <varname>standard_conforming_strings</varname> не передано никакого значения, то приложения могут принять его равным <literal>off</literal>. Это означает, что символы обратной косой черты в строковых литералах интерпретируются в качестве спецсимволов. Также, наличие этого параметра может рассматриваться как указание на то, что синтаксис escape-строк (<literal>E'...'</literal>) является приемлемым.</para>

      <para>Хотя возвращаемый указатель объявлен со спецификатором <literal>const</literal>, фактически он указывает на изменяемое хранилище, связанное со структурой <literal>PGconn</literal>. Не стоит рассчитывать на то, что указатель останется действительным при последующих запросах.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprotocolversion">
     <term>
      <function>PQprotocolVersion</function>
      <indexterm><primary>PQprotocolVersion</primary></indexterm>
     </term>

     <listitem>
      <para>Запрашивает протокол, используемый между клиентом и сервером. <synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis> Приложения могут использовать эту функцию, чтобы определить, поддерживаются ли опредёленные функциональные возможности. В настоящее время возможными значениями являются 2 (протокол версии 2.0), 3 (протокол версии 3.0) или ноль (проблемы в подключении). Версия протокола не будет изменяться после завершения процедуры подключения, но теоретически она могла бы измениться в процессе переподключения. Версия протокола 3.0 обычно используется при взаимодействии с серверами <productname>PostgreSQL</productname> версии 7.4 или более поздними; серверы до версии 7.4 поддерживают только протокол версии 2.0. (Протокол версии 1.0 является устаревшим и не поддерживается библиотекой <application>libpq</application>.)</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqserverversion">
     <term>
      <function>PQserverVersion</function>
      <indexterm><primary>PQserverVersion</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает целое число, представляющее версию сервера. <synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis> Приложения могут использовать эту функцию, чтобы определить версию сервера баз данных, к которому они подключены. Число формируется путём преобразования номеров старшей, младшей и корректирующей версий в двузначные десятичные числа и соединения их вместе. Например, для версии 8.1.5 будет возвращено число 80105, а для версии 8.2 будет возвращено число 80200 (ведущие нули не показаны). Если соединение не работает, то возвращается ноль.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqerrormessage">
     <term>
      <function>PQerrorMessage</function>
      <indexterm><primary>PQerrorMessage</primary></indexterm>
     </term>

     <listitem>
      <para><indexterm><primary>сообщение об ошибке</primary></indexterm> Возвращает сообщение об ошибке, наиболее недавно сгенерированное операцией, выполненной в рамках текущего подключения. <synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis></para>

      <para>Почти все функции библиотеки <application>libpq</application> в случае сбоя сформируют сообщение для <function>PQerrorMessage</function>. Обратите внимание, что по соглашениям, принятым в <application>libpq</application>, непустой результат функции <function>PQerrorMessage</function> может состоять из нескольких строк и будет включать завершающий символ новой строки. Вызывающая функция не должна освобождать память, на которую указывает возвращаемое значение, напрямую. Она будет освобождена, когда связанный с ней дескриптор <structname>PGconn</structname> будет передан функции <function>PQfinish</function>. Не стоит ожидать, что результирующая строка останется той же самой при выполнении нескольких операций со структурой <literal>PGconn</literal>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</primary></indexterm></term>
     <listitem>
      <para>Получает номер файлового дескриптора для сокета соединения с сервером. Действительный дескриптор будет больше или равен 0; значение -1 показывает, что в данный момент не открыто ни одного соединения с сервером. (Значение не изменится во время обычной работы, но может измениться во время установки или переустановки подключения.) <synopsis>
int PQsocket(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqselect">
     <term><function>PQselect</function><indexterm><primary>PQselect</primary></indexterm></term>
     <listitem>
      <para>Вызывает select(2) для наблюдения за несколькими файловыми дескрипторами в ожидании доступности одного или нескольких из этих дескрипторов для некоторого вида операций ввода/вывода (например, для чтения). <synopsis>
int PQselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout, int isRsocket);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqselectextended">
     <term><function>PQselectExtended</function><indexterm><primary>PQselectExtended</primary></indexterm></term>
     <listitem>
      <para>Вызывает select(2) или poll(2) для ожидания ввода. В аргументе <literal>timeout</literal> указывается число миллисекунд, на которое <function>PQselectExtended</function> должна заблокироваться в ожидании готовности файлового дескриптора подключения. Отрицательное значение в аргументе <literal>timeout</literal> обозначает бесконечный таймаут. Если в аргументе <literal>timeout</literal> передаётся 0, функция <function>poll()</function> завершается немедленно. <synopsis>
int PQselectExtended(const PGconn *conn, int timeout_ms);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbackendpid">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</primary></indexterm></term>
     <listitem>
      <para>Возвращает <acronym>ID</acronym> (PID)<indexterm><primary>PID</primary> <secondary>определение PID серверного процесса</secondary> <tertiary>в libpq</tertiary></indexterm> серверного процесса, обрабатывающего это подключение. <synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis></para>

      <para><acronym>PID</acronym> серверного процесса полезен для отладочных целей и для сопоставления с сообщениями команды <command>NOTIFY</command> (которые включают <acronym>PID</acronym> уведомляющего серверного процесса). Примите к сведению, что <acronym>PID</acronym> принадлежит процессу, выполняющемуся на компьютере сервера баз данных, а не на локальном компьютере.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionneedspassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</primary></indexterm></term>
     <listitem>
      <para>Возвращает true (1), если метод аутентификации соединения требовал пароля, однако он не был предоставлен. Возвращает false (0), если пароль не требовался. <synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis></para>

      <para>Эту функцию можно применить после неудачной попытки подключения, чтобы решить, нужно ли предлагать пользователю ввести пароль.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionusedpassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</primary></indexterm></term>
     <listitem>
      <para>Возвращает true (1), если метод аутентификации соединения использовал пароль. Возвращает false (0) в противном случае. <synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis></para>

      <para>Эту функцию можно применить как после неудачной, так и после успешной попытки подключения, чтобы определить, требовал ли сервер предоставления пароля.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>Следующие функции возвращают информацию, относящуюся к SSL. Эта информация обычно не меняется после того, как подключение установлено. <variablelist>
    <varlistentry id="libpq-pqsslinuse">
     <term><function>PQsslInUse</function><indexterm><primary>PQsslInUse</primary></indexterm></term>
     <listitem>
      <para>Возвращает true (1), если для текущего подключения используется SSL, и false (0) в противном случае. <synopsis>
int PQsslInUse(const PGconn *conn);
</synopsis></para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslattribute">
     <term><function>PQsslAttribute</function><indexterm><primary>PQsslAttribute</primary></indexterm></term>
     <listitem>
      <para>Возвращает связанную с SSL информацию о соединении. <synopsis>
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
</synopsis></para>

      <para>Список доступных атрибутов зависит от применяемой библиотеки SSL и типа подключения. Если атрибут недоступен, возвращается NULL.</para>

      <para>Обычно доступны следующие атрибуты: <variablelist>
        <varlistentry>
         <term><literal>library</literal></term>
          <listitem>
           <para>Имя используемой реализации SSL. (В настоящее время поддерживается только <literal>"OpenSSL"</literal>)</para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>protocol</literal></term>
          <listitem>
           <para>Применяемая версия SSL/TLS. Наиболее распространены варианты <literal>"SSLv2"</literal>, <literal>"SSLv3"</literal>, <literal>"TLSv1"</literal>, <literal>"TLSv1.1"</literal> и <literal>"TLSv1.2"</literal>, но реализация может возвращать и другие строки, если применяется какой-то другой протокол.</para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>key_bits</literal></term>
          <listitem>
           <para>Число бит в ключе, используемом алгоритмом шифрования.</para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>cipher</literal></term>
          <listitem>
           <para>Краткое имя применяемого комплекта шифров, например: <literal>"DHE-RSA-DES-CBC3-SHA"</literal>. Эти имена могут быть разными в разных реализациях SSL.</para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>compression</literal></term>
          <listitem>
           <para>Если применяется сжатие SSL, возвращает имя алгоритма сжатия, либо "on", если сжатие используется, но его алгоритм неизвестен. Если сжатие не применяется, возвращает "off".</para>
          </listitem>
         </varlistentry>
       </variablelist></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslattributenames">
     <term><function>PQsslAttributeNames</function><indexterm><primary>PQsslAttributeNames</primary></indexterm></term>
     <listitem>
      <para>Возвращает массив имён доступных атрибутов SSL. Завершается массив указателем NULL. <synopsis>
const char * const * PQsslAttributeNames(const PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslstruct">
     <term><function>PQsslStruct</function><indexterm><primary>PQsslStruct</primary></indexterm></term>
     <listitem>
      <para>Возвращает указатель на специфичный для реализации SSL объект, описывающий подключение. <synopsis>
void *PQsslStruct(const PGconn *conn, const char *struct_name);
</synopsis></para>
      <para>Доступная структура (или структуры) зависит от того, какая реализация SSL применяется. Для OpenSSL выдаётся одна структура под именем "OpenSSL", и эта структура, на которую указывает возвращённый указатель, имеет тип <literal>SSL</literal> (определённый в OpenSSL). Для обращения к этой функции можно воспользоваться кодом в следующих строках: <programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQsslStruct(dbconn, "OpenSSL");
    if (ssl)
    {
        /* use OpenSSL functions to access ssl */
    }
]]></programlisting></para>
      <para>Эта структура может использоваться, чтобы сличить уровни шифрования, проверить сертификаты сервера и т. д. За информацией об этой структуре обратитесь к документации по <productname>OpenSSL</productname>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetssl">
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</primary></indexterm></term>
     <listitem>
      <para><indexterm><primary>SSL</primary> <secondary sortas="libpq">в libpq</secondary></indexterm> Возвращает структуру SSL, использовавшуюся в соединении, или null, если SSL не используется. <synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis></para>

      <para>Эта функция равнозначна <literal>PQsslStruct(conn, "OpenSSL")</literal>. Её не следует применять в новых приложениях, так как возвращаемая структура специфична для OpenSSL и её нельзя будет получить с другой реализацией SSL. Чтобы проверить, использует ли подключение SSL, лучше вызвать <function>PQsslInUse</function>, а чтобы получить свойства подключения — <function>PQsslAttribute</function>.</para>
     </listitem>
    </varlistentry>

   </variablelist></para>

 </sect1>

 <sect1 id="libpq-exec">
  <title>Функции для исполнения команд</title>

  <para>После того как соединение с сервером было успешно установлено, функции, описанные в этом разделе, используются для выполнения SQL-запросов и команд.</para>

  <sect2 id="libpq-exec-main">
   <title>Главные функции</title>

   <para><variablelist>
     <varlistentry id="libpq-pqexec">
      <term>
       <function>PQexec</function>
       <indexterm><primary>PQexec</primary></indexterm>
      </term>

      <listitem>
       <para>Передаёт команду серверу и ожидает результата. <synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis></para>

       <para>Возвращает указатель на <structname>PGresult</structname> или, возможно, пустой указатель (null). Как правило, возвращается непустой указатель, исключением являются ситуации нехватки памяти или серьёзные ошибки, такие, как невозможность отправки команды серверу. Для проверки возвращаемого значения на наличие ошибок следует вызывать функцию <function>PQresultStatus</function> (в случае нулевого указателя она возвратит <symbol>PGRES_FATAL_ERROR</symbol>). Для получения дополнительной информации о таких ошибках используйте функцию <function>PQerrorMessage</function>.</para>
      </listitem>
     </varlistentry>
    </variablelist> Строка команды может включать в себя более одной SQL-команды (которые разделяются точкой с запятой). Несколько запросов, отправленных с помощью одного вызова <function>PQexec</function>, обрабатываются в рамках одной транзакции, если только команды <command>BEGIN</command>/<command>COMMIT</command> не включены явно в строку запроса, чтобы разделить его на несколько транзакций. Обратите внимание, однако, что возвращаемая структура <structname>PGresult</structname> описывает только результат последней из выполненных команд, содержащихся в строке запроса. Если одна из команд завершается сбоем, то обработка строки запроса на этом останавливается, и возвращённая структура <structname>PGresult</structname> описывает состояние ошибки.</para>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecparams">
      <term>
       <function>PQexecParams</function>
       <indexterm><primary>PQexecParams</primary></indexterm>
      </term>

      <listitem>
       <para>Отправляет команду серверу и ожидает результата. Имеет возможность передать параметры отдельно от текста SQL-команды. <synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis></para>

       <para><function>PQexecParams</function> подобна <function>PQexec</function>, но предлагает дополнительную функциональность: значения параметров могут быть указаны отдельно от самой строки-команды, а результаты запроса могут быть затребованы либо в текстовом, либо в двоичном формате. <function>PQexecParams</function> поддерживается только при подключениях по протоколу версии 3.0 или более поздних версий. Её вызов завершится сбоем при использовании протокола версии 2.0.</para>

       <para>Параметры функции следующие: <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
           <para>Объект, описывающий подключение, через которое пересылается команда.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <para>Строка SQL-команды, которая должна быть выполнена. Если используются параметры, то в строке команды на них ссылаются, как <literal>$1</literal>, <literal>$2</literal> и т. д.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <para>Число предоставляемых параметров. Оно равно длине массивов <parameter>paramTypes[]</parameter>, <parameter>paramValues[]</parameter>, <parameter>paramLengths[]</parameter> и <parameter>paramFormats[]</parameter>. (Указатели на массивы могут быть равны <symbol>NULL</symbol>, когда <parameter>nParams</parameter> равно нулю.)</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <para>Предписывает, посредством OID, типы данных, которые должны быть назначены параметрам. Если значение <parameter>paramTypes </parameter> равно <symbol>NULL</symbol> или какой-либо отдельный элемент в массиве равен нулю, тогда сервер самостоятельно определит тип данных для параметра точно таким же образом, как он сделал бы для литеральной строки, тип которой не указан.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <para>Указывает фактические значения параметров. Нулевой указатель в этом массиве означает, что соответствующий параметр равен null; в противном случае указатель указывает на текстовую строку, завершающуюся нулевым символом (для текстового формата), или на двоичные данные в формате, которого ожидает сервер (для двоичного формата).</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <para>Указывает фактические длины данных для параметров, представленных в двоичном формате. Он игнорируется для параметров, имеющих значение null, и для параметров, представленных в текстовом формате. Указатель на массив может быть нулевым, когда нет двоичных параметров.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <para>Указывает, являются ли параметры текстовыми (поместите нуль в элемент массива, соответствующий такому параметру) или двоичными (поместите единицу в элемент массива, соответствующий такому параметру). Если указатель на массив является нулевым, тогда все параметры считаются текстовыми строками.</para>
           <para>Значения, переданные в двоичном формате, требуют знания внутреннего представления, которого ожидает сервер. Например, целые числа должны передаваться с использованием сетевого порядка байтов. Передача значений типа <type>numeric</type> требует знания того формата, в котором их хранит сервер, как это реализовано в <filename>src/backend/utils/adt/numeric.c::numeric_send()</filename> и <filename>src/backend/utils/adt/numeric.c::numeric_recv()</filename>.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <para>Требует указать ноль, чтобы получить результаты в текстовом формате, или единицу, чтобы получить результаты в двоичном формате. (В настоящее время нет возможности получить различные столбцы результата в разных форматах, хотя это и возможно на уровне протокола, лежащего в основе подключений.)</para>
          </listitem>
         </varlistentry>
        </variablelist></para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>Важнейшим преимуществом <function>PQexecParams</function> над <function>PQexec</function> является то, что значения параметров могут быть отделены от строки-команды. Это позволяет избежать использования кавычек и экранирующих символов, что является трудоёмким методом, часто приводящим к ошибкам.</para>

   <para>В отличие от <function>PQexec</function>, <function>PQexecParams</function> позволяет включать не более одной SQL-команды в строку запроса. (В ней могут содержаться точки с запятой, однако может присутствовать не более одной непустой команды.) Это ограничение накладывается базовым протоколом, но оно приносит и некоторую пользу в качестве дополнительной защиты от атак методом SQL-инъекций.</para>

   <tip>
    <para>Указание типов параметров с помощью OID является трудоёмким, особенно если вы предпочитаете не указывать явно значений OID в вашей программе. Однако, вы можете избежать этого даже в случаях, когда сервер самостоятельно не может определить тип параметра или выбирает не тот тип, который вы хотите. В строке SQL-команды добавьте явное приведение типа для этого параметра, чтобы показать, какой тип данных вы будете отправлять. Например: <programlisting>SELECT * FROM mytable WHERE x = $1::bigint;</programlisting> Это приведёт к тому, что параметр <literal>$1</literal> будет считаться имеющим тип <type>bigint</type>, в то время как по умолчанию ему был бы назначен тот же самый тип, что и <literal>x</literal>. Такое явное принятие решения о типе параметра либо с помощью описанного метода, либо путём задания числового OID строго рекомендуется, когда значения параметров отправляются в двоичном формате, поскольку двоичный формат имеет меньшую избыточность, чем текстовый, и поэтому гораздо менее вероятно, что сервер обнаружит ошибку несоответствия типов, допущенную вами.</para>
   </tip>

   <para><variablelist>
     <varlistentry id="libpq-pqprepare">
      <term><function>PQprepare</function>
       <indexterm><primary>PQprepare</primary></indexterm>
      </term>

      <listitem>
       <para>Отправляет запрос, чтобы создать подготовленный оператор с конкретными параметрами, и ожидает завершения. <synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis></para>

       <para><function>PQprepare</function> создаёт подготовленный оператор для последующего исполнения с помощью <function>PQexecPrepared</function>. Благодаря этому, команды, которые будут выполняться многократно, не потребуется разбирать и планировать каждый раз; за подробностями обратитесь к <xref remap="3" linkend="sql-prepare"/>. <function>PQprepare</function> поддерживается только с подключениями по протоколу 3.0 и новее; с протоколом 2.0 эта функция работать не будет.</para>

       <para>Функция создаёт подготовленный оператор с именем <parameter>stmtName</parameter> из строки <parameter>query</parameter>, которая должна содержать единственную SQL-команду. <parameter>stmtName</parameter> может быть пустой строкой <literal>""</literal>, тогда будет создан неименованный оператор (в таком случае любой уже существующий неименованный оператор будет автоматически заменён), в противном случае, если имя оператора уже определено в текущем сеансе работы, будет ошибка. Если используются параметры, то в запросе к ним обращаются таким образом: <literal>$1</literal>, <literal>$2</literal> и т. д. <parameter>nParams</parameter> представляет число параметров, типы данных для которых указаны в массиве <parameter>paramTypes[]</parameter>. (Указатель на массив может быть равен <symbol>NULL</symbol>, когда значение <parameter>nParams</parameter> равно нулю.) <parameter>paramTypes[]</parameter> указывает, посредством OID, типы данных, которые будут назначены параметрам. Если <parameter>paramTypes</parameter> равен <symbol>NULL</symbol> или какой-либо элемент в этом массиве равен нулю, то сервер назначает тип данных соответствующему параметру точно таким же способом, как он сделал бы для литеральной строки, не имеющей типа. Также в запросе можно использовать параметры с номерами, большими, чем <parameter>nParams</parameter>; типы данных для них сервер также сможет подобрать. (См. описание <function>PQdescribePrepared</function>, где сказано, какие существуют средства, чтобы определить, какие типы данных были подобраны).</para>

       <para>Как и при вызове <function>PQexec</function>, результатом является объект <structname>PGresult</structname>, содержимое которого показывает успех или сбой на стороне сервера. Нулевой указатель означает нехватку памяти или невозможность вообще отправить команду. Для получения дополнительной информации о таких ошибках используйте <function>PQerrorMessage</function>.</para>
      </listitem>
     </varlistentry>
    </variablelist> Подготовленные операторы для использования с <function>PQexecPrepared</function> можно также создать путём исполнения SQL-команд <xref linkend="sql-prepare"/>. Также, хотя никакой функции <application>libpq</application> для удаления подготовленного оператора не предусмотрено, для этой цели можно воспользоваться SQL-командой <xref linkend="sql-deallocate"/>.</para>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecprepared">
      <term>
       <function>PQexecPrepared</function>
       <indexterm><primary>PQexecPrepared</primary></indexterm>
      </term>

      <listitem>
       <para>Отправляет запрос на исполнение подготовленного оператора с данными параметрами и ожидает результата. <synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis></para>

       <para><function>PQexecPrepared</function> подобна <function>PQexecParams</function>, но команда, подлежащая исполнению, указывается путём передачи имени предварительно подготовленного оператора вместо передачи строки запроса. Эта возможность позволяет командам, которые вызываются многократно, подвергаться разбору и планированию только один раз, а не при каждом их исполнении. Оператор должен быть подготовлен предварительно в рамках текущего сеанса работы. <function>PQexecPrepared</function> поддерживается только в соединениях по протоколу версии 3.0 или более поздних версий. При использовании протокола версии 2.0 функция завершится сбоем.</para>

       <para>Параметры идентичны <function>PQexecParams</function>, за исключением того, что вместо строки запроса передаётся имя подготовленного оператора, и отсутствует параметр <parameter>paramTypes[]</parameter> (он не нужен, поскольку типы данных для параметров подготовленного оператора были определены при его создании).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeprepared">
      <term>
       <function>PQdescribePrepared</function>
       <indexterm><primary>PQdescribePrepared</primary></indexterm>
      </term>

      <listitem>
       <para>Передаёт запрос на получение информации об указанном подготовленном операторе и ожидает завершения. <synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis></para>

       <para><function>PQdescribePrepared</function> позволяет приложению получить информацию о предварительно подготовленном операторе. <function>PQdescribePrepared</function> поддерживается только в соединениях по протоколу версии 3.0 или более поздних версий. При использовании протокола версии 2.0 функция завершится сбоем.</para>

       <para>Для ссылки на неименованный оператор значение <parameter>stmtName</parameter> может быть пустой строкой <literal>""</literal> или <symbol>NULL</symbol>, в противном случае оно должно быть именем существующего подготовленного оператора. В случае успешного выполнения возвращается <structname>PGresult</structname> со статусом <literal>PGRES_COMMAND_OK</literal>. Функции <function>PQnparams</function> и <function>PQparamtype</function> позволяют извлечь из <structname>PGresult</structname> информацию о параметрах подготовленного оператора, а функции <function>PQnfields</function>, <function>PQfname</function>, <function>PQftype</function> и т. п. предоставляют информацию о результирующих столбцах (если они есть) данного оператора.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeportal">
      <term>
       <function>PQdescribePortal</function>
       <indexterm><primary>PQdescribePortal</primary></indexterm>
      </term>

      <listitem>
       <para>Передаёт запрос на получение информации об указанном портале и ожидает завершения. <synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis></para>

       <para><function>PQdescribePortal</function> позволяет приложению получить информацию о предварительно созданном портале. (<application>libpq</application> не предоставляет прямого доступа к порталам, но вы можете использовать эту функцию для ознакомления со свойствами курсора, созданного с помощью SQL-команды <command>DECLARE CURSOR</command>.) <function>PQdescribePortal</function> поддерживается только в соединениях по протоколу версии 3.0 или более поздних версий. При использовании протокола версии 2.0 функция завершится сбоем.</para>

       <para>Для ссылки на неименованный портал значение <parameter>portalName</parameter> может быть пустой строкой <literal>""</literal> или <symbol>NULL</symbol>, в противном случае оно должно быть именем существующего портала. В случае успешного завершения возвращается <structname>PGresult</structname> со статусом <literal>PGRES_COMMAND_OK</literal>. С помощью функций <function>PQnfields</function>, <function>PQfname</function>, <function>PQftype</function> и т. д. можно извлечь из <structname>PGresult</structname> информацию о результирующих столбцах (если они есть) данного портала.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>Структура <structname>PGresult</structname><indexterm><primary>PGresult</primary></indexterm> содержит результат, возвращённый сервером. Разработчики приложений <application>libpq</application> должны тщательно поддерживать абстракцию <structname>PGresult</structname>. Для получения доступа к содержимому <structname>PGresult</structname> используйте функции доступа, описанные ниже. Избегайте непосредственного обращения к полям структуры <structname>PGresult</structname>, поскольку они могут измениться в будущем. <variablelist>
     <varlistentry id="libpq-pqresultstatus">
      <term>
       <function>PQresultStatus</function>
       <indexterm><primary>PQresultStatus</primary></indexterm>
      </term>

      <listitem>
       <para>Возвращает статус результата выполнения команды. <synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis></para>

       <para><function>PQresultStatus</function> может возвращать одно из следующих значений: <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
           <para>Строка, отправленная серверу, была пустой.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <para>Успешное завершение команды, не возвращающей никаких данных.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <para>Успешное завершение команды, возвращающей данные (такой, как <command>SELECT</command> или <command>SHOW</command>).</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <para>Начат перенос данных Copy Out (с сервера).</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <para>Начат перенос данных Copy In (на сервер).</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <para>Ответ сервера не был распознан.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <para>Произошла не фатальная ошибка (уведомление или предупреждение).</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <para>Произошла фатальная ошибка.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <para>Начат перенос данных Copy In/Out (на сервер и с сервера). Эта функция в настоящее время используется только для потоковой репликации, поэтому такой статус не должен иметь место в обычных приложениях.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <para>Структура <structname>PGresult</structname> содержит только одну результирующую строку, возвращённую текущей командой. Этот статус имеет место только тогда, когда для данного запроса был выбран режим построчного вывода (см. <xref remap="4" linkend="libpq-single-row-mode"/>).</para>
          </listitem>
         </varlistentry>
        </variablelist> Если статус результата <literal>PGRES_TUPLES_OK</literal> или <literal>PGRES_SINGLE_TUPLE</literal>, тогда для извлечения строк, возвращённых запросом, можно использовать функции, описанные ниже. Обратите внимание, что команда <command>SELECT</command>, даже когда она не извлекает ни одной строки, всё же показывает <literal>PGRES_TUPLES_OK</literal>. <literal>PGRES_COMMAND_OK</literal> предназначен для команд, которые никогда не возвращают строки (<command>INSERT</command> или <command>UPDATE</command> без использования предложения <literal>RETURNING</literal> и др.). Ответ <literal>PGRES_EMPTY_QUERY</literal> может указывать на наличие ошибки в клиентском программном обеспечении.</para>

       <para>Результат со статусом <symbol>PGRES_NONFATAL_ERROR</symbol> никогда не будет возвращён напрямую функцией <function>PQexec</function> или другими функциями исполнения запросов; вместо этого результаты такого вида передаются обработчику уведомлений (см. <xref remap="4" linkend="libpq-notice-processing"/>).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresstatus">
      <term>
       <function>PQresStatus</function>
       <indexterm><primary>PQresStatus</primary></indexterm>
      </term>

      <listitem>
       <para>Преобразует значение перечислимого типа, возвращённое функцией <function>PQresultStatus</function>, в строковую константу, описывающую код статуса. Вызывающая функция не должна освобождать память, на которую указывает возвращаемый указатель. <synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis></para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrormessage">
      <term>
       <function>PQresultErrorMessage</function>
       <indexterm><primary>PQresultErrorMessage</primary></indexterm>
      </term>

      <listitem>
       <para>Возвращает сообщение об ошибке, связанное с командой, или пустую строку, если ошибки не произошло. <synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis> Если произошла ошибка, то возвращённая строка будет включать завершающий символ новой строки. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель <structname>PGresult</structname> будет передан функции <function>PQclear</function>.</para>

       <para>Если непосредственно после вызова <function>PQexec</function> или <function>PQgetResult</function> вызвать функцию <function>PQerrorMessage</function> (для данного подключения), то она возвратит ту же самую строку, что и <function>PQresultErrorMessage</function> (для данного результата). Однако, <structname>PGresult</structname> сохранит своё сообщение об ошибке до тех пор, пока не будет уничтожен, в то время, как сообщение об ошибке, связанное с данным подключением, будет изменяться при выполнении последующих операций. Воспользуйтесь функцией <function>PQresultErrorMessage</function>, когда вы хотите узнать статус, связанный с конкретной структурой <structname>PGresult</structname>; используйте функцию <function>PQerrorMessage</function>, когда вы хотите узнать статус выполнения самой последней операции на данном соединении.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresultverboseerrormessage">
      <term>
       <function>PQresultVerboseErrorMessage</function>
       <indexterm><primary>PQresultVerboseErrorMessage</primary></indexterm>
      </term>

      <listitem>
       <para>Возвращает переформатированную версию сообщения об ошибке, связанного с объектом <structname>PGresult</structname>. <synopsis>
char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);
</synopsis> В некоторых ситуациях клиент может захотеть получить более подробную версию ранее выданного сообщения об ошибке. Эту потребность удовлетворяет функция <function>PQresultVerboseErrorMessage</function>, формируя сообщение, которое было бы выдано функцией <function>PQresultErrorMessage</function>, если бы заданный уровень детализации был текущим для соединения в момент заполнения <structname>PGresult</structname>. Если же в <structname>PGresult</structname> не содержится ошибка, вместо этого выдаётся сообщение <quote>PGresult is not an error result</quote> (PGresult — не результат с ошибкой). Возвращаемое этой функцией сообщение завершается переводом строки.</para>

       <para>В отличие от многих других функций, извлекающих данные из <structname>PGresult</structname>, результат этой функции — новая размещённая в памяти строка. Когда эта строка будет не нужна, вызывающий код должен освободить её место, вызвав <function>PQfreemem()</function>.</para>

       <para>При нехватке памяти может быть возвращёно NULL.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrorfield">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</primary></indexterm></term>
      <listitem>
       <para>Возвращает индивидуальное поле из отчёта об ошибке. <synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis> <parameter>fieldcode</parameter> это идентификатор поля ошибки; см. символические константы, перечисленные ниже. Если <structname>PGresult</structname> не содержит ошибки или предупреждения или не включает указанное поле, то возвращается <symbol>NULL</symbol>. Значения полей обычно не включают завершающий символ новой строки. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель <structname>PGresult</structname> будет передан функции <function>PQclear</function>.</para>

       <para>Доступны следующие коды полей: <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</symbol></term>
          <listitem>
           <para>Серьёзность; поле может содержать <literal>ERROR</literal>, <literal>FATAL</literal> или <literal>PANIC</literal> (в сообщении об ошибке) либо <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, <literal>INFO</literal> или <literal>LOG</literal> (в сообщении-уведомлении) либо локализованный перевод одного из этих значений. Присутствует всегда.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-severity-nonlocalized">
          <term><symbol>PG_DIAG_SEVERITY_NONLOCALIZED</symbol></term>
          <listitem>
           <para>Серьёзность; поле может содержать <literal>ERROR</literal>, <literal>FATAL</literal> или <literal>PANIC</literal> (в сообщении об ошибке) либо <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, <literal>INFO</literal> или <literal>LOG</literal> (в сообщении-уведомлении). Это поле подобно <symbol>PG_DIAG_SEVERITY</symbol>, но его содержимое никогда не переводится. Присутствует только в отчётах, выдаваемых <productname>&productname;</productname> версии 9.6 и новее.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term>
           <symbol>PG_DIAG_SQLSTATE</symbol>
          <indexterm><primary>коды ошибок</primary> <secondary>libpq</secondary></indexterm>
          </term>
          <listitem>
           <para>Код ошибки в соответствии с соглашением о кодах SQLSTATE. Код SQLSTATE идентифицирует тип случившейся ошибки; он может использоваться клиентскими приложениями, чтобы выполнять конкретные операции (такие, как обработка ошибок) в ответ на конкретную ошибку базы данных. Список возможных кодов SQLSTATE приведён в <xref remap="6" linkend="errcodes-appendix"/>. Это поле не подлежит локализации. Оно всегда присутствует.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</symbol></term>
          <listitem>
           <para>Главное сообщение об ошибке, предназначенное для прочтения пользователем. Как правило составляет всего одну строку. Это поле всегда присутствует.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</symbol></term>
          <listitem>
           <para>Необязательное дополнительное сообщение об ошибке, передающее более детальную информацию о проблеме. Может занимать несколько строк.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</symbol></term>
          <listitem>
           <para>Подсказка: необязательное предположение о том, что можно сделать в данной проблемной ситуации. Оно должно отличаться от детальной информации в том смысле, что оно предлагает совет (возможно, и неподходящий), а не просто факты. Может занимать несколько строк.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</symbol></term>
          <listitem>
           <para>Строка, содержащая десятичное целое число, указывающее позицию расположения ошибки в качестве индекса в оригинальной строке оператора. Первый символ имеет позицию 1, при этом позиции измеряются в символах а не в байтах.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</symbol></term>
          <listitem>
           <para>Это поле определяется точно так же, как и поле <symbol>PG_DIAG_STATEMENT_POSITION</symbol>, но оно используется, когда позиция местонахождения ошибки относится к команде, сгенерированной внутренними модулями, а не к команде, представленной клиентом. Когда появляется это поле, то всегда появляется и поле <symbol>PG_DIAG_INTERNAL_QUERY</symbol>.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</symbol></term>
          <listitem>
           <para>Текст команды, сгенерированной внутренними модулями, завершившейся сбоем. Это мог бы быть, например, SQL-запрос, выданный функцией на языке PL/pgSQL.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</symbol></term>
          <listitem>
           <para>Характеристика контекста, в котором произошла ошибка. В настоящее время она включает вывод стека вызовов активных функций процедурного языка и запросов, сгенерированных внутренними модулями. Стек выводится по одному элементу в строке, при этом первым идет самый последний из элементов (самый недавний вызов).</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</symbol></term>
          <listitem>
           <para>Если ошибка была связана с конкретным объектом базы данных, то в это поле будет записано имя схемы, содержащей данный объект.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</symbol></term>
          <listitem>
           <para>Если ошибка была связана с конкретной таблицей, то в это поле будет записано имя таблицы. (Для получения имени схемы для данной таблицы обратитесь к полю, содержащему имя схемы.)</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</symbol></term>
          <listitem>
           <para>Если ошибка была связана с конкретным столбцом таблицы, то в это поле будет записано имя столбца. (Чтобы идентифицировать таблицу, обратитесь к полям, содержащим имена схемы и таблицы.)</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</symbol></term>
          <listitem>
           <para>Если ошибка была связана с конкретным типом данных, то в это поле будет записано имя типа данных. (Чтобы получить имя схемы, которой принадлежит этот тип данных, обратитесь к полю, содержащему имя схемы.)</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</symbol></term>
          <listitem>
           <para>Если ошибка была связана с конкретным ограничением, то в это поле будет записано имя ограничения. Чтобы получить имя таблицы или домена, связанных с этим ограничением, обратитесь к полям, перечисленным выше. (С этой целью индексы рассматриваются как ограничения, даже если они и не были созданы с помощью синтаксиса для создания ограничений.)</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</symbol></term>
          <listitem>
           <para>Имя файла, содержащего позицию в исходном коде, для которой было выдано сообщение об ошибка.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</symbol></term>
          <listitem>
           <para>Номер строки той позиции в исходном коде, для которой было выдано сообщение об ошибке.</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</symbol></term>
          <listitem>
           <para>Имя функции в исходном коде, сообщающей об ошибке.</para>
          </listitem>
         </varlistentry>
        </variablelist></para>

       <note>
        <para>Поля для имени схемы, имени таблицы, имени столбца, имени типа данных и имени ограничения предоставляются лишь для ограниченного числа типов ошибок; см. <xref remap="4" linkend="errcodes-appendix"/>. Не рассчитывайте на то, что присутствие любого из этих полей гарантирует и присутствие какого-то другого поля. Базовые источники ошибок придерживаются взаимосвязей, описанных выше, но функции, определённые пользователем, могут использовать эти поля другими способами. Аналогично, не рассчитывайте на то, что эти поля обозначают объекты, существующие в текущей базе данных в настоящий момент.</para>
       </note>

       <para>Клиент отвечает за форматирование отображаемой информации в соответствии с его нуждами; в частности, он должен разбивать длинные строки, как требуется. Символы новой строки, встречающиеся в полях сообщения об ошибке, должны обрабатываться, как разрывы абзацев, а не строк.</para>

       <para>Ошибки, сгенерированные внутренними модулями <application>libpq</application>, будут иметь поля серьёзности ошибки и основного сообщения, но, как правило, никаких других полей. Ошибки, возвращаемые сервером, работающим по протоколу версии ниже 3.0, будут включать поля серьёзности ошибки и основного сообщения, а также иногда детальное сообщение, но больше никаких полей.</para>

       <para>Заметьте, что поля ошибки доступны только из объектов <structname>PGresult</structname>, а не из объектов <structname>PGconn</structname>. Не существует функции <function>PQerrorField</function>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</primary></indexterm></term>
      <listitem>
       <para>Освобождает область памяти, связанную с <structname>PGresult</structname>. Результат выполнения каждой команды должен быть освобождён с помощью <function>PQclear</function>, когда он больше не нужен. <synopsis>
void PQclear(PGresult *res);
</synopsis></para>

       <para>Вы можете держать объект <structname>PGresult</structname> под рукой до тех пор, пока он вам нужен; он не исчезает, ни когда вы выдаёте новую команду, ни даже если вы закрываете соединение. Чтобы от него избавиться, вы должны вызвать <function>PQclear</function>. Если этого не делать, то в результате будут иметь место утечки памяти в вашем приложении.</para>
      </listitem>
     </varlistentry>
    </variablelist></para>
  </sect2>

  <sect2 id="libpq-exec-select-info">
   <title>Извлечение информации, связанной с результатом запроса</title>

   <para>Эти функции служат для извлечения информации из объекта <structname>PGresult</structname>, который представляет результат успешного запроса (то есть такого, который имеет статус <literal>PGRES_TUPLES_OK</literal> или <literal>PGRES_SINGLE_TUPLE</literal>). Их также можно использовать для извлечения информации об успешной операции DESCRIBE: результат этой операции содержит всю ту же самую информацию о столбцах, которая была бы получена при реальном исполнении запроса, но не содержит ни одной строки. Для объектов, имеющих другие значения статуса, эти функции будут действовать таким образом, как будто результат не содержит ни одной строки и ни одного столбца.</para>

   <variablelist>
    <varlistentry id="libpq-pqntuples">
     <term>
      <function>PQntuples</function>
      <indexterm><primary>PQntuples</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает число строк (кортежей) в полученной выборке. (Заметьте, что объекты <structname>PGresult</structname> не могут содержать более чем <literal>INT_MAX</literal> строк, так что для результата достаточно типа <type>int</type>.) <synopsis>
int PQntuples(const PGresult *res);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnfields">
     <term>
      <function>PQnfields</function>
      <indexterm><primary>PQnfields</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает число столбцов (полей) в каждой строке полученной выборки. <synopsis>
int PQnfields(const PGresult *res);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfname">
     <term>
      <function>PQfname</function>
      <indexterm><primary>PQfname</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает имя столбца, соответствующего данному номеру столбца. Номера столбцов начинаются с 0. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <structname>PGresult</structname> будет передан функции <function>PQclear</function>. <synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis></para>

      <para>Если номер столбца выходит за пределы допустимого диапазона, то возвращается <symbol>NULL</symbol>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfnumber">
     <term>
      <function>PQfnumber</function>
      <indexterm><primary>PQfnumber</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает номер столбца, соответствующий данному имени столбца. <synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis></para>

      <para>Если данное имя не совпадает с именем ни одного из столбцов, то возвращается -1.</para>

      <para>Данное имя интерпретируется, как идентификатор в SQL-команде. Это означает, что оно переводится в нижний регистр, если только оно не заключено в двойные кавычки. Например, для выборки, сгенерированной с помощью такой SQL-команды: <programlisting>SELECT 1 AS FOO, 2 AS "BAR";</programlisting> мы получили бы следующие результаты: <programlisting>PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation></programlisting></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftable">
     <term>
      <function>PQftable</function>
      <indexterm><primary>PQftable</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает OID таблицы, из которой был получен данный столбец. Номера столбцов начинаются с 0. <synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis></para>

      <para>В следующих случаях возвращается <literal>InvalidOid</literal>: если номер столбца выходит за пределы допустимого диапазона; если указанный столбец не является простой ссылкой на столбец таблицы; когда используется протокол версии более ранней, чем 3.0. Вы можете сделать запрос к системной таблице <literal>pg_class</literal>, чтобы точно определить, к какой таблице было произведено обращение.</para>

      <para>Тип данных <type>Oid</type> и константа <literal>InvalidOid</literal> будут определены, когда вы включите заголовочный файл для <application>libpq</application>. Они будут принадлежать к одному из целочисленных типов.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftablecol">
     <term>
      <function>PQftablecol</function>
      <indexterm><primary>PQftablecol</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает номер столбца (в пределах его таблицы) для указанного столбца в полученной выборке. Номера столбцов в полученной выборке начинаются с 0, но столбцы в таблице имеют ненулевые номера. <synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis></para>

      <para>В следующих случаях возвращается ноль: если номер столбца выходит за пределы допустимого диапазона; если указанный столбец не является простой ссылкой на столбец таблицы; когда используется протокол версии более ранней, чем 3.0.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat">
     <term>
      <function>PQfformat</function>
      <indexterm><primary>PQfformat</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает код формата, показывающий формат данного столбца. Номера столбцов начинаются с 0. <synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis></para>

      <para>Значение кода формата, равное нулю, указывает на текстовое представление данных, в то время, как значение, равное единице, означает двоичное представление. (Другие значения кодов зарезервированы для определения в будущем.)</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftype">
     <term>
      <function>PQftype</function>
      <indexterm><primary>PQftype</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает тип данных, соответствующий данному номеру столбца. Возвращаемое целое значение является внутренним номером OID для этого типа. Номера столбцов начинаются с 0. <synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis></para>

      <para>Вы может сделать запрос к системной таблице <literal>pg_type</literal>, чтобы получить имена и свойства различных типов данных. Значения <acronym>OID</acronym> для встроенных типов данных определены в файле <filename>src/include/catalog/pg_type.h</filename> в дереве исходных кодов.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfmod">
     <term>
      <function>PQfmod</function>
      <indexterm><primary>PQfmod</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает модификатор типа для столбца, соответствующего данному номеру. Номера столбцов начинаются с 0. <synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis></para>

      <para>Интерпретация значений модификатора зависит от типа; они обычно показывают точность или предельные размеры. Значение -1 используется, чтобы показать <quote>нет доступной информации</quote>. Большинство типов данных не используют модификаторов, в таком случае значение всегда будет -1.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfsize">
     <term>
      <function>PQfsize</function>
      <indexterm><primary>PQfsize</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает размер в байтах для столбца, соответствующего данному номеру. Номера столбцов начинаются с 0. <synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis></para>

      <para><function>PQfsize</function> возвращает размер пространства, выделенного для этого столбца в строке базы данных, другими словами, это размер внутреннего представления этого типа данных на сервере. (Следовательно, эта информация не является по-настоящему полезной для клиентов.) Отрицательное значение говорит о том, что тип данных имеет переменную длину.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm><primary>PQbinaryTuples</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает 1, если <structname>PGresult</structname> содержит двоичные данные, или 0, если данные текстовые. <synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis></para>

      <para>Эта функция не рекомендуется к использованию (за исключением применения в связи с командой <command>COPY</command>), поскольку один и тот же <structname>PGresult</structname> может содержать в некоторых столбцах текстовые данные, а в остальных &mdash; двоичные. Предпочтительнее использовать <function>PQfformat</function>. <function>PQbinaryTuples</function> возвращает 1, только если все столбцы в выборке являются двоичными (код формата 1).</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetvalue">
     <term>
      <function>PQgetvalue</function>
       <indexterm><primary>PQgetvalue</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает значение одного поля из одной строки, содержащейся в <structname>PGresult</structname>. Номера строк и столбцов начинаются с 0. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <structname>PGresult</structname> будет передан функции <function>PQclear</function>.  <synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis></para>

      <para>Для данных в текстовом формате значение, возвращаемое функцией <function>PQgetvalue</function>, является значением поля, представленным в виде символьной строки с завершающим нулевым символом. Для данных в двоичном формате используется двоичное представление значения. Оно определяется функциями <function>typsend</function> и <function>typreceive</function> для конкретного типа данных. (В этом случае к значению также добавляется нулевой байт, но обычно это не приносит пользы, поскольку вероятно, что значение уже содержит нулевые байты.)</para>

      <para>Пустая строка возвращается в том случае, когда значение поля отсутствует (null). См. <function>PQgetisnull</function>, чтобы отличать отсутствие значения (null) от значения, равного пустой строке.</para>

      <para>Указатель, возвращаемый функцией <function>PQgetvalue</function>, указывает на область хранения, которая является частью структуры <structname>PGresult</structname>. Не следует модифицировать данные, на которые указывает этот указатель, а нужно явно скопировать данные в другую область хранения, если предполагается их использовать за пределами времени жизни самой структуры <structname>PGresult</structname>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetisnull">
     <term>
      <function>PQgetisnull</function>
      <indexterm><primary>PQgetisnull</primary></indexterm>
      <indexterm><primary>значение NULL</primary> <secondary sortas="libpq">в libpq</secondary></indexterm>
     </term>

     <listitem>
      <para>Проверяет поле на предмет отсутствия значения (null). Номера строк и столбцов начинаются с 0. <synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis></para>

      <para>Эта функция возвращает 1, если значение в поле отсутствует (null), и 0, если поле содержит непустое (non-null) значение. (Обратите внимание, что <function>PQgetvalue</function> возвратит пустую строку, а не нулевой указатель, если значение в поле отсутствует.)</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlength">
     <term>
     <function>PQgetlength</function>
     <indexterm><primary>PQgetlength</primary></indexterm></term>

     <listitem>
      <para>Возвращает фактическую длину значения поля в байтах. Номера строк и столбцов начинаются с 0. <synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis></para>

      <para>Это фактическая длина данных для конкретного значения данных, то есть размер объекта, на который указывает <function>PQgetvalue</function>. Для текстового формата данных это то же самое, что <function>strlen()</function>. Для двоичного же формата это существенная информация. Обратите внимание, что <emphasis>не</emphasis> следует полагаться на <function>PQfsize</function>, чтобы получить фактическую длину данных.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnparams">
     <term>
      <function>PQnparams</function>
      <indexterm><primary>PQnparams</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает число параметров подготовленного оператора. <synopsis>
int PQnparams(const PGresult *res);
</synopsis></para>

      <para>Эта функция полезна только при исследовании результата работы функции <function>PQdescribePrepared</function>. Для других типов запросов она возвратит ноль.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparamtype">
     <term>
      <function>PQparamtype</function>
      <indexterm><primary>PQparamtype</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает тип данных для указанного параметра оператора. Номера параметров начинаются с 0. <synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis></para>

      <para>Эта функция полезна только при исследовании результата работы функции <function>PQdescribePrepared</function>. Для других типов запросов она возвратит ноль.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprint">
     <term>
      <function>PQprint</function>
      <indexterm><primary>PQprint</primary></indexterm>
     </term>

     <listitem>
      <para>Выводит все строки и, по выбору, имена столбцов в указанный поток вывода. <synopsis>
void PQprint(FILE *fout,      /* поток вывода */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* печатать заголовки полей и счётчик строк */
    pqbool  align;       /* выравнивать поля */
    pqbool  standard;    /* старый формат */
    pqbool  html3;       /* выводить HTML-таблицы */
    pqbool  expanded;    /* расширять таблицы */
    pqbool  pager;       /* использовать программу для постраничного просмотра, если нужно */
    char    *fieldSep;   /* разделитель полей */
    char    *tableOpt;   /* атрибуты для HTML-таблицы */
    char    *caption;    /* заголовок HTML-таблицы */
    char    **fieldName; /* массив заменителей для имён полей, завершающийся нулевым символом */
} PQprintOpt;
</synopsis></para>

      <para>Эту функцию прежде использовала утилита <application>psql</application> для вывода результатов запроса, но больше она её не использует. Обратите внимание, предполагается, что все данные представлены в текстовом формате.</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-exec-nonselect">
   <title>Получение другой информации о результате</title>

   <para>Эти функции используются для получения остальной информации из объектов <structname>PGresult</structname>.</para>

   <variablelist>
    <varlistentry id="libpq-pqcmdstatus">
     <term>
      <function>PQcmdStatus</function>
      <indexterm><primary>PQcmdStatus</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает дескриптор статуса для SQL-команды, которая сгенерировала <structname>PGresult</structname>. <synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis></para>

      <para>Как правило, это просто имя команды, но могут быть включены и дополнительные сведения, такие, как число обработанных строк. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <structname>PGresult</structname> будет передан функции <function>PQclear</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcmdtuples">
     <term>
      <function>PQcmdTuples</function>
      <indexterm><primary>PQcmdTuples</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает число строк, которые затронула SQL-команда. <synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis></para>

      <para>Эта функция возвращает строковое значение, содержащее число строк, которые затронул <acronym>SQL</acronym>-оператор, сгенерировавший данный <structname>PGresult</structname>. Эту функцию можно использовать только сразу после выполнения команд <command>SELECT</command>, <command>CREATE TABLE AS</command>, <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>, <command>MOVE</command>, <command>FETCH</command> или <command>COPY</command>, а также после оператора <command>EXECUTE</command>, выполнившего подготовленный запрос, содержащий команды <command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</command>. Если команда, которая сгенерировала <structname>PGresult</structname>, была какой-то иной, то <function>PQcmdTuples</function> возвращает пустую строку. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <structname>PGresult</structname> будет передан функции <function>PQclear</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidvalue">
     <term>
      <function>PQoidValue</function>
      <indexterm><primary>PQoidValue</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает OID<indexterm><primary>OID</primary> <secondary>в libpq</secondary></indexterm> вставленной строки, если <acronym>SQL</acronym>-команда была командой <command>INSERT</command>, которая вставила ровно одну строку в таблицу, имеющую идентификаторы OID, или командой <command>EXECUTE</command>, которая выполнила подготовленный запрос, содержащий соответствующий оператор <command>INSERT</command>. В противном случае эта функция возвращает <literal>InvalidOid</literal>. Эта функция также возвратит <literal>InvalidOid</literal>, если таблица, затронутая командой <command>INSERT</command>, не содержит идентификаторов OID. <synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidstatus">
     <term>
      <function>PQoidStatus</function>
      <indexterm><primary>PQoidStatus</primary></indexterm>
     </term>

     <listitem>
      <para>Эта функция считается не рекомендуемой к использованию (в качестве замены служит <function>PQoidValue</function>), а также она не отвечает требованиям потоковой безопасности. Она возвращает строковое значение, содержащее OID вставленной строки, в то время как <function>PQoidValue</function> возвращает значение OID. <synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis></para>

     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-exec-escape-string">
   <title>Экранирование строковых значений для включения в SQL-команды</title>

   <indexterm zone="libpq-exec-escape-string"><primary>экранированные строки</primary> <secondary>в libpq</secondary></indexterm>

   <variablelist>
    <varlistentry id="libpq-pqescapeliteral">
     <term>
      <function>PQescapeLiteral</function>
      <indexterm><primary>PQescapeLiteral</primary></indexterm>
     </term>

     <listitem>
     <para>
<synopsis>char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);</synopsis>
     </para>

     <para><function>PQescapeLiteral</function> экранирует строковое значение для использования внутри SQL-команды. Это полезно при вставке в SQL-команды значений данных в виде литеральных констант. Определённые символы (такие, как кавычки и символы обратной косой черты) должны экранироваться, чтобы предотвратить их специальную интерпретацию синтаксическим анализатором языка SQL. <function>PQescapeLiteral</function> выполняет эту операцию.</para>

     <para><function>PQescapeLiteral</function> возвращает экранированную версию параметра <parameter>str</parameter>, размещённую в области памяти, распределённой с помощью функции <function>malloc()</function>. Эту память нужно освобождать с помощью функции <function>PQfreemem()</function>, когда возвращённое значение больше не требуется. Завершающий нулевой байт не нужен и не должен учитываться в параметре <parameter>length</parameter>. (Если завершающий нулевой байт был найден до того, как были обработаны <parameter>length</parameter> байтов, то <function>PQescapeLiteral</function> останавливает работу на нулевом байте; таким образом, поведение функции напоминает <function>strncpy</function>.) В возвращённой строке все специальные символы заменены таким образом, что синтаксический анализатор строковых литералов <productname>&productname;</productname> может обработать их должным образом. Завершающий нулевой байт также будет добавлен. Одинарные кавычки, которые должны окружать строковые литералы <productname>&productname;</productname>, включаются в результирующую строку.</para>

     <para>В случае ошибки <function>PQescapeLiteral</function> возвращает <symbol>NULL</symbol>, и в объект <parameter>conn</parameter> помещается соответствующее сообщение.</para>

     <tip>
      <para>Особенно важно выполнять надлежащее экранирование при обработке строк, полученных из ненадёжных источников. В противном случае ваша безопасность подвергается риску из-за уязвимости в отношении атак с использованием <quote>SQL-инъекций</quote>, с помощью которых нежелательные SQL-команды направляются в вашу базу данных.</para>
     </tip>

     <para>Обратите внимание, что нет необходимости (и это будет даже некорректно) экранировать значения данных, передаваемых в виде отдельных параметров в функцию <function>PQexecParams</function> или родственные ей функции.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapeidentifier">
     <term>
      <function>PQescapeIdentifier</function>
      <indexterm><primary>PQescapeIdentifier</primary></indexterm>
     </term>

     <listitem>
     <para>
<synopsis>char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);</synopsis>
     </para>

     <para><function>PQescapeIdentifier</function> экранирует строку, предназначенную для использования в качестве идентификатора SQL, такого, как таблица, столбец или имя функции. Это полезно, когда идентификатор, выбранный пользователем, может содержать специальные символы, которые в противном случае не интерпретировались бы синтаксическим анализатором SQL, как часть идентификатора, или когда идентификатор может содержать символы верхнего регистра, и этот регистр требуется сохранить.</para>

     <para><function>PQescapeIdentifier</function> возвращает версию параметра <parameter>str</parameter>, экранированную как SQL-идентификатор, и размещённую в области памяти, распределённой с помощью функции <function>malloc()</function>. Эту память нужно освобождать с помощью функции <function>PQfreemem()</function>, когда возвращённое значение больше не требуется. Завершающий нулевой байт не нужен и не должен учитываться в параметре <parameter>length</parameter>. (Если завершающий нулевой байт был найден до того, как были обработаны <parameter>length</parameter> байтов, то <function>PQescapeIdentifier</function> останавливает работу на нулевом байте; таким образом, поведение функции напоминает <function>strncpy</function>.) В возвращённой строке все специальные символы заменены таким образом, что она будет надлежащим образом обработана, как SQL-идентификатор. Завершающий нулевой байт также будет добавлен. Возвращённая строка также будет заключена в двойные кавычки.</para>

     <para>В случае ошибки <function>PQescapeIdentifier</function> возвращает <symbol>NULL</symbol>, и в объект <parameter>conn</parameter> помещается соответствующее сообщение.</para>

     <tip>
      <para>Как и в случае со строковыми литералами, для того чтобы предотвратить атаки с помощью SQL-инъекций, SQL-идентификаторы должны экранироваться, когда они получены из ненадёжного источника.</para>
     </tip>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestringconn">
     <term>
      <function>PQescapeStringConn</function>
      <indexterm><primary>PQescapeStringConn</primary></indexterm>
     </term>

     <listitem>
     <para>
<synopsis>size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);</synopsis>
     </para>

     <para><function>PQescapeStringConn</function> экранирует строковые литералы наподобие <function>PQescapeLiteral</function>. Но, в отличие от <function>PQescapeLiteral</function>, за предоставление буфера надлежащего размера отвечает вызывающая функция. Более того, <function>PQescapeStringConn</function> не добавляет одинарные кавычки, которые должны окружать строковые литералы <productname>&productname;</productname>; они должны быть включены в SQL-команду, в которую вставляется результирующая строка. Параметр <parameter>from</parameter> указывает на первый символ строки, которая должна экранироваться, а параметр <parameter>length</parameter> задаёт число байтов в этой строке. Завершающий нулевой байт не требуется и не должен учитываться в параметре <parameter>length</parameter>. (Если завершающий нулевой байт был найден до того, как были обработаны <parameter>length</parameter> байтов, то <function>PQescapeStringConn</function> останавливает работу на нулевом байте; таким образом, поведение функции напоминает <function>strncpy</function>.) Параметр <parameter>to</parameter> должен указывать на буфер, который сможет вместить как минимум на один байт больше, чем предписывает удвоенное значение параметра <parameter>length</parameter>, в противном случае поведение функции не определено. Поведение будет также не определено, если строки <parameter>to</parameter> и <parameter>from</parameter> перекрываются.</para>

     <para>Если параметр <parameter>error</parameter> не равен <symbol>NULL</symbol>, тогда значение <literal>*error</literal> устанавливается равным нулю в случае успешной работы и не равным нулю в случае ошибки. В настоящее время единственным возможным условием возникновения ошибки является неверная мультибайтовая кодировка в исходной строке. Выходная строка формируется даже при наличии ошибки, но можно ожидать, что сервер отвергнет её как неверно сформированную. В случае ошибки в объект <parameter>conn</parameter> записывается соответствующее сообщение независимо от того, равно ли <symbol>NULL</symbol> значение параметра <parameter>error</parameter>.</para>

     <para><function>PQescapeStringConn</function> возвращает число байтов, записанных по адресу <parameter>to</parameter>, не включая завершающий нулевой байт.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestring">
     <term>
      <function>PQescapeString</function>
      <indexterm><primary>PQescapeString</primary></indexterm>
     </term>

     <listitem>
     <para><function>PQescapeString</function> является более старой, не рекомендованной к использованию версией функции <function>PQescapeStringConn</function>. <synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis></para>

     <para>Единственное отличие от <function>PQescapeStringConn</function> состоит в том, что функция <function>PQescapeString</function> не принимает <structname>PGconn</structname> или <parameter>error</parameter> в качестве параметров. Из-за этого она не может скорректировать своё поведение в зависимости от свойств подключения (таких, как кодировка символов) и, следовательно, <emphasis>она может выдавать неверные результаты</emphasis>. Также она не имеет способа сообщить об ошибках.</para>

     <para><function>PQescapeString</function> может безопасно использоваться в клиентских программах, которые работают лишь с одним подключением к <productname>&productname;</productname> за один раз (в этом случае функция может найти то, что ей нужно знать, <quote>за кулисами</quote>). В других контекстах её использование несёт в себе угрозу безопасности и его следует избегать в пользу применения функции <function>PQescapeStringConn</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebyteaconn">
     <term>
      <function>PQescapeByteaConn</function>
      <indexterm><primary>PQescapeByteaConn</primary></indexterm>
     </term>

     <listitem>
     <para>Экранирует двоичные данные для их использования внутри SQL-команды с типом данных <type>bytea</type>. Как и в случае с <function>PQescapeStringConn</function>, эта функция применяется только тогда, когда данные вставляются непосредственно в строку SQL-команды. <synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis></para>

      <para>Байты, имеющие определённые значения, должны экранироваться, когда они используются в качестве составной части литерала, имеющего тип <type>bytea</type>, в <acronym>SQL</acronym>-операторе. <function>PQescapeByteaConn</function> экранирует байты, используя либо hex-кодирование, либо экранирование с помощью обратной косой черты. См. <xref remap="4" linkend="datatype-binary"/> для получения дополнительной информации.</para>

      <para>Параметр <parameter>from</parameter> указывает на первый байт строки, которая должна экранироваться, а параметр <parameter>from_length</parameter> задаёт число байтов в этой двоичной строке. (Завершающий нулевой байт не нужен и не учитывается.) Параметр <parameter>to_length</parameter> указывает на переменную, которая будет содержать длину результирующей экранированной строки. Эта длина включает завершающий нулевой байт результирующей строки.</para>

      <para><function>PQescapeByteaConn</function> возвращает экранированную версию двоичной строки, на которую указывает параметр <parameter>from</parameter>, и размещает её в памяти, распределённой с помощью <function>malloc()</function>. Эта память должна быть освобождена с помощью функции <function>PQfreemem()</function>, когда результирующая строка больше не нужна. В возвращаемой строке все специальные символы заменены так, чтобы синтаксический анализатор литеральных строк <productname>&productname;</productname> и функция ввода для типа <type>bytea</type> могли обработать их надлежащим образом. Завершающий нулевой байт также добавляется. Одинарные кавычки, которые должны окружать строковые литералы <productname>&productname;</productname>, не являются частью результирующей строки.</para>

      <para>В случае ошибки возвращается нулевой указатель, и соответствующее сообщение об ошибке записывается в объект <parameter>conn</parameter>. В настоящее время единственной возможной ошибкой может быть нехватка памяти для результирующей строки.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebytea">
     <term>
      <function>PQescapeBytea</function>
      <indexterm><primary>PQescapeBytea</primary></indexterm>
     </term>

     <listitem>
      <para><function>PQescapeBytea</function> является более старой, не рекомендуемой к использованию версией функции <function>PQescapeByteaConn</function>. <synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis></para>

      <para>Единственное отличие от <function>PQescapeByteaConn</function> состоит в том, что функция <function>PQescapeBytea</function> не принимает <structname>PGconn</structname> в качестве параметра. Из-за этого <function>PQescapeBytea</function> может безопасно использоваться в клиентских программах, которые работают лишь с одним подключением к <productname>&productname;</productname> за один раз (в этом случае функция может найти то, что ей нужно знать, <quote>за кулисами</quote>). Она <emphasis>может выдавать неверные результаты</emphasis> при использовании в программах, которые формируют множественные подключения к базе данных (в таких случаях используйте <function>PQescapeByteaConn</function>).</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqunescapebytea">
     <term>
      <function>PQunescapeBytea</function>
      <indexterm><primary>PQunescapeBytea</primary></indexterm>
     </term>

     <listitem>
      <para>Преобразует строковое представление двоичных данных в двоичные данные &mdash; является обратной функцией к функции <function>PQescapeBytea</function>. Она нужна, когда данные типа <type>bytea</type> извлекаются в текстовом формате, но не когда они извлекаются в двоичном формате. <synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis></para>

      <para>Параметр <parameter>from</parameter> указывает на строку, такую, какую могла бы возвратить функция <function>PQgetvalue</function>, применённая к столбцу типа <type>bytea</type>. <function>PQunescapeBytea</function> преобразует это строковое представление в его двоичное представление. Она возвращает указатель на буфер, распределённый с помощью функции <function>malloc()</function> (или <symbol>NULL</symbol> в случае ошибки) и помещает размер буфера по адресу <parameter>to_length</parameter>. Когда результат не будет нужен, необходимо освободить его память, вызвав <function>PQfreemem</function>.</para>

      <para>Это преобразование не является точной инверсией для <function>PQescapeBytea</function>, поскольку ожидается, что строка, полученная от <function>PQgetvalue</function>, не будет <quote>экранированной</quote>. В частности, это означает, что учитывать режим спецпоследовательностей не нужно, и поэтому в параметре нет необходимости <structname>PGconn</structname>.</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-async">
  <title>Асинхронная обработка команд</title>

  <indexterm zone="libpq-async"><primary>неблокирующее соединение</primary></indexterm>

  <para>Функция <function>PQexec</function> хорошо подходит для отправки команд серверу в нормальных, синхронных приложениях. Однако, она имеет ряд недостатков, которые могут иметь значение для некоторых пользователей: <itemizedlist>
    <listitem>
     <para><function>PQexec</function> ожидает завершения выполнения команды. Приложение может иметь и другую работу, которую нужно делать (такую, как поддержание пользовательского интерфейса), в таком случае оно не захочет блокироваться, ожидая ответа.</para>
    </listitem>

    <listitem>
     <para>Поскольку выполнение клиентского приложения приостанавливается, пока оно ожидает результата, то приложению трудно решить, что оно хотело бы попытаться отменить выполняющуюся команду. (Это можно сделать из обработчика сигнала, но никак иначе.)</para>
    </listitem>

    <listitem>
     <para><function>PQexec</function> может возвратить только одну структуру <structname>PGresult</structname>. Если отправленная серверу строка-команда содержит множественные <acronym>SQL</acronym>-команды, то все структуры <structname>PGresult</structname>, кроме последней, отбрасываются функцией <function>PQexec</function>.</para>
    </listitem>

    <listitem>
     <para><function>PQexec</function> всегда собирает все результаты выполнения команды, буферизуя их в единственной структуре <structname>PGresult</structname>. В то время как для приложения это упрощает логику обработки ошибок, это может быть непрактично, когда результат содержит много строк.</para>
    </listitem>
   </itemizedlist></para>

  <para>Приложения, которым эти ограничения не подходят, могут вместо <function>PQexec</function> использовать базовые функции, на основе которых и построена функция <function>PQexec</function>: <function>PQsendQuery</function> и <function>PQgetResult</function>. Есть также функции <function>PQsendQueryParams</function>, <function>PQsendPrepare</function>, <function>PQsendQueryPrepared</function>, <function>PQsendDescribePrepared</function> и <function>PQsendDescribePortal</function>, которые можно использовать совместно с <function>PQgetResult</function>, чтобы продублировать функциональность <function>PQexecParams</function>, <function>PQprepare</function>, <function>PQexecPrepared</function>, <function>PQdescribePrepared</function> и <function>PQdescribePortal</function> соответственно. <variablelist>
    <varlistentry id="libpq-pqsendquery">
     <term>
      <function>PQsendQuery</function>
      <indexterm><primary>PQsendQuery</primary></indexterm>
     </term>

     <listitem>
      <para>Отправляет команду серверу, не ожидая получения результата. Если команда была отправлена успешно, то функция возвратит значение 1, в противном случае она возвратит 0 (тогда нужно воспользоваться функцией <function>PQerrorMessage</function> для получения дополнительной информации о сбое). <synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis> После успешного вызова <function>PQsendQuery</function> вызовите <function>PQgetResult</function> один или несколько раз, чтобы получить результат. Функцию <function>PQsendQuery</function> нельзя вызвать повторно (на том же самом соединении) до тех пор, пока <function>PQgetResult</function> не вернёт нулевой указатель, означающий, что выполнение команды завершено.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryparams">
     <term>
      <function>PQsendQueryParams</function>
      <indexterm><primary>PQsendQueryParams</primary></indexterm>
     </term>

     <listitem>
      <para>Отправляет серверу команду и обособленные параметры, не ожидая получения результатов. <synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis> Эта функция эквивалентна функции <function>PQsendQuery</function>, за исключением того, что параметры запроса можно указать отдельно от самой строки запроса. Эта функция обрабатывает свои параметры точно так же, как и функция <function>PQexecParams</function>. Аналогично функции <function>PQexecParams</function>, данная функция не будет работать при подключениях по протоколу версии 2.0, также она позволяет включить только одну команду в строку запроса.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendprepare">
     <term>
      <function>PQsendPrepare</function>
      <indexterm><primary>PQsendPrepare</primary></indexterm>
     </term>

     <listitem>
      <para>Посылает запрос на создание подготовленного оператора с данными параметрами и не дожидается завершения его выполнения.<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis> Это асинхронная версия функции <function>PQprepare</function>. Она возвращает 1, если ей удалось отправить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию <function>PQgetResult</function>, чтобы определить, успешно ли создал сервер подготовленный оператор. Эта функция обрабатывает свои параметры точно так же, как и функция <function>PQprepare</function>. Аналогично функции <function>PQprepare</function>, данная функция не будет работать при подключениях по протоколу версии 2.0.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryprepared">
     <term>
      <function>PQsendQueryPrepared</function>
      <indexterm><primary>PQsendQueryPrepared</primary></indexterm>
     </term>

     <listitem>
      <para>Посылает запрос на выполнение подготовленного оператора с данными параметрами, не ожидая получения результата. <synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis> Эта функция подобна функции <function>PQsendQueryParams</function>, но команда, которая должна быть выполнена, задаётся путём указания предварительно подготовленного оператора, вместо задания строки запроса. Эта функция обрабатывает свои параметры точно так же, как и функция <function>PQexecPrepared</function>. Аналогично функции <function>PQexecPrepared</function>, данная функция не будет работать при подключениях по протоколу версии 2.0.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeprepared">
     <term>
      <function>PQsendDescribePrepared</function>
      <indexterm><primary>PQsendDescribePrepared</primary></indexterm>
     </term>

     <listitem>
      <para>Отправляет запрос на получение информации об указанном подготовленном операторе и не дожидается завершения выполнения запроса. <synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis> Это асинхронная версия функции <function>PQdescribePrepared</function>. Она возвращает 1, если ей удалось отправить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию <function>PQgetResult</function> для получения результата. Эта функция обрабатывает свои параметры точно так же, как и функция <function>PQdescribePrepared</function>. Аналогично функции <function>PQdescribePrepared</function>, данная функция не будет работать при подключениях по протоколу версии 2.0.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeportal">
     <term>
      <function>PQsendDescribePortal</function>
      <indexterm><primary>PQsendDescribePortal</primary></indexterm>
     </term>

     <listitem>
      <para>Отправляет запрос на получение информации об указанном портале и не дожидается завершения выполнения запроса. <synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis> Это асинхронная версия функции <function>PQdescribePortal</function>. Она возвращает 1, если ей удалось отправить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию <function>PQgetResult</function> для получения результата. Эта функция обрабатывает свои параметры точно так же, как и функция <function>PQdescribePortal</function>. Аналогично функции <function>PQdescribePortal</function>, данная функция не будет работать при подключениях по протоколу версии 2.0.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetresult">
     <term>
      <function>PQgetResult</function>
      <indexterm><primary>PQgetResult</primary></indexterm>
     </term>

     <listitem>
      <para>Ожидает получения следующего результата после предшествующего вызова <function>PQsendQuery</function>, <function>PQsendQueryParams</function>, <function>PQsendPrepare</function>, <function>PQsendQueryPrepared</function>, <function>PQsendDescribePrepared</function> или <function>PQsendDescribePortal</function> и возвращает его. Когда команда завершена и результатов больше не будет, тогда возвращается нулевой указатель. <synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis></para>

      <para>Функция <function>PQgetResult</function> должна вызываться повторно до тех пор, пока она не вернёт нулевой указатель, означающий, что команда завершена. (Если она вызвана, когда нет ни одной активной команды, тогда <function>PQgetResult</function> просто возвратит нулевой указатель сразу же.) Каждый ненулевой результат, полученный от <function>PQgetResult</function>, должен обрабатываться с помощью тех же самых функций доступа к структуре <structname>PGresult</structname>, которые были описаны выше. Не забывайте освобождать память, занимаемую каждым результирующим объектом, с помощью функции <function>PQclear</function>, когда работа с этим объектом закончена. Обратите внимание, что <function>PQgetResult</function> заблокируется, только если какая-либо команда активна, а необходимые ответные данные ещё не были прочитаны функцией <function>PQconsumeInput</function>.</para>

      <note>
       <para>Даже когда <function>PQresultStatus</function> показывает фатальную ошибку, все равно следует вызывать функцию <function>PQgetResult</function> до тех пор, пока она не возвратит нулевой указатель, чтобы позволить <application>libpq</application> полностью обработать информацию об ошибке.</para>
      </note>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>Использование <function>PQsendQuery</function> и <function>PQgetResult</function> решает одну из проблем <function>PQexec</function>: если строка команды содержит несколько <acronym>SQL</acronym>-команд, то результаты каждой из них можно получить индивидуально. (Между прочим, это позволяет организовать частичное совмещение обработки: клиент может обрабатывать результаты одной команды, в то время как сервер ещё работает с более поздними запросами, содержащимися в той же самой строке-команде.)</para>

  <para>Ещё одной часто требующейся функциональной возможностью, которую можно получить с помощью <function>PQsendQuery</function> и <function>PQgetResult</function>, является извлечение больших выборок по одной строке за раз. Это обсуждается в <xref remap="6" linkend="libpq-single-row-mode"/>.</para>

  <para>Сам по себе вызов <function>PQgetResult</function> всё же заставит клиента заблокироваться до те пор, пока сервер не завершит выполнение следующей <acronym>SQL</acronym>-команды. Этого можно избежать с помощью надлежащего использования ещё двух функций: <variablelist>
    <varlistentry id="libpq-pqconsumeinput">
     <term>
      <function>PQconsumeInput</function>
      <indexterm><primary>PQconsumeInput</primary></indexterm>
     </term>

     <listitem>
      <para>Если сервер готов передать данные, принять их. <synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis></para>

      <para><function>PQconsumeInput</function> обычно возвращает 1, показывая, что <quote>ошибки нет</quote>, но возвращает 0, если имела место какая-либо проблема (в таком случае можно обратиться к функции <function>PQerrorMessage</function> за уточнением). Обратите внимание, что результат не говорит, были ли какие-либо входные данные фактически собраны. После вызова функции <function>PQconsumeInput</function> приложение может проверить <function>PQisBusy</function> и/или <function>PQnotifies</function>, чтобы посмотреть, не изменилось ли их состояние.</para>

      <para><function>PQconsumeInput</function> можно вызвать, даже если приложение ещё не готово иметь дело с результатом или уведомлением. Функция прочитает доступные данные и сохранит их в буфере, при этом обрабатывая условие готовности к чтению функции <function>PQselect()</function>. Таким образом, приложение может использовать <function>PQconsumeInput</function>, чтобы немедленно обработать это состояние <function>PQselect()</function>, а изучать результаты позже.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisbusy">
     <term>
      <function>PQisBusy</function>
      <indexterm><primary>PQisBusy</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает 1, если команда занята работой, то есть функция <function>PQgetResult</function> была бы заблокирована в ожидании ввода. Возвращаемое значение 0 показывает, что функция <function>PQgetResult</function> при её вызове гарантированно не будет заблокирована. <synopsis>
int PQisBusy(PGconn *conn);
</synopsis></para>

      <para>Функция <function>PQisBusy</function> сама не будет пытаться прочитать данные с сервера; следовательно, сначала нужно вызвать <function>PQconsumeInput</function>, иначе состояние занятости никогда не прекратится.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>В типичном приложении, использующем эти функции, будет главный цикл, в котором <function>PQselect()</function> или <function>PQselectExtended()</function> служат для организации ожидания наступления всех условий, на которые цикл должен отвечать. Одним из условий будет наличие ввода, доступного от сервера, что в терминах функции <function>PQselect()</function> означает наличие данных, готовых для через файловый дескриптор, идентифицируемый с помощью <function>PQsocket</function>. Когда главный цикл обнаруживает ввод, готовый для чтения, он должен вызвать <function>PQconsumeInput</function>, чтобы прочитать этот ввод. Затем он может вызвать <function>PQisBusy</function>, а после неё уже <function>PQgetResult</function>, если <function>PQisBusy</function> возвратит ложное значение (0). Главный цикл может также вызвать <function>PQnotifies</function>, чтобы обнаружить сообщения <command>NOTIFY</command> (см. <xref remap="4" linkend="libpq-notify"/>).</para>

  <para>Клиент, который использует <function>PQsendQuery</function>/<function>PQgetResult</function>, может также попытаться отменить команду, которая всё ещё обрабатывается сервером; см. <xref remap="4" linkend="libpq-cancel"/>. Но, независимо от возвращаемого значения функции <function>PQcancel</function>, приложение должно продолжать обычную последовательность операций чтения результатов запроса, используя <function>PQgetResult</function>. Успешная отмена просто заставит команду завершиться раньше, чем она сделала бы в противном случае.</para>

  <para>Используя функции, описанные выше, можно избежать блокирования, ожидая ввода от сервера баз данных. Однако, всё же возможно, что приложение будет заблокировано в ожидании отправки вывода на сервер. Это бывает относительно нечасто, но может иметь место, если отправлены очень длинные SQL-команды или значения данных. (Однако, это значительно более вероятно, если приложение отправляет данные через команду <command>COPY IN</command>.) Чтобы предотвратить эту возможность и достичь совершенно неблокирующего режима работы с базой данных, можно использовать следующие дополнительные функции. <variablelist>
    <varlistentry id="libpq-pqsetnonblocking">
     <term>
      <function>PQsetnonblocking</function>
      <indexterm><primary>PQsetnonblocking</primary></indexterm>
     </term>

     <listitem>
      <para>Устанавливает неблокирующий статус подключения. <synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis></para>

      <para>Устанавливает состояние подключения как неблокирующее, если <parameter>arg</parameter> равен 1, или блокирующее, если <parameter>arg</parameter> равен 0. Возвращает 0 в случае успешного завершения и -1 в случае ошибки.</para>

      <para>В неблокирующем состоянии вызовы <function>PQsendQuery</function>, <function>PQputline</function>, <function>PQputnbytes</function>, <function>PQputCopyData</function> и <function>PQendcopy</function> не будут блокироваться, а вместо этого возвратят ошибку, если вызов должен быть повторным.</para>

      <para>Обратите внимание, что функция <function>PQexec</function> не соблюдает неблокирующий режим. Если она вызывается, она всё равно работает в блокирующем режиме.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisnonblocking">
     <term>
      <function>PQisnonblocking</function>
      <indexterm><primary>PQisnonblocking</primary></indexterm>
     </term>

     <listitem>
      <para>Возвращает режим блокирования для подключения базы данных. <synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis></para>

      <para>Возвращает 1, если подключение установлено в неблокирующем режиме, и 0, если режим блокирующий.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqflush">
     <term>
      <function>PQflush</function>
       <indexterm><primary>PQflush</primary></indexterm>
      </term>

      <listitem>
       <para>Пытается сбросить любые выходные данные, стоящие в очереди, на сервер. Возвращает 0 в случае успеха (или если очередь на отправку пуста), -1 в случае сбоя по какой-либо причине или 1, если она ещё не смогла отправить все данные, находящиеся в очереди (этот случай может иметь место, только если соединение неблокирующее). <synopsis>
int PQflush(PGconn *conn);
</synopsis></para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>После отправки любой команды или данных через неблокирующее подключение следует вызвать функцию <function>PQflush</function>. Если она возвратит 1, подождите, пока сокет станет готовым к чтению или записи. Если он станет готовым к записи, то вызовите <function>PQflush</function> снова. Если он станет готовым к чтению, то вызовите <function>PQconsumeInput</function>, а затем вызовите <function>PQflush</function> снова. Повторяйте до тех пор, пока <function>PQflush</function> не возвратит 0. (Необходимо выполнять проверку на состояние готовности к чтению и забирать входные данные с помощью <function>PQconsumeInput</function>, потому что сервер может заблокироваться, пытаясь отправить нам данные, например, сообщения NOTICE, и не будет читать наши данные до тех пор, пока мы не прочитаем его.) Как только <function>PQflush</function> возвратит 0, подождите, пока сокет не станет готовым к чтению, а затем прочитайте ответ, как описано выше.</para>

 </sect1>

 <sect1 id="libpq-single-row-mode">
  <title>Построчное извлечение результатов запроса</title>

  <indexterm zone="libpq-single-row-mode"><primary>libpq</primary> <secondary>однострочный режим</secondary></indexterm>

  <para>Обычно <application>libpq</application> собирает весь результат выполнения SQL-команды и возвращает его приложению в виде единственной структуры <structname>PGresult</structname>. Это может оказаться неприемлемым для команд, которые возвращают большое число строк. В таких случаях приложение может воспользоваться функциями <function>PQsendQuery</function> и <function>PQgetResult</function> в <firstterm>однострочном режиме</firstterm>. В этом режиме результирующие строки передаются приложению по одной за один раз, по мере того, как они принимаются от сервера.</para>

  <para>Для того чтобы войти в однострочный режим, вызовите <function>PQsetSingleRowMode</function> сразу же после успешного вызова функции <function>PQsendQuery</function> (или родственной функции). Выбор этого режима действителен только для текущего исполняющегося запроса. Затем повторно вызывайте функцию <function>PQgetResult</function> до тех пор, пока она не возвратит null, как описано в <xref linkend="libpq-async"/>. Если запрос возвращает какое-то число строк, то они возвращаются в виде индивидуальных объектов <structname>PGresult</structname>, которые выглядят, как обычные выборки, за исключением того, что их код статуса будет <literal>PGRES_SINGLE_TUPLE</literal> вместо <literal>PGRES_TUPLES_OK</literal>. После последней строки (или сразу же, если запрос не возвращает ни одной строки) будет возвращён объект, не содержащий ни одной строки и имеющий статус <literal>PGRES_TUPLES_OK</literal>; это сигнал о том, что строк больше не будет. (Но обратите внимание, что всё же необходимо продолжать вызывать функцию <function>PQgetResult</function>, пока она не возвратит значение null.) Все эти объекты <structname>PGresult</structname> будут содержать те же самые описательные данные (имена столбцов, типы и т. д.), которые имел бы обычный объект <structname>PGresult</structname>. Память, занимаемую каждым объектом, нужно освобождать с помощью <function>PQclear</function>, как обычно.</para>

  <para>
   <variablelist>
    <varlistentry id="libpq-pqsetsinglerowmode">
     <term>
      <function>PQsetSingleRowMode</function>
      <indexterm><primary>PQsetSingleRowMode</primary></indexterm>
     </term>

     <listitem>
      <para>Выбирает однострочный режим для текущего выполняющегося запроса. <synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis></para>

      <para>Эту функцию можно вызывать только непосредственно после функции <function>PQsendQuery</function> или одной из её родственных функций, до выполнения любой другой операции на этом подключении, такой, как <function>PQconsumeInput</function> или <function>PQgetResult</function>. Будучи вызванной своевременно, функция активирует однострочный режим для текущего запроса и возвращает 1. В противном случае режим остаётся не изменённым, а функция возвращает 0. В любом случае режим возвращается в нормальное состояние после завершения текущего запроса.</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <caution>
   <para>В процессе обработки запроса сервер может возвратить некоторое количество строк, а затем столкнуться с ошибкой, вынуждающей его аварийно завершить запрос. Обычно <application>libpq</application> отбрасывает такие строки и сообщает только об ошибке. Но в однострочном режиме эти строки уже будут возвращены приложению. Следовательно, приложение увидит ряд объектов <structname>PGresult</structname>, имеющих статус <literal>PGRES_SINGLE_TUPLE</literal>, за которыми последует объект со статусом <literal>PGRES_FATAL_ERROR</literal>. Для обеспечения надлежащего поведения транзакций приложение должно быть спроектировано таким образом, чтобы отбрасывать или отменять все операции, проведённые с уже обработанными строками, если запрос в конечном итоге завершается сбоем.</para>
  </caution>

 </sect1>

 <sect1 id="libpq-cancel">
  <title>Отмена запросов в процессе выполнения</title>

  <indexterm zone="libpq-cancel"><primary>отмена</primary> <secondary>SQL-команд</secondary></indexterm>

  <para>Клиентское приложение может запросить отмену команды, которая ещё обрабатывается сервером, используя функции, описанные в этом разделе. <variablelist>
    <varlistentry id="libpq-pqgetcancel">
     <term>
      <function>PQgetCancel</function>
      <indexterm><primary>PQgetCancel</primary></indexterm>
     </term>

     <listitem>
      <para>Создаёт структуру данных, содержащую информацию, необходимую для отмены команды, запущенной через конкретное подключение к базе данных.<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis></para>

      <para>Функция <function>PQgetCancel</function> создаёт объект <structname>PGcancel</structname><indexterm><primary>PGcancel</primary></indexterm>, получив объект <structname>PGconn</structname>, описывающий подключение. Она возвратит <symbol>NULL</symbol>, если данный параметр <parameter>conn</parameter> равен <symbol>NULL</symbol> или представляет собой недействительное подключения. Объект <structname>PGcancel</structname> является непрозрачной структурой, которая не предназначена для того, чтобы приложение обращалось к ней напрямую; её можно только передавать функции <function>PQcancel</function> или <function>PQfreeCancel</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfreecancel">
     <term>
      <function>PQfreeCancel</function>
      <indexterm><primary>PQfreeCancel</primary></indexterm>
     </term>

     <listitem>
      <para>Освобождает память, занимаемую структурой данных, созданной функцией <function>PQgetCancel</function>. <synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis></para>

      <para><function>PQfreeCancel</function> освобождает память, занимаемую объектом, предварительно созданным функцией <function>PQgetCancel</function>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcancel">
     <term>
      <function>PQcancel</function>
      <indexterm><primary>PQcancel</primary></indexterm>
     </term>

     <listitem>
      <para>Требует, чтобы сервер прекратил обработку текущей команды. <synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis></para>

      <para>Возвращаемое значение равно 1, если запрос на отмену был успешно отправлен, и 0 в противном случае. В случае неудачной отправки <parameter>errbuf</parameter> заполняется пояснительным сообщением об ошибке. <parameter>errbuf</parameter> должен быть массивом символов, имеющим размер <parameter>errbufsize</parameter> (рекомендуемый размер составляет 256 байтов).</para>

      <para>Успешная отправка ещё не является гарантией того, что запрос будет иметь какой-то эффект. Если отмена сработала, текущая команда завершится досрочно и возвратит в качестве результата ошибку. Если же отмена не получится (например, потому, что сервер уже завершил обработку команды), тогда вообще не будет видимого результата.</para>

      <para><function>PQcancel</function> можно безопасно вызывать из обработчика сигнала, если <parameter>errbuf</parameter> является локальной переменной в обработчике сигнала. Объект <structname>PGcancel</structname> доступен только в режиме чтения, пока речь идёт о функции <function>PQcancel</function>, поэтому её можно также вызывать из потока, отдельного от того, который управляет объектом <structname>PGconn</structname>.</para>
     </listitem>
    </varlistentry>
   </variablelist> <variablelist>
    <varlistentry id="libpq-pqrequestcancel">
     <term>
      <function>PQrequestCancel</function>
      <indexterm><primary>PQrequestCancel</primary></indexterm>
     </term>

     <listitem>
      <para><function>PQrequestCancel</function> является нерекомендуемым вариантом функции <function>PQcancel</function>. <synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis></para>

      <para>Выдаёт запрос на то, чтобы сервер прекратил обработку текущей команды. Функция работает напрямую с объектом <structname>PGconn</structname> и в случае сбоя сохраняет сообщение об ошибке в объекте <structname>PGconn</structname> (откуда его можно извлечь с помощью <function>PQerrorMessage</function>). Хотя функциональность та же самая, этот подход создаёт риски для многопоточных программ и обработчиков сигналов, поскольку возможно, что перезапись сообщения об ошибке, хранящегося в объекте <structname>PGconn</structname>, внесёт путаницу в текущую операцию, выполняемую на данном подключении.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

 </sect1>

 <sect1 id="libpq-fastpath">
  <title>Интерфейс быстрого пути</title>

  <indexterm zone="libpq-fastpath"><primary>быстрый путь</primary></indexterm>

  <para><productname>&productname;</productname> предоставляет интерфейс для передачи серверу простых вызовов функций по быстрому пути.</para>

  <tip>
   <para>Этот интерфейс несколько устарел, поскольку можно достичь подобной производительности и большей функциональности путём создания подготовленного оператора, определяющего вызов функции. Последующее выполнение этого оператора с передачей параметров и результатов в двоичном виде можно считать заменой вызову по быстрому пути.</para>
  </tip>

  <para>Функция <function>PQfn</function><indexterm><primary>PQfn</primary></indexterm> запрашивает выполнение серверной функции посредством интерфейса быстрого доступа: <synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis></para>

  <para>Аргумент <parameter>fnid</parameter> представляет собой OID функции, которая подлежит выполнению. <parameter>args</parameter> и <parameter>nargs</parameter> определяют параметры, которые должны быть переданы этой функции; они должны соответствовать списку аргументов объявленной функции. Когда поле <parameter>isint</parameter> структуры, передаваемой в качестве параметра, имеет значение "истина", тогда значение <parameter>u.integer</parameter> передаётся серверу в виде целого числа указанной длины (это должно быть 2 или 4 байта); при этом устанавливается нужный порядок байтов. Когда <parameter>isint</parameter> имеет значение "ложь", тогда указанное число байтов по адресу <parameter>*u.ptr</parameter> отправляется без какой-либо обработки; данные должны быть представлены в формате, которого ожидает сервер для передачи в двоичном виде данных того типа, что и аргументы функции. (Объявление поля <parameter>u.ptr</parameter>, как имеющего тип <type>int *</type>, является историческим; было бы лучше рассматривать его как тип <type>void *</type>.) <parameter>result_buf</parameter> указывает на буфер, в который должно быть помещено возвращаемое значение функции. Вызывающий код должен выделить достаточное место для сохранения возвращаемого значения. (Это никак не проверяется!) Фактическая длина результирующего значения в байтах будет возвращена в переменной целого типа, на которую указывает <parameter>result_len</parameter>. Если ожидается получение двух- или четырёхбайтового целочисленного результата, то присвойте параметру <parameter>result_is_int</parameter> значение 1, в противном случае назначьте ему 0. Когда параметр <parameter>result_is_int</parameter> равен 1, <application>libpq</application> переставляет байты в передаваемом значении, если это необходимо, так, чтобы оно было доставлено на клиентскую машину в виде правильного значения типа <type>int</type>; обратите внимание, что по адресу <parameter>*result_buf</parameter> доставляется четырёхбайтовое целое для любого допустимого размера результата. Когда <parameter>result_is_int</parameter> равен 0, тогда строка байтов в двоичном формате, отправленная сервером, будет возвращена немодифицированной. (В этом случае лучше рассматривать <parameter>result_buf</parameter> как имеющий тип <type>void *</type>.)</para>

  <para><function>PQfn</function> всегда возвращает действительный указатель на объект <structname>PGresult</structname>. Перед использованием результата нужно сначала проверить его статус. Вызывающая функция отвечает за освобождение памяти, занимаемой объектом <structname>PGresult</structname>, когда он больше не нужен, с помощью <function>PQclear</function>.</para>

  <para>Обратите внимание, что при использовании этого интерфейса невозможно обработать NULL в аргументах и результате, а также множества значений в результате.</para>

 </sect1>

 <sect1 id="libpq-notify">
  <title>Асинхронное уведомление</title>

  <indexterm zone="libpq-notify"><primary>NOTIFY</primary> <secondary>в libpq</secondary></indexterm>

  <para><productname>&productname;</productname> предлагает асинхронное уведомление посредством команд <command>LISTEN</command> и <command>NOTIFY</command>. Клиентский сеанс работы регистрирует свою заинтересованность в конкретном канале уведомлений с помощью команды <command>LISTEN</command> (и может остановить прослушивание с помощью команды <command>UNLISTEN</command>). Все сеансы, прослушивающие конкретный канал, будут уведомляться в асинхронном режиме, когда в рамках любого сеанса команда <command>NOTIFY</command> выполняется с параметром, указывающим имя этого канала. Для передачи дополнительных данных прослушивающим сеансам может использоваться строка <quote>payload</quote>.</para>

  <para>Приложения, использующие <application>libpq</application>, отправляют серверу команды <command>LISTEN</command>, <command>UNLISTEN</command> и <command>NOTIFY</command>, как обычные SQL-команды. Прибытие сообщений от команды <command>NOTIFY</command> можно впоследствии обнаружить с помощью вызова функции <function>PQnotifies</function>.<indexterm><primary>PQnotifies</primary></indexterm></para>

  <para>Функция <function>PQnotifies</function> возвращает следующее уведомление из списка необработанных уведомительных сообщений, полученных от сервера. Она возвращает нулевой указатель, если нет уведомлений, ожидающих обработки. Как только уведомление возвращено из функции <function>PQnotifies</function>, оно считается обработанным и будет удалено из списка уведомлений. <synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* имя канала уведомлений */
    int  be_pid;                /* ID серверного процесса, посылающего уведомление */
    char *extra;                /* строка сообщения в уведомлении */
} PGnotify;
</synopsis> После обработки объекта <structname>PGnotify</structname>, возвращённого функцией <function>PQnotifies</function>, обязательно освободите память, занимаемую им, с помощью функции <function>PQfreemem</function>. Достаточно освободить указатель на <structname>PGnotify</structname>; поля <structfield>relname</structfield> и <structfield>extra</structfield> не представляют отдельных областей памяти. (Имена этих полей являются таковыми по историческим причинам; в частности, имена каналов не обязаны иметь ничего общего с именами реляционных отношений.)</para>

  <para><xref linkend="libpq-example-2"/> представляет пример программы, иллюстрирующей использование асинхронного уведомления.</para>

  <para>Функция <function>PQnotifies</function> в действительности не читает данные с сервера; она просто возвращает сообщения, предварительно собранные другой функцией библиотеки <application>libpq</application>. В предшествующих выпусках <application>libpq</application> единственным способом обеспечения своевременного получения сообщений от команды <command>NOTIFY</command> была постоянная отправка команд, даже пустых, а затем проверка <function>PQnotifies</function> после каждого вызова <function>PQexec</function>. Хотя этот метод всё ещё работает, он не рекомендуется, поскольку растрачивает впустую процессорное время.</para>

  <para>Более удачным способом проверки наличия сообщений от команды <command>NOTIFY</command>, когда у вас нет полезных команд для выполнения, является вызов функции <function>PQconsumeInput</function> с последующей проверкой <function>PQnotifies</function>. Вы можете использовать <function>PQselect()</function> или <function>PQselectExtended()</function>, чтобы подождать прибытия данных с сервера, не занимая тем самым ресурсы <acronym>CPU</acronym> в отсутствие задач для выполнения. (Получить номер дескриптора для использования с <function>PQselect()</function> можно с помощью функции <function>PQsocket</function>.) Заметьте, что это будет работать независимо от того, отправляете ли вы команды, используя <function>PQsendQuery</function>/<function>PQgetResult</function>, или просто вызываете <function>PQexec</function>. Однако важно не забывать проверять <function>PQnotifies</function> после каждого вызова <function>PQgetResult</function> или <function>PQexec</function>, чтобы увидеть, не поступили ли какие-либо уведомления в процессе обработки команды.</para>

 </sect1>

 <sect1 id="libpq-copy">
  <title>Функции, связанные с командой <command>COPY</command></title>

  <indexterm zone="libpq-copy"><primary>COPY</primary> <secondary>с libpq</secondary></indexterm>

  <para>Команда <command>COPY</command> в <productname>&productname;</productname> имеет возможность читать и записывать данные через сетевое подключение, установленное <application>libpq</application>. Описанные в этом разделе функции позволяют приложениям воспользоваться этой возможностью для передачи или приёма копируемых данных.</para>

  <para>Общая процедура такова: сначала приложение выдаёт SQL-команду <command>COPY</command>, вызывая <function>PQexec</function> или одну из подобных функций. В ответ оно должно получить (если не возникла ошибка) объект <structname>PGresult</structname> с кодом состояния <literal>PGRES_COPY_OUT</literal> или <literal>PGRES_COPY_IN</literal> (в зависимости от направления копирования). Затем приложение должно использовать функции, описанные в этом разделе, и принимать или передавать строки данных. По завершении передачи возвращается ещё один объект <structname>PGresult</structname>, сообщающий о состоянии завершения передачи. В случае успеха он содержит код состояния <literal>PGRES_COMMAND_OK</literal>, а если возникает какая-то проблема — <literal>PGRES_FATAL_ERROR</literal>. После этого можно продолжать выполнять SQL-команды через <function>PQexec</function>. (Пока операция <command>COPY</command> не завершена, выполнять другие SQL-команды через то же подключение нельзя.)</para>

  <para>Если команда <command>COPY</command> была выполнена через <function>PQexec</function> в строке, содержащей дополнительные команды, приложение должно продолжить получать результаты через <function>PQgetResult</function> после завершения последовательности <command>COPY</command>. Только когда <function>PQgetResult</function> возвращает <symbol>NULL</symbol>, можно с уверенностью считать, что командная строка <function>PQexec</function> выполнена полностью, и безопасно передавать другие команды.</para>

  <para>Функции, описанные в этом разделе, должны выполняться только после получения кода состояния <literal>PGRES_COPY_OUT</literal> или <literal>PGRES_COPY_IN</literal> от функции <function>PQexec</function> или <function>PQgetResult</function>.</para>

  <para>Объект <structname>PGresult</structname> с таким кодом состояния содержит дополнительные данные о начавшейся операции <command>COPY</command>. Эти данные можно получить функциями, также применяющимися при обработке результатов запроса: <variablelist>
    <varlistentry id="libpq-pqnfields-1">
     <term>
      <function>PQnfields</function>
      <indexterm><primary>PQnfields</primary> <secondary>с COPY</secondary></indexterm>
     </term>

     <listitem>
      <para>Возвращает число копируемых столбцов (полей).</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples-1">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm><primary>PQbinaryTuples</primary> <secondary>с COPY</secondary></indexterm>
     </term>

     <listitem>
      <para>Значение 0 указывает, что для всей операции копирования применяется текстовый формат (строки разделяются символами новой строки, столбцы разделяются символами-разделителями и т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный формат. За дополнительными сведениями обратитесь к <xref remap="3" linkend="sql-copy"/>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat-1">
     <term>
      <function>PQfformat</function>
      <indexterm><primary>PQfformat</primary> <secondary>с COPY</secondary></indexterm>
     </term>

     <listitem>
      <para>Возвращает код формата (0 — текстовый, 1 — двоичный), связанный с каждым копируемым столбцом. Коды форматов столбцов всегда будут нулевыми, если общий формат копирования — текстовый, но с двоичным форматом поддерживаются и текстовые, и двоичные столбцы. (Однако в текущей реализации <command>COPY</command> при двоичном копировании столбцы могут быть только двоичными, так что форматы столбцов должны всегда соответствовать общему формату.)</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <note>
   <para>Эти дополнительные значения данных доступны только при использовании протокола 3.0. С протоколом 2.0 все эти функции возвращают 0.</para>
  </note>

  <sect2 id="libpq-copy-send">
   <title>Функции для передачи данных <command>COPY</command></title>

   <para>Эти функции применяются для передачи данных при операции <literal>COPY FROM STDIN</literal>. Они не будут работать, если подключение находится не в состоянии <literal>COPY_IN</literal>.</para>

   <variablelist>
    <varlistentry id="libpq-pqputcopydata">
     <term>
      <function>PQputCopyData</function>
      <indexterm><primary>PQputCopyData</primary></indexterm>
     </term>

     <listitem>
      <para>Отправляет данные на сервер, когда активно состояние <literal>COPY_IN</literal>. <synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis></para>

      <para>Передаёт серверу данные <command>COPY</command> из указанного буфера (<parameter>buffer</parameter>), длиной <parameter>nbytes</parameter> байт. Она возвращает 1, если данные были переданы, 0, если они не попали в очередь, так как буферы были заполнены (это возможно только в неблокирующем режиме), или -1, если произошла ошибка. (Если возвращено -1, подробности ошибки можно узнать, вызвав <function>PQerrorMessage</function>. Если получен 0, дождитесь состояния готовности к записи и повторите попытку.)</para>

      <para>Приложение может разделять поток данных <command>COPY</command> на буферизуемые блоки любого удобного размера. Границы буфера не имеют семантического значения при передаче. Содержимое потока данных должно соответствовать формату данных, ожидаемому командой <command>COPY</command>; за подробностями обратитесь к <xref remap="3" linkend="sql-copy"/>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputcopyend">
     <term>
      <function>PQputCopyEnd</function>
      <indexterm><primary>PQputCopyEnd</primary></indexterm>
     </term>

     <listitem>
      <para>Отправляет признак конца данных на сервер, когда активно состояние <literal>COPY_IN</literal>. <synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis></para>

      <para>Завершает операцию <literal>COPY_IN</literal> с успешным результатом, если в <parameter>errormsg</parameter> передаётся <symbol>NULL</symbol>. Если <parameter>errormsg</parameter> не <symbol>NULL</symbol>, команда <command>COPY</command> будет завершена с ошибкой, а сообщением об ошибке будет строка, переданная в <parameter>errormsg</parameter>. (Однако не следует полагать, что именно это сообщение будет получено от сервера назад, так как сервер мог уже прервать операцию <command>COPY</command> по своим причинам. Также заметьте, что принудительный вызов ошибки не работает с соединениями по протоколу версии до 3.0.)</para>

      <para>Эта функция возвращает 1, если сообщение завершения было передано; в неблокирующем режиме это означает только, что сообщение завершения успешно поставлено в очередь. (Чтобы удостовериться, что данные были успешно отправлены в неблокирующем режиме, следует дождаться готовности к записи и вызывать <function>PQflush</function> в цикле, пока она не вернёт ноль.) Нулевой результат означает, что функция не смогла поставить сообщение завершения в очередь по причине заполнения буферов; это возможно только в неблокирующем режиме. (В этом случае нужно дождаться готовности к записи и попытаться вызвать <function>PQputCopyEnd</function> снова.) Если действительно происходит ошибка, возвращается -1; получить её подробности можно, вызвав <function>PQerrorMessage</function>.</para>

      <para>После успешного вызова <function>PQputCopyEnd</function> вызовите <function>PQgetResult</function>, чтобы узнать окончательный результат команды <command>COPY</command>. Ожидать появления этого результата можно обычным образом. Затем вернитесь к обычным операциям.</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-receive">
   <title>Функции для приёма данных <command>COPY</command></title>

   <para>Эти функции применяются для получения данных при операции <literal>COPY TO STDOUT</literal>. Они не будут работать, если подключение находится не в состоянии <literal>COPY_OUT</literal>.</para>

   <variablelist>
    <varlistentry id="libpq-pqgetcopydata">
     <term>
      <function>PQgetCopyData</function>
      <indexterm><primary>PQgetCopyData</primary></indexterm>
     </term>

     <listitem>
      <para>Принимает данные от сервера, когда активно состояние <literal>COPY_OUT</literal>. <synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis></para>

      <para>Запрашивает следующую строку данных с сервера в процессе операции <command>COPY</command>. Данные всегда возвращаются строка за строкой; если поступила только часть строки, она не возвращается. Успешное получение строки данных подразумевает выделение блока памяти для этих данных. В параметре <parameter>buffer</parameter> ей передаётся указатель, отличный от <symbol>NULL</symbol>. По адресу <parameter>*buffer</parameter> записывается указатель на выделенную память, либо <symbol>NULL</symbol>, когда буфер не возвращается. Если буфер результата отличен от <symbol>NULL</symbol>, его следует освободить, когда он станет не нужен, вызвав <function>PQfreemem</function>.</para>

      <para>Когда строка получена успешно, возвращается число байт данных в этой строке (это число всегда больше нуля). Возвращаемое строковое значение всегда завершается нулём, хотя это полезно, вероятно, только для текстовой <command>COPY</command>. Нулевой результат означает, что операция <command>COPY</command> продолжает выполняться, но строка ещё не готова (это возможно, только когда параметр <parameter>async</parameter> равен true). Возвращённое значение -1 означает, что команда <command>COPY</command> завершена, а -2 показывает, что произошла ошибка (её причину можно узнать с помощью <function>PQerrorMessage</function>).</para>

      <para>Когда параметр <parameter>async</parameter> равен true (отличен от нуля), функция <function>PQgetCopyData</function> не будет блокироваться, ожидая данных; она возвратит ноль, если выполнение <command>COPY</command> продолжается, но полная строка ещё не получена. (В этом случае нужно дождаться готовности к чтению и затем вызвать <function>PQconsumeInput</function>, прежде чем вызывать <function>PQgetCopyData</function> ещё раз.) Когда <parameter>async</parameter> равен false (нулю), <function>PQgetCopyData</function> будет заблокирована до поступления данных или окончания операции.</para>

      <para>Когда <function>PQgetCopyData</function> возвращает -1, вызовите <function>PQgetResult</function>, чтобы узнать окончательный результат команды <command>COPY</command>. Ожидать появления этого результата можно обычным образом. Затем вернитесь к обычным операциям.</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-deprecated">
   <title>Устаревшие функции для <command>COPY</command></title>

   <para>Эти функции представляют старые методы выполнения операции <command>COPY</command>. Хотя они продолжают работать, они признаны устаревшими из-за плохой обработки ошибок, неудобных способов обнаружения конца данных и отсутствия поддержки двоичных или неблокирующих передач.</para>

   <variablelist>
    <varlistentry id="libpq-pqgetline">
     <term>
      <function>PQgetline</function>
      <indexterm><primary>PQgetline</primary></indexterm>
     </term>

     <listitem>
      <para>Читает передаваемую сервером строку символов, завершающуюся символом новой строки, в буфер (buffer) размера <parameter>length</parameter>. <synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis></para>

      <para>Эта функция копирует <parameter>length</parameter>-1 символов в буфер и преобразует символ конца строки в нулевой байт. <function>PQgetline</function> возвращает <symbol>EOF</symbol> в конце ввода, 0, если была прочитана вся строка, и 1, если буфер заполнен, но завершающий символ конца строки ещё не прочитан.</para>
       <para>Заметьте, что приложение должно проверить, не состоит ли новая строка в точности из двух символов <literal>\.</literal>, что будет означать, что сервер завершил передачу результатов команды <command>COPY</command>. Если приложение может принимать строки длиннее <parameter>length</parameter>-1 символов, необходимо позаботиться о том, чтобы оно корректно распознавало строку <literal>\.</literal> (а не воспринимало, например, конец длинной строки данных как завершающую строку).</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlineasync">
     <term>
      <function>PQgetlineAsync</function>
      <indexterm><primary>PQgetlineAsync</primary></indexterm>
     </term>

     <listitem>
      <para>Читает передаваемую сервером строку данных <command>COPY</command> в буфер без блокировки. <synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis></para>

      <para>Эта функция похожа на <function>PQgetline</function>, но может применяться в приложениях, которые должны читать данные <command>COPY</command> асинхронно, то есть, без блокировки. Запустив команду <command>COPY</command> и получив ответ <literal>PGRES_COPY_OUT</literal>, приложение должно вызывать <function>PQconsumeInput</function> и <function>PQgetlineAsync</function>, пока не будет получен сигнал конца данных.</para>
       <para>В отличие от <function>PQgetline</function>, эта функция сама отвечает за обнаружение конца данных.</para>

      <para>При каждом вызове <function>PQgetlineAsync</function> будет возвращать данные, если во входном буфере <application>libpq</application> оказывается полная строка данных. В противном случае никакие данные не возвращаются до поступления остального содержимого строки. Эта функция возвращает -1, если обнаруживается признак завершения копирования, или 0, если данные не получены, или положительное количество возвращённых байт данных. Если возвращается -1, вызывающий код должен затем вызвать <function>PQendcopy</function> и после этого перейти в обычный режим работы.</para>

      <para>Возвращаемые данные не будут пересекать границы строк данных. При этом может быть возвращена одна строка целиком. Но если буфер, выделенный вызывающим кодом, оказывается слишком мал для строки, передаваемой сервером, возвращена будет часть строки. Когда передаются текстовые данные, это можно выявить, проверив, содержит ли последний возвращаемый байт символ <literal>\n</literal>. (Для <command>COPY</command> в двоичном формате потребуется собственно разобрать формат данных <command>COPY</command>, чтобы выявить подобную ситуацию.) Возвращаемая строка не завершается нулём. (Если вы хотите получить строку с нулём в конце, передайте в <parameter>bufsize</parameter> число на единицу меньше фактического размера блока.)</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputline">
     <term>
      <function>PQputline</function>
      <indexterm><primary>PQputline</primary></indexterm>
     </term>

     <listitem>
      <para>Передаёт серверу строку, завершённую нулём. Возвращает 0 в случае успеха, либо <symbol>EOF</symbol>, если передать строку не удаётся. <synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis></para>

      <para>Поток данных <command>COPY</command>, передаваемых последовательностью вызовов <function>PQputline</function>, имеет тот же формат, что возвращает <function>PQgetlineAsync</function>, за исключением того, что приложения не обязательно должны передавать по одной строке данных за вызов <function>PQputline</function>; они могут посылать части строк или сразу несколько строк.</para>

      <note>
       <para>До версии 3.0 протокола <productname>&productname;</productname> приложение должно было явно отправлять два символа <literal>\.</literal> последней строкой, чтобы сообщить серверу, что оно закончило передачу данных <command>COPY</command>. Хотя это по-прежнему работает, такое поведение считается устаревшим и ожидается, что особое значение <literal>\.</literal> будет исключено в будущих версиях. Передав собственно данные, сейчас достаточно вызвать <function>PQendcopy</function>.</para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputnbytes">
     <term>
      <function>PQputnbytes</function>
      <indexterm><primary>PQputnbytes</primary></indexterm>
     </term>

     <listitem>
      <para>Передаёт серверу строку, не завершённую нулём. Возвращает 0 в случае успеха, либо <symbol>EOF</symbol>, если передать строку не удаётся. <synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis></para>

      <para>Поведение этой функции не отличается от <function>PQputline</function>, но её буфер данных не должен содержать завершающий ноль, так как для неё число передаваемых байт задаётся непосредственно. Используйте эту функцию для передачи двоичных данных.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqendcopy">
     <term>
      <function>PQendcopy</function>
      <indexterm><primary>PQendcopy</primary></indexterm>
     </term>

     <listitem>
      <para>Производит синхронизацию с сервером. <synopsis>
int PQendcopy(PGconn *conn);
</synopsis> Эта функция ожидает завершения копирования сервером. Её следует вызывать, либо когда серверу была передана последняя строка функцией <function>PQputline</function>, либо когда от сервера была получена последняя строка функцией <function>PGgetline</function>. Если её не вызвать, сервер <quote>потеряет синхронизацию</quote> с клиентом. После завершения этой функции сервер готов принимать следующую команду SQL. В случае успешного завершения возвращается 0, в противном случае — ненулевое значение. (Чтобы получить подробности ошибки при ненулевом значении, вызовите <function>PQerrorMessage</function>.)</para>

      <para>Вызывая <function>PQgetResult</function>, приложение должно обрабатывать результат <literal>PGRES_COPY_OUT</literal>, в цикле выполняя <function>PQgetline</function>, а обнаружив завершающую строку, вызвать <function>PQendcopy</function>. Затем оно должно вернуться к циклу <function>PQgetResult</function>, и выйти из него, когда <function>PQgetResult</function> возвратит нулевой указатель. Подобным образом, получив результат <literal>PGRES_COPY_IN</literal>, приложение должно выполнить серию вызовов <function>PQputline</function>, завершить её, вызвав <function>PQendcopy</function>, а затем вернуться к циклу <function>PQgetResult</function>. При такой организации обработки команда <command>COPY</command> будет корректно выполняться и в составе последовательности команд <acronym>SQL</acronym>.</para>

      <para>Старые приложения обычно передают команду <command>COPY</command> через <function>PQexec</function> и рассчитывают, что транзакция будет завершена после <function>PQendcopy</function>. Это будет работать, только если команда <command>COPY</command> является единственной <acronym>SQL</acronym>-командой в строке команд.</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-control">
  <title>Функции управления</title>

  <para>Эти функции управляют различными аспектами поведения <application>libpq</application>.</para>

  <variablelist>
   <varlistentry id="libpq-pqclientencoding">
    <term>
     <function>PQclientEncoding</function>
     <indexterm><primary>PQclientEncoding</primary></indexterm>
    </term>

    <listitem>
     <para>Возвращает кодировку клиента. <synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis> Заметьте, что она возвращает идентификатор кодировки, а не символьную строку вида <literal>EUC_JP</literal>. В случае ошибки она возвращает -1. Преобразовать идентификатор кодировки в имя можно, воспользовавшись следующей функцией: <synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis></para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetclientencoding">
    <term>
     <function>PQsetClientEncoding</function>
     <indexterm><primary>PQsetClientEncoding</primary></indexterm>
    </term>

    <listitem>
     <para>Устанавливает кодировку клиента. <synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis> В <replaceable>conn</replaceable> передаётся соединение с сервером, а в <replaceable>encoding</replaceable> — имя требуемой кодировки. Если функция устанавливает кодировку успешно, она возвращает 0, или -1 в противном случае. Определить текущую кодировку для соединения можно, воспользовавшись функцией <function>PQclientEncoding</function>.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqseterrorverbosity">
    <term>
     <function>PQsetErrorVerbosity</function>
     <indexterm><primary>PQsetErrorVerbosity</primary></indexterm>
    </term>

    <listitem>
     <para>Определяет уровень детализации сообщений, возвращаемых функциями <function>PQerrorMessage</function> и <function>PQresultErrorMessage</function>. <synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis> <function>PQsetErrorVerbosity</function> устанавливает уровень детализации и возвращает предыдущее значение для соединения. В &laquo;лаконичном&raquo; режиме (<firstterm>TERSE</firstterm>) возвращаемые сообщения содержат только уровень серьёзности, основной текст и позицию; всё это обычно умещается в одной строке. В режиме по умолчанию выдаваемые сообщения дополнительно содержат поля подробного описания, подсказки или контекста (они могут занимать несколько строк). В &laquo;многословном&raquo; режиме (<firstterm>VERBOSE</firstterm>) передаются все доступные поля сообщения. Изменение уровня детализации не влияет на сообщения, уже сформированные в существующих объектах <structname>PGresult</structname>, а затрагивает только последующие сообщения. (Но можно воспользоваться <function>PQresultVerboseErrorMessage</function>, чтобы получить предыдущую ошибку с другим уровнем детализации.)</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqseterrorcontextvisibility">
    <term>
     <function>PQsetErrorContextVisibility</function>
     <indexterm><primary>PQsetErrorContextVisibility</primary></indexterm>
    </term>

    <listitem>
     <para>Определяет вариант обработки полей <literal>КОНТЕКСТ</literal> в сообщениях, возвращаемых функциями <function>PQerrorMessage</function> и <function>PQresultErrorMessage</function>. <synopsis>
typedef enum
{
    PQSHOW_CONTEXT_NEVER,
    PQSHOW_CONTEXT_ERRORS,
    PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;

PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context);
</synopsis> <function>PQsetErrorContextVisibility</function> устанавливает режим вывода контекста сообщений и возвращает предыдущее значение. В зависимости от этого режима, поле <literal>КОНТЕКСТ</literal> может включаться в сообщения или нет (если только не выбран уровень детализации <firstterm>TERSE</firstterm>, при котором <literal>КОНТЕКСТ</literal> не выводится никогда). В режиме <firstterm>NEVER</firstterm> поле <literal>КОНТЕКСТ</literal> не выводится никогда, а в режиме <firstterm>ALWAYS</firstterm>, выводится всегда (если оно имеется). В режиме <firstterm>ERRORS</firstterm> (по умолчанию), поля <literal>CONTEXT</literal> включаются только в сообщения об ошибках, но не в уведомления или предупреждения. Изменение этого уровня не влияет на сообщения, уже сформированные в существующих объектах <structname>PGresult</structname>, а затрагивает только последующие сообщения. (Но можно воспользоваться <function>PQresultVerboseErrorMessage</function>, чтобы получить предыдущую ошибку с другим режимом вывода контекста.)</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqtrace">
    <term>
     <function>PQtrace</function>
     <indexterm><primary>PQtrace</primary></indexterm>
    </term>

    <listitem>
     <para>Включает трассировку клиент-серверного взаимодействия с выводом в поток отладочных сообщений. <synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis></para>

     <note>
      <para>В Windows, если библиотека <application>libpq</application> и приложение скомпилированы с разными флагами, эта функция может вызвать крах приложения из-за различий внутреннего представления указателей <literal>FILE</literal>. В частности, флаги многопоточной/однопоточной, выпускаемой/отладочной или статической/динамической сборки должны быть одинаковыми для библиотеки и всех использующих её приложений.</para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pquntrace">
    <term>
     <function>PQuntrace</function>
     <indexterm><primary>PQuntrace</primary></indexterm>
    </term>

    <listitem>
     <para>Выключает трассировку, запущенную функцией <function>PQtrace</function>. <synopsis>
void PQuntrace(PGconn *conn);
</synopsis></para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="libpq-misc">
  <title>Функции разного назначения</title>

  <para>Как всегда, находятся функции, которые не попадают ни в одну из категорий.</para>

  <variablelist>
   <varlistentry id="libpq-pqfreemem">
    <term>
     <function>PQfreemem</function>
     <indexterm><primary>PQfreemem</primary></indexterm>
    </term>

    <listitem>
     <para>Освобождает память, которую выделила <application>libpq</application>. <synopsis>
void PQfreemem(void *ptr);
</synopsis></para>

     <para>Освобождает память, выделенную библиотекой <application>libpq</application>, а именно функциями <function>PQescapeByteaConn</function>, <function>PQescapeBytea</function>, <function>PQunescapeBytea</function> и <function>PQnotifies</function>. Особенно важно использовать именно эту функцию, а не <function>free()</function>, в Microsoft Windows. Это связано с тем, что выделение памяти в DLL и освобождение её в приложении будет работать, только если флаги многопоточной/однопоточной, выпускаемой/отладочной или статической/динамической сборки для DLL и приложения полностью совпадают. На других платформах эта функция действует так же, как стандартная библиотечная функция <function>free()</function>.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqconninfofree">
    <term>
     <function>PQconninfoFree</function>
     <indexterm><primary>PQconninfoFree</primary></indexterm>
    </term>

    <listitem>
     <para>Освобождает структуры данных, выделенные функциями <function>PQconndefaults</function> и <function>PQconninfoParse</function>. <synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis></para>

     <para>Простая функция <function>PQfreemem</function> не подойдёт для этого, так как эти структуры содержат ссылки на подчинённые строки.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqencryptpassword">
    <term>
     <function>PQencryptPassword</function>
     <indexterm><primary>PQencryptPassword</primary></indexterm>
    </term>

    <listitem>
     <para>Подготавливает зашифрованную форму пароля <productname>&productname;</productname>. <synopsis>
char * PQencryptPassword(const char *passwd, const char *user);
</synopsis> Эта функция предназначена для клиентских приложений, желающих передавать команды вида <literal>ALTER USER joe PASSWORD 'pwd'</literal>. В такой команде лучше не передавать исходный пароль открытым текстом, так как он может появиться в рабочих журналах, мониторе активности и т. д. Вместо этого, воспользуйтесь данной функцией и переведите пароль в зашифрованную форму, прежде чем передавать его. В аргументах ей передаётся пароль в открытом виде и имя пользователя SQL, для которого он предназначен. Возвращает она строку, выделенную функцией <function>malloc</function>, или <symbol>NULL</symbol> в случае нехватки памяти. Вызывающий код может рассчитывать на то, что в этой строке не будет специальных символов, требующих экранирования. Завершив работу с этой строкой, вызовите <function>PQfreemem</function>, чтобы освободить её.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqmakeemptypgresult">
    <term>
     <function>PQmakeEmptyPGresult</function>
     <indexterm><primary>PQmakeEmptyPGresult</primary></indexterm>
    </term>

    <listitem>
     <para>Конструирует пустой объект <structname>PGresult</structname> с указанным состоянием. <synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis></para>

     <para>Это внутренняя функция <application>libpq</application>, выделяющая память и инициализирующая пустой объект <structname>PGresult</structname>. Эта функция возвращает <symbol>NULL</symbol>, если не может выделить память. Она сделана экспортируемой, так как некоторые приложения находят полезным создавать объекты результатов (в частности, объекты с состоянием ошибки) самостоятельно. Если в <parameter>conn</parameter> передаётся не null и <parameter>status</parameter> указывает на ошибку, в <structname>PGresult</structname> копируется текущее сообщение об ошибке для заданного соединения. Также, если в <parameter>conn</parameter> передаётся не null, в <structname>PGresult</structname> копируются все процедуры событий, зарегистрированные для этого соединения. (При этом вызовы <literal>PGEVT_RESULTCREATE</literal> не выполняются; см. описание <function>PQfireResultCreateEvents</function>.) Заметьте, что в конце для этого объекта следует вызвать <function>PQclear</function>, как и для объекта <structname>PGresult</structname>, возвращённого самой библиотекой <application>libpq</application>.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqfireresultcreateevents">
    <term>
     <function>PQfireResultCreateEvents</function>
     <indexterm><primary>PQfireResultCreateEvents</primary></indexterm>
    </term>
    <listitem>
     <para>Вызывает событие <literal>PGEVT_RESULTCREATE</literal> (см. <xref remap="4" linkend="libpq-events"/>) для каждой процедуры событий, зарегистрированной в объекте <structname>PGresult</structname>. Возвращает ненулевое значение в случае успеха или ноль в случае ошибки в одной из процедур. <synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis></para>

     <para>Аргумент <literal>conn</literal> передаётся процедурам событий, но непосредственно не используется. Он может быть равен <symbol>NULL</symbol>, если он не нужен процедурам событий.</para>

     <para>Процедуры событий, уже получившие событие <literal>PGEVT_RESULTCREATE</literal> или <literal>PGEVT_RESULTCOPY</literal> для этого объекта, больше не вызываются.</para>

     <para>Основная причина отделения этой функции от <function>PQmakeEmptyPGresult</function> в том, что часто требуется создать объект <structname>PGresult</structname> и наполнить его данными, прежде чем вызывать процедуры событий.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqcopyresult">
    <term>
     <function>PQcopyResult</function>
     <indexterm><primary>PQcopyResult</primary></indexterm>
    </term>

    <listitem>
     <para>Создаёт копию объекта <structname>PGresult</structname>. Эта копия никак не связана с исходным результатом и поэтому, когда она становится не нужна, необходимо вызвать <function>PQclear</function>. Если функция завершается ошибкой, она возвращает <symbol>NULL</symbol>. <synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis></para>

     <para>Создаваемая копия не будет точной. В возвращаемый результат всегда помещается состояние <literal>PGRES_TUPLES_OK</literal> и в него не копируются никакие сообщения об ошибках из исходного объекта. (Однако в него копируется строка состояния команды.) Что ещё в него будет копироваться, определяет аргумент <parameter>flags</parameter>, в котором складываются несколько флагов. Флаг <literal>PG_COPYRES_ATTRS</literal> включает копирование атрибутов исходного объекта (определений столбцов), а флаг <literal>PG_COPYRES_TUPLES</literal> включает копирование кортежей из исходного объекта (при этом также копируются и атрибуты.) Флаг <literal>PG_COPYRES_NOTICEHOOKS</literal> включает копирование обработчиков замечаний, а флаг <literal>PG_COPYRES_EVENTS</literal> — событий из исходного объекта результата. (Но любые данные, связанные с экземпляром исходного объекта, не копируются.)</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetresultattrs">
    <term>
     <function>PQsetResultAttrs</function>
     <indexterm><primary>PQsetResultAttrs</primary></indexterm>
    </term>

    <listitem>
     <para>Устанавливает атрибуты объекта <structname>PGresult</structname>. <synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis></para>

     <para>Предоставленная структура <parameter>attDescs</parameter> копируется в результат. Если указатель <parameter>attDescs</parameter> равен <symbol>NULL</symbol> или <parameter>numAttributes</parameter> меньше одного, запрос игнорируется и функция выполняется без ошибки. Если <parameter>res</parameter> уже содержит атрибуты, функция завершается ошибкой. В случае ошибки функция возвращает ноль, а в обратном случае — ненулевое значение.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetvalue">
    <term>
     <function>PQsetvalue</function>
     <indexterm><primary>PQsetvalue</primary></indexterm>
    </term>

    <listitem>
     <para>Устанавливает значение поля кортежа в объекте <structname>PGresult</structname>. <synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis></para>

     <para>Эта функция автоматически увеличивает внутренний массив кортежей при необходимости. Однако значение <parameter>tup_num</parameter> должно быть меньше или равно <function>PQntuples</function>, что означает, что эта функция может увеличивать массив кортежей только на один кортеж. Но в существующем кортеже любые поля могут изменяться в любом порядке. Если значение в поле с номером <parameter>field_num</parameter> уже существует, оно будет перезаписано. Если <parameter>len</parameter> равно -1 или <parameter>value</parameter> равно <symbol>NULL</symbol>, в поле будет записано значение SQL NULL. Устанавливаемое значение (<parameter>value</parameter>) копируется в закрытую область объекта результата, так что от него можно избавиться после завершения функции. Если функция завершается ошибкой, она возвращает ноль, а в обратном случае — ненулевое значение.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqresultalloc">
    <term>
     <function>PQresultAlloc</function>
     <indexterm><primary>PQresultAlloc</primary></indexterm>
    </term>

    <listitem>
     <para>Выделяет подчинённую область памяти для объекта <structname>PGresult</structname>. <synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis></para>

     <para>Любая память, выделенная этой функцией, будет освобождена при очистке объекта <parameter>res</parameter>. В случае ошибки эта функция возвращает <symbol>NULL</symbol>. Результат гарантированно выравнивается должным образом для любого типа данных, как и при <function>malloc</function>.</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqlibversion">
    <term>
     <function>PQlibVersion</function>
     <indexterm><primary>PQlibVersion</primary> <seealso>PQserverVersion</seealso></indexterm>
    </term>

    <listitem>
     <para>Возвращает версию используемой библиотеки <productname>libpq</productname>. <synopsis>
int PQlibVersion(void);
</synopsis></para>

     <para>По результату этой функции можно во время выполнения определить, предоставляется ли определённая функциональность загруженной в данный момент версией libpq. Эта функция может использоваться, например, чтобы понять, какие параметры соединения может принять <function>PQconnectdb</function> или поддерживается ли вывод <type>bytea</type> в формате <literal>hex</literal>, появившийся в PostgreSQL 9.0.</para>

     <para>Это число формируется в результате преобразования номеров старшей, дополнительной и корректирующей версии в числа из двух цифр и соединения их вместе. Например, для версии 9.1 будет возвращено 90100, а для версии 9.1.2 — 90102 (ведущие нули не показываются).</para>

     <note>
      <para>Эта функция появилась в <productname>PostgreSQL</productname> версии 9.1, поэтому с её помощью нельзя проверить функциональность предыдущих версий, так как при компоновке с ней будет создана зависимость от версии 9.1.</para>
     </note>
    </listitem>
   </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="libpq-notice-processing">
  <title>Обработка замечаний</title>

  <indexterm zone="libpq-notice-processing"><primary>обработка замечаний</primary> <secondary>в libpq</secondary></indexterm>

  <para>Сообщения с замечаниями и предупреждениями, выдаваемые сервером, не возвращаются функциями, выполняющими запросы, так как они не свидетельствуют об ошибке в запросе. Вместо этого они передаются функции обработки замечаний и после завершения этой функции выполнение продолжается как обычно. Стандартная функция обработки замечаний выводит сообщение в <filename>stderr</filename>, но приложение может переопределить это поведение, предоставив собственный обработчик.</para>

  <para>По историческим причинам обработка замечаний выполняется на двух уровнях, приёмником замечаний и обработчиком замечаний. По умолчанию приёмник замечаний форматирует замечание и передаёт сформированную строку обработчику замечаний для вывода. Однако приложения, которые реализуют свой приёмник замечаний, обычно просто игнорируют слой обработчика и выполняют все действия в коде приёмника.</para>

  <para>Функция <function>PQsetNoticeReceiver</function> <indexterm><primary>приёмник замечаний</primary></indexterm> <indexterm><primary>PQsetNoticeReceiver</primary></indexterm> устанавливает или возвращает текущий приёмник замечаний для объекта соединения. Подобным образом, <function>PQsetNoticeProcessor</function> <indexterm><primary>обработчик замечаний</primary></indexterm> <indexterm><primary>PQsetNoticeProcessor</primary></indexterm> устанавливает или возвращает текущий обработчик замечаний. <synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis> Каждая из этих функций возвращает указатель на ранее установленный приёмник или обработчик замечаний и устанавливает новый указатель. Если ей передаётся нулевой указатель, она ничего не делает, только возвращает текущий указатель.</para>

  <para>Когда сообщение с замечанием или предупреждением поступает от сервера, либо выдаётся самой библиотекой <application>libpq</application>, вызывается функция приёмника замечания. Сообщение передаётся ей в виде состояния <symbol>PGRES_NONFATAL_ERROR</symbol> объекта <structname>PGresult</structname>. (Это позволяет приёмнику извлечь из него отдельные поля, используя <function>PQresultErrorField</function>, либо получить полное готовое сообщение, вызвав <function>PQresultErrorMessage</function> или <function>PQresultVerboseErrorMessage</function>.) Ей также передаётся тот же неопределённый указатель, что был передан функции <function>PQsetNoticeReceiver</function>. (Этот указатель может пригодиться для обращения к внутреннему состоянию приложения при необходимости.)</para>

  <para>Стандартный приёмник замечаний просто извлекает сообщение (вызывая <function>PQresultErrorMessage</function>) и передаёт его обработчику замечаний.</para>

  <para>Обработчик замечаний отвечает за обработку сообщения с замечанием или предупреждением в текстовом виде. Ему передаётся строка с текстом сообщения (включающая завершающий символ новой строки) и неопределённый указатель, который был передан функции <function>PQsetNoticeProcessor</function>. (Этот указатель может пригодиться для обращения к внутреннему состоянию приложения при необходимости.)</para>

  <para>Стандартный обработчик замечаний прост: <programlisting>static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}</programlisting></para>

  <para>Установив приёмник или обработчик замечаний, вы можете ожидать, что эта функция будет вызываться, пока будут существовать объект <structname>PGconn</structname> или объекты <structname>PGresult</structname>, созданные с ней. Когда создаётся <structname>PGresult</structname>, указатели текущих обработчиков замечаний, установленные в <structname>PGconn</structname>, копируются в <structname>PGresult</structname> для возможного использования функциями вроде <function>PQgetvalue</function>.</para>

 </sect1>

 <sect1 id="libpq-events">
  <title>Система событий</title>

  <para>Система событий <application>libpq</application> разработана для уведомления функций-обработчиков об интересных событиях <application>libpq</application>, например, о создании и уничтожении объектов <structname>PGconn</structname> и <structname>PGresult</structname>. Основное их предназначение в том, чтобы позволить приложениям связать собственные данные с объектами <structname>PGconn</structname> и <structname>PGresult</structname> и обеспечить их освобождение в нужное время.</para>

  <para>Каждый зарегистрированный обработчик событий связывается с двумя элементами данных, которые известны <application>libpq</application> только как скрытые указатели <literal>void *</literal>. Первый <firstterm>сквозной</firstterm> указатель передаётся приложением, когда обработчик событий регистрируется в <structname>PGconn</structname>. Этот указатель никогда не меняется на протяжении жизни <structname>PGconn</structname> и все объекты <structname>PGresult</structname> создаются с ним; поэтому, если он используется, он должен указывать на долгоживущие данные. В дополнение к нему имеется указатель <firstterm>данных экземпляра</firstterm>, который изначально равен <symbol>NULL</symbol> во всех объектах <structname>PGconn</structname> и <structname>PGresult</structname>. Этим указателем можно управлять с помощью функций <function>PQinstanceData</function>, <function>PQsetInstanceData</function>, <function>PQresultInstanceData</function> и <function>PQsetResultInstanceData</function>. Заметьте, что в отличие от сквозного указателя, данные экземпляра <structname>PGconn</structname> автоматически не наследуются объектами <structname>PGresult</structname>, создаваемыми из него. Библиотека <application>libpq</application> не знает, на что указывают сквозной указатель и указатель данных экземпляра (если они ненулевые) и никогда не будет пытаться освобождать их &mdash; за это отвечает обработчик событий.</para>

  <sect2 id="libpq-events-types">
   <title>Типы событий</title>

   <para>Перечисление <literal>PGEventId</literal> описывает типы событий, обрабатываемых системой событий. Имена всех их значений начинаются с <literal>PGEVT</literal>. Для каждого типа событий имеется соответствующая структура информации о событии, содержащая параметры, передаваемые обработчикам событий. Определены следующие типы событий:</para>

   <variablelist>
    <varlistentry id="libpq-pgevt-register">
     <term><literal>PGEVT_REGISTER</literal></term>
     <listitem>
      <para>Событие регистрации происходит, когда вызывается <function>PQregisterEventProc</function>. Это идеальное время для инициализации данных экземпляра (<literal>instanceData</literal>), которые могут понадобиться процедуре событий. Для каждого обработчика событий в рамках соединения будет выдаваться только одно событие регистрации. Если обработка события завершается ошибкой, регистрация прерывается. <synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis> При поступлении события <literal>PGEVT_REGISTER</literal> указатель <parameter>evtInfo</parameter> следует привести к <structname>PGEventRegister *</structname>. Эта структура содержит объект <structname>PGconn</structname>, который должен быть в состоянии <literal>CONNECTION_OK</literal>; это гарантируется, если <function>PQregisterEventProc</function> вызывается сразу после получения рабочего объекта <structname>PGconn</structname>. В случае выдачи кода ошибки всю очистку необходимо провести самостоятельно, так как событие <literal>PGEVT_CONNDESTROY</literal> не поступит.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-connreset">
     <term><literal>PGEVT_CONNRESET</literal></term>
     <listitem>
      <para>Событие сброса соединения происходит при завершении <function>PQreset</function> или <function>PQresetPoll</function>. В обоих случаях это событие вызывается, только если сброс был успешным. Если обработка события завершается ошибкой, происходит сбой всей операции сброса соединения; объект <structname>PGconn</structname> переходит в состояние <literal>CONNECTION_BAD</literal> и <function>PQresetPoll</function> возвращает <literal>PGRES_POLLING_FAILED</literal>. <synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis> При поступлении события <literal>PGEVT_CONNRESET</literal> указатель <parameter>evtInfo</parameter> следует привести к <structname>PGEventConnReset *</structname>. Хотя переданный объект <structname>PGconn</structname> был только что сброшен, все данные события остаются неизменными. При поступлении этого события должны быть сброшены/перезагружены/вновь запрошены все сопутствующие данные <literal>instanceData</literal>. Заметьте, что даже если обработчик события выдаст ошибку при обработке <literal>PGEVT_CONNRESET</literal>, событие <literal>PGEVT_CONNDESTROY</literal> всё равно поступит при закрытии соединения.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-conndestroy">
     <term><literal>PGEVT_CONNDESTROY</literal></term>
     <listitem>
      <para>Событие уничтожения соединения вызывается в ответ на вызов <function>PQfinish</function>. Обработчик этого события отвечает за корректную очистку своих данных событий, так как libpq не может управлять его памятью. Невыполнение очистки должным образом приведёт к утечкам памяти. <synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis> При поступлении события <literal>PGEVT_CONNDESTROY</literal> указатель <parameter>evtInfo</parameter> следует привести к <structname>PGEventConnDestroy *</structname>. Это событие происходит перед тем, как <function>PQfinish</function> производит всю остальную очистку. Значение, возвращаемое обработчиком событий, игнорируется, так как из <function>PQfinish</function> никак нельзя сообщить об ошибке. Кроме того, ошибка в обработчике событий не должна прерывать процесс очистки ставшей ненужной памяти.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcreate">
     <term><literal>PGEVT_RESULTCREATE</literal></term>
     <listitem>
      <para>Событие создания объекта результата происходит при завершении любой функции, выполняющей запрос и получающей результат, включая <function>PQgetResult</function>. Это событие происходит только после того, как результат был успешно получен. <synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis> При поступлении события <literal>PGEVT_RESULTCREATE</literal> указатель <parameter>evtInfo</parameter> следует привести к <structname>PGEventResultCreate *</structname>. В <parameter>conn</parameter> передаётся соединение, для которого сформирован результат. Это идеальное место для инициализации любых данных <literal>instanceData</literal>, которые нужно связать с результатом. В случае сбоя обработчика объект результата очищается и ошибка распространяется дальше. Обработчик события не должен пытаться выполнять <function>PQclear</function> для объекта результата самостоятельно. Возвращая ошибку, необходимо выполнить очистку данных, так как событие <literal>PGEVT_RESULTDESTROY</literal> для этого объекта не поступит.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcopy">
     <term><literal>PGEVT_RESULTCOPY</literal></term>
     <listitem>
      <para>Событие копирования объекта результата происходит при выполнении функции <function>PQcopyResult</function>. Это событие происходит только после того, как копирование будет завершено. Только те обработчики событий, которые успешно обработали событие <literal>PGEVT_RESULTCREATE</literal> или <literal>PGEVT_RESULTCOPY</literal> для исходного объекта, получат событие <literal>PGEVT_RESULTCOPY</literal>. <synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis> При поступлении события <literal>PGEVT_RESULTCOPY</literal> указатель <parameter>evtInfo</parameter> следует привести к <structname>PGEventResultCopy *</structname>. Поле <parameter>src</parameter> указывает на объект результата, который копируется, а <parameter>dest</parameter> — на целевой объект. Это событие может применяться для реализации внутреннего копирования <literal>instanceData</literal>, так как сама функция <literal>PQcopyResult</literal> не может это сделать. В случае сбоя обработчика вся операция копирования прерывается и объект результата в <parameter>dest</parameter> очищается. Возвращая ошибку, необходимо выполнить очистку данных целевого объекта, так как событие <literal>PGEVT_RESULTDESTROY</literal> для него не поступит.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultdestroy">
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
     <listitem>
      <para>Событие уничтожения объекта результата происходит при выполнении <function>PQclear</function>. Обработчик этого события отвечает за корректную очистку своих данных событий, так как libpq не может управлять его памятью. Невыполнение очистки должным образом приведёт к утечкам памяти. <synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis> При поступлении события <literal>PGEVT_RESULTDESTROY</literal> указатель <parameter>evtInfo</parameter> следует привести к <structname>PGEventResultDestroy *</structname>. Это событие происходит перед тем, как <function>PQclear</function> производит всю остальную очистку. Значение, возвращаемое обработчиком событий, игнорируется, так как из <function>PQclear</function> никак нельзя сообщить об ошибке. Кроме того, ошибка в обработчике событий не должна прерывать процесс очистки ставшей ненужной памяти.</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-proc">
   <title>Процедура обработки событий</title>

   <variablelist>
    <varlistentry id="libpq-pgeventproc">
     <term>
      <literal>PGEventProc</literal>
      <indexterm><primary>PGEventProc</primary></indexterm>
     </term>

     <listitem>
      <para><literal>PGEventProc</literal> — это определение типа для указателя на обработчик событий, то есть функцию обратного вызова, получающую события от libpq. Обработчик событий должен иметь такую сигнатуру: <synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis> Параметр <parameter>evtId</parameter> говорит, какое событие <literal>PGEVT</literal> произошло. Указатель <parameter>evtInfo</parameter> должен приводиться к типу определённой структуры для получения дополнительной информации о событии. В параметре <parameter>passThrough</parameter> передаётся сквозной указатель, поступивший в <function>PQregisterEventProc</function> при регистрации обработчика события. Эта функция должна вернуть ненулевое значение в случае успеха или ноль в противном случае.</para>

      <para>Обработчик определённого события может быть зарегистрирован в любом <structname>PGconn</structname> только раз. Это связано с тем, что адрес обработчика используется как ключ для выбора связанных данных экземпляра.</para>

      <caution>
       <para>В Windows функции могут иметь два разных адреса: один, видимый снаружи DLL, и второй, видимый внутри DLL. Учитывая это, надо позаботиться о том, чтобы только один из адресов использовался с функциями обработки событий <application>libpq</application>, иначе возникнет путаница. Самый простой способ написать код, который будет работать — всегда помечать обработчик событий как <literal>static</literal>. Если адрес обработчика нужно получить вне его исходного файла, экспортируйте отдельную функцию, которая будет возвращать этот адрес.</para>
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-funcs">
   <title>Функции поддержки событий</title>

    <variablelist>
    <varlistentry id="libpq-pqregistereventproc">
     <term>
      <function>PQregisterEventProc</function>
      <indexterm><primary>PQregisterEventProc</primary></indexterm>
     </term>

     <listitem>
      <para>Регистрирует обработчик событий в libpq. <synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis></para>

      <para>Обработчик событий должен быть зарегистрирован один раз для каждого соединения <structname>PGconn</structname>, события которого представляют интерес. Число обработчиков событий, которые можно зарегистрировать для соединения, не ограничивается ничем, кроме объёма памяти. Эта функция возвращает ненулевое значение в случае успеха или ноль в противном случае.</para>

      <para>Процедура, переданная в аргументе <parameter>proc</parameter>, будет вызываться, когда произойдёт событие libpq. Её адрес в памяти также применяется для поиска данных <literal>instanceData</literal>. Аргумент <parameter>name</parameter> используется при упоминании обработчика событий в сообщениях об ошибках. Это значение не может быть равно <symbol>NULL</symbol> или указывать на строку нулевой длины. Эта строка имени копируется в <structname>PGconn</structname>, так что переданная строка может быть временной. Сквозной указатель (<parameter>passThrough</parameter>) будет передаваться обработчику <parameter>proc</parameter> при каждом вызове события. Этот аргумент может равняться <symbol>NULL</symbol>.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetinstancedata">
     <term>
      <function>PQsetInstanceData</function>
      <indexterm><primary>PQsetInstanceData</primary></indexterm>
     </term>
     <listitem>
      <para>Устанавливает для подключения <parameter>conn</parameter> указатель <literal>instanceData</literal> для обработчика <parameter>proc</parameter> равным <parameter>data</parameter>. Эта функция возвращает ненулевое значение в случае успеха или ноль в противном случае. (Ошибка возможна, только если обработчик <parameter>proc</parameter> не был корректно зарегистрирован для соединения <parameter>conn</parameter>.) <synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinstancedata">
     <term>
      <function>PQinstanceData</function>
      <indexterm><primary>PQinstanceData</primary></indexterm>
     </term>
     <listitem>
      <para>Возвращает для соединения <parameter>conn</parameter> указатель на <literal>instanceData</literal>, связанный с обработчиком <parameter>proc</parameter>, либо <symbol>NULL</symbol>, если такого обработчика нет. <synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultsetinstancedata">
     <term>
      <function>PQresultSetInstanceData</function>
      <indexterm><primary>PQresultSetInstanceData</primary></indexterm>
     </term>
     <listitem>
      <para>Устанавливает для объекта результата (<parameter>res</parameter>) указатель <literal>instanceData</literal> для обработчика <parameter>proc</parameter> равным <parameter>data</parameter>. Эта функция возвращает ненулевое значение в случае успеха или ноль в противном случае. (Ошибка возможна, только если обработчик <parameter>proc</parameter> не был корректно зарегистрирован для объекта результата.) <synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis></para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultinstancedata">
     <term>
      <function>PQresultInstanceData</function>
      <indexterm><primary>PQresultInstanceData</primary></indexterm>
     </term>
     <listitem>
      <para>Возвращает для объекта результата (<parameter>res</parameter>) указатель на <literal>instanceData</literal>, связанный с обработчиком <parameter>proc</parameter>, либо <symbol>NULL</symbol>, если такого обработчика нет. <synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis></para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-example">
   <title>Пример обработки событий</title>

   <para>Ниже показан схематичный пример управления внутренними данными, связанными с подключениями и результатами libpq.</para>

<programlisting>
<![CDATA[
/* required header for libpq events (note: includes libpq-fe.h) */
#include <libpq-events.h>

/* The instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* called once on any connection that should receive events.
     * Sends a PGEVT_REGISTER to myEventProc.
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    /* conn instanceData is available */
    data = PQinstanceData(conn, myEventProc);

    /* Sends a PGEVT_RESULTCREATE to myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* result instanceData is available */
    data = PQresultInstanceData(res, myEventProc);

    /* If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* result instanceData is available if PG_COPYRES_EVENTS was
     * used during the PQcopyResult call.
     */
    data = PQresultInstanceData(res_copy, myEventProc);

    /* Both clears send a PGEVT_RESULTDESTROY to myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* Sends a PGEVT_CONNDESTROY to myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* associate app specific data with connection */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* free instance data because the conn is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* associate app specific data with result (copy it from conn) */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* associate app specific data with result (copy it from a result) */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* free instance data because the result is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        /* unknown event ID, just return TRUE. */
        default:
            break;
    }

    return TRUE; /* event processing succeeded */
}
]]>
</programlisting>
  </sect2>
 </sect1>

 <sect1 id="libpq-envars">
  <title>Переменные окружения</title>

  <indexterm zone="libpq-envars"><primary>переменная окружения</primary></indexterm>

  <para>Воспользовавшись следующими переменными окружения, можно задать значения параметров соединения по умолчанию, которые будут использоваться функциями <function>PQconnectdb</function>, <function>PQsetdbLogin</function> и <function>PQsetdb</function>, если никакое значение не будет задано вызывающим кодом. В частности, используя их, можно обойтись без жёсткого задания параметров соединения в простых клиентских приложениях. <itemizedlist>
    <listitem>
     <para><indexterm><primary><envar>PGHOST</envar></primary></indexterm> <envar>PGHOST</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-host"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGHOSTADDR</envar></primary></indexterm> <envar>PGHOSTADDR</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-hostaddr"/>. Эту переменную можно задать вместо или вместе с <envar>PGHOST</envar> для предотвращения поиска адреса в DNS.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGPORT</envar></primary></indexterm> <envar>PGPORT</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-port"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGDATABASE</envar></primary></indexterm> <envar>PGDATABASE</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-dbname"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGUSER</envar></primary></indexterm> <envar>PGUSER</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-user"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGPASSWORD</envar></primary></indexterm> <envar>PGPASSWORD</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-password"/>. Использовать эту переменную окружения не рекомендуется по соображениям безопасности, так как в некоторых операционных системах непривилегированные пользователи могут видеть переменные окружения процессов в выводе <application>ps</application>; вместо этого лучше использовать файл <filename>~/.pgpass</filename> (см. <xref remap="4" linkend="libpq-pgpass"/>).</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGPASSFILE</envar></primary></indexterm> <envar>PGPASSFILE</envar> устанавливает имя файла паролей, в котором будут находиться сохранённые пароли. По умолчанию применяется имя файла <filename>~/.pgpass</filename> (см. <xref remap="4" linkend="libpq-pgpass"/>).</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSERVICE</envar></primary></indexterm> <envar>PGSERVICE</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-service"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSERVICEFILE</envar></primary></indexterm> <envar>PGSERVICEFILE</envar> задаёт имя личного файла пользователя с параметрами подключения к службам. По умолчанию применяется имя файла <filename>~/.pg_service.conf</filename> (см. <xref remap="4" linkend="libpq-pgservice"/>).</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGOPTIONS</envar></primary></indexterm> <envar>PGOPTIONS</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-options"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGAPPNAME</envar></primary></indexterm> <envar>PGAPPNAME</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-application-name"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSSLMODE</envar></primary></indexterm> <envar>PGSSLMODE</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-sslmode"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGREQUIRESSL</envar></primary></indexterm> <envar>PGREQUIRESSL</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-requiressl"/>. Эта переменная окружения утратила актуальность с появлением переменной <envar>PGSSLMODE</envar>; если установить обе переменные, значение данной не возымеет эффекта.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSSLCOMPRESSION</envar></primary></indexterm> <envar>PGSSLCOMPRESSION</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-sslcompression"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSSLCERT</envar></primary></indexterm> <envar>PGSSLCERT</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-sslcert"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSSLKEY</envar></primary></indexterm> <envar>PGSSLKEY</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-sslkey"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSSLROOTCERT</envar></primary></indexterm> <envar>PGSSLROOTCERT</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-sslrootcert"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGSSLCRL</envar></primary></indexterm> <envar>PGSSLCRL</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-sslcrl"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGREQUIREPEER</envar></primary></indexterm> <envar>PGREQUIREPEER</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-requirepeer"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGKRBSRVNAME</envar></primary></indexterm> <envar>PGKRBSRVNAME</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-krbsrvname"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGGSSLIB</envar></primary></indexterm> <envar>PGGSSLIB</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-gsslib"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGCONNECT_TIMEOUT</envar></primary></indexterm> <envar>PGCONNECT_TIMEOUT</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-connect-timeout"/>.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGCLIENTENCODING</envar></primary></indexterm> <envar>PGCLIENTENCODING</envar> действует так же, как параметр соединения <xref linkend="libpq-connect-client-encoding"/>.</para>
    </listitem>


   </itemizedlist></para>

  <para>Следующие переменные окружения позволяют задать поведение по умолчанию для каждого отдельного сеанса <productname>&productname;</productname>. (См. также описание команд <xref linkend="sql-alterrole"/> и <xref linkend="sql-alterdatabase"/>, позволяющих установить поведение по умолчанию для отдельного пользователя или отдельной базы.) <itemizedlist>
    <listitem>
     <para><indexterm><primary><envar>PGDATESTYLE</envar></primary></indexterm> <envar>PGDATESTYLE</envar> устанавливает стиль представления даты/времени по умолчанию. (Равносильно <literal>SET datestyle TO ...</literal>.)</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGTZ</envar></primary></indexterm> <envar>PGTZ</envar> устанавливает часовой пояс по умолчанию. (Равносильно <literal>SET timezone TO ...</literal>.)</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGGEQO</envar></primary></indexterm> <envar>PGGEQO</envar> устанавливает режим по умолчанию для генетического оптимизатора запросов. (Равносильно <literal>SET geqo TO ...</literal>.)</para>
    </listitem>
   </itemizedlist> Информацию о корректных значениях этих переменных окружения можно найти в описании <acronym>SQL</acronym>-команды <xref linkend="sql-set"/>.</para>

  <para>Следующие переменные среды определяют внутреннее поведение <application>libpq</application>; они переопределяют встроенные значения. <itemizedlist>
    <listitem>
     <para><indexterm><primary><envar>PGSYSCONFDIR</envar></primary></indexterm> <envar>PGSYSCONFDIR</envar> задаёт каталог, в котором содержится файл <filename>pg_service.conf</filename>, а в будущем он может содержать и другие общесистемные файлы конфигурации.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary><envar>PGLOCALEDIR</envar></primary></indexterm> <envar>PGLOCALEDIR</envar> задаёт каталог, содержащий файлы <literal>locale</literal>, предназначенные для перевода сообщений.</para>
    </listitem>
   </itemizedlist></para>

 </sect1>


 <sect1 id="libpq-pgpass">
  <title>Файл паролей</title>

  <indexterm zone="libpq-pgpass"><primary>файл паролей</primary></indexterm>
  <indexterm zone="libpq-pgpass"><primary>.pgpass</primary></indexterm>

  <para>Файл <filename>.pgpass</filename> в домашнем каталоге пользователя или файл, заданный в <envar>PGPASSFILE</envar>, может содержать пароли, которые будут использоваться, если для подключения требуется пароль (и пароль не задаётся другим способом). В Microsoft Windows этот файл называется <filename>%APPDATA%\postgresql\pgpass.conf</filename> (где <filename>%APPDATA%</filename> обозначает каталог данных приложений (Application Data) в профиле пользователя).</para>

  <para>Этот файл должен содержать строки следующего формата: <synopsis>
<replaceable>сервер</replaceable>:<replaceable>порт</replaceable>:<replaceable>база_данных</replaceable>:<replaceable>имя_пользователя</replaceable>:<replaceable>пароль</replaceable>
</synopsis> (Вы можете вставить в этот файл комментарий-памятку, скопировав показанную строку в него и добавив в начало <literal>#</literal>.) Первые четыре поля могут содержать строковые значения, либо знак <literal>*</literal>, соответствующий всему. Применяться будет пароль, указанный в первой из строк, значения полей в которой соответствуют текущему соединению. (Поэтому, если вы используете звёздочки, поместите более конкретные записи первыми.) Если запись должна содержать символ <literal>:</literal> или <literal>\</literal>, добавьте перед ним <literal>\</literal>. Имени сервера <literal>localhost</literal> соответствуют локальные соединения и по TCP (по имени компьютера <literal>localhost</literal>), и через доменный сокет Unix (заданный в <literal>pghost</literal>, либо каталог сокетов по умолчанию). На ведомом сервере имя базы данных <literal>replication</literal> соответствует подключениям потоковой репликации, которые устанавливает ведущий. Поле <replaceable>база_данных</replaceable> имеет ограниченную ценность, так как пользователи используют один пароль для всех баз данных в кластере.</para>

  <para>В системах Unix разрешения <filename>.pgpass</filename> должны запрещать чтение его всеми или группой; этого можно добиться командой <command>chmod 0600 ~/.pgpass</command>. Если разрешения будут менее строгими, этот файл не будет прочитан. В Microsoft Windows предполагается, что файл хранится в безопасном месте, и никакие дополнительные проверки не производятся.</para>
 </sect1>


 <sect1 id="libpq-pgservice">
  <title>Файл соединений служб</title>

  <indexterm zone="libpq-pgservice"><primary>файл соединений служб</primary></indexterm>
  <indexterm zone="libpq-pgservice"><primary>pg_service.conf</primary></indexterm>
  <indexterm zone="libpq-pgservice"><primary>.pg_service.conf</primary></indexterm>

  <para>Файл соединений служб позволяет связать параметры соединений libpq с одним именем службы. Затем это имя службы можно задать при подключении через libpq и будут применены все связанные с ним параметры. Это позволяет модифицировать параметры соединений, обходясь без перекомпиляции приложения libpq. Имя службы можно также задать в переменной окружения <envar>PGSERVICE</envar>.</para>

  <para>Файл соединений служб может быть личным файлом пользователя с путём <filename>~/.pg_service.conf</filename> или задаваться переменной окружения <envar>PGSERVICEFILE</envar>, либо это может быть системный файл с путём <filename>`pg_config --sysconfdir`/pg_service.conf</filename> или в каталоге, задаваемом переменной окружения <envar>PGSYSCONFDIR</envar>. Если для одного имени службы существует определение и в системном файле, и в файле пользователя, определение пользователя имеет приоритет.</para>

  <para>В этом файле используется формат <quote>INI-файлов</quote>, в котором имя раздела задаёт имя службы, а параметры внутри — параметры соединения; их список приведён в <xref remap="6" linkend="libpq-paramkeywords"/>. Например: <programlisting># комментарий
[mydb]
host=somehost
port=5433
user=admin</programlisting> Пример такого файла можно найти в <filename>share/pg_service.conf.sample</filename>.</para>
  <para>Если в одном разделе файла службы присутствуют несколько указаний <literal>host</literal>, они воспринимаются как определения альтернативных серверов для отработки отказа или распределения нагрузки (см. описание параметра <xref linkend="libpq-connect-host"/> в строке подключения).</para>
  <para>Для всех других параметров первое значение имеет приоритет перед последующими.</para>
  <para>Параметры, заданные в строке подключения, включая параметры служб, имеют приоритет перед значениями, заданными в файле соединений служб.</para>
 </sect1>


 <sect1 id="libpq-ldap">
  <title>Получение параметров соединения через LDAP</title>

  <indexterm zone="libpq-ldap"><primary>получение параметров соединения через LDAP</primary></indexterm>

  <para>Если библиотека <application>libpq</application> была собрана с поддержка LDAP (<command>configure</command> передавался ключ <literal><option>--with-ldap</option></literal>), такие параметры соединения, как <literal>host</literal> и <literal>dbname</literal>, можно получить через LDAP с центрального сервера. Преимущество такого подхода в том, что при изменении параметров подключения к базе данных свойства соединения не придётся изменять на всех клиентских компьютерах.</para>

  <para>Для получения параметров соединений через LDAP используется файл соединений служб <filename>pg_service.conf</filename> (см. <xref remap="4" linkend="libpq-pgservice"/>). Строка в <filename>pg_service.conf</filename>, начинающаяся с указания протокола <literal>ldap://</literal>, будет воспринята как URL в LDAP и выполнится как запрос к LDAP. Результатом запроса должен быть список пар <literal>keyword = value</literal>, которые и будут задавать параметры соединений. Заданный URL должен соответствовать RFC 1959 и иметь следующий вид: <synopsis>
ldap://[<replaceable>имя_сервера</replaceable>[:<replaceable>порт</replaceable>]]/<replaceable>база_поиска</replaceable>?<replaceable>атрибут</replaceable>?<replaceable>область_поиска</replaceable>?<replaceable>фильтр</replaceable>
</synopsis>; по умолчанию <replaceable>имя_сервера</replaceable> — <literal>localhost</literal>, а <replaceable>порт</replaceable> — 389.</para>

  <para>Обработка <filename>pg_service.conf</filename> прекращается после удачного поиска в LDAP, но если с сервером LDAP связаться не удаётся, обрабатываются следующие строки этого файла. Так сделано для того, чтобы можно было реализовать запасные варианты, добавив дополнительные строки с URL LDAP, указывающими на другие серверы LDAP, или классические пары <literal>keyword = value</literal>, либо используя параметры соединений по умолчанию. Если же вы хотите получить ошибку в этой ситуации, добавьте после строки с URL-адресом LDAP синтаксически некорректную строку.</para>

  <para>Простую запись LDAP, созданную из такого файла LDIF <programlisting>version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require</programlisting> можно запросить из каталога LDAP, указав следующий URL: <programlisting>ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)</programlisting></para>

  <para>Также возможно сочетать обычные записи в файле служб с поиском в LDAP. Полный пример описания службы в <filename>pg_service.conf</filename> может быть таким: <programlisting># в LDAP хранится только имя и порт сервера; имя базы и пользователя нужно задать явно
[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)</programlisting></para>

 </sect1>


 <sect1 id="libpq-ssl">
  <title>Поддержка SSL</title>

  <indexterm zone="libpq-ssl"><primary>SSL</primary></indexterm>

  <para><productname>&productname;</productname> реализует собственную поддержку <acronym>SSL</acronym>-подключений для шифрования клиент-серверного взаимодействия в качестве меры безопасности. Подробнее функциональность <acronym>SSL</acronym> на стороне сервера описывается в <xref remap="6" linkend="ssl-tcp"/>.</para>

  <para>Библиотека <application>libpq</application> читает системный файл конфигурации <productname>OpenSSL</productname>. По умолчанию этот файл называется <filename>openssl.cnf</filename> и находится в каталоге, который сообщает команда <literal>openssl version -d</literal>. Если требуется указать другое расположение файла конфигурации, его можно задать в переменной окружения <envar>OPENSSL_CONF</envar>.</para>

 <sect2 id="libq-ssl-certificates">
  <title>Проверка сертификатов сервера на стороне клиента</title>

  <para>По умолчанию <productname>&productname;</productname> не выполняет никакие проверки сертификата сервера. Это означает, что клиента можно ввести в заблуждение, подменив сервер (например, изменив запись в DNS или заняв его IP-адрес). Чтобы предотвратить подобную подмену, необходимо включить проверку сертификатов <acronym>SSL</acronym>.</para>

  <para>Если в <literal>sslmode</literal> выбран режим <literal>verify-ca</literal>, libpq будет определять, можно ли доверять серверу, проверяя всю цепочку сертификатов до доверенного центра сертификации (<acronym>ЦС</acronym>). Если режим <literal>sslmode</literal> — <literal>verify-full</literal>, libpq будет <emphasis>также</emphasis> проверять, соответствует ли имя сервера имени в сертификате. Подключение SSL не будет установлено, если проверить сертификат сервера не удастся. В максимально защищённых окружениях рекомендуется использовать режим <literal>verify-full</literal>.</para>

  <para>В режиме <literal>verify-full</literal> имя компьютера сверяется с атрибутом (или атрибутами) Subject Alternative Name (Альтернативное имя субъекта) в сертификате или с атрибутом Common Name (Общее имя), если в сертификате отсутствует атрибут Subject Alternative Name типа <literal>dNSName</literal>. Если атрибут имени сертификата начинается со звёздочки (<literal>*</literal>), звёздочка воспринимается как подстановочный знак и ей будут соответствовать все символы, <emphasis>кроме</emphasis> точки (<literal>.</literal>). Это означает, что такой сертификат не будет соответствовать поддоменам. Если подключение устанавливается по IP-адресу, а не по имени компьютера, проверяться будет IP-адрес (без поиска в DNS).</para>

  <para>Чтобы можно было проверить сертификат сервера, файл <filename>~/.postgresql/root.crt</filename> в домашнем каталоге пользователя должен содержать сертификат(ы) одного или нескольких доверенных <acronym>ЦС</acronym>. Если <filename>root.crt</filename> содержит сертификаты промежуточных <acronym>ЦС</acronym>, он также должен содержать цепочки сертификатов до их корневого <acronym>ЦС</acronym>. (В Microsoft Windows этот файл называется <filename>%APPDATA%\postgresql\root.crt</filename>.)</para>

  <para>Если существует файл <filename>~/.postgresql/root.crl</filename> (или <filename>%APPDATA%\postgresql\root.crl</filename> в Microsoft Windows), при проверке также учитывается содержащийся в нём список отозванных сертификатов (CRL, Certificate Revocation List).</para>

  <para>Размещение файла корневых сертификатов и CRL можно поменять, задав параметры соединения <literal>sslrootcert</literal> и <literal>sslcrl</literal> или переменные окружения <envar>PGSSLROOTCERT</envar> и <envar>PGSSLCRL</envar>, соответственно.</para>

  <note>
   <para>Для обратной совместимости с предыдущими версиями &productname;, при наличии файла с сертификатами корневых ЦС поведение режима <literal>sslmode</literal>=<literal>require</literal> не отличается от режима <literal>verify-ca</literal>, то есть сертификат сервера будет проверяться по сертификату ЦС. Полагаться на это поведение не рекомендуется — приложения, которым нужно проверять сертификат, должны всегда выбирать режим <literal>verify-ca</literal> или <literal>verify-full</literal>.</para>
  </note>
 </sect2>

 <sect2 id="libpq-ssl-clientcert">
  <title>Клиентские сертификаты</title>

  <para>Если сервер запрашивает доверенный клиентский сертификат, <application>libpq</application> передаёт ему сертификат из файла <filename>~/.postgresql/postgresql.crt</filename> в домашнем каталоге пользователя. Этот сертификат должен быть подписан одним из центров сертификации (<acronym>ЦС</acronym>), доверенным для сервера. Также должен присутствовать закрытый ключ в файле <filename>~/.postgresql/postgresql.key</filename>. Файл закрытого ключа не должен быть доступен всем или группе; этого можно добиться командой <command>chmod 0600 ~/.postgresql/postgresql.key</command>. В Microsoft Windows эти файлы называются <filename>%APPDATA%\postgresql\postgresql.crt</filename> и <filename>%APPDATA%\postgresql\postgresql.key</filename>, и никакие специальные проверки не производятся, так как предполагается, что этот каталог безопасен. Размещение файлов сертификата и ключа можно переопределить параметрами соединения <literal>sslcert</literal> и <literal>sslkey</literal>, либо переменными окружения <envar>PGSSLCERT</envar> и <envar>PGSSLKEY</envar>, соответственно.</para>

  <para>В некоторых случаях сертификат клиента может подписываться <quote>промежуточным</quote> центром сертификации, сам сертификат не обязательно должен быть доверенным для сервера. Чтобы использовать такой сертификат, нужно добавить в файл <filename>postgresql.crt</filename> сертификат выдавшего его центра сертификации, затем сертификат вышестоящего центра и так далее, до сертификата <quote>корневого</quote> или <quote>промежуточного</quote> центра, которому доверяет сервер. Сервер считает сертификат доверенным, если он подписан сертификатом, содержащимся в его собственном файле <filename>root.crt</filename>.</para>

  <para>Заметьте, что файл <filename>~/.postgresql/root.crt</filename> на клиенте содержит сертификаты центров сертификации верхнего уровня, которые считаются доверенными для подписания серверных сертификатов. В принципе в нём может отсутствовать сертификат ЦС, подписавшего сертификат клиента, хотя в большинстве случаев этот ЦС также будет доверенным для клиентских сертификатов.</para>

 </sect2>

 <sect2 id="libpq-ssl-protection">
  <title>Защита, обеспечиваемая в различных режимах</title>

  <para>Разные значения параметра <literal>sslmode</literal> обеспечивают разные уровни защиты. SSL позволяет защититься от следующих типов атак: <variablelist>
    <varlistentry>
     <term>Прослушивание</term>
     <listitem>
      <para>Если третья сторона может прослушивать сетевой трафик между клиентом и сервером, она может получить как информацию соединения (включая имя пользователя и пароль), так и передаваемые данные. Чтобы защититься от этого, <acronym>SSL</acronym> шифрует трафик.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Посредник (<acronym>MITM</acronym>)</term>
     <listitem>
      <para>Если третья сторона может модифицировать данные, передаваемые между клиентом и сервером, она может представиться сервером и, таким образом, сможет видеть и модифицировать данные, <emphasis>даже если они зашифрованы</emphasis>. Третья сторона затем может воспроизводить характеристики соединения и данные для подлинного сервера, что сделает невозможным обнаружение этой атаки. Векторами такой атаки может быть &laquo;отравление&raquo; DNS и подмена адресов, в результате чего клиент будет обращаться не к тому серверу, к которому нужно. Также есть несколько других вариантов реализации этой атаки. Для защиты в <acronym>SSL</acronym> применяется проверка сертификатов, в результате которой сервер доказывает свою подлинность клиенту.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Олицетворение</term>
     <listitem>
      <para>Если третья сторона может представляться авторизованным клиентом, она может просто обращаться к данным, к которым не должна иметь доступа. Обычно это происходит вследствие небезопасного управления паролями. В <acronym>SSL</acronym> для предотвращения этой угрозы используются клиентские сертификаты, гарантирующие, что к серверу могут обращаться только владельцы действительных сертификатов.</para>
     </listitem>
    </varlistentry>
   </variablelist></para>

  <para>Чтобы соединение было гарантированно безопасным, SSL должен быть настроен <emphasis>на клиенте и на сервере</emphasis>, прежде чем будет установлено соединение. Если он настроен только на сервере, клиент может начать передавать важную информацию (например, пароли), до того как поймёт, что сервер требует высокого уровня безопасности. В libpq для установления безопасных соединений нужно задать для параметра <literal>sslmode</literal> значение <literal>verify-full</literal> или <literal>verify-ca</literal> и предоставить системе корневой сертификат для проверки. В качестве аналогии можно привести использование адреса с <literal>https</literal> для безопасного просмотра веб-содержимого.</para>

  <para>Когда подлинность сервера подтверждена, клиент может передавать конфиденциальные данные. Это значит, что до этого момента клиенту не нужно знать, применяются ли сертификаты для аутентификации, так что настройка использования сертификатов только на стороне сервера не угрожает безопасности.</para>

  <para>Все варианты использования <acronym>SSL</acronym> подразумевают издержки шифрования и обмена ключами, что порождает необходимость выбора между производительностью и безопасностью. В <xref remap="6" linkend="libpq-ssl-sslmode-statements"/> описываются риски, от которых защищают различные варианты <literal>sslmode</literal>, и приводятся утверждения относительно защиты и издержек.</para>

  <table id="libpq-ssl-sslmode-statements">
   <title>Описания режимов SSL</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry><literal>sslmode</literal></entry>
      <entry>Защита от прослушивания</entry>
      <entry>Защита от <acronym>MITM</acronym></entry>
      <entry>Утверждение</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>disable</literal></entry>
      <entry>Нет</entry>
      <entry>Нет</entry>
      <entry>Мне не важна безопасность и я не приемлю издержки, связанные с шифрованием.</entry>
     </row>

     <row>
      <entry><literal>allow</literal></entry>
      <entry>Возможно</entry>
      <entry>Нет</entry>
      <entry>Мне не важна безопасность, но я приемлю издержки, связанные с шифрованием, если на этом настаивает сервер.</entry>
     </row>

     <row>
      <entry><literal>prefer</literal></entry>
      <entry>Возможно</entry>
      <entry>Нет</entry>
      <entry>Мне не важна безопасность, но я предпочитаю шифрование (и приемлю связанные издержки), если это поддерживает сервер.</entry>
     </row>

     <row>
      <entry><literal>require</literal></entry>
      <entry>Да</entry>
      <entry>Нет</entry>
      <entry>Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. Я доверяю сети в том, что она обеспечивает подключение к нужному серверу.</entry>
     </row>

     <row>
      <entry><literal>verify-ca</literal></entry>
      <entry>Да</entry>
      <entry>Зависит от политики <acronym>ЦС</acronym></entry>
      <entry>Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. Мне нужна уверенность в том, что я подключаюсь к доверенному серверу.</entry>
     </row>

     <row>
      <entry><literal>verify-full</literal></entry>
       <entry>Да</entry>
       <entry>Да</entry>
       <entry>Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. Мне нужна уверенность в том, что я подключаюсь к доверенному серверу и это именно указанный мной сервер.</entry>
      </row>

    </tbody>
   </tgroup>
  </table>

  <para>Различие вариантов <literal>verify-ca</literal> и <literal>verify-full</literal> зависит от характера корневого <acronym>ЦС</acronym>. Если используется публичный <acronym>ЦС</acronym>, режим <literal>verify-ca</literal> допускает подключение к серверу с сертификатом, который получил <emphasis>кто угодно</emphasis> в этом <acronym>ЦС</acronym>. В такой ситуации нужно всегда использовать режим <literal>verify-full</literal>. Если же используется локальный <acronym>ЦС</acronym> или даже самоподписанный сертификат, режим <literal>verify-ca</literal> обычно обеспечивает достаточную защиту.</para>

  <para>По умолчанию параметр <literal>sslmode</literal> имеет значение <literal>prefer</literal>. Как показано в этой таблице, он не имеет большого смысла с точки зрения безопасности, и даёт только выигрыш в производительности, если это возможно. Он выбран по умолчанию для обратной совместимости и не рекомендуется для защищённых окружений.</para>

 </sect2>

 <sect2 id="libpq-ssl-fileusage">
  <title>Файлы, используемые клиентом SSL</title>

  <para>В <xref remap="6" linkend="libpq-ssl-file-usage"/> перечислены файлы, имеющие отношение к настройке SSL на стороне клиента.</para>

  <table id="libpq-ssl-file-usage">
   <title>Файлы, используемые клиентом SSL/libpq</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Файл</entry>
      <entry>Содержимое</entry>
      <entry>Назначение</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><filename>~/.postgresql/postgresql.crt</filename></entry>
      <entry>сертификат клиента</entry>
      <entry>запрашивается сервером</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/postgresql.key</filename></entry>
      <entry>закрытый ключ клиента</entry>
      <entry>подтверждает клиентский сертификат, передаваемый владельцем; не гарантирует, что владелец сертификата заслуживает доверия</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crt</filename></entry>
      <entry>сертификаты доверенных ЦС</entry>
      <entry>позволяет проверить, что сертификат сервера подписан доверенным центром сертификации</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crl</filename></entry>
      <entry>сертификаты, отозванные центрами сертификации</entry>
      <entry>сертификат сервера должен отсутствовать в этом списке</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="libpq-ssl-initialize">
  <title>Инициализация библиотеки SSL</title>

  <para>Если ваше приложение инициализирует библиотеку <literal>libssl</literal> и/или <literal>libcrypto</literal>, и <application>libpq</application> собрана с поддержкой <acronym>SSL</acronym>, вы должны вызвать <function>PQinitOpenSSL</function>, чтобы сообщить <application>libpq</application>, что библиотека <literal>libssl</literal> и/или <literal>libcrypto</literal> уже инициализированы вашим приложением, чтобы <application>libpq</application> не пыталась ещё раз инициализировать их. Более подробно API SSL описано на странице <ulink url="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html"/>.</para>

  <para>
   <variablelist>
    <varlistentry id="libpq-pqinitopenssl">
     <term>
      <function>PQinitOpenSSL</function>
      <indexterm><primary>PQinitOpenSSL</primary></indexterm>
     </term>

     <listitem>
      <para>Позволяет приложениям выбрать, какие библиотеки безопасности нужно инициализировать. <synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis></para>

      <para>Когда параметр <parameter>do_ssl</parameter> отличен от нуля, <application>libpq</application> будет инициализировать библиотеку <application>OpenSSL</application> перед первым подключением к базе данных. Когда параметр <parameter>do_crypto</parameter> не равен нулю, будет инициализироваться библиотека <literal>libcrypto</literal>. По умолчанию (если функция <function>PQinitOpenSSL</function> не вызывается) инициализируются обе библиотеки. Если поддержка SSL не была скомпилирована, эта функция присутствует, но ничего не делает.</para>

      <para>Если ваше приложение использует и инициализирует библиотеку <application>OpenSSL</application> или её нижележащую библиотеку <literal>libcrypto</literal>, вы <emphasis>должны</emphasis> вызвать эту функцию, передав нули в соответствующих параметрах, перед первым подключением к базе данных. Собственно инициализацию также важно произвести перед установлением подключения.</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinitssl">
     <term>
      <function>PQinitSSL</function>
      <indexterm><primary>PQinitSSL</primary></indexterm>
     </term>

     <listitem>
      <para>Позволяет приложениям выбрать, какие библиотеки безопасности нужно инициализировать. <synopsis>
void PQinitSSL(int do_ssl);
</synopsis></para>

      <para>Эта функция равнозначна вызову <literal>PQinitOpenSSL(do_ssl, do_ssl)</literal>. Приложениям достаточно инициализировать или не инициализировать обе библиотеки <application>OpenSSL</application> и <literal>libcrypto</literal> одновременно.</para>

      <para>Функция <function>PQinitSSL</function> существует со времён <productname>PostgreSQL</productname> 8.0, тогда как <function>PQinitOpenSSL</function> появилась в <productname>PostgreSQL</productname> 8.4, так что <function>PQinitSSL</function> может быть предпочтительней для приложений, которым нужно работать с более старыми версиями <application>libpq</application>.</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

 </sect1>


 <sect1 id="libpq-threading">
  <title>Поведение в многопоточных программах</title>

  <indexterm zone="libpq-threading"><primary>потоки</primary> <secondary>с libpq</secondary></indexterm>

  <para>Библиотека <application>libpq</application> по умолчанию поддерживает повторные вызовы и многопоточность. Для соответствующего варианта сборки вашего приложения вам может понадобиться передать компилятору специальные параметры командной строки. Чтобы узнать, как собрать многопоточное приложение, обратитесь к документации вашей системы или поищите в файле <filename>src/Makefile.global</filename> значения <literal>PTHREAD_CFLAGS</literal> и <literal>PTHREAD_LIBS</literal>. Эта функция позволяет узнать, поддерживает ли <application>libpq</application> многопоточность:</para>

  <variablelist>
   <varlistentry id="libpq-pqisthreadsafe">
    <term>
     <function>PQisthreadsafe</function>
     <indexterm><primary>PQisthreadsafe</primary></indexterm>
    </term>

    <listitem>
     <para>Возвращает состояние потокобезопасности в библиотеке <application>libpq</application>. <synopsis>
int PQisthreadsafe();
</synopsis></para>

     <para>Возвращает 1, если библиотека <application>libpq</application> потокобезопасная, или 0 в противном случае.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>Реализация многопоточности не лишена ограничений: два потока не должны пытаться одновременно работать с одним объектом <structname>PGconn</structname>. В частности, не допускается параллельное выполнение команд из разных потоков через один объект соединения. (Если вам нужно выполнять команды одновременно, используйте несколько соединений.)</para>

  <para>Объекты <structname>PGresult</structname> после создания обычно доступны только для чтения, и поэтому их можно свободно передавать между потоками. Однако, если вы используете какую-либо из функций, изменяющих <structname>PGresult</structname>, описанных в <xref remap="6" linkend="libpq-misc"/> или <xref remap="6" linkend="libpq-events"/>, вы должны также избегать одновременных обращений к одному объекту <structname>PGresult</structname>.</para>

  <para>Устаревшие функции <function>PQrequestCancel</function> и <function>PQoidStatus</function> не являются потокобезопасными и не должны применяться в многопоточных программах. Вместо <function>PQrequestCancel</function> можно использовать <function>PQcancel</function>, а вместо <function>PQoidStatus</function> — <function>PQoidValue</function>.</para>

  <para>Если вы применяете Kerberos в своём приложении (помимо возможного использования внутри <application>libpq</application>), вы должны обеспечить блокировку вокруг вызовов Kerberos, так как функции Kerberos не являются потокобезопасными. Обратите внимание на функцию <function>PQregisterThreadLock</function> в исходном коде <application>libpq</application>, позволяющую организовать совместные блокировки между <application>libpq</application> и вашим приложением.</para>

  <para>Если вы сталкиваетесь с проблемами многопоточности в приложениях, запустите программу <filename>src/tools/thread</filename>, чтобы понять, есть ли в вашей системе небезопасные при многопоточности функции. Эта программа запускается скриптом <filename>configure</filename>, но если вы устанавливаете двоичный пакет, ваши библиотеки могут не соответствовать тем, что использовались при сборке.</para>
 </sect1>


 <sect1 id="libpq-build">
  <title>Сборка программ с <application>libpq</application></title>

  <indexterm zone="libpq-build"><primary>компиляция</primary> <secondary>приложений с libpq</secondary></indexterm>

  <para>Чтобы собрать (то есть, скомпилировать и скомпоновать) программу, использующую <application>libpq</application>, вы должны проделать следующие действия: <itemizedlist>
    <listitem>
     <para>Включите заголовочный файл <filename>libpq-fe.h</filename>: <programlisting>#include &lt;libpq-fe.h&gt;</programlisting> Если вы не сделаете этого, обычно вас ждут примерно такие сообщения об ошибках от компилятора: <screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen></para>
    </listitem>

    <listitem>
     <para>Сообщите вашему компилятору каталог, в котором установлены заголовочные файлы <productname>&productname;</productname>, передав ему параметр <literal>-I<replaceable>каталог</replaceable></literal>. (В некоторых случаях компилятор сам может обращаться к нужному каталогу, так что этот параметр можно опустить.) Например, ваша команда компиляции может быть такой: <programlisting>cc -c -I/usr/local/pgsql/include testprog.c</programlisting> Если вы используете скрипты сборки Makefile, добавьте этот параметр в переменную <varname>CPPFLAGS</varname>: <programlisting>CPPFLAGS += -I/usr/local/pgsql/include</programlisting></para>

     <para>Если существует возможность, что вашу программу будут компилировать другие пользователи, то путь к каталогу не следует жёстко задавать таким образом. Вместо этого вы можете воспользоваться утилитой <command>pg_config</command><indexterm><primary>pg_config</primary> <secondary sortas="libpq">с libpq</secondary></indexterm> и узнать, где в локальной системе находятся заголовочные файлы, следующим образом: <screen>
<prompt>$</prompt> pg_config --includedir
<computeroutput>/usr/local/include</computeroutput>
</screen></para>

     <para>Если у вас установлена программа <command>pkg-config</command><indexterm><primary>pkg-config</primary> <secondary sortas="libpq">с libpq</secondary></indexterm>, вместо этого вы можете выполнить: <screen>
<prompt>$</prompt> pkg-config --cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen> Заметьте, что при этом перед путём сразу будет добавлен ключ <option>-I</option>.</para>

     <para>Если требуемый параметр не будет передан компилятору, вы получите примерно такое сообщение об ошибке: <screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen></para>
    </listitem>

    <listitem>
     <para>При компоновке окончательной программы добавьте параметр <literal>-lpq</literal>, чтобы была подключена библиотека <application>libpq</application>, а также параметр <literal>-L<replaceable>каталог</replaceable></literal>, указывающий на каталог, в котором находится <application>libpq</application>. (Опять же, компилятор будет просматривать определённые каталоги по умолчанию.) Для максимальной переносимости указывайте ключ <option>-L</option> перед параметром <option>-lpq</option>. Например: <programlisting>cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq</programlisting></para>

     <para>Каталог с библиотекой можно узнать, так же используя <command>pg_config</command>: <screen>
<prompt>$</prompt> pg_config --libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen></para>

     <para>Или с помощью той же программы <command>pkg-config</command>: <screen>
<prompt>$</prompt> pkg-config --libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen> Заметьте, что и в этом случае выводится полностью сформированный параметр, а не только путь.</para>

     <para>В случае проблем в этой области возможны примерно такие сообщения об ошибках: <screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen> Они означают, что вы забыли добавить параметр <option>-lpq</option>. <screen>
/usr/bin/ld: cannot find -lpq
</screen> Такая ошибка означает, что вы забыли добавить ключ <option>-L</option> или не указали правильный каталог.</para>
    </listitem>
   </itemizedlist></para>

 </sect1>


 <sect1 id="libpq-example">
  <title>Примеры программ</title>

  <para>Эти и другие примеры можно найти в каталоге <filename>src/test/examples</filename> в дистрибутиве исходного кода.</para>

  <example id="libpq-example-1">
   <title>Первая программа, демонстрирующая использование <application>libpq</application></title>

<programlisting>
<![CDATA[
/*
 * testlibpq.c
 *
 *      Test the C version of libpq, the PostgreSQL frontend library.
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * Our test case here involves using a cursor, for which we must be inside
     * a transaction block.  We could do the whole thing with a single
     * PQexec() of "select * from pg_database", but that's too trivial to make
     * a good example.
     */

    /* Start a transaction block */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * Should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /*
     * Fetch rows from pg_database, the system catalog of databases
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* first, print out the attribute names */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* next, print out the rows */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* close the portal ... we don't bother to check for errors ... */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* end the transaction */
    res = PQexec(conn, "END");
    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-2">
   <title>Вторая программа, демонстрирующая использование <application>libpq</application></title>

<programlisting>
<![CDATA[
/*
 * testlibpq2.c
 *      Test of the asynchronous notification interface
 *
 * Start this program, then from psql in another window do
 *   NOTIFY TBL2;
 * Repeat four times to get this program to exit.
 *
 * Or, if you want to get fancy, try this:
 * populate a database with the following commands
 * (provided in src/test/examples/testlibpq2.sql):
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * and do this four times:
 *
 *   INSERT INTO TBL1 VALUES (10);
 */

#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * Issue LISTEN command to enable notifications from the rule's NOTIFY.
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /* Quit after four notifies are received. */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * Sleep until something happens on the connection.  We use
         * PQselectExtended to wait for input.
         */
        int         sock;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* shouldn't happen */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (PQselectExtended(conn, -1) < 0)
        {
            fprintf(stderr, "PQselectExtended() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* Now check for input */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-3">
   <title>Третья программа, демонстрирующая использование <application>libpq</application></title>

<programlisting>
<![CDATA[
/*
 * testlibpq3.c
 *      Test out-of-line parameters and binary I/O.
 *
 * Before running this, populate a database with the following commands
 * (provided in src/test/examples/testlibpq3.sql):
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * The expected output is:
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */

#ifdef WIN32
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * This function prints a query result that is a binary-format fetch from
 * a table defined as in the comment above.  We split it out because the
 * main() function uses it twice.
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* Use PQfnumber to avoid assumptions about field order in result */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* Get the field values (we ignore possibility they are null!) */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * The binary representation of INT4 is in network byte order, which
         * we'd better coerce to the local byte order.
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * The binary representation of TEXT is, well, text, and since libpq
         * was nice enough to append a zero byte to it, it'll work just fine
         * as a C string.
         *
         * The binary representation of BYTEA is a bunch of bytes, which could
         * include embedded nulls so we have to pay attention to field length.
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * The point of this program is to illustrate use of PQexecParams() with
     * out-of-line parameters, as well as binary transmission of data.
     *
     * This first example transmits the parameters as text, but receives the
     * results in binary format.  By using out-of-line parameters we can avoid
     * a lot of tedious mucking about with quoting and escaping, even though
     * the data is text.  Notice how we don't have to do anything special with
     * the quote mark in the parameter value.
     */

    /* Here is our out-of-line parameter value */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       NULL,    /* don't need param lengths since text */
                       NULL,    /* default to all text params */
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * In this second example we transmit an integer parameter in binary form,
     * and again retrieve the results in binary form.
     *
     * Although we tell PQexecParams we are letting the backend deduce
     * parameter type, we really force the decision by casting the parameter
     * symbol in the query text.  This is a good safety measure when sending
     * binary parameters.
     */

    /* Convert integer value "2" to network byte order */
    binaryIntVal = htonl((uint32_t) 2);

    /* Set up parameter arrays for PQexecParams */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* binary */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

 </sect1>
</chapter>
