<!-- doc/src/xml/rowtypes.xml -->

<sect1 id="rowtypes">
 <title>Составные типы</title>

 <indexterm><primary>составной тип</primary></indexterm>

 <indexterm><primary>тип табличной строки</primary></indexterm>

 <para><firstterm>Составной тип</firstterm> представляет структуру табличной строки или записи; по сути это просто список имён полей и соответствующих типов данных. <productname>&productname;</productname> позволяет использовать составные типы во многом так же, как и простые типы. Например, в определении таблицы можно объявить столбец составного типа.</para>

 <sect2 id="rowtypes-declaring">
  <title>Объявление составных типов</title>

 <para>Ниже приведены два простых примера определения составных типов: <programlisting>CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);</programlisting> Синтаксис очень похож на <command>CREATE TABLE</command>, за исключением того, что он допускает только названия полей и их типы, какие-либо ограничения (такие как <literal>NOT NULL</literal>) в настоящее время не поддерживаются. Заметьте, что ключевое слово <literal>AS</literal> здесь имеет значение; без него система будет считать, что подразумевается другой тип команды <command>CREATE TYPE</command>, и выдаст неожиданную синтаксическую ошибку.</para>

 <para>Определив такие типы, мы можем использовать их в таблицах: <programlisting>CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);</programlisting> или функциях: <programlisting>CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric
AS 'SELECT $1.price * $2' LANGUAGE SQL;

SELECT price_extension(item, 10) FROM on_hand;</programlisting></para>

 <para>Всякий раз, когда создаётся таблица, вместе с ней автоматически создаётся составной тип, представляющий тип строки таблицы, именем которого будет имя таблицы. Например, при выполнении команды: <programlisting>CREATE TABLE inventory_item (
    name            text,
    supplier_id     integer REFERENCES suppliers,
    price           numeric CHECK (price &gt; 0)
);</programlisting> будет создан составной тип <literal>inventory_item</literal>, в точности соответствующий тому, что был показан выше, и использовать его можно так же. Заметьте, что в текущей реализации есть один недостаток: так как с составным типом не могут быть связаны ограничения, описанные в определении таблицы ограничения <emphasis>не применяются</emphasis> к значениям составного типа вне таблицы. (В некоторой степени это можно обойти, используя в составных типах домены.)</para>
 </sect2>

 <sect2>
  <title>Конструирование составных значений</title>

  <indexterm><primary>составной тип</primary> <secondary>константа</secondary></indexterm>

  <para>Чтобы записать значение составного типа в виде текстовой константы, его поля нужно заключить в круглые скобки и разделить их запятыми. Значение любого поля можно заключить в кавычки, а если оно содержит запятые или скобки, это делать обязательно. (Подробнее об этом говорится <link linkend="rowtypes-io-syntax">ниже</link>.) Таким образом, в общем виде константа составного типа записывается так: <synopsis>
'( <replaceable>значение1</replaceable> , <replaceable>значение2</replaceable> , ... )'
</synopsis> Например, эта запись: <programlisting>'("fuzzy dice",42,1.99)'</programlisting> будет допустимой для описанного выше типа <literal>inventory_item</literal>. Чтобы присвоить NULL одному из полей, в соответствующем месте в списке нужно оставить пустое место. Например, эта константа задаёт значение NULL для третьего поля: <programlisting>'("fuzzy dice",42,)'</programlisting> Если же вместо NULL требуется вставить пустую строку, нужно записать пару кавычек: <programlisting>'("",42,)'</programlisting> Здесь в первом поле окажется пустая строка, а в третьем &mdash; NULL.</para>

  <para>(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай констант, описанных в <xref remap="6" linkend="sql-syntax-constants-generic"/>. Константа изначально воспринимается как строка и передаётся процедуре преобразования составного типа. При этом может потребоваться явно указать тип, к которому будет приведена константа.)</para>

 <para>Значения составных типов также можно конструировать, используя синтаксис выражения <literal>ROW</literal>. В большинстве случаев это значительно проще, чем записывать значения в строке, так как при этом не нужно беспокоиться о вложенности кавычек. Мы уже обсуждали этот метод ранее: <programlisting>ROW('fuzzy dice', 42, 1.99)
ROW('', 42, NULL)</programlisting> Ключевое слово ROW на самом деле может быть необязательным, если в выражении определяются несколько полей, так что эту запись можно упростить до: <programlisting>('fuzzy dice', 42, 1.99)
('', 42, NULL)</programlisting> Синтаксис выражения <literal>ROW</literal> более подробно рассматривается в <xref remap="6" linkend="sql-syntax-row-constructors"/>.</para>
 </sect2>

 <sect2 id="rowtypes-accessing">
  <title>Обращение к составным типам</title>

 <para>Чтобы обратиться к полю столбца составного типа, после имени столбца нужно добавить точку и имя поля, подобно тому, как указывается столбец после имени таблицы. На самом деле, эти обращения неотличимы, так что часто бывает необходимо использовать скобки, чтобы команда была разобрана правильно. Например, можно попытаться выбрать поле столбца из тестовой таблицы <literal>on_hand</literal> таким образом: <programlisting>SELECT item.name FROM on_hand WHERE item.price &gt; 9.99;</programlisting> Но это не будет работать, так как согласно правилам SQL имя <literal>item</literal> здесь воспринимается как имя таблицы, а не столбца в таблице <literal>on_hand</literal>. Поэтому этот запрос нужно переписать так: <programlisting>SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;</programlisting> либо указать также и имя таблицы (например, в запросе с многими таблицами), примерно так: <programlisting>SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;</programlisting> В результате объект в скобках будет правильно интерпретирован как ссылка на столбец <literal>item</literal>, из которого выбирается поле.</para>

 <para>При выборке поля из значения составного типа также возможны подобные синтаксические казусы. Например, чтобы выбрать одно поле из результата функции, возвращающей составное значение, потребуется написать что-то подобное: <programlisting>SELECT (my_func(...)).field FROM ...</programlisting> Без дополнительных скобок в этом запросе произойдёт синтаксическая ошибка.</para>

 <para>Специальное имя поля <literal>*</literal> означает <quote>все поля</quote>; подробнее об этом рассказывается в <xref remap="6" linkend="rowtypes-usage"/>.</para>
 </sect2>

 <sect2>
  <title>Изменение составных типов</title>

 <para>Ниже приведены примеры правильных команд добавления и изменения значений составных столбцов. Первые команды иллюстрируют добавление или изменение всего столбца: <programlisting>INSERT INTO mytab (complex_col) VALUES((1.1,2.2));

UPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;</programlisting> В первом примере опущено ключевое слово <literal>ROW</literal>, а во втором оно есть; присутствовать или отсутствовать оно может в обоих случаях.</para>

 <para>Мы можем изменить также отдельное поле составного столбца: <programlisting>UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;</programlisting> Заметьте, что при этом не нужно (и на самом деле даже нельзя) заключать в скобки имя столбца, следующее сразу за предложением <literal>SET</literal>, но в ссылке на тот же столбец в выражении, находящемся по правую сторону знака равенства, скобки обязательны.</para>

 <para>И мы также можем указать поля в качестве цели команды <command>INSERT</command>: <programlisting>INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);</programlisting> Если при этом мы не укажем значения для всех полей столбца, оставшиеся поля будут заполнены значениями NULL.</para>
 </sect2>

 <sect2 id="rowtypes-usage">
  <title>Использование составных типов в запросах</title>

  <para>С составными типами в запросах связаны особые правила синтаксиса и поведение. Эти правила образуют полезные конструкции, но они могут быть неочевидными, если не понимать стоящую за ними логику.</para>

  <para>В <productname>&productname;</productname> ссылка на имя таблицы (или её псевдоним) в запросе по сути является ссылкой на составное значение текущей строки в этой таблице. Например, имея таблицу <structname>inventory_item</structname>, показанную <link linkend="rowtypes-declaring">выше</link>, мы можем написать: <programlisting>SELECT c FROM inventory_item c;</programlisting> Этот запрос выдаёт один столбец с составным значением, и его результат может быть таким: <programlisting>           c
------------------------
 ("fuzzy dice",42,1.99)
(1 row)</programlisting> Заметьте, однако, что простые имена сопоставляются сначала с именами столбцов, и только потом с именами таблиц, так что такой результат получается только потому, что в таблицах запроса не оказалось столбца с именем <structfield>c</structfield>.</para>

  <para>Обычную запись полного имени столбца вида <replaceable>имя_таблицы</replaceable><literal>.</literal><replaceable>имя_столбца</replaceable> можно понимать как применение <link linkend="field-selection">выбора поля</link> к составному значению текущей строки таблицы. (Из соображений эффективности на самом деле это реализовано по-другому.)</para>

  <para>Когда мы пишем <programlisting>SELECT c.* FROM inventory_item c;</programlisting> то, согласно стандарту SQL, мы должны получить содержимое таблицы, развёрнутое в отдельные столбцы: <programlisting>    name    | supplier_id | price
------------+-------------+-------
 fuzzy dice |          42 |  1.99
(1 row)</programlisting> как с запросом <programlisting>SELECT c.name, c.supplier_id, c.price FROM inventory_item c;</programlisting> <productname>&productname;</productname> применяет такое развёртывание для любых выражений с составными значениями, хотя как показано <link linkend="rowtypes-accessing">выше</link>, необходимо заключить в скобки значение, к которому применяется <literal>.*</literal>, если только это не простое имя таблицы. Например, если <function>myfunc()</function> — функция, возвращающая составной тип со столбцами <structfield>a</structfield>, <structfield>b</structfield> и <structfield>c</structfield>, то эти два запроса выдадут одинаковый результат: <programlisting>SELECT (myfunc(x)).* FROM some_table;
SELECT (myfunc(x)).a, (myfunc(x)).b, (myfunc(x)).c FROM some_table;</programlisting></para>

  <tip>
   <para><productname>&productname;</productname> осуществляет развёртывание столбцов фактически переводя первую форму во вторую. Таким образом, в данном примере <function>myfunc()</function> будет вызываться три раза для каждой строки и с тем, и с тем синтаксисом. Если это дорогостоящая функция и вы хотите избежать лишних вызовов, это осуществимо с таким запросом: <programlisting>SELECT (m).* FROM (SELECT myfunc(x) AS m FROM some_table OFFSET 0) ss;</programlisting> Предложение <literal>OFFSET 0</literal> добавлено, чтобы оптимизатор не упрощал подзапрос, в результате чего он может преобразоваться в форму с множественными вызовами <function>myfunc()</function>.</para>
  </tip>

  <para>Запись <replaceable>составное_значение</replaceable><literal>.*</literal> приводит к такому развёртыванию столбцов, когда она фигурирует на верхнем уровне <link linkend="queries-select-lists">выходного списка <command>SELECT</command></link>, в <link linkend="dml-returning">списке <literal>RETURNING</literal></link> команд <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>, в <link linkend="queries-values"><literal>предложении VALUES</literal></link> или в <link linkend="sql-syntax-row-constructors">конструкторе строки</link>. Во всех других контекстах (включая вложенные в одну из этих конструкций), добавление <literal>.*</literal> к составному значению не меняет это значение, так как это воспринимается как <quote>все столбцы</quote> и поэтому выдаётся то же составное значение. Например, если функция <function>somefunc()</function> принимает в качестве аргумента составное значение, эти запросы равносильны: <programlisting>SELECT somefunc(c.*) FROM inventory_item c;
SELECT somefunc(c) FROM inventory_item c;</programlisting> В обоих случаях текущая строка таблицы <structname>inventory_item</structname> передаётся функции как один аргумент с составным значением. И хотя дополнение <literal>.*</literal> в этих случаях не играет роли, использовать его считается хорошим стилем, так как это ясно указывает на использование составного значения. В частности анализатор запроса воспримет <literal>c</literal> в записи <literal>c.*</literal> как ссылку на имя или псевдоним таблицы, а не имя столбца, что избавляет от неоднозначности; тогда как без <literal>.*</literal> неясно, означает ли <literal>c</literal> имя таблицы или имя столбца, и на самом деле при наличии столбца с именем <literal>c</literal> будет выбрано второе прочтение.</para>

  <para>Эту концепцию демонстрирует и следующий пример, все запросы в котором действуют одинаково: <programlisting>SELECT * FROM inventory_item c ORDER BY c;
SELECT * FROM inventory_item c ORDER BY c.*;
SELECT * FROM inventory_item c ORDER BY ROW(c.*);</programlisting> Все эти предложения <literal>ORDER BY</literal> обращаются к составному значению строки, вследствие чего строки сортируются по правилам, описанным в <xref remap="6" linkend="composite-type-comparison"/>. Однако, если в <structname>inventory_item</structname> содержится столбец с именем <structfield>c</structfield>, первый запрос будет отличаться от других, так как в нём выполнится сортировка только по данному столбцу. С показанными выше именами столбцов предыдущим запросам также равнозначны следующие: <programlisting>SELECT * FROM inventory_item c ORDER BY ROW(c.name, c.supplier_id, c.price);
SELECT * FROM inventory_item c ORDER BY (c.name, c.supplier_id, c.price);</programlisting> (В последнем случае используется конструктор строки, в котором опущено ключевое слово <literal>ROW</literal>.)</para>

  <para>Другая особенность синтаксиса, связанная с составными значениями, состоит в том, что мы можем использовать <firstterm>функциональную запись</firstterm> для извлечения поля составного значения. Это легко можно объяснить тем, что записи <literal><replaceable>поле</replaceable>(<replaceable>таблица</replaceable>)</literal> и <literal><replaceable>таблица</replaceable>.<replaceable>поле</replaceable></literal> взаимозаменяемы. Например, следующие запросы равнозначны: <programlisting>SELECT c.name FROM inventory_item c WHERE c.price &gt; 1000;
SELECT name(c) FROM inventory_item c WHERE price(c) &gt; 1000;</programlisting> Более того, если у нас есть функция, принимающая один аргумент составного типа, мы можем вызвать её в любой записи. Все эти запросы равносильны: <programlisting>SELECT somefunc(c) FROM inventory_item c;
SELECT somefunc(c.*) FROM inventory_item c;
SELECT c.somefunc FROM inventory_item c;</programlisting></para>

  <para>Эта равнозначность записи с полем и функциональной записи позволяет использовать с составными типами функции, реализующие <quote>вычисляемые поля</quote>. <indexterm><primary>вычисляемое поле</primary></indexterm> <indexterm><primary>поле</primary> <secondary>вычисляемое</secondary></indexterm> При этом приложению, использующему последний из предыдущих запросов, не нужно знать, что фактически <literal>somefunc</literal> — не настоящий столбец таблицы.</para>

  <tip>
   <para>Учитывая такое поведение, будет неразумно давать функции, принимающей один аргумент составного типа, то же имя, что и одному из полей данного составного типа. Если возникнет неоднозначность, предпочтительнее окажется прочтение имени поля, так что такую функцию нельзя будет вызвать без дополнительных трюков. Например, для принудительного прочтения имени функции, потребуется дополнить это имя схемой, то есть, написать <literal><replaceable>схема</replaceable>.<replaceable>функция</replaceable>(<replaceable>составное_значение</replaceable>)</literal>.</para>
  </tip>
 </sect2>

 <sect2 id="rowtypes-io-syntax">
  <title>Синтаксис вводимых и выводимых значений составного типа</title>

  <para>Внешнее текстовое представление составного значения состоит из записи элементов, интерпретируемых по правилам ввода/вывода для соответствующих типов полей, и оформления структуры составного типа. Оформление состоит из круглых скобок (<literal>(</literal> и <literal>)</literal>) окружающих всё значение, и запятых (<literal>,</literal>) между его элементами. Пробельные символы вне скобок игнорируются, но внутри они считаются частью соответствующего элемента и могут учитываться или не учитываться в зависимости от правил преобразования вводимых данных для типа этого элемента. Например, в записи: <programlisting>'(  42)'</programlisting> пробелы будут игнорироваться, если соответствующее поле имеет целочисленный тип, но не текстовый.</para>

  <para>Как было показано ранее, записывая составное значение, любой его элемент можно заключить в кавычки. Это <emphasis>нужно</emphasis> делать, если при разборе этого значения без кавычек возможна неоднозначность. Например, в кавычки нужно заключать элементы, содержащие скобки, кавычки, запятую или обратную косую черту. Чтобы включить в поле составного значения, заключённое в кавычки, такие символы, как кавычки или обратная косая черта, перед ними нужно добавить обратную косую черту. (Кроме того, продублированные кавычки в значении поля, заключённого в кавычки, воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой стороны, можно обойтись без кавычек, защитив все символы в данных, которые могут быть восприняты как часть синтаксиса составного значения, с помощью спецпоследовательностей.</para>

  <para>Значение NULL в этой записи представляется пустым местом (когда между запятыми или скобками нет никаких символов). Чтобы ввести именно пустую строку, а не NULL, нужно написать <literal>""</literal>.</para>

  <para>Функция вывода составного значения заключает значения полей в кавычки, если они представляют собой пустые строки, либо содержат скобки, запятые, кавычки или обратную косую черту, либо состоят из одних пробелов. (В последнем случае можно обойтись без кавычек, но они добавляются для удобочитаемости.) Кавычки и обратная косая черта, заключённые в значения полей, при выводе дублируются.</para>

 <note>
  <para>Помните, что написанная SQL-команда прежде всего интерпретируется как текстовая строка, а затем как составное значение. Вследствие этого число символов обратной косой черты удваивается (если используются спецпоследовательности). Например, чтобы ввести в поле составного столбца значение типа <type>text</type> с обратной косой чертой и кавычками, команду нужно будет записать так: <programlisting>INSERT ... VALUES (E'("\\"\\\\")');</programlisting> Сначала обработчик спецпоследовательностей удаляет один уровень обратной косой черты, так что анализатор составного значения получает на вход <literal>("\"\\")</literal>. В свою очередь, он передаёт эту строку процедуре ввода значения типа <type>text</type>, где она преобразуются в <literal>"\</literal>. (Если бы мы работали с типом данных, процедура ввода которого также интерпретирует обратную косую черту особым образом, например <type>bytea</type>, нам могло бы понадобиться уже восемь таких символов, чтобы сохранить этот символ в поле составного значения.) Во избежание такого дублирования спецсимволов строки можно заключать в доллары (см. <xref remap="4" linkend="sql-syntax-dollar-quoting"/>).</para>
 </note>

 <tip>
  <para>Записывать составные значения в командах SQL часто бывает удобнее с помощью конструктора <literal>ROW</literal>. В <literal>ROW</literal> отдельные значения элементов записываются так же, как если бы они не были членами составного выражения.</para>
 </tip>
 </sect2>

</sect1>
