<!-- doc/src/xml/config.xml -->

<chapter id="runtime-config">
  <title>Настройка сервера</title>

  <indexterm><primary>настройка</primary> <secondary>сервера</secondary></indexterm>

  <para>На работу системы баз данных оказывают влияние множество параметров конфигурации. В первом разделе этой главы рассказывается, как управлять этими параметрами, а в последующих разделах подробно описывается каждый из них.</para>

  <sect1 id="config-setting">
   <title>Изменение параметров</title>

   <sect2 id="config-setting-names-values">
    <title>Имена и значения параметров</title>

    <para>Имена всех параметров являются регистронезависимыми. Каждый параметр принимает значение одного из пяти типов: логический, строка, целое, число с плавающей точкой или перечисление. От типа значения зависит синтаксис установки этого параметра:</para>

    <itemizedlist>
     <listitem>
      <para><emphasis>Логический:</emphasis> Значения могут задаваться строками <literal>on</literal>, <literal>off</literal>, <literal>true</literal>, <literal>false</literal>, <literal>yes</literal>, <literal>no</literal>, <literal>1</literal>, <literal>0</literal> (регистр не имеет значения), либо как достаточно однозначный префикс одной из этих строк.</para>
     </listitem>

     <listitem>
      <para><emphasis>Строка:</emphasis> Обычно строковое значение заключается в апострофы (при этом внутренние апострофы дублируются). Однако, если значение является простым числом или идентификатором, апострофы обычно можно опустить.</para>
     </listitem>

     <listitem>
      <para><emphasis>Число (целое или с плавающей точкой):</emphasis> Десятичная точка как разделитель целой и дробной части допускается только для параметров, принимающих числа с плавающей точкой. Разделители разрядов в записи числа не принимаются. Заключать в апострофы число не требуется.</para>
     </listitem>

     <listitem>
      <para><emphasis>Число с единицей измерения:</emphasis> Некоторые числовые параметры задаются с единицами измерения, так как они описывают количества информации или времени. Единицами могут быть килобайты, блоки (обычно восемь килобайт), миллисекунды, секунды или минуты. При указании только числового значения для такого параметра единицей измерения будет считаться единица по умолчанию для параметра, которая указывается в <structname>pg_settings</structname>.<structfield>unit</structfield>. Для удобства параметры также можно задавать, указывая единицу измерения явно, например, задать <literal>'120 ms'</literal> для значения времени, при этом такое значение будет переведено в основную единицу измерения параметра. Заметьте, что для этого значение должно записываться в виде строки (в апострофах). Имя единицы является регистронезависимым, а между ним и числом допускаются пробельные символы. <itemizedlist>
        <listitem>
         <para>Допустимые единицы информации: <literal>kB</literal> (килобайты), <literal>MB</literal> (мегабайты), <literal>GB</literal> (гигабайты) и <literal>TB</literal> (терабайты). Множителем единиц информации считается 1024, не 1000.</para>
        </listitem>

        <listitem>
         <para>Допустимые единицы времени: <literal>ms</literal> (миллисекунды), <literal>s</literal> (секунды), <literal>min</literal> (минуты), <literal>h</literal> (часы) и <literal>d</literal> (дни).</para>
        </listitem>
       </itemizedlist></para>
     </listitem>

     <listitem>
      <para><emphasis>Перечисление:</emphasis> Параметры, имеющие тип перечисление, записываются так же, как строковые параметры, но могут иметь только ограниченный набор значений. Список допустимых значений такого параметра задаётся в <structname>pg_settings</structname>.<structfield>enumvals</structfield>. В значениях перечислений регистр не учитывается.</para>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="config-setting-configuration-file">
    <title>Определение параметров в файле конфигурации</title>

    <para>Самый основной способ установки этих параметров — определение их значений в файле <filename>postgresql.conf</filename><indexterm><primary>postgresql.conf</primary></indexterm>, который обычно находится в каталоге данных. При инициализации каталога кластера БД в этот каталог помещается копия стандартного файла. Например, он может выглядеть так: <programlisting># Это комментарий
log_connections = yes
log_destination = 'syslog'
search_path = '"$user", public'
shared_buffers = 128MB</programlisting> Каждый параметр определяется в отдельной строке. Знак равенства в ней между именем и значением является необязательным. Пробельные символы в строке не играют роли (кроме значений, заключённых в апострофы), а пустые строки игнорируются. Знаки решётки (<literal>#</literal>) обозначают продолжение строки как комментарий. Значения параметров, не являющиеся простыми идентификаторами или числами, должны заключаться в апострофы. Чтобы включить в такое значение собственно апостроф, его следует продублировать (предпочтительнее) или предварить обратной косой чертой.</para>

    <para>Параметры, установленные таким образом, задают значения по умолчанию для данного кластера. Эти значения будут действовать в активных сеансах, если не будут переопределены. В следующих разделах описывается, как их может переопределить администратор или пользователь.</para>

    <para><indexterm><primary>SIGHUP</primary></indexterm> Основной процесс сервера перечитывает файл конфигурации заново, получая сигнал <systemitem>SIGHUP</systemitem>; послать его проще всего можно, запустив <literal>pg_ctl reload</literal> в командной строке или вызвав SQL-функцию <function>pg_reload_conf()</function>. Основной процесс сервера передаёт этот сигнал всем остальным запущенным серверным процессам, так что существующие сеансы тоже получают новые значения (после того, как завершится выполнение текущей команды клиента). Также возможно послать этот сигнал напрямую одному из серверных процессов. Учтите, что некоторые параметры можно установить только при запуске сервера; любые изменения их значений в файле конфигурации не будут учитываться до перезапуска сервера. Более того, при обработке <systemitem>SIGHUP</systemitem> игнорируются неверные значения параметров (но об этом сообщается в журнале).</para>

    <para>В дополнение к <filename>postgresql.conf</filename> в каталоге данных <productname>&productname;</productname> содержится файл <filename>postgresql.auto.conf</filename><indexterm><primary>postgresql.auto.conf</primary></indexterm>, который имеет тот же формат, что и <filename>postgresql.conf</filename>, но не должен редактироваться вручную. Этот файл содержит параметры, задаваемые командой <xref linkend="sql-altersystem"/>. Он считывается автоматически одновременно с <filename>postgresql.conf</filename> и заданные в нём параметры действуют таким же образом. Параметры в <filename>postgresql.auto.conf</filename> переопределяют те, что указаны в <filename>postgresql.conf</filename>.</para>

    <para>Системное представление <link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link> может быть полезным для предварительной проверки изменений в файле конфигурации или диагностики проблем, если сигнал <systemitem>SIGHUP</systemitem> не даёт желаемого эффекта.</para>
   </sect2>

   <sect2 id="config-setting-sql-command-interaction">
    <title>Управление параметрами через SQL</title>

     <para>В <productname>&productname;</productname> есть три SQL-команды, задающие для параметров значения по умолчанию. Уже упомянутая команда <xref linkend="sql-altersystem"/> даёт возможность изменять глобальные значения средствами SQL; она функционально равнозначна редактированию <filename>postgresql.conf</filename>. Кроме того, есть ещё две команды, которые позволяют задавать значения по умолчанию на уровне баз данных и ролей:</para>

     <itemizedlist>
     <listitem>
      <para>Команда <xref linkend="sql-alterdatabase"/> позволяет переопределить глобальные параметры на уровне базы данных.</para>
     </listitem>

     <listitem>
      <para>Команда <xref linkend="sql-alterrole"/> позволяет переопределить для конкретного пользователя как глобальные, так и локальные для базы данных параметры.</para>
     </listitem>
    </itemizedlist>

     <para>Значения, установленные командами <command>ALTER DATABASE</command> и <command>ALTER ROLE</command>, применяются только при новом подключении к базе данных. Они переопределяют значения, полученные из файлов конфигурации или командной строки сервера, и применяются по умолчанию в рамках сеанса. Заметьте, что некоторые параметры невозможно изменить после запуска сервера, поэтому их нельзя установить этими командами (или командами, перечисленными ниже).</para>

     <para>Когда клиент подключён к базе данных, он может воспользоваться двумя дополнительными командами SQL (и равнозначными функциями), которые предоставляет <productname>&productname;</productname> для управления параметрами конфигурации:</para>

    <itemizedlist>
     <listitem>
     <para>Команда <xref linkend="sql-show"/> позволяет узнать текущее значение всех параметров. Соответствующая ей функция — <function>current_setting(имя_параметра text)</function>.</para>
     </listitem>

     <listitem>
      <para>Команда <xref linkend="sql-set"/> позволяет изменить текущее значение параметров, которые действуют локально в рамках сеанса; на другие сеансы она не влияет. Соответствующая ей функция — <function>set_config(имя_параметра, новое_значение, локально)</function>.</para>
     </listitem>
    </itemizedlist>

    <para>Кроме того, просмотреть и изменить значения параметров для текущего сеанса можно в системном представлении <link linkend="view-pg-settings"><structname>pg_settings</structname></link>:</para>

    <itemizedlist>
     <listitem>
      <para>Запрос на чтение представления выдаёт ту же информацию, что и <command>SHOW ALL</command>, но более подробно. Этот подход и более гибкий, так как в нём можно указать условия фильтра или связать результат с другими отношениями.</para>
     </listitem>

     <listitem>
      <para>Выполнение <xref linkend="sql-update"/> для этого представления, а именно присвоение значения столбцу, равносильно выполнению команды <command>SET</command>. Например, команде <programlisting>SET configuration_parameter TO DEFAULT;</programlisting> равнозначен запрос: <programlisting>UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';</programlisting></para>
     </listitem>
    </itemizedlist>

   </sect2>

   <sect2>
    <title>Управление параметрами в командной строке</title>

     <para>Помимо изменения глобальных значений по умолчанию и переопределения их на уровне базы данных или роли, параметры <productname>&productname;</productname> можно изменить, используя средства командной строки. Управление через командную строку поддерживают и сервер, и клиентская библиотека <application>libpq</application>.</para>

     <itemizedlist>
      <listitem>
      <para>При запуске сервера, значения параметров можно передать команде <command>postgres</command> в аргументе командной строки <option>-c</option>. Например: <programlisting>postgres -c log_connections=yes -c log_destination='syslog'</programlisting> Параметры, заданные таким образом, переопределяют те, что были установлены в <filename>postgresql.conf</filename> или командой <command>ALTER SYSTEM</command>, так что их нельзя изменить глобально без перезапуска сервера.</para>
    </listitem>

    <listitem>
     <para>При запуске клиентского сеанса, использующего <application>libpq</application>, значения параметров можно указать в переменной окружения <envar>PGOPTIONS</envar>. Заданные таким образом параметры будут определять значения по умолчанию на время сеанса, но никак не влияют на другие сеансы. По историческим причинам формат <envar>PGOPTIONS</envar> похож на тот, что применяется при запуске команды <command>postgres</command>; в частности, в нём должен присутствовать флаг <option>-c</option>. Например: <programlisting>env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql</programlisting></para>

     <para>Другие клиенты и библиотеки могут иметь собственные механизмы управления параметрами, через командную строку или как-то иначе, используя которые пользователь сможет менять параметры сеанса, не выполняя непосредственно команды SQL.</para>
    </listitem>
   </itemizedlist>

   </sect2>

   <sect2 id="config-includes">
    <title>Упорядочение содержимого файлов конфигурации</title>

     <para><productname>&productname;</productname> предоставляет несколько возможностей для разделения сложных файлов <filename>postgresql.conf</filename> на вложенные файлы. Эти возможности особенно полезны при управлении множеством серверов с похожими, но не одинаковыми конфигурациями.</para>

     <para><indexterm><primary><literal>включение</literal></primary> <secondary>в файл конфигурации</secondary></indexterm> Помимо присвоений значений параметров, <filename>postgresql.conf</filename> может содержать <firstterm>директивы включения</firstterm> файлов, которые будут прочитаны и обработаны, как если бы их содержимое было вставлено в данном месте файла конфигурации. Это позволяет разбивать файл конфигурации на физически отдельные части. Директивы включения записываются просто: <programlisting>include 'имя_файла'</programlisting> Если имя файла задаётся не абсолютным путём, оно рассматривается относительно каталога, в котором находится включающий файл конфигурации. Включения файлов могут быть вложенными.</para>

     <para><indexterm><primary><literal>include_if_exists</literal></primary> <secondary>в файле конфигурации</secondary></indexterm> Кроме того, есть директива <literal>include_if_exists</literal>, которая работает подобно <literal>include</literal>, за исключением случаев, когда включаемый файл не существует или не может быть прочитан. Обычная директива <literal>include</literal> считает это критической ошибкой, но <literal>include_if_exists</literal> просто выводит сообщение и продолжает обрабатывать текущий файл конфигурации.</para>

     <para><indexterm><primary><literal>include_dir</literal></primary> <secondary>в файле конфигурации</secondary></indexterm> Файл <filename>postgresql.conf</filename> может также содержать директивы <literal>include_dir</literal>, позволяющие подключать целые каталоги с файлами конфигурации. Они записываются так: <programlisting>include_dir 'каталог'</programlisting> Имена, заданные не абсолютным путём, рассматриваются относительно каталога, содержащего текущий файл конфигурации. В заданном каталоге включению подлежат только файлы с именами, оканчивающимися на <literal>.conf</literal>. При этом файлы с именами, начинающимися с &laquo;<literal>.</literal>&raquo;, тоже игнорируются, для предотвращения ошибок, так как они считаются скрытыми в ряде систем. Набор файлов во включаемом каталоге обрабатывается по порядку имён (определяемому правилами, принятыми в C, т. е. цифры идут перед буквами, а буквы в верхнем регистре — перед буквами в нижнем).</para>

     <para>Включение файлов или каталогов позволяет разделить конфигурацию базы данных на логические части, а не вести один большой файл <filename>postgresql.conf</filename>. Например, представьте, что в некоторой компании есть два сервера баз данных, с разным объёмом ОЗУ. Скорее всего при этом их конфигурации будут иметь общие элементы, например, параметры ведения журналов. Но параметры, связанные с памятью, у них будут различаться. Кроме того, другие параметры могут быть специфическими для каждого сервера. Один из вариантов эффективного управления такими конфигурациями — разделить изменения стандартной конфигурации на три файла. Чтобы подключить эти файлы, можно добавить в конец файла <filename>postgresql.conf</filename> следующие директивы: <programlisting>include 'shared.conf'
include 'memory.conf'
include 'server.conf'</programlisting> Общие для всех серверов параметры будут помещаться в <filename>shared.conf</filename>. Файл <filename>memory.conf</filename> может иметь два варианта — первый для серверов с 8ГБ ОЗУ, а второй для серверов с 16 ГБ. Наконец, <filename>server.conf</filename> может содержать действительно специфические параметры для каждого отдельного сервера.</para>

     <para>Также возможно создать каталог с файлами конфигурации и поместить туда все эти файлы. Например, так можно подключить каталог <filename>conf.d</filename> в конце <filename>postgresql.conf</filename>: <programlisting>include_dir 'conf.d'</programlisting> Затем можно дать файлам в каталоге <filename>conf.d</filename> следующие имена: <programlisting>00shared.conf
01memory.conf
02server.conf</programlisting> Такое именование устанавливает чёткий порядок подключения этих файлов, что важно, так как если параметр определяется несколько раз в разных файлах конфигурации, действовать будет последнее определение. В рамках данного примера, установленное в <filename>conf.d/02server.conf</filename> значение переопределит значение того же параметра, заданное в <filename>conf.d/01memory.conf</filename>.</para>

     <para>Вы можете применить этот подход и с описательными именами файлов: <programlisting>00shared.conf
01memory-8GB.conf
02server-foo.conf</programlisting> При таком упорядочивании каждому варианту файла конфигурации даётся уникальное имя. Это помогает исключить конфликты, если конфигурации разных серверов нужно хранить в одном месте, например, в репозитории системы управления версиями. (Кстати, хранение файлов конфигурации в системе управления версиями — это ещё один эффективный приём, который стоит применять.)</para>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-file-locations">
    <title>Расположения файлов</title>

     <para>В дополнение к вышеупомянутому <filename>postgresql.conf</filename>, <productname>&productname;</productname> обрабатывает два редактируемых вручную файла конфигурации, в которых настраивается аутентификация клиентов (их использование рассматривается в <xref remap="6" linkend="client-authentication"/>). По умолчанию все три файла конфигурации размещаются в каталоге данных кластера БД. Параметры, описанные в этом разделе, позволяют разместить их и в любом другом месте. (Это позволяет упростить администрирование, в частности, выполнять резервное копирование этих файлов обычно проще, когда они хранятся отдельно.)</para>

     <variablelist>
     <varlistentry id="guc-data-directory" xreflabel="data_directory">
      <term><varname>data_directory</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>data_directory</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт каталог, в котором хранятся данные. Этот параметр можно задать только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-config-file" xreflabel="config_file">
      <term><varname>config_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>config_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт основной файл конфигурации сервера (его стандартное имя — <filename>postgresql.conf</filename>). Этот параметр можно задать только в командной строке <command>postgres</command>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hba-file" xreflabel="hba_file">
      <term><varname>hba_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>hba_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт файл конфигурации для аутентификации по сетевым узлам (его стандартное имя — <filename>pg_hba.conf</filename>). Этот параметр можно задать только при старте сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ident-file" xreflabel="ident_file">
      <term><varname>ident_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>ident_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт файл конфигурации для сопоставлений имён пользователей (его стандартное имя — <filename>pg_ident.conf</filename>). Этот параметр можно задать только при запуске сервера. См. также <xref remap="4" linkend="auth-username-maps"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-external-pid-file" xreflabel="external_pid_file">
      <term><varname>external_pid_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>external_pid_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя дополнительного файла с идентификатором процесса (PID), который будет создавать сервер для использования программами администрирования. Этот параметр можно задать только при запуске сервера.</para>
      </listitem>
     </varlistentry>
     </variablelist>

     <para>При стандартной установке ни один из этих параметров не задаётся явно. Вместо них задаётся только каталог данных, аргументом командной строки <option>-D</option> или переменной окружения <envar>PGDATA</envar>, и все необходимые файлы конфигурации загружаются из этого каталога.</para>

     <para>Если вы хотите разместить файлы конфигурации не в каталоге данных, то аргумент командной строки <command>postgres</command> <option>-D</option> или переменная окружения <envar>PGDATA</envar> должны указывать на каталог, содержащий файлы конфигурации, а в <filename>postgresql.conf</filename> (или в командной строке) должен задаваться параметр <varname>data_directory</varname>, указывающий, где фактически находятся данные. Учтите, что <varname>data_directory</varname> переопределяет путь, задаваемый в <option>-D</option> или <envar>PGDATA</envar> как путь каталога данных, но не расположение файлов конфигурации.</para>

     <para>При желании вы можете задать имена и расположение файлов конфигурации по отдельности, воспользовавшись параметрами <varname>config_file</varname>, <varname>hba_file</varname> и/или <varname>ident_file</varname>. Параметр <varname>config_file</varname> можно задать только в командной строке <command>postgres</command>, тогда как остальные можно задать и в основном файле конфигурации. Если явно заданы все три эти параметра плюс <varname>data_directory</varname>, то задавать <option>-D</option> или <envar>PGDATA</envar> не нужно.</para>

     <para>Во всех этих параметрах относительный путь должен задаваться от каталога, в котором запускается <command>postgres</command>.</para>
   </sect1>

   <sect1 id="runtime-config-connection">
    <title>Подключения и аутентификация</title>

    <sect2 id="runtime-config-connection-settings">
     <title>Параметры подключений</title>

     <variablelist>

     <varlistentry id="guc-listen-addresses" xreflabel="listen_addresses">
      <term><varname>listen_addresses</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>listen_addresses</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт адреса TCP/IP, по которым сервер будет принимать подключения клиентских приложений. Это значение принимает форму списка, разделённого запятыми, из имён и/или числовых IP-адресов компьютеров. Особый элемент, <literal>*</literal>, обозначает все имеющиеся IP-интерфейсы. Запись <literal>0.0.0.0</literal> позволяет задействовать все адреса IPv4, а <literal>::</literal> — все адреса IPv6. Если список пуст, сервер не будет привязываться ни к какому IP-интерфейсу, а значит, подключиться к нему можно будет только через доменные сокеты Unix. По умолчанию этот параметр содержит <systemitem class="systemname">localhost</systemitem>, что допускает подключение к серверу по TCP/IP только через локальный интерфейс <quote>замыкания</quote>. Хотя механизм аутентификации клиентов (см. <xref remap="4" linkend="client-authentication"/>) позволяет гибко управлять доступом пользователей к серверу, параметр <varname>listen_addresses</varname> может ограничить интерфейсы, через которые будут приниматься соединения, что бывает полезно для предотвращения злонамеренных попыток подключения через незащищённые сетевые интерфейсы. Этот параметр можно задать только при запуске сервера.</para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-port" xreflabel="port">
      <term><varname>port</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>port</varname></primary></indexterm></term>
      <listitem>
       <para>TCP-порт, открываемый сервером; по умолчанию, 5432. Заметьте, что этот порт используется для всех IP-адресов, через которые сервер принимает подключения. Этот параметр можно задать только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-connections" xreflabel="max_connections">
      <term><varname>max_connections</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_connections</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет максимальное число одновременных подключений к серверу БД. По умолчанию обычно это 100 подключений, но это число может быть меньше, если ядро накладывает свои ограничения (это определяется в процессе <application>initdb</application>). Этот параметр можно задать только при запуске сервера.</para>

       <para>Для сервера, работающего в режиме резерва, значение этого параметра должно быть больше или равно значению на главном. В противном случае на резервном сервере не будут разрешены запросы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-superuser-reserved-connections" xreflabel="superuser_reserved_connections">
      <term><varname>superuser_reserved_connections</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>superuser_reserved_connections</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет количество <quote>слотов</quote> подключений, которые <productname>&productname;</productname> будет резервировать для суперпользователей. При этом всего одновременно активными могут быть максимум <xref linkend="guc-max-connections"/> подключений. Когда число активных одновременных подключений больше или равно <varname>max_connections</varname> минус <varname>superuser_reserved_connections</varname>, принимаются только подключения суперпользователей, а все другие подключения, в том числе подключения для репликации, запрещаются.</para>

       <para>По умолчанию резервируются три соединения. Это значение должно быть меньше значения <varname>max_connections</varname>. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-directories" xreflabel="unix_socket_directories">
      <term><varname>unix_socket_directories</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>unix_socket_directories</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт каталог доменного сокета Unix, через который сервер будет принимать подключения клиентских приложений. Создать несколько сокетов можно, перечислив в этом значении несколько каталогов через запятую. Пробелы между элементами этого списка игнорируются; если в пути каталога содержатся пробелы, его нужно заключать в двойные кавычки. При пустом значении сервер не будет работать с доменными сокетами Unix, в этом случае к нему можно будет подключиться только по TCP/IP. Значение по умолчанию обычно <filename>/tmp</filename>, но его можно изменить во время сборки. Задать этот параметр можно только при запуске сервера.</para>

       <para>Помимо самого файла сокета, который называется <literal>.s.PGSQL.<replaceable>nnnn</replaceable></literal> (где <replaceable>nnnn</replaceable> — номер порта сервера), в каждом каталоге <varname>unix_socket_directories</varname> создаётся обычный файл <literal>.s.PGSQL.<replaceable>nnnn</replaceable>.lock</literal>. Ни в коем случае не удаляйте эти файлы вручную.</para>

       <para>Этот параметр не действует в системе Windows, так как в ней нет доменных сокетов Unix.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-group" xreflabel="unix_socket_group">
      <term><varname>unix_socket_group</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>unix_socket_group</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт группу-владельца доменных сокетов Unix. (Пользователем-владельцем сокетов всегда будет пользователь, запускающий сервер.) В сочетании с <varname>unix_socket_permissions</varname> данный параметр можно использовать как дополнительный механизм управления доступом к доменным сокетам. По умолчанию он содержит пустую строку, то есть группой-владельцем становится основная группа пользователя, запускающего сервер. Задать этот параметр можно только при запуске сервера.</para>

       <para>Этот параметр не действует в системе Windows, так как в ней нет доменных сокетов Unix.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-permissions" xreflabel="unix_socket_permissions">
      <term><varname>unix_socket_permissions</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>unix_socket_permissions</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт права доступа к доменным сокетам Unix. Для доменных сокетов применяется обычный набор разрешений Unix. Значение параметра ожидается в числовом виде, который принимают функции <function>chmod</function> и <function>umask</function>. (Для применения обычного восьмеричного формата число должно начинаться с <literal>0</literal> (нуля).)</para>

       <para>По умолчанию действуют разрешения <literal>0777</literal>, при которых подключаться к сокету могут все. Другие разумные варианты — <literal>0770</literal> (доступ имеет только пользователь и группа, см. также <varname>unix_socket_group</varname>) и <literal>0700</literal> (только пользователь). (Заметьте, что для доменных сокетов требуется только право на запись, так что добавлять или отзывать права на чтение/выполнение не имеет смысла.)</para>

       <para>Этот механизм управления доступом не зависит от описанного в <xref remap="6" linkend="client-authentication"/>.</para>

       <para>Этот параметр можно задать только при запуске сервера.</para>

       <para>Данный параметр неприменим для некоторых систем, в частности, Solaris (а именно Solaris 10), которые полностью игнорируют разрешения для сокетов. В таких системах примерно тот же эффект можно получить, указав в параметре <varname>unix_socket_directories</varname> каталог, доступ к которому ограничен должным образом. Этот параметр также неприменим в Windows, где нет доменных сокетов Unix.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bonjour" xreflabel="bonjour">
      <term><varname>bonjour</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>bonjour</varname></primary></indexterm></term>
      <listitem>
       <para>Включает объявления о существовании сервера посредством <productname>Bonjour</productname>. По умолчанию выключен. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bonjour-name" xreflabel="bonjour_name">
      <term><varname>bonjour_name</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>bonjour_name</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя службы в среде <productname>Bonjour</productname>. Если значение этого параметра — пустая строка (<literal>''</literal>) (это значение по умолчанию), в качестве этого имени используется имя компьютера. Этот параметр игнорируется, если сервер был скомпилирован без поддержки <productname>Bonjour</productname>. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-idle" xreflabel="tcp_keepalives_idle">
      <term><varname>tcp_keepalives_idle</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>tcp_keepalives_idle</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт период неактивности (в секундах), после которого по TCP клиенту должен отправляться сигнал сохранения соединения. При значении 0 действует системный параметр. Этот параметр поддерживается только в системах, воспринимающих параметр сокета <symbol>TCP_KEEPIDLE</symbol> или равнозначный, и в Windows; в других системах он должен быть равен нулю. В сеансах, подключённых через доменные сокеты Unix, он игнорируется и всегда считается равным 0.</para>
       <note>
        <para>В Windows при нулевом значении этот период устанавливается равным 2 часам, так как Windows не позволяет прочитать системное значение по умолчанию.</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-interval" xreflabel="tcp_keepalives_interval">
      <term><varname>tcp_keepalives_interval</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>tcp_keepalives_interval</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт интервал (в секундах), по истечении которого следует повторять сигнал сохранения соединения, если ответ от клиента не был получен. При значении 0 действует системное значение. Этот параметр поддерживается только в системах, воспринимающих параметр сокета <symbol>TCP_KEEPINTVL</symbol> или равнозначный, и в Windows; в других системах он должен быть равен нулю. В сеансах, подключённых через доменные сокеты Unix, он игнорируется и всегда считается равным 0.</para>
       <note>
        <para>В Windows при нулевом значении этот интервал устанавливается равным 1 секунде, так как Windows не позволяет прочитать системное значение по умолчанию.</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-count" xreflabel="tcp_keepalives_count">
      <term><varname>tcp_keepalives_count</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>tcp_keepalives_count</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт число TCP-сигналов сохранения соединения, которые могут быть потеряны до того, как соединение сервера с клиентом будет признано прерванным. При значении 0 действует системное значение. Этот параметр поддерживается только в системах, воспринимающих параметр сокета <symbol>TCP_KEEPCNT</symbol> или равнозначный; в других системах он должен быть равен нулю. В сеансах, подключённых через доменные сокеты Unix, он игнорируется и всегда считается равным 0.</para>
       <note>
        <para>В Windows данный параметр не поддерживается и должен быть равен нулю.</para>
       </note>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-connection-security">
     <title>Безопасность и аутентификация</title>

     <variablelist>
     <varlistentry id="guc-authentication-timeout" xreflabel="authentication_timeout">
      <term><varname>authentication_timeout</varname> (<type>integer</type>) <indexterm><primary>тайм-аут</primary> <secondary>проверка подлинности клиента</secondary></indexterm> <indexterm><primary>проверке подлинности</primary> <secondary>тайм-аут при</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>authentication_timeout</varname></primary></indexterm></term>

      <listitem>
       <para>Максимальное время, за которое должна произойти аутентификация (в секундах). Если потенциальный клиент не сможет пройти проверку подлинности за это время, сервер закроет соединение. Благодаря этому, зависшие при подключении клиенты не будут занимать соединения неограниченно долго. Значение этого параметра по умолчанию — одна минута (<literal>1m</literal>). Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl" xreflabel="ssl">
      <term><varname>ssl</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>ssl</varname></primary></indexterm></term>
      <listitem>
       <para>Разрешает <acronym>SSL</acronym>-подключения. Прежде чем включать SSL, прочитайте <xref remap="4" linkend="ssl-tcp"/>. По умолчанию он выключен (<literal>off</literal>). Этот параметр можно задать только при запуске сервера. <acronym>SSL</acronym>-подключения поддерживаются только для соединений по TCP/IP.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ca-file" xreflabel="ssl_ca_file">
      <term><varname>ssl_ca_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>ssl_ca_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя файла, содержащего сертификаты центров сертификации (ЦС) для SSL-сервера. По умолчанию этот параметр пуст; то есть информация о ЦС не загружается и проверка клиентских сертификатов не выполняется. (В предыдущих выпусках &productname; это имя было фиксированным: <filename>root.crt</filename>.) При указании относительного пути он рассматривается от каталога данных. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-cert-file" xreflabel="ssl_cert_file">
      <term><varname>ssl_cert_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>ssl_cert_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя файла, содержащего сертификат SSL-сервера. Имя по умолчанию — <filename>server.crt</filename>. Относительные пути рассматриваются от каталога данных. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-crl-file" xreflabel="ssl_crl_file">
      <term><varname>ssl_crl_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>ssl_crl_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя файла, содержащего список отзыва сертификатов (CRL) для SSL-сервера. По умолчанию не определён, то есть файл CRL не загружается. (В предыдущих выпусках &productname; это имя было фиксированным: <filename>root.crl</filename>.) При указании относительного пути он рассматривается от каталога данных. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-key-file" xreflabel="ssl_key_file">
      <term><varname>ssl_key_file</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>ssl_key_file</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя файла, содержащего закрытый ключ SSL-сервера. По умолчанию имеет значение <filename>server.key</filename>. При указании относительного пути он рассматривается от каталога данных. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ciphers" xreflabel="ssl_ciphers">
      <term><varname>ssl_ciphers</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>ssl_ciphers</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт список наборов шифров <acronym>SSL</acronym>, которые могут применяться для защиты соединений. Синтаксис этого параметра и список поддерживаемых значений можно найти на странице <citerefentry><refentrytitle>ciphers</refentrytitle></citerefentry> руководства по <application>OpenSSL</application>. По умолчанию этот параметр имеет значение <literal>HIGH:MEDIUM:+3DES:!aNULL</literal>. Обычно оно вполне приемлемо при отсутствии особых требований по безопасности. Этот параметр можно задать только при запуске сервера.</para>

       <para>Объяснение значения по умолчанию: <variablelist>
         <varlistentry>
          <term><literal>HIGH</literal></term>
          <listitem>
           <para>Наборы шифров, в которых используются шифры из группы высокого уровня (<literal>HIGH</literal>), (например: AES, Camellia, 3DES)</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>MEDIUM</literal></term>
          <listitem>
           <para>Наборы шифров, в которых используются шифры из группы среднего уровня (<literal>MEDIUM</literal>) (например, RC4, SEED)</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>+3DES</literal></term>
          <listitem>
           <para>Порядок шифров для группы <literal>HIGH</literal> по умолчанию в OpenSSL определён некорректно. В нём 3DES оказывается выше AES128, что неправильно, так как он считается менее безопасным, чем AES128, и работает гораздо медленнее. Включение <literal>+3DES</literal> меняет этот порядок, чтобы данный алгоритм следовал после всех шифров групп <literal>HIGH</literal> и <literal>MEDIUM</literal>.</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>!aNULL</literal></term>
          <listitem>
           <para>Отключает наборы анонимных шифров, не требующие проверки подлинности. Такие наборы уязвимы для атак с посредником, поэтому использовать их не следует.</para>
          </listitem>
         </varlistentry>
        </variablelist></para>

       <para>Конкретные наборы шифров и их свойства очень различаются от версии к версии OpenSSL. Чтобы получить фактическую информацию о них для текущей установленной версии <application>OpenSSL</application>, выполните команду <literal>openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'</literal>. Учтите, что этот список фильтруется во время выполнения, в зависимости от типа ключа сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-prefer-server-ciphers" xreflabel="ssl_prefer_server_ciphers">
      <term><varname>ssl_prefer_server_ciphers</varname> (<type>bool</type>) <indexterm><primary>параметр конфигурации <varname>ssl_prefer_server_ciphers</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет, должны ли шифры SSL сервера предпочитаться клиентским. По умолчанию предпочтение отдаётся шифрам сервера. Этот параметр можно задать только при запуске сервера.</para>

       <para>В старых версиях &productname; этот параметр отсутствовал и предпочтение отдавалось выбору клиента. Введён этот параметр в основном для обеспечения совместимости с этими версиями. Вообще же обычно лучше использовать конфигурацию сервера, так как в конфигурации на стороне клиента более вероятны ошибки.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ecdh-curve" xreflabel="ssl_ecdh_curve">
      <term><varname>ssl_ecdh_curve</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>ssl_ecdh_curve</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя кривой для использования при обмене ключами <acronym>ECDH</acronym>. Эту кривую должны поддерживать все подключающиеся клиенты. Это не обязательно должна быть кривая, с которой был получен ключ сервера. По умолчанию выбирается кривая <literal>prime256v1</literal>. Этот параметр можно задать только при запуске сервера.</para>

       <para>Наиболее популярные кривые OpenSSL: <literal>prime256v1</literal> (NIST P-256), <literal>secp384r1</literal> (NIST P-384) и <literal>secp521r1</literal> (NIST P-521).</para>

       <para>Полный список доступных кривых можно получить командой <command>openssl ecparam -list_curves</command>. Однако не все из них пригодны для <acronym>TLS</acronym>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-password-encryption" xreflabel="password_encryption">
      <term><varname>password_encryption</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>password_encryption</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр определяет, будет ли пароль шифроваться, когда он передаётся в <xref linkend="sql-createuser"/> или <xref linkend="sql-alterrole"/> без указания <literal>ENCRYPTED</literal> или <literal>UNENCRYPTED</literal>. Значение по умолчанию — <literal>md5</literal>, то есть пароль сохраняется в виде хеша MD5. Со значением <literal>plain</literal> он сохраняется в открытом виде. Также принимаются значения <literal>on</literal> и <literal>off</literal>, действующие как псевдонимы для <literal>md5</literal> и <literal>plain</literal>, соответственно. Если задать в этом параметре <literal>scram</literal>, пароль будет защищён алгоритмом SCRAM-SHA-256.</para>       
      </listitem>
     </varlistentry>

     <varlistentry id="guc-krb-server-keyfile" xreflabel="krb_server_keyfile">
      <term><varname>krb_server_keyfile</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>krb_server_keyfile</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт размещение файла ключей для сервера Kerberos. За подробностями обратитесь к <xref remap="3" linkend="gssapi-auth"/>. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-krb-caseins-users" xreflabel="krb_caseins_users">
      <term><varname>krb_caseins_users</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>krb_caseins_users</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет, должны ли имена пользователей GSSAPI обрабатываться без учёта регистра. По умолчанию значение этого параметра — <literal>off</literal> (регистр учитывается). Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-db-user-namespace" xreflabel="db_user_namespace">
      <term><varname>db_user_namespace</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>db_user_namespace</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр позволяет относить имена пользователей к базам данных. По умолчанию он имеет значение off (выключен). Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>

       <para>Если он включён, имена создаваемых пользователей должны иметь вид <replaceable>имя_пользователя@база_данных</replaceable>. Когда подключающийся клиент передаёт <replaceable>имя_пользователя</replaceable>, к этому имени добавляется <literal>@</literal> с именем базы данных, и сервер идентифицирует пользователя по этому полному имени. Заметьте, что для создания пользователя с именем, содержащим <literal>@</literal>, в среде SQL потребуется заключить это имя в кавычки.</para>

       <para>Когда этот параметр включён, он не мешает создавать и использовать обычных глобальных пользователей. Чтобы подключиться с таким именем пользователя, достаточно добавить к имени <literal>@</literal>, например так: <literal>joe@</literal>. Получив такое имя, сервер отбросит <literal>@</literal>, и будет идентифицировать пользователя по начальному имени.</para>

       <para>Параметр <varname>db_user_namespace</varname> порождает расхождение между именами пользователей на стороне сервера и клиента. Но проверки подлинности всегда выполняются с именем с точки зрения сервера, так что, настраивая аутентификацию, следует указывать серверное представление имени, а не клиентское. Так как метод аутентификации <literal>md5</literal> подмешивает имя пользователя в качестве соли и на стороне сервера, и на стороне клиента, и метод <literal>scram</literal> также и там, и там получает соль, зависящую от имени, методы <literal>md5</literal> и <literal>scram</literal> использовать с <varname>db_user_namespace</varname> невозможно.</para>

       <note>
        <para>Эта возможность предлагается в качестве временной меры, пока не будет найдено полноценное решение. Тогда этот параметр будет ликвидирован.</para>
       </note>
      </listitem>
     </varlistentry>

    </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-resource">
    <title>Потребление ресурсов</title>

    <sect2 id="runtime-config-resource-memory">
     <title>Память</title>

     <variablelist>
     <varlistentry id="guc-shared-buffers" xreflabel="shared_buffers">
      <term><varname>shared_buffers</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>shared_buffers</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти. По умолчанию это обычно 128 мегабайт (<literal>128MB</literal>), но может быть и меньше, если конфигурация вашего ядра накладывает дополнительные ограничения (это определяется в процессе <application>initdb</application>). Это значение не должно быть меньше 128 килобайт. (Этот минимум зависит от величины <symbol>BLCKSZ</symbol>.) Однако для хорошей производительности обычно требуются гораздо большие значения. Задать этот параметр можно только при запуске сервера.</para>

       <para>Если вы используете выделенный сервер с объёмом ОЗУ 1 ГБ и более, разумным начальным значением <varname>shared_buffers</varname> будет 25% от объёма памяти. Существуют варианты нагрузки, при которых эффективны будут и ещё большие значения <varname>shared_buffers</varname>, но так как <productname>&productname;</productname> использует и кеш операционной системы, выделять для <varname>shared_buffers</varname> более 40% ОЗУ вряд ли будет полезно. При увеличении <varname>shared_buffers</varname> обычно требуется соответственно увеличить <varname>max_wal_size</varname>, чтобы растянуть процесс записи большого объёма новых или изменённых данных на более продолжительное время.</para>

       <para>В серверах с объёмом ОЗУ меньше 1ГБ следует использовать меньший процент ОЗУ, чтобы оставить достаточно памяти для операционной системы. Кроме того, большие значения <varname>shared_buffers</varname> не так эффективны в Windows. Возможно, вы получите лучшие результаты, если оставите это значение относительно небольшим и будете больше полагаться на кеш операционной системы. Оптимальные значения <varname>shared_buffers</varname> для Windows обычно лежат в интервале от 64 до 512 мегабайт.</para>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-huge-pages" xreflabel="huge_pages">
      <term><varname>huge_pages</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>huge_pages</varname></primary></indexterm></term>
      <listitem>
       <para>Включает/отключает использование огромных страниц памяти. Допустимые значения: <literal>try</literal> (попытаться, по умолчанию), <literal>on</literal> (вкл.) и <literal>off</literal> (выкл.).</para>

       <para>В настоящее время это поддерживается только в Linux. В других системах значение <literal>try</literal> просто игнорируется.</para>

       <para>В результате использования огромных страниц уменьшаются таблицы страниц и сокращается время, которое тратит процессор на управление памятью. За подробностями обратитесь к <xref remap="3" linkend="linux-huge-pages"/>.</para>

       <para>Когда <varname>huge_pages</varname> имеет значение <literal>try</literal>, сервер попытается использовать огромные страницы, но может переключиться на обычные, если это не удастся. Со значением <literal>on</literal>, если использовать огромные страницы не получится, сервер не будет запущен. Со значением <literal>off</literal> огромные страницы использоваться не будут.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-temp-buffers" xreflabel="temp_buffers">
      <term><varname>temp_buffers</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>temp_buffers</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальное число временных буферов для каждого сеанса, По умолчанию объём временных буферов составляет восемь мегабайт (1024 буфера). Этот параметр можно изменить в отдельном сеансе, но только до первого обращения к временным таблицам; после этого изменить его значение для текущего сеанса не удастся.</para>

       <para>Сеанс выделяет временные буферы по мере необходимости до достижения предела, заданного параметром <varname>temp_buffers</varname>. Если сеанс не задействует временные буферы, то для него хранятся только дескрипторы буферов, которые занимает около 64 байтов (в количестве <varname>temp_buffers</varname>). Однако если буфер действительно используется, он будет дополнительно занимать 8192 байта (или в общем случае, <symbol>BLCKSZ</symbol> байтов).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-prepared-transactions" xreflabel="max_prepared_transactions">
      <term><varname>max_prepared_transactions</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_prepared_transactions</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальное число транзакций, которые могут одновременно находиться в <quote>подготовленном</quote> состоянии (см. <xref remap="4" linkend="sql-prepare-transaction"/>). При нулевом значении (по умолчанию) механизм подготовленных транзакций отключается. Задать этот параметр можно только при запуске сервера.</para>

       <para>Если использовать транзакции не планируется, этот параметр следует обнулить, чтобы не допустить непреднамеренного создания подготовленных транзакций. Если же подготовленные транзакции применяются, то <varname>max_prepared_transactions</varname>, вероятно, должен быть не меньше, чем <xref linkend="guc-max-connections"/>, чтобы подготовить транзакцию можно было в каждом сеансе.</para>

       <para>Для сервера, работающего в режиме резерва, значение этого параметра должно быть больше или равно значению на главном. В противном случае на резервном сервере не будут разрешены запросы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-work-mem" xreflabel="work_mem">
      <term><varname>work_mem</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>work_mem</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт объём памяти, который будет использоваться для внутренних операций сортировки и хеш-таблиц, прежде чем будут задействованы временные файлы на диске. Значение по умолчанию — четыре мегабайта (<literal>4MB</literal>). Заметьте, что в сложных запросах одновременно могут выполняться несколько операций сортировки или хеширования, так что этот объём памяти будет доступен для каждой операции. Кроме того, такие операции могут выполняться одновременно в разных сеансах. Таким образом, общий объём памяти может многократно превосходить значение <varname>work_mem</varname>; это следует учитывать, выбирая подходящее значение. Операции сортировки используются для <literal>ORDER BY</literal>, <literal>DISTINCT</literal> и соединений слиянием. Хеш-таблицы используются при соединениях и агрегировании по хешу, а также обработке подзапросов <literal>IN</literal> с применением хеша.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-maintenance-work-mem" xreflabel="maintenance_work_mem">
      <term><varname>maintenance_work_mem</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>maintenance_work_mem</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный объём памяти для операций обслуживания БД, в частности <command>VACUUM</command>, <command>CREATE INDEX</command> и <command>ALTER TABLE ADD FOREIGN KEY</command>. По умолчанию его значение — 64 мегабайта (<literal>64MB</literal>). Так как в один момент времени в сеансе может выполняться только одна такая операция, и обычно они не запускаются параллельно, это значение вполне может быть гораздо больше <varname>work_mem</varname>. Увеличение этого значения может привести к ускорению операций очистки и восстановления БД из копии.</para>
       <para>Учтите, что когда выполняется автоочистка, этот объём может быть выделен <xref linkend="guc-autovacuum-max-workers"/> раз, поэтому не стоит устанавливать значение по умолчанию слишком большим. Возможно, будет лучше управлять объёмом памяти для автоочистки отдельно, изменяя <xref linkend="guc-autovacuum-work-mem"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-replacement-sort-tuples" xreflabel="replacement_sort_tuples">
      <term><varname>replacement_sort_tuples</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>replacement_sort_tuples</varname></primary></indexterm></term>
      <listitem>
       <para>Когда количество сортируемых кортежей меньше заданного числа, для получения первого потока сортируемых данных будет применяться не алгоритм quicksort, а выбор с замещением. Это может быть полезно в системах с ограниченным объёмом памяти, когда кортежи, поступающие на вход большой операции сортировки, характеризуются хорошей корреляцией физического и логического порядка. Заметьте, что это не относится к кортежам с <emphasis>обратной</emphasis> корреляцией. Вполне возможно, что алгоритм выбора с замещением сформирует один длинный поток и слияние не потребуется, тогда как со стратегией по умолчанию может быть получено много потоков, которые затем потребуется слить для получения окончательного отсортированного результата. Это позволяет ускорить операции сортировки.</para>
       <para>Значение по умолчанию — 150000 кортежей. Заметьте, что увеличивать это значение обычно не очень полезно, и может быть даже контрпродуктивно, так как эффективность приоритетной очереди зависит от доступного объёма кеша процессора, тогда как со стандартной стратегией потоки сортируются <firstterm>кеш-независимым</firstterm> алгоритмом. Благодаря этому, стандартная стратегия позволяет автоматически и прозрачно использовать доступный кеш процессора более эффективным образом.</para>
       <para>Если в <varname>maintenance_work_mem</varname> задано значение по умолчанию, внешние сортировки в служебных командах (например, сортировки, выполняемые командами <command>CREATE INDEX</command> для построения-индекса B-дерева) обычно никогда не используют алгоритм выбора с замещением (так как все кортежи помещаются в память), кроме случаев, когда входные кортежи достаточно велики.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-work-mem" xreflabel="autovacuum_work_mem">
      <term><varname>autovacuum_work_mem</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_work_mem</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный объём памяти, который будет использовать каждый рабочий процесс автоочистки. По умолчанию равен -1, что означает, что этот объём определяется значением <xref linkend="guc-maintenance-work-mem"/>. Этот параметр не влияет на поведение команды <command>VACUUM</command>, выполняемой в других контекстах.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-stack-depth" xreflabel="max_stack_depth">
      <term><varname>max_stack_depth</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_stack_depth</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальную безопасную глубину стека для исполнителя. В идеале это значение должно равняться предельному размеру стека, ограниченному ядром (как устанавливает команда <literal>ulimit -s</literal> или равнозначные ей), за вычетом запаса примерно в мегабайт. Этот запас необходим, потому что сервер проверяет глубину стека не в каждой процедуре, а только в потенциально рекурсивных процедурах, например, при вычислении выражений. Значение по умолчанию — два мегабайта (<literal>2MB</literal>), выбрано с большим запасом, так что риск переполнения стека минимален. Однако, с другой стороны, его может быть недостаточно для выполнения сложных функций. Изменить этот параметр могут только суперпользователи.</para>

       <para>Если <varname>max_stack_depth</varname> будет превышать фактический предел ядра, то функция с неограниченной рекурсией сможет вызвать крах отдельного процесса сервера. В системах, где <productname>&productname;</productname> может определить предел, установленный ядром, он не позволит установить для этого параметра небезопасное значение. Однако эту информацию выдают не все системы, поэтому выбирать это значение следует с осторожностью.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-dynamic-shared-memory-type" xreflabel="dynamic_shared_memory_type">
      <term><varname>dynamic_shared_memory_type</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>dynamic_shared_memory_type</varname></primary></indexterm></term>
      <listitem>
       <para>Выбирает механизм динамической разделяемой памяти, который будет использовать сервер. Допустимые варианты: <literal>posix</literal> (для выделения разделяемой памяти POSIX функцией <literal>shm_open</literal>), <literal>sysv</literal> (для выделения разделяемой памяти System V функцией <literal>shmget</literal>), <literal>windows</literal> (для выделения разделяемой памяти в Windows), <literal>mmap</literal> (для эмуляции разделяемой памяти через отображение в память файлов, хранящихся в каталоге данных) и <literal>none</literal> (для отключения этой функциональности). Не все варианты поддерживаются на разных платформах; первый из поддерживаемых данной платформой вариантов становится для неё вариантом по умолчанию. Применять <literal>mmap</literal>, который нигде не выбирается по умолчанию, вообще не рекомендуется, так как операционная система может периодически записывать на диск изменённые страницы, что создаст дополнительную нагрузку; однако, это может быть полезно для отладки, когда каталог <literal>pg_dynshmem</literal> находится в RAM-диске или когда другие механизмы разделяемой памяти недоступны.</para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>

     <sect2 id="runtime-config-resource-disk">
     <title>Диск</title>

     <variablelist>
     <varlistentry id="guc-temp-file-limit" xreflabel="temp_file_limit">
      <term><varname>temp_file_limit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>temp_file_limit</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный объём дискового пространства, который сможет использовать один процесс для временных файлов, например, при сортировке и хешировании, или для сохранения удерживаемого курсора. Транзакция, которая попытается превысить этот предел, будет отменена. Этот параметр задаётся в килобайтах, а значение <literal>-1</literal> (по умолчанию) означает, что предел отсутствует. Изменить этот параметр могут только суперпользователи.</para>
       <para>Этот параметр ограничивает общий объём, который могут занимать в момент времени все временные файлы, задействованные в данном процессе <productname>&productname;</productname>. Следует отметить, что при этом учитывается только место, занимаемое явно создаваемыми временными таблицами; на временные файлы, которые создаются неявно при выполнении запроса, это ограничение <emphasis>не</emphasis> распространяется.</para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>

     <sect2 id="runtime-config-resource-kernel">
     <title>Использование ресурсов ядра</title>

     <variablelist>
     <varlistentry id="guc-max-files-per-process" xreflabel="max_files_per_process">
      <term><varname>max_files_per_process</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_files_per_process</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальное число файлов, которые могут быть одновременно открыты каждым серверным подпроцессом. Значение по умолчанию — 1000 файлов. Если ядро реализует безопасное ограничение по процессам, об этом параметре можно не беспокоиться. Но на некоторых платформах (а именно, в большинстве систем BSD) ядро позволяет отдельному процессу открыть больше файлов, чем могут открыть несколько процессов одновременно. Если вы столкнётесь с ошибками <quote>Too many open files</quote> (Слишком много открытых файлов), попробуйте уменьшить это число. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>
     </variablelist>
    </sect2>

    <sect2 id="runtime-config-resource-vacuum-cost">
     <title>Задержка очистки по стоимости</title>

     <para>Во время выполнения команд <xref linkend="sql-vacuum"/> и <xref linkend="sql-analyze"/> система ведёт внутренний счётчик, в котором суммирует оцениваемую стоимость различных выполняемых операций ввода/вывода. Когда накопленная стоимость превышает предел (<varname>vacuum_cost_limit</varname>), процесс, выполняющий эту операцию, засыпает на некоторое время (<varname>vacuum_cost_delay</varname>). Затем счётчик сбрасывается и процесс продолжается.</para>

     <para>Данный подход реализован для того, чтобы администраторы могли снизить влияние этих команд на параллельную работу с базой, за счёт уменьшения нагрузки на подсистему ввода-вывода. Очень часто не имеет значения, насколько быстро выполнятся команды обслуживания (например, <command>VACUUM</command> и <command>ANALYZE</command>), но очень важно, чтобы они как можно меньше влияли на выполнение других операций с базой данных. Администраторы имеют возможность управлять этим, настраивая задержку очистки по стоимости.</para>

     <para>По умолчанию этот режим отключён для выполняемых вручную команд <command>VACUUM</command>. Чтобы включить его, нужно установить в <varname>vacuum_cost_delay</varname> ненулевое значение.</para>

     <variablelist>
      <varlistentry id="guc-vacuum-cost-delay" xreflabel="vacuum_cost_delay">
       <term><varname>vacuum_cost_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_cost_delay</varname></primary></indexterm></term>
       <listitem>
        <para>Продолжительность времени, в миллисекундах, в течение которого будет простаивать процесс, превысивший предел стоимости. По умолчанию его значение равно нулю, то есть задержка очистки отсутствует. При положительных значениях интенсивность очистки будет зависеть от стоимости. Заметьте, что во многих системах разрешение таймера составляет 10 мс, поэтому если задать в <varname>vacuum_cost_delay</varname> значение, не кратное 10, фактически будет получен тот же результат, что и со следующим за ним кратным 10.</para>

        <para>При настройке интенсивности очистки для <varname>vacuum_cost_delay</varname> обычно выбираются довольно небольшие значения, например 10 или 20 миллисекунд. Чтобы точнее ограничить потребление ресурсов при очистке, лучше всего изменять другие параметры стоимости очистки.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-hit" xreflabel="vacuum_cost_page_hit">
       <term><varname>vacuum_cost_page_hit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_cost_page_hit</varname></primary></indexterm></term>
       <listitem>
        <para>Примерная стоимость очистки буфера, оказавшегося в общем кеше. Это подразумевает блокировку пула буферов, поиск в хеш-таблице и сканирование содержимого страницы. По умолчанию этот параметр равен одному.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-miss" xreflabel="vacuum_cost_page_miss">
       <term><varname>vacuum_cost_page_miss</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_cost_page_miss</varname></primary></indexterm></term>
       <listitem>
        <para>Примерная стоимость очистки буфера, который нужно прочитать с диска. Это подразумевает блокировку пула буферов, поиск в хеш-таблице, чтение требуемого блока с диска и сканирование его содержимого. По умолчанию этот параметр равен 10.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-dirty" xreflabel="vacuum_cost_page_dirty">
       <term><varname>vacuum_cost_page_dirty</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_cost_page_dirty</varname></primary></indexterm></term>
       <listitem>
        <para>Примерная стоимость очистки, при которой изменяется блок, не модифицированный ранее. В неё включается дополнительная стоимость ввода/вывода, связанная с записью изменённого блока на диск. По умолчанию этот параметр равен 20.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-limit" xreflabel="vacuum_cost_limit">
       <term><varname>vacuum_cost_limit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_cost_limit</varname></primary></indexterm></term>
       <listitem>
        <para>Общая стоимость, при накоплении которой процесс очистки будет засыпать. По умолчанию этот параметр равен 200.</para>
       </listitem>
      </varlistentry>
     </variablelist>

     <note>
      <para>Некоторые операции устанавливают критические блокировки и поэтому должны завершаться как можно быстрее. Во время таких операций задержка очистки по стоимости не осуществляется, так что накопленная за это время стоимость может намного превышать установленный предел. Во избежание ненужных длительных задержек в таких случаях, фактическая задержка вычисляется по формуле <varname>vacuum_cost_delay</varname> * <varname>accumulated_balance</varname> / <varname>vacuum_cost_limit</varname> и ограничивается максимумом, равным <varname>vacuum_cost_delay</varname> * 4.</para>
     </note>
    </sect2>

    <sect2 id="runtime-config-resource-background-writer">
     <title>Фоновая запись</title>

     <para>В числе специальных процессов сервера есть процесс <firstterm>фоновой записи</firstterm>, задача которого — осуществлять запись <quote>грязных</quote> (новых или изменённых) общих буферов на диск. Он старается записывать данные из буферов так, чтобы обычным серверным процессам, обрабатывающим запросы, не приходилось ждать записи или это ожидание было минимальным. Однако процесс фоновой записи увеличивает общую нагрузку на подсистему ввода/вывода, так как он может записывать неоднократно изменяемую страницу при каждом изменении, тогда как она может быть записана всего раз в контрольной точке. Параметры, рассматриваемые в данном подразделе, позволяют настроить поведение фоновой записи для конкретных нужд.</para>

     <variablelist>
      <varlistentry id="guc-bgwriter-delay" xreflabel="bgwriter_delay">
       <term><varname>bgwriter_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>bgwriter_delay</varname></primary></indexterm></term>
       <listitem>
        <para>Задаёт задержку между раундами активности процесса фоновой записи. Во время раунда этот процесс осуществляет запись некоторого количество загрязнённых буферов (это настраивается следующими параметрами). Затем он засыпает на время <varname>bgwriter_delay</varname> (задаваемое в миллисекундах), и всё повторяется снова. Однако если в пуле не остаётся загрязнённых буферов, он может быть неактивен более длительное время. По умолчанию этот параметр равен 200 миллисекундам (<literal>200ms</literal>). Заметьте, что во многих системах разрешение таймера составляет 10 мс, поэтому если задать в <varname>bgwriter_delay</varname> значение, не кратное 10, фактически будет получен тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-lru-maxpages" xreflabel="bgwriter_lru_maxpages">
       <term><varname>bgwriter_lru_maxpages</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>bgwriter_lru_maxpages</varname></primary></indexterm></term>
       <listitem>
        <para>Задаёт максимальное число буферов, которое сможет записать процесс фоновой записи за раунд активности. При нулевом значении фоновая запись отключается. (Учтите, что на контрольные точки, которые управляются отдельным вспомогательным процессом, это не влияет.) По умолчанию значение этого параметра — 100 буферов. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-lru-multiplier" xreflabel="bgwriter_lru_multiplier">
       <term><varname>bgwriter_lru_multiplier</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>bgwriter_lru_multiplier</varname></primary></indexterm></term>
       <listitem>
        <para>Число загрязнённых буферов, записываемых в очередном раунде, зависит от того, сколько новых буферов требовалось серверным процессам в предыдущих раундах. Средняя недавняя потребность умножается на <varname>bgwriter_lru_multiplier</varname> и предполагается, что именно столько буферов потребуется на следующем раунде. Процесс фоновой записи будет записывать на диск и освобождать буферы, пока число свободных буферов не достигнет целевого значения. (При этом число буферов, записываемых за раунд, ограничивается сверху параметром <varname>bgwriter_lru_maxpages</varname>.) Таким образом, со множителем, равным 1.0, записывается ровно столько буферов, сколько требуется по предположению (<quote>точно по плану</quote>). Увеличение этого множителя даёт некоторую страховку от резких скачков потребностей, тогда как уменьшение отражает намерение оставить некоторый объём записи для серверных процессов. По умолчанию он равен 2.0. Этот параметр можно установить только в файле <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-flush-after" xreflabel="bgwriter_flush_after">
       <term><varname>bgwriter_flush_after</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>bgwriter_flush_after</varname></primary></indexterm></term>
       <listitem>
        <para>Когда процессом фоновой записи записывается больше чем <varname>bgwriter_flush_after</varname> байт, сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничивает объём &laquo;грязных&raquo; данных в страничном кеше ядра и уменьшает вероятность затормаживания при выполнении fsync в конце контрольной точки или когда ОС сбрасывает данные на диск большими порциями в фоне. Часто это значительно уменьшает задержки транзакций, но бывают ситуации, особенно когда объём рабочей нагрузки больше <xref linkend="guc-shared-buffers"/>, но меньше страничного кеша ОС, когда производительность может упасть. Этот параметр действует не на всех платформах. Он может принимать значение от <literal>0</literal> (при этом управление отложенной записью отключается) до 2 Мбайт (<literal>2MB</literal>). Значение по умолчанию — <literal>512kB</literal> в Linux и <literal>0</literal> в других ОС. (Если <symbol>BLCKSZ</symbol> отличен от 8 Кбайт, значение по умолчанию и максимум корректируются пропорционально.) Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>С маленькими значениями <varname>bgwriter_lru_maxpages</varname> и <varname>bgwriter_lru_multiplier</varname> уменьшается активность ввода/вывода со стороны процесса фоновой записи, но увеличивается вероятность того, что запись придётся производить непосредственно серверным процессам, что замедлит выполнение запросов.</para>
    </sect2>

    <sect2 id="runtime-config-resource-async-behavior">
     <title>Асинхронное поведение</title>

     <variablelist>
      <varlistentry id="guc-effective-io-concurrency" xreflabel="effective_io_concurrency">
       <term><varname>effective_io_concurrency</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>effective_io_concurrency</varname></primary></indexterm></term>
       <listitem>
        <para>Задаёт допустимое число параллельных операций ввода/вывода, которое говорит <productname>&productname;</productname> о том, сколько операций ввода/вывода могут быть выполнены одновременно. Чем больше это число, тем больше операций ввода/вывода будет пытаться выполнить параллельно <productname>&productname;</productname> в отдельном сеансе. Допустимые значения лежат в интервале от 1 до 1000, а нулевое значение отключает асинхронные запросы ввода/вывода. В настоящее время этот параметр влияет только на сканирование по битовой карте.</para>

        <para>Для магнитных носителей хорошим начальным значением этого параметра будет число отдельных дисков, составляющих массив RAID 0 или RAID 1, в котором размещена база данных. (Для RAID 5 следует исключить один диск (как диск с чётностью).) Однако, если база данных часто обрабатывает множество запросов в различных сеансах, и при небольших значениях дисковый массив может быть полностью загружен. Если продолжать увеличивать это значение при полной загрузке дисков, это приведёт только к увеличению нагрузки на процессор. Диски SSD и другие виды хранилища в памяти часто могут обрабатывать множество параллельных запросов, так что оптимальным числом может быть несколько сотен.</para>

        <para>Асинхронный ввод/вывод зависит от эффективности функции <function>posix_fadvise</function>, которая отсутствует в некоторых операционных системах. В случае её отсутствия попытка задать для этого параметра любое ненулевое значение приведёт к ошибке. В некоторых системах (например, в Solaris), эта функция присутствует, но на самом деле ничего не делает.</para>

        <para>Значение по умолчанию равно 1 в системах, где это поддерживается, и 0 в остальных. Это значение можно переопределить для таблиц в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <xref remap="4" linkend="sql-altertablespace"/>).</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-worker-processes" xreflabel="max_worker_processes">
       <term><varname>max_worker_processes</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_worker_processes</varname></primary></indexterm></term>
       <listitem>
        <para>Задаёт максимальное число фоновых процессов, которое можно запустить в текущей системе. Этот параметр можно задать только при запуске сервера. Значение по умолчанию — 8.</para>

        <para>Для сервера, работающего в режиме резерва, значение этого параметра должно быть больше или равно значению на главном. В противном случае на резервном сервере не будут разрешены запросы.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-parallel-workers-per-gather" xreflabel="max_parallel_workers_per_gather">
       <term><varname>max_parallel_workers_per_gather</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_parallel_workers_per_gather</varname></primary></indexterm></term>
       <listitem>
        <para>Задаёт максимальное число рабочих процессов, которые могут запускаться одним узлом <literal>Gather</literal>. Параллельные рабочие процессы берутся из пула процессов, контролируемого параметром <xref linkend="guc-max-worker-processes"/>. Учтите, что запрошенное количество рабочих процессов может быть недоступно во время выполнения. В этом случае план будет выполняться с меньшим числом процессов, что может быть неэффективно. Значение 0 (заданное по умолчанию) отключает параллельное выполнение запросов.</para>

        <para>Учтите, что параллельные запросы могут потреблять значительно больше ресурсов, чем не параллельные, так как каждый рабочий процесс является отдельным процессом и оказывает на систему примерно такое же влияние, как дополнительный пользовательский сеанс. Это следует учитывать, выбирая значение этого параметра, а также настраивая другие параметры, управляющие использованием ресурсов, например <xref linkend="guc-work-mem"/>. Ограничения ресурсов, такие как <varname>work_mem</varname>, применяются к каждому рабочему процессу отдельно, что означает, что общая нагрузка для всех процессов может оказаться гораздо больше, чем при обычном использовании одного процесса. Например, параллельный запрос, задействующий 4 рабочих процесса, может использовать в 5 раз больше времени процессора, объёма памяти, ввода/вывода и т. д., по сравнению с запросом, не задействующим рабочие процессы вовсе.</para>

        <para>За дополнительными сведениями о параллельных запросах обратитесь к <xref remap="3" linkend="parallel-query"/>.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-backend-flush-after" xreflabel="backend_flush_after">
       <term><varname>backend_flush_after</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>backend_flush_after</varname></primary></indexterm></term>
       <listitem>
        <para>Когда одним обслуживающим процессом записывается больше <varname>backend_flush_after</varname> байт, сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничивает объём &laquo;грязных&raquo; данных в страничном кеше ядра и уменьшает вероятность затормаживания при выполнении fsync в конце контрольной точки или когда ОС сбрасывает данные на диск большими порциями в фоне. Часто это значительно сокращает задержки транзакций, но бывают ситуации, особенно когда объём рабочей нагрузки больше <xref linkend="guc-shared-buffers"/>, но меньше страничного кеша ОС, когда производительность может упасть. Этот параметр действует не на всех платформах. Он может принимать значение от <literal>0</literal> (при этом управление отложенной записью отключается) до 2 Мбайт (<literal>2MB</literal>). По умолчанию он имеет значение <literal>0</literal>, то есть это поведение отключено. (Если <symbol>BLCKSZ</symbol> отличен от 8 Кбайт, максимальное значение корректируется пропорционально.)</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-old-snapshot-threshold" xreflabel="old_snapshot_threshold">
       <term><varname>old_snapshot_threshold</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>old_snapshot_threshold</varname></primary></indexterm></term>
       <listitem>
        <para>Задаёт минимальное время, которое можно пользоваться снимком без риска получить ошибку <literal>снимок слишком стар</literal>. Этот параметр можно задать только при запуске сервера.</para>

        <para>По истечении этого времени старые данные могут вычищены. Это предотвращает замусоривание данными снимков, которые остаются задействованными долгое время. Во избежание получения некорректных результатов из-за очистки данных, которые должны были бы наблюдаться в снимке, клиенту будет выдана ошибка, если возраст снимка превысит заданный предел и из этого снимка будет запрошена страница, изменённая со времени его создания.</para>

        <para>Значение <literal>-1</literal> (по умолчанию) отключает это поведение. Полезные значения для производственной среды могут лежать в интервале от нескольких часов до нескольких дней. Заданное значение округляется до минут, а минимальные значения (как например, <literal>0</literal> или <literal>1min</literal>) допускаются только потому, что они могут быть полезны при тестировании. Хотя допустимым будет и значение <literal>60d</literal> (60 дней), учтите, что при многих видах нагрузки критичное замусоривание базы или зацикливание идентификаторов транзакций на уровне страниц может происходить в намного меньших временных отрезках.</para>

        <para>Когда это ограничение действует, освобождённое пространство в конце отношения не может быть отдано операционной системе, так как при этом будет удалена информация, необходимая для выявления условия <literal>снимок слишком стар</literal>. Всё пространство, выделенное отношению, останется связанным с ним до тех пор, пока не будет освобождено явно (например, с помощью команды <command>VACUUM FULL</command>).</para>

        <para>Установка этого параметра не гарантирует, что обозначенная ошибка будет выдаваться при всех возможных обстоятельствах. На самом деле, если можно получить корректные результаты, например, из курсора, материализовавшего результирующий набор, ошибка не будет выдана, даже если нижележащие строки в целевой таблице были ликвидированы при очистке. Некоторые таблицы не могут быть безопасно очищены в сжатые сроки, так что на них этот параметр не распространяется. В частности, это касается системных каталогов и таблиц с хеш-индексами. Для таких таблиц этот параметр не сокращает раздувание, но и не чреват ошибкой <literal>снимок слишком стар</literal> при сканировании.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-wal">
    <title>Журнал упреждающей записи</title>

   <para>За дополнительной информацией о настройке этих параметров обратитесь к <xref remap="3" linkend="wal-configuration"/>.</para>

    <sect2 id="runtime-config-wal-settings">
     <title>Параметры</title>
     <variablelist>

     <varlistentry id="guc-wal-level" xreflabel="wal_level">
      <term><varname>wal_level</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>wal_level</varname></primary></indexterm></term>
      <listitem>
       <para>Параметр <varname>wal_level</varname> определяет, как много информации записывается в WAL. Со значением <literal>minimal</literal> (по умолчанию) в журнал записывается только информация, необходимая для восстановления после сбоя или аварийного отключения. Вариант <literal>replica</literal> добавляет в него то, что необходимо для архивирования WAL, а также информацию, необходимую для выполнения запросов на резервном сервере в режиме &laquo;только чтение&raquo;. Наконец, <literal>logical</literal> добавляет информацию, требуемую для поддержки логического декодирования. Каждый последующий уровень включает всю информацию, записываемую на всех предыдущих. Задать этот параметр можно только при запуске сервера.</para>
       <para>На уровне <literal>minimal</literal> некоторые массовые операции могут выполняться в обход журнала без риска потери данных, и при этом они выполнятся гораздо быстрее (см. <xref remap="4" linkend="populate-pitr"/>). В частности, такая оптимизация возможна с операциями: <simplelist>
         <member><command>CREATE TABLE AS</command></member>
         <member><command>CREATE INDEX</command></member>
         <member><command>CLUSTER</command></member>
         <member><command>COPY</command> с таблицами, которые были созданы или опустошены в той же транзакции</member>
        </simplelist> Однако такой минимальный журнал не будет содержать достаточно информации для восстановления данных из базовой копии и журналов, поэтому для реализации стратегии архивации WAL (см. <xref remap="4" linkend="guc-archive-mode"/>) и потоковой репликации необходим уровень <literal>replica</literal> или более высокий.</para>
       <para>На уровне <literal>logical</literal> в журнал записывается та же информация, что и на уровне <literal>replica</literal>, плюс информация, необходимая для извлечения из журнала наборов логических изменений. Повышение уровня до <literal>logical</literal> приводит к значительному увеличению объёма WAL, особенно если многие таблицы имеют характеристику <literal>REPLICA IDENTITY FULL</literal> и выполняется множество команд <command>UPDATE</command> и <command>DELETE</command>.</para>
       <para>В выпусках до 9.6 для этого параметра допускались значения <literal>archive</literal> и <literal>hot_standby</literal>. Эти значения по-прежнему принимаются, но теперь отображаются в значение <literal>replica</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-fsync" xreflabel="fsync">
      <term><varname>fsync</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>fsync</varname></primary></indexterm></term>
      <listitem>
       <para>Если этот параметр установлен, сервер <productname>&productname;</productname> старается добиться, чтобы изменения были записаны на диск физически, выполняя системные вызовы <function>fsync()</function> или другими подобными методами (см. <xref remap="4" linkend="guc-wal-sync-method"/>). Это даёт гарантию, что кластер баз данных сможет вернуться в согласованное состояние после сбоя оборудования или операционной системы.</para>

       <para>Хотя отключение <varname>fsync</varname> часто даёт выигрыш в скорости, это может привести к неисправимой порче данных в случае отключения питания или сбоя системы. Поэтому отключать <varname>fsync</varname> рекомендуется, только если вы легко сможет восстановить всю базу из внешнего источника.</para>

       <para>В качестве примеров, когда отключение <varname>fsync</varname> неопасно, можно привести начальное наполнение нового кластера данными из копии, обработку массива данных, после которой базу данных можно удалить и создать заново, либо эксплуатацию копии базы данных только для чтения, которая регулярно пересоздаётся и не используется для отработки отказа. Качественное оборудование само по себе не является достаточной причиной для отключения <varname>fsync</varname>.</para>

       <para>При смене значения <varname>fsync</varname> с off на on для надёжного восстановления также необходимо сбросить все изменённые буферы из ядра в надёжное хранилище. Это можно сделать, когда сервер остановлен или когда режим fsync включён, с помощью команды <command>initdb --sync-only</command>, либо выполнить команду <command>sync</command>, размонтировать файловую систему или перезагрузить сервер.</para>

       <para>Во многих случаях отключение <xref linkend="guc-synchronous-commit"/> для некритичных транзакций может дать больший выигрыш в скорости, чем отключение <varname>fsync</varname>, при этом не добавляя риски повреждения данных.</para>

       <para>Параметр <varname>fsync</varname> можно задать только в файле <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Если вы отключаете этот параметр, возможно, имеет смысл отключить также и <xref linkend="guc-full-page-writes"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-synchronous-commit" xreflabel="synchronous_commit">
      <term><varname>synchronous_commit</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>synchronous_commit</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет, будет ли сервер при фиксировании транзакции ждать, пока записи из WAL сохранятся на диске, прежде чем сообщить клиенту об успешном завершении операции. Допустимые значения: <literal>on</literal>, <literal>remote_apply</literal>, <literal>remote_write</literal>, <literal>local</literal> и <literal>off</literal>. Значение по умолчанию (оно же самое безопасное) — <literal>on</literal>. Со значением <literal>off</literal> может образоваться окно от момента, когда клиент узнаёт об успешном завершении, до момента, когда транзакция действительно гарантированно защищена от сбоя. (Максимальный размер окна равен тройному значению <xref linkend="guc-wal-writer-delay"/>.) В отличие от <xref linkend="guc-fsync"/>, значение <literal>off</literal> для этого параметра не угрожает целостности данных: сбой операционной системы или базы данных может привести к потере последних транзакций, считавшихся зафиксированными, но состояние базы данных будет точно таким же, как и в случае штатного прерывания этих транзакций. Поэтому выключение режима <varname>synchronous_commit</varname> может быть полезной альтернативой отключению <xref linkend="guc-fsync"/>, когда производительность важнее, чем надёжная гарантия сохранности каждой транзакции. Подробнее это обсуждается в <xref remap="6" linkend="wal-async-commit"/>.</para>
       <para>Если задано значение <xref linkend="guc-synchronous-standby-names"/>, этот параметр также определяет, будет ли сервер при фиксировании транзакции ждать, пока выполнится репликация соответствующих записей WAL на резервный сервер(ы). Со значением <literal>on</literal> фиксирование завершается только после получения ответов от текущих синхронных резервных серверов, подтверждающих, что они получили запись о фиксировании транзакции и сохранили её на диске. Это гарантирует, что транзакция не будет потеряна, если только база данных не будет повреждена и на главном, и на всех синхронных резервных серверах. Со значением <literal>remote_apply</literal> фиксирование завершается после получения ответов от синхронных резервных серверов, говорящих, что они получили запись о фиксировании транзакции и применили её, так что она стала видна для запросов на этих серверах. Со значением <literal>remote_write</literal> фиксирование завершается после получения ответов от текущих синхронных резервных серверов, говорящих, что они получили запись о фиксировании транзакции и передали её ОС для сохранения на диске. Этот вариант позволяет гарантировать сохранность данных даже в случае отказа резервного сервера <productname>&productname;</productname>, но не в случае сбоя на уровне ОС, так как данные могут ещё не достичь надёжного хранилища на этом сервере. Наконец, со значением <literal>local</literal> фиксирование завершается после локального сброса данных, не дожидаясь репликации. Обычно это нежелательный вариант при синхронной репликации, но он представлен для полноты.</para>
       <para>Если параметр <varname>synchronous_standby_names</varname> пуст, варианты <literal moreinfo="none">on</literal>, <literal moreinfo="none">remote_write</literal> и <literal moreinfo="none">local</literal> реализуют одинаковый уровень синхронизации: при фиксировании транзакции сервер ждёт только сохранения данных на локальный диск.</para>
       <para>Этот параметр можно изменить в любое время; поведение каждой конкретной транзакции определяется значением, действующим в момент её фиксирования. Таким образом, есть возможность и смысл фиксировать некоторые транзакции синхронно, а другие — асинхронно. Например, чтобы зафиксировать одну транзакцию из нескольких команд асинхронно, когда по умолчанию выбран противоположный вариант, выполните в этой транзакции <command>SET LOCAL synchronous_commit TO OFF</command>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-sync-method" xreflabel="wal_sync_method">
      <term><varname>wal_sync_method</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>wal_sync_method</varname></primary></indexterm></term>
      <listitem>
       <para>Метод, применяемый для принудительного сохранения изменений WAL на диске. Если режим <varname>fsync</varname> отключён, данный параметр не действует, так как принудительное сохранение изменений WAL не производится вовсе. Возможные значения этого параметра:</para>
       <itemizedlist>
        <listitem>
        <para><literal>open_datasync</literal> (для сохранения файлов WAL открывать их функцией <function>open()</function> с параметром <symbol>O_DSYNC</symbol>)</para>
        </listitem>
        <listitem>
        <para><literal>fdatasync</literal> (вызывать <function>fdatasync()</function> при каждом фиксировании)</para>
        </listitem>
        <listitem>
        <para><literal>fsync</literal> (вызывать <function>fsync()</function> при каждом фиксировании)</para>
        </listitem>
        <listitem>
        <para><literal>fsync_writethrough</literal> (вызывать <function>fsync()</function> при каждом фиксировании, форсируя сквозную запись кеша)</para>
        </listitem>
        <listitem>
        <para><literal>open_sync</literal> (для сохранения файлов WAL открывать их функцией <function>open()</function> с параметром <symbol>O_SYNC</symbol>)</para>
        </listitem>
       </itemizedlist>
       <para>Варианты <literal>open_</literal>* также применяют флаг <literal>O_DIRECT</literal>, если он доступен. Не все эти методы поддерживается в разных системах. По умолчанию выбирается первый из этих методов, который поддерживается текущей системой, с одним исключением — в Linux по умолчанию выбирается <literal>fdatasync</literal>. Выбираемый по умолчанию вариант не обязательно будет идеальным; в зависимости от требований к отказоустойчивости или производительности может потребоваться скорректировать выбранное значение или внести другие изменения в конфигурацию вашей системы. Соответствующие аспекты конфигурации рассматриваются в <xref remap="6" linkend="wal-reliability"/>. Этот параметр можно задать только в файле <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-full-page-writes" xreflabel="full_page_writes">
      <term><varname>full_page_writes</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>full_page_writes</varname></primary></indexterm></term>
      <listitem>
       <para>Когда этот параметр включён, сервер <productname>&productname;</productname> записывает в WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки. Это необходимо, потому что запись страницы, прерванная при сбое операционной системы, может выполниться частично, и на диске окажется страница, содержащая смесь старых данных с новыми. При этом информации об изменениях на уровне строк, которая обычно сохраняется в WAL, будет недостаточно для получения согласованного содержимого такой страницы при восстановлении после сбоя. Сохранение образа всей страницы гарантирует, что страницу можно восстановить корректно, ценой увеличения объёма данных, которые будут записываться в WAL. (Так как воспроизведение WAL всегда начинается от контрольной точки, достаточно сделать это при первом изменении каждой страницы после контрольной точки. Таким образом, уменьшить затраты на запись полных страниц можно, увеличив интервалы контрольных точек.)</para>

       <para>Отключение этого параметра ускоряет обычные операции, но может привести к неисправимому повреждению или незаметной порче данных после сбоя системы. Так как при этом возникают практически те же риски, что и при отключении <varname>fsync</varname>, хотя и в меньшей степени, отключать его следует только при тех же обстоятельствах, которые перечислялись в рекомендациях для вышеописанного параметра.</para>

       <para>Отключение этого параметра не влияет на возможность применения архивов WAL для восстановления состояния на момент времени (см. <xref remap="4" linkend="continuous-archiving"/>).</para>

       <para>Этот параметр можно задать только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. По умолчанию этот параметр имеет значение <literal>on</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-log-hints" xreflabel="wal_log_hints">
      <term><varname>wal_log_hints</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>wal_log_hints</varname></primary></indexterm></term>
      <listitem>
       <para>Когда этот параметр имеет значение <literal>on</literal>, сервер <productname>&productname;</productname> записывает в WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки, даже при второстепенных изменениях так называемых вспомогательных битов.</para>

       <para>Если включён расчёт контрольных сумм данных, изменения вспомогательных битов всегда проходят через WAL и этот параметр игнорируется. С помощью этого параметра можно проверить, насколько больше дополнительной информации записывалось бы в журнал, если бы для базы данных был включён подсчёт контрольных сумм.</para>

       <para>Этот параметр можно задать только при запуске сервера. По умолчанию он имеет значение <literal>off</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-compression" xreflabel="wal_compression">
      <term><varname>wal_compression</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>wal_compression</varname></primary></indexterm></term>
      <listitem>
       <para>Когда этот параметр имеет значение <literal>on</literal>, сервер <productname>&productname;</productname> сжимает образ полной страницы, записываемый в WAL, когда включён режим <xref linkend="guc-full-page-writes"/> или при создании базовой копии. Сжатый образ страницы будет развёрнут при воспроизведении WAL. Значение по умолчанию — <literal>off</literal>. Изменить этот параметр могут только суперпользователи.</para>

       <para>Этот параметр позволяет без дополнительных рисков повреждения данных уменьшить объём WAL, ценой дополнительной нагрузки на процессор, связанной со сжатием данных при записи в WAL и разворачиванием их при воспроизведении WAL.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-buffers" xreflabel="wal_buffers">
      <term><varname>wal_buffers</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_buffers</varname></primary></indexterm></term>
      <listitem>
       <para>Объём разделяемой памяти, который будет использоваться для буферизации данных WAL, ещё не записанных на диск. Значение по умолчанию, равное -1, задаёт размер, равный 1/32 (около 3%) от <xref linkend="guc-shared-buffers"/>, но не меньше, чем <literal>64 КБ</literal> и не больше, чем размер одного сегмента WAL (обычно <literal>16 МБ</literal>). Это значение можно задать вручную, если выбираемое автоматически слишком мало или велико, но при этом любое положительное число меньше <literal>32 КБ</literal> будет восприниматься как <literal>32 КБ</literal>. Этот параметр можно задать только при запуске сервера.</para>

       <para>Содержимое буферов WAL записывается на диск при фиксировании каждой транзакции, так что очень большие значения вряд ли принесут значительную пользу. Однако значение как минимум в несколько мегабайт может увеличить быстродействие при записи на нагруженном сервере, когда сразу множество клиентов фиксируют транзакции. Автонастройка, действующая при значении по умолчанию (-1), в большинстве случаев выбирает разумные значения.</para>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-writer-delay" xreflabel="wal_writer_delay">
      <term><varname>wal_writer_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_writer_delay</varname></primary></indexterm></term>
      <listitem>
      <para>Определяет, как часто процесс записи WAL будет сбрасывать WAL на диск. После очередного сброса WAL он делает паузу на <varname>wal_writer_delay</varname> миллисекунд, но может быть пробуждён асинхронно фиксируемой транзакцией. Если предыдущая операция сброса имела место в последние <varname>wal_writer_delay</varname> миллисекунд и за это время было получено меньше <varname>wal_writer_flush_after</varname> байт WAL, данные WAL только передаются ОС, но не сбрасываются на диск. Значение по умолчанию — 200 миллисекунд (<literal>200ms</literal>). Заметьте, что во многих системах разрешение таймера паузы составляет 10 мс; если задать в <varname>wal_writer_delay</varname> значение, не кратное 10, может быть получен тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-writer-flush-after" xreflabel="wal_writer_flush_after">
      <term><varname>wal_writer_flush_after</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_writer_flush_after</varname></primary></indexterm></term>
      <listitem>
      <para>Определяет, как часто процесс записи WAL будет сбрасывать WAL на диск. Если предыдущая операция сброса имела место в последние <varname>wal_writer_delay</varname> миллисекунд и за это время было получено меньше <varname>wal_writer_flush_after</varname> байт WAL, данные WAL только передаются операционной системе, но не сбрасываются на диск. Если <varname>wal_writer_flush_after</varname> равен <literal>0</literal>, WAL сбрасывается на диск немедленно. Значение по умолчанию — 1 Мбайт (<literal>1MB</literal>). Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-delay" xreflabel="commit_delay">
      <term><varname>commit_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>commit_delay</varname></primary></indexterm></term>
      <listitem>
       <para>Параметр <varname>commit_delay</varname> добавляет паузу (в микросекундах) перед собственно выполнением сохранения WAL. Эта задержка может увеличить быстродействие при фиксировании множества транзакций, позволяя зафиксировать большее число транзакций за одну операции сохранения WAL, если система нагружена достаточно сильно и за заданное время успевают зафиксироваться другие транзакции. Однако этот параметр также увеличивает задержку максимум до <varname>commit_delay</varname> микросекунд при каждом сохранении WAL. Эта задержка окажется бесполезной, если никакие другие транзакции не будут зафиксированы за это время, поэтому она добавляется, только в если момент запроса сохранения WAL активны как минимум <varname>commit_siblings</varname> других транзакций. Кроме того, эти задержки не добавляются при выключенном <varname>fsync</varname>. По умолчанию значение <varname>commit_delay</varname> равно нулю (задержка отсутствует). Изменить этот параметр могут только суперпользователи.</para>
       <para>В <productname>PostgreSQL</productname> до версии 9.3, параметр <varname>commit_delay</varname> работал по-другому и не так эффективно: он задерживал только фиксирование транзакций, а не все операции сохранения WAL, и заданная пауза выдерживалась полностью, даже если WAL удавалось сохранить быстрее. Начиная с версии 9.3, заданное время ожидает только первый процесс, готовый произвести сохранение, тогда как все последующие процессы ждут только, когда он закончит эту операцию.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-siblings" xreflabel="commit_siblings">
      <term><varname>commit_siblings</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>commit_siblings</varname></primary></indexterm></term>
      <listitem>
       <para>Минимальное число одновременно открытых транзакций, при котором будет добавляться задержка <varname>commit_delay</varname>. Чем больше это значение, тем больше вероятность, что минимум одна транзакция окажется готовой к фиксированию за время задержки. По умолчанию это число равно пяти.</para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-wal-checkpoints">
     <title>Контрольные точки</title>

    <variablelist>
     <varlistentry id="guc-checkpoint-timeout" xreflabel="checkpoint_timeout">
      <term><varname>checkpoint_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>checkpoint_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Максимальное время между автоматическими контрольными точками в WAL (в секундах). Допускаются значения от 30 секунд до одного дня. Значение по умолчанию — пять минут (<literal>5min</literal>). Увеличение этого параметра может привести к увеличению времени, которое потребуется для восстановления после сбоя. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-completion-target" xreflabel="checkpoint_completion_target">
      <term><varname>checkpoint_completion_target</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>checkpoint_completion_target</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт целевое время для завершения процедуры контрольной точки, как коэффициент для общего времени между контрольными точками. По умолчанию это значение равно 0.5. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-flush-after" xreflabel="checkpoint_flush_after">
      <term><varname>checkpoint_flush_after</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>checkpoint_flush_after</varname></primary></indexterm></term>
      <listitem>
       <para>Когда в процессе контрольной точки записывается больше чем <varname>checkpoint_flush_after</varname> байт, сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничивает объём &laquo;грязных&raquo; данных в страничном кеше ядра и уменьшает вероятность затормаживания при выполнении fsync в конце этой контрольной точки или когда ОС сбрасывает данные на диск большими порциями в фоне. Часто это значительно уменьшает задержки транзакций, но бывают ситуации, особенно когда объём рабочей нагрузки больше <xref linkend="guc-shared-buffers"/>, но меньше страничного кеша ОС, когда производительность может упасть. Этот параметр действует не на всех платформах. Он может принимать значение от <literal>0</literal> (при этом управление отложенной записью отключается) до 2 Мбайт (<literal>2MB</literal>). Значение по умолчанию — <literal>256kB</literal> в Linux и <literal>0</literal> в других ОС. (Если <symbol>BLCKSZ</symbol> отличен от 8 Кбайт, значение по умолчанию и максимум корректируются пропорционально). Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-warning" xreflabel="checkpoint_warning">
      <term><varname>checkpoint_warning</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>checkpoint_warning</varname></primary></indexterm></term>
      <listitem>
       <para>Записывать в журнал сервера сообщение в случае, если контрольные точки, вызванные заполнением файлов сегментов, выполняются раньше, чем через заданное число секунд (что говорит о том, что значение <varname>max_wal_size</varname> нужно увеличить). Значение по умолчанию равно 30 секундам (<literal>30s</literal>). При нуле это предупреждение отключается. Если <varname>checkpoint_timeout</varname> меньше, чем <varname>checkpoint_warning</varname>, предупреждения так же не будут выводиться. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-wal-size" xreflabel="max_wal_size">
      <term><varname>max_wal_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_wal_size</varname></primary></indexterm></term>
      <listitem>
       <para>Максимальный размер, до которого может вырастать WAL между автоматическими контрольными точками в WAL. Это мягкий предел; размер WAL может превышать <varname>max_wal_size</varname> при особых обстоятельствах, например, при высокой нагрузке, сбое в <varname>archive_command</varname> или при большом значении <varname>wal_keep_segments</varname>. Значение по умолчанию — 1 ГБ. Увеличение этого параметра может привести к увеличению времени, которое потребуется для восстановления после сбоя. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-min-wal-size" xreflabel="min_wal_size">
      <term><varname>min_wal_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>min_wal_size</varname></primary></indexterm></term>
      <listitem>
       <para>Пока WAL занимает на диске меньше этого объёма, старые файлы WAL в контрольных точках всегда перерабатываются, а не удаляются. Это позволяет зарезервировать достаточно места для WAL, чтобы справиться с резкими скачками использования WAL, например, при выполнении больших пакетных заданий. Значение по умолчанию — 80 МБ. Этот параметр можно установить только в <filename>postgresql.conf</filename> или в командной строке сервера.</para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-wal-archiving">
     <title>Архивация</title>

    <variablelist>
     <varlistentry id="guc-archive-mode" xreflabel="archive_mode">
      <term><varname>archive_mode</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>archive_mode</varname></primary></indexterm></term>
      <listitem>
       <para>Когда параметр <varname>archive_mode</varname> включён, полные сегменты WAL передаются в хранилище архива командой <xref linkend="guc-archive-command"/>. Помимо значения <literal>off</literal> (выключающего архивацию) есть ещё два: <literal>on</literal> (вкл.) и <literal>always</literal> (всегда). В обычном состоянии эти два режима не различаются, но в режиме <literal>always</literal> архивация WAL активна и во время восстановления архива, и в резерве. В этом режиме все файлы, восстановленные из архива или полученные при потоковой репликации, будут архивироваться (снова). За подробностями обратитесь к <xref remap="3" linkend="continuous-archiving-in-standby"/>.</para>
       <para>Параметры <varname>archive_mode</varname> и <varname>archive_command</varname> разделены, чтобы команду архивации (<varname>archive_command</varname>) можно было изменять, не отключая режим архивации. Этот параметр можно задать только при запуске сервера. Режим архивации нельзя включить, когда установлен минимальный уровень WAL (<varname>wal_level</varname> имеет значение <literal>minimal</literal>).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-archive-command" xreflabel="archive_command">
      <term><varname>archive_command</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>archive_command</varname></primary></indexterm></term>
      <listitem>
       <para>Команда локальной оболочки, которая будет выполняться для архивации завершённого сегмента WAL. Любое вхождение <literal>%p</literal> в этой строке заменяется путём архивируемого файла, а вхождение <literal>%f</literal> заменяется только его именем. (Путь задаётся относительно рабочего каталога сервера, то есть каталога данных кластера.) Чтобы вставить в команду символ <literal>%</literal>, его нужно записать как <literal>%%</literal>. Важно, чтобы команда возвращала нулевой код выхода, только если она завершается успешно. За дополнительной информацией обратитесь к <xref remap="3" linkend="backup-archiving-wal"/>.</para>
       <para>Этот параметр можно задать только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Если режим архивации (<varname>archive_mode</varname>) не был включён при запуске, этот параметр игнорируется. Если значение <varname>archive_command</varname> — пустая строка (по умолчанию), но <varname>archive_mode</varname> включён, архивация WAL временно отключается, но сервер продолжает накапливать файлы сегментов WAL в ожидании, что команда будет вскоре определена. Если в качестве <varname>archive_command</varname> задать команду, которая ничего не делает, но сообщает об успешном завершении, например <literal>/bin/true</literal> (или <literal>REM</literal> в Windows), архивация по сути отключается, но при этом нарушается цепочка файлов WAL, необходимых для восстановления архива, поэтому такой вариант следует использовать только в особых случаях.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-archive-timeout" xreflabel="archive_timeout">
      <term><varname>archive_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>archive_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Команда <xref linkend="guc-archive-command"/> вызывается только для завершённых сегментов WAL. Поэтому, если ваш сервер записывает мало данных WAL (или это наблюдается в некоторые периоды времени), от завершения транзакции до надёжного сохранения её в архивном хранилище может пройти довольно много времени. Для ограничения времени существования неархивированных данных можно установить значение <varname>archive_timeout</varname>, чтобы сервер периодически переключался на новый файл сегмента WAL. Когда этот параметр больше нуля, сервер будет переключаться на новый файл сегмента, если с момента последнего переключения на новый файл пройдёт заданное число секунд, и наблюдалась какая-то активность базы данных, даже если это была просто контрольная точка. (Для сокращения числа ненужных контрольных точек в простаивающей системе можно увеличить <varname>checkpoint_timeout</varname>.) Заметьте, что архивируемые файлы, закрываемые раньше из-за принудительного переключения, всё равно будут иметь тот же размер, что и полностью заполненные. Поэтому устанавливать для <varname>archive_timeout</varname> очень маленькое значение неразумно &mdash; это ведёт к замусориванию архивного хранилища. Обычно для <varname>archive_timeout</varname> имеет смысл задавать значение около минуты. Если вам нужно, чтобы данные копировались с главного сервера на резервный, вам следует подумать о переходе от архивации к потоковой репликации. Этот параметр можно задать только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

   </sect1>

   <sect1 id="runtime-config-replication">
    <title>Репликация</title>

    <para>Эти параметры управляют поведением встроенного механизма <firstterm>потоковой репликации</firstterm> (см. <xref remap="4" linkend="streaming-replication"/>). Когда он применяется, один сервер является главным, а другие — резервными. Главный сервер всегда передаёт данные, а резервные всегда принимают данные репликации, но когда настроена каскадная репликация (см. <xref remap="4" linkend="cascading-replication"/>), резервные серверы также могут быть и передающими. Следующие параметры в основном относятся к передающим и резервным серверам, хотя некоторые параметры имеют смысл только для главного. Все эти параметры вполне могут быть разными в рамках одного кластера, если это требуется.</para>

    <sect2 id="runtime-config-replication-sender">
     <title>Передающие серверы</title>

     <para>Эти параметры можно задать на любом сервере, который передаёт данные репликации одному или нескольким резервным. Главный сервер всегда является передающим, так что на нём они должны задаваться всегда. Роль и значение этих параметров не меняются после того, как резервный сервер становится главным.</para>

     <variablelist>
      <varlistentry id="guc-max-wal-senders" xreflabel="max_wal_senders">
       <term><varname>max_wal_senders</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_wal_senders</varname></primary></indexterm></term>
       <listitem>
       <para>Задаёт максимально допустимое число одновременных подключений резервных серверов или клиентов потокового копирования (т. е. максимальное количество одновременно работающих процессов передачи WAL). По умолчанию это значение равно нулю, то есть репликация отключается. Передающие WAL процессы учитываются в общем числе соединений, так что этот параметр не может превышать <xref linkend="guc-max-connections"/>. В случае неожиданного отключения клиента потоковой передачи слот подключения может оставаться занятым до достижения тайм-аута, так что этот параметр должен быть немного больше максимального ожидаемого числа клиентов, чтобы отключившиеся клиенты могли переподключиться немедленно. Задать этот параметр можно только при запуске сервера. Чтобы к данному серверу могли подключаться резервные, уровень <varname>wal_level</varname> должен быть <literal>replica</literal> или выше.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-replication-slots" xreflabel="max_replication_slots">
       <term><varname>max_replication_slots</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_replication_slots</varname></primary></indexterm></term>
       <listitem>
        <para>Задаёт максимальное число слотов репликации (см. <xref remap="4" linkend="streaming-replication-slots"/>), которое сможет поддерживать сервер. Значение по умолчанию — ноль. Этот параметр можно задать только при запуске сервера. Чтобы эти слоты репликации можно было использовать, уровень <varname>wal_level</varname> должен быть <literal>replica</literal> или выше. Если заданное значение данного параметра будет меньше, чем число уже существующих слотов репликации, сервер не запустится.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-wal-keep-segments" xreflabel="wal_keep_segments">
       <term><varname>wal_keep_segments</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_keep_segments</varname></primary></indexterm></term>
       <listitem>
       <para>Задаёт минимальное число файлов прошлых сегментов журнала, которые будут сохраняться в каталоге <filename>pg_xlog</filename>, чтобы резервный сервер мог выбрать их при потоковой репликации. Обычно сегмент имеет размер 16 мегабайт. Если резервный сервер, подключённый к передающему, отстаёт больше чем на <varname>wal_keep_segments</varname> сегментов, передающий удаляет сегменты WAL, всё ещё необходимые резервному, и в этом случае соединение репликации прерывается. В результате этого затем также будут прерваны зависимые соединения. (Однако резервный сервер сможет восстановиться, выбрав этот сегмент из архива, если осуществляется архивация WAL.)</para>

       <para>Этот параметр задаёт только минимальное число сегментов, сохраняемое в каталоге <filename>pg_xlog</filename>; система может сохранить больше сегментов для архивации WAL или для восстановления с момента контрольной точки. Если <varname>wal_keep_segments</varname> равен нулю (это значение по умолчанию), система не сохраняет никакие дополнительные сегменты для резервных серверов, поэтому число старых сегментов WAL, доступных для резервных серверов, зависит от положения предыдущей контрольной точи и состояния архивации WAL. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       </listitem>
      </varlistentry>

     <varlistentry id="guc-wal-sender-timeout" xreflabel="wal_sender_timeout">
      <term><varname>wal_sender_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_sender_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт период времени (в миллисекундах), по истечении которого прерываются неактивные соединения репликации. Это помогает передающему серверу обнаружить сбой резервного или разрывы в сети. При значении, равном нулю, тайм-аут отключается. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Значение по умолчанию — 60 секунд.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-commit-timestamp" xreflabel="track_commit_timestamp">
      <term><varname>track_commit_timestamp</varname> (<type>bool</type>) <indexterm><primary>параметр конфигурации <varname>track_commit_timestamp</varname></primary></indexterm></term>
      <listitem>
       <para>Включает запись времени фиксации транзакций. Этот параметр можно задать только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. По умолчанию этот параметр имеет значение <literal>off</literal>.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-replication-master">
     <title>Главный сервер</title>

     <para>Эти параметры можно задать на главном/ведущем сервере, который должен передавать данные репликации одному или нескольким резервным. Заметьте, что помимо этих параметров на главном сервере должен быть правильно установлен <xref linkend="guc-wal-level"/>, а также может быть включена архивация WAL (см. <xref remap="4" linkend="runtime-config-wal-archiving"/>). Значения этих параметров на резервных серверах не важны, хотя их можно подготовить заранее, на случай, если резервный сервер придётся сделать главным.</para>

    <variablelist>

     <varlistentry id="guc-synchronous-standby-names" xreflabel="synchronous_standby_names">
      <term><varname>synchronous_standby_names</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>synchronous_standby_names</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет список резервных серверов, которые могут поддерживать <firstterm>синхронную репликацию</firstterm>, как описано в <xref remap="6" linkend="synchronous-replication"/>. Активных синхронных резервных серверов может быть один или несколько; транзакции, ожидающие фиксирования, будут завершаться только после того, как эти резервные серверы подтвердят получение их данных. Синхронными резервными серверами будут те, имена которых указаны в начале этого списка, и которые подключены к главному и принимают поток данных в реальном времени (что показывает признак <literal>streaming</literal> в представлении <link linkend="monitoring-stats-views-table"><literal>pg_stat_replication</literal></link>). Следующие резервные серверы в этом списке являются потенциальными синхронными серверами. Если любой из текущих синхронных резервных серверов отключается по какой-либо причине, он немедленно заменяется другим, следующим по приоритету. Таким образом, указание нескольких имён резервных серверов позволяет обеспечить очень высокую степень доступности.</para>
       <para>Этот параметр принимает список резервных серверов в одной из следующих форм: <synopsis>
<replaceable class="parameter">число_синхронных</replaceable> ( <replaceable class="parameter">имя_резерва</replaceable> [, ...] )
<replaceable class="parameter">имя_резерва</replaceable> [, ...]
</synopsis> здесь <replaceable class="parameter">число_синхронных</replaceable> — число синхронных резервных серверов, от которых необходимо дожидаться ответов для завершения транзакций, а <replaceable class="parameter">имя_резерва</replaceable> — имя резервного сервера. Например, со значением <literal>3 (s1, s2, s3, s4)</literal> фиксирование транзакций будет завершаться только после получения записей WAL тремя выбранными по приоритету резервными серверами из списка <literal>s1</literal>, <literal>s2</literal>, <literal>s3</literal> и <literal>s4</literal>.</para>
        <para>Вторая форма использовалась в <productname>&productname;</productname> до версии 9.6 и по-прежнему поддерживается. По сути она равнозначна первой с <replaceable class="parameter">числом_синхронных</replaceable>, равным 1. Например, <literal>1 (s1, s2)</literal> и <literal>s1, s2</literal> действуют одинаково: в качестве синхронного резерва выбирается либо <literal>s1</literal>, либо <literal>s2</literal>.</para>
       <para>В качестве имени резервного сервера в данном случае указывается значение параметра <varname>application_name</varname>, задаваемое в строке подключения <varname>primary_conninfo</varname> на резервном сервере, принимающем WAL. Уникальность этих имён не контролируется. В случае дублирования имён более приоритетным синхронным резервным сервером будет считаться один, хотя какой именно, не определено. Специальному указанию <literal>*</literal> соответствует любое имя приложения (<varname>application_name</varname>), включая имя приложения по умолчанию (<literal>walreceiver</literal>).</para>
       <note>
        <para>Каждое <replaceable class="parameter">имя_резерва</replaceable> должно задаваться в виде допустимого идентификатора SQL, кроме <literal>*</literal>. При необходимости его можно заключать в кавычки. Но заметьте, что идентификаторы <replaceable class="parameter">имя_резерва</replaceable> сравниваются с именами приложений без учёта регистра, независимо от того, заключены ли они в кавычки или нет.</para>
       </note>
       <para>Если имена синхронных резервных серверов не определены, синхронная репликация не включается и фиксируемые транзакции не будут ждать репликации. Это поведение по умолчанию. Даже когда синхронная репликация включена, для отдельных транзакций можно отключить ожидание репликации, задав для параметра <xref linkend="guc-synchronous-commit"/> значение <literal>local</literal> или <literal>off</literal>.</para>
       <para>Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-defer-cleanup-age" xreflabel="vacuum_defer_cleanup_age">
      <term><varname>vacuum_defer_cleanup_age</varname> (<type>integer 64</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_defer_cleanup_age</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт число транзакций, на которое будет отложена очистка старых версий строк при <command>VACUUM</command> и изменениях <acronym>HOT</acronym>. По умолчанию это число равно нулю, то есть старые версии строк могут удаляться сразу, как только перестанут быть видимыми в открытых транзакциях. Это значение можно сделать ненулевым на главном сервере, работающим с серверами горячего резерва, как описано в <xref remap="6" linkend="hot-standby"/>. В результате увеличится время, в течение которого будут успешно выполняться запросы на резервном сервере без конфликтов из-за ранней очистки строк. Однако ввиду того, что эта отсрочка определяется числом записывающих транзакций, выполняющихся на главном сервере, сложно предсказать, каким будет дополнительное время отсрочки на резервном сервере. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       <para>В качестве альтернативы этому параметру можно также рассмотреть <varname>hot_standby_feedback</varname> на резервном сервере.</para>
       <para>Этот параметр не предотвращает очистку старых строк, которые достигли возраста, заданного параметром <varname>old_snapshot_threshold</varname>.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-replication-standby">
     <title>Резервные серверы</title>

     <para>Эти параметры управляют поведением резервного сервера, который будет получать данные репликации. На главном сервере они не играют никакой роли.</para>

    <variablelist>

     <varlistentry id="guc-hot-standby" xreflabel="hot_standby">
      <term><varname>hot_standby</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>hot_standby</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет, можно ли будет подключаться к серверу и выполнять запросы в процессе восстановления, как описано в <xref remap="6" linkend="hot-standby"/>. Значение по умолчанию — <literal>off</literal> (подключения не разрешаются). Задать этот параметр можно только при запуске сервера. Данный параметр играет роль только в режиме резервного сервера или при восстановлении архива.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-standby-archive-delay" xreflabel="max_standby_archive_delay">
      <term><varname>max_standby_archive_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_standby_archive_delay</varname></primary></indexterm></term>
      <listitem>
       <para>В режиме горячего резерва этот параметр определяет, как долго должен ждать резервный сервер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как описано в <xref remap="6" linkend="hot-standby-conflict"/>. Задержка <varname>max_standby_archive_delay</varname> применяется при обработке данных WAL, считываемых из архива (не текущих данных). Значение этого параметра задаётся в миллисекундах (если явно не указаны другие единицы) и по умолчанию равно 30 секундам. При значении, равном -1, резервный сервер может ждать завершения конфликтующих запросов неограниченное время. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       <para>Заметьте, что параметр <varname>max_standby_archive_delay</varname> определяет не максимальное время, которое отводится для выполнения каждого запроса, а максимальное общее время, за которое должны быть применены изменения из одного сегмента WAL. Таким образом, если один запрос привёл к значительной задержке при обработке сегмента WAL, остальным конфликтующим запросам будет отведено гораздо меньше времени.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-standby-streaming-delay" xreflabel="max_standby_streaming_delay">
      <term><varname>max_standby_streaming_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_standby_streaming_delay</varname></primary></indexterm></term>
      <listitem>
       <para>В режиме горячего резерва этот параметр определяет, как долго должен ждать резервный сервер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как описано в <xref remap="6" linkend="hot-standby-conflict"/>. Задержка <varname>max_standby_streaming_delay</varname> применяется при обработке данных WAL, поступающих при потоковой репликации. Значение этого параметра задаётся в миллисекундах (если явно не указаны другие единицы) и по умолчанию равно 30 секундам. При значении, равном -1, резервный сервер может ждать завершения конфликтующих запросов неограниченное время. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       <para>Заметьте, что параметр <varname>max_standby_streaming_delay</varname> определяет не максимальное время, которое отводится для выполнения каждого запроса, а максимальное общее время, за которое должны быть применены изменения из WAL после получения от главного сервера. Таким образом, если один запрос привёл к значительной задержке, остальным конфликтующим запросам будет отводиться гораздо меньше времени, пока резервный сервер не догонит главный.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-receiver-status-interval" xreflabel="wal_receiver_status_interval">
      <term><varname>wal_receiver_status_interval</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_receiver_status_interval</varname></primary></indexterm></term>
      <listitem>
      <para>Определяет минимальную частоту, с которой процесс, принимающий WAL на резервном сервере, будет сообщать о состоянии репликации ведущему или вышестоящему резервному, где это состояние можно наблюдать в представлении <link linkend="monitoring-stats-views-table"><literal>pg_stat_replication</literal></link>. В этом сообщении передаются следующие позиции в журнале транзакций: позиция изменений записанных, изменений, сохранённых на диске, и изменений применённых. Значение параметра задаётся в секундах и определяет максимальный интервал между сообщениями. Сообщения о состоянии передаются при каждом продвижении позиций записанных или сохранённых на диске изменений, но с промежутком не больше, чем заданный этим параметром. Таким образом, последняя переданная позиция применённых изменений может немного отставать от фактической в текущий момент. При нулевом значении этого параметра передача состояния полностью отключается. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. По умолчанию его значение равно 10 секундам.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hot-standby-feedback" xreflabel="hot_standby_feedback">
      <term><varname>hot_standby_feedback</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>hot_standby_feedback</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет, будет ли сервер горячего резерва сообщать ведущему или вышестоящему резервному о запросах, которые он выполняет в данный момент. Это позволяет исключить необходимость отмены запросов, вызванную очисткой записей, но при некоторых типах нагрузки это может приводить к раздуванию базы данных на ведущем сервере. Эти сообщения о запросах будут отправляться не чаще, чем раз в интервал, задаваемый параметром <varname>wal_receiver_status_interval</varname>. Значение данного параметра по умолчанию — <literal>off</literal>. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       <para>Если используется каскадная репликация, сообщения о запросах передаются выше, пока в итоге не достигнут ведущего сервера. На промежуточных серверах эта информация больше никак не задействуется.</para>
       <para>Этот параметр не переопределяет поведение <varname>old_snapshot_threshold</varname>, установленное на ведущем сервере; снимок на резервном сервере, имеющий возраст больше заданного указанным параметром на ведущем, может стать недействительным, что приведёт к отмене транзакций на резервном. Это объясняется тем, что предназначение <varname>old_snapshot_threshold</varname> заключается в указании абсолютного ограничения времени, в течение которого могут накапливаться мёртвые строки, которое иначе могло бы нарушаться из-за конфигурации резервного сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-receiver-timeout" xreflabel="wal_receiver_timeout">
      <term><varname>wal_receiver_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_receiver_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт период времени (в миллисекундах), по истечении которого прерываются неактивные соединения репликации. Это помогает принимающему резервному серверу обнаружить сбой ведущего узла или разрыв сети. При значении, равном нулю, тайм-аут отключается. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Значение по умолчанию — 60 секунд.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-retrieve-retry-interval" xreflabel="wal_retrieve_retry_interval">
      <term><varname>wal_retrieve_retry_interval</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_retrieve_retry_interval</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет, сколько резервный сервер должен ждать поступления данных WAL из любых источников (потоковая репликация, локальный <filename>pg_xlog</filename> или архив WAL), прежде чем повторять попытку получения WAL. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке сервера. Значение по умолчанию — 5 секунд. Если единицы не задаются, подразумеваются миллисекунды.</para>
       <para>Этот параметр полезен в конфигурациях, когда для узла в схеме восстановления нужно регулировать время ожидания новых данных WAL. Например, при восстановлении архива можно ускорить реакцию на появление нового файла WAL, уменьшив значение этого параметра. В системе с низкой активностью WAL увеличение этого параметра приведёт к сокращению числа запросов, необходимых для отслеживания архивов WAL, что может быть полезно в облачных окружениях, где учитывается число обращений к инфраструктуре.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-query">
    <title>Планирование запросов</title>

    <sect2 id="runtime-config-query-enable">
     <title>Конфигурация методов планировщика</title>

      <para>Эти параметры конфигурации дают возможность грубо влиять на планы, выбираемые оптимизатором запросов. Если автоматически выбранный оптимизатором план конкретного запроса оказался неоптимальным, в качестве <emphasis>временного</emphasis> решения можно воспользоваться одним из этих параметров и вынудить планировщик выбрать другой план. Улучшить качество планов, выбираемых планировщиком, можно и более подходящими способами, в частности, скорректировать константы стоимости (см. <xref remap="4" linkend="runtime-config-query-constants"/>), выполнить <xref linkend="sql-analyze"/> вручную, изменить значение параметра конфигурации <xref linkend="guc-default-statistics-target"/> и увеличить объём статистики, собираемой для отдельных столбцов, воспользовавшись командой <command>ALTER TABLE SET STATISTICS</command>.</para>

     <variablelist>
     <varlistentry id="guc-enable-bitmapscan" xreflabel="enable_bitmapscan">
      <term><varname>enable_bitmapscan</varname> (<type>boolean</type>) <indexterm><primary>сканирование по битовой карте</primary></indexterm> <indexterm><primary>параметр конфигурации <varname>enable_bitmapscan</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планов сканирования по битовой карте. По умолчанию имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-hashagg" xreflabel="enable_hashagg">
      <term><varname>enable_hashagg</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_hashagg</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планов агрегирования по хешу. По умолчанию имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-hashjoin" xreflabel="enable_hashjoin">
      <term><varname>enable_hashjoin</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_hashjoin</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планов соединения по хешу. По умолчанию имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-indexscan" xreflabel="enable_indexscan">
      <term><varname>enable_indexscan</varname> (<type>boolean</type>) <indexterm><primary>сканирование по индексу</primary></indexterm> <indexterm><primary>параметр конфигурации <varname>enable_indexscan</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планов сканирования по индексу. По умолчанию имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-indexonlyscan" xreflabel="enable_indexonlyscan">
      <term><varname>enable_indexonlyscan</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_indexonlyscan</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планов сканирования только индекса (см. <xref remap="4" linkend="indexes-index-only-scans"/>). По умолчанию имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-material" xreflabel="enable_material">
      <term><varname>enable_material</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_material</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование материализации при планировании запросов. Полностью исключить материализацию невозможно, но при выключении этого параметра планировщик не будет вставлять узлы материализации, за исключением случаев, где они требуются для правильности. По умолчанию этот параметр имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-mergejoin" xreflabel="enable_mergejoin">
      <term><varname>enable_mergejoin</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_mergejoin</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планов соединения слиянием. По умолчанию имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-nestloop" xreflabel="enable_nestloop">
      <term><varname>enable_nestloop</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_nestloop</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планировщиком планов соединения с вложенными циклами. Полностью исключить вложенные циклы невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <literal>on</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-seqscan" xreflabel="enable_seqscan">
      <term><varname>enable_seqscan</varname> (<type>boolean</type>) <indexterm><primary>последовательное сканирование</primary></indexterm> <indexterm><primary>параметр конфигурации <varname>enable_seqscan</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планировщиком планов последовательного сканирования. Полностью исключить последовательное сканирование невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <literal>on</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-sort" xreflabel="enable_sort">
      <term><varname>enable_sort</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_sort</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планировщиком шагов с явной сортировкой. Полностью исключить явную сортировку невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <literal>on</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-tidscan" xreflabel="enable_tidscan">
      <term><varname>enable_tidscan</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>enable_tidscan</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает использование планов сканирования <acronym>TID</acronym>. По умолчанию имеет значение <literal>on</literal> (вкл.).</para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-query-constants">
     <title>Константы стоимости для планировщика</title>

    <para>Переменные <firstterm>стоимости</firstterm>, описанные в данном разделе, задаются по произвольной шкале. Значение имеют только их отношения, поэтому умножение или деление всех переменных на один коэффициент никак не повлияет на выбор планировщика. По умолчанию эти переменные определяются относительно стоимости чтения последовательной страницы: то есть, переменную <varname>seq_page_cost</varname> удобно задать равной <literal>1.0</literal>, а все другие переменные стоимости определить относительно неё. Но при желании можно использовать и другую шкалу, например, выразить в миллисекундах фактическое время выполнения запросов на конкретной машине.</para>

   <note>
    <para>К сожалению, какого-либо чётко определённого способа определения идеальных значений стоимости не существует. Лучше всего выбирать их как средние показатели при выполнении целого ряда разнообразных запросов, которые будет обрабатывать конкретная СУБД. Это значит, что менять их по результатам всего нескольких экспериментов очень рискованно.</para>
   </note>

     <variablelist>

     <varlistentry id="guc-seq-page-cost" xreflabel="seq_page_cost">
      <term><varname>seq_page_cost</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>seq_page_cost</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт приблизительную стоимость чтения одной страницы с диска, которое выполняется в серии последовательных чтений. Значение по умолчанию равно 1.0. Это значение можно переопределить для таблиц и индексов в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <xref remap="4" linkend="sql-altertablespace"/>).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-random-page-cost" xreflabel="random_page_cost">
      <term><varname>random_page_cost</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>random_page_cost</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт приблизительную стоимость чтения одной произвольной страницы с диска. Значение по умолчанию равно 4.0. Это значение можно переопределить для таблиц и индексов в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <xref remap="4" linkend="sql-altertablespace"/>).</para>

       <para>При уменьшении этого значения по отношению к <varname>seq_page_cost</varname> система начинает предпочитать сканирование по индексу; при увеличении такое сканирование становится более дорогостоящим. Оба эти значения также можно увеличить или уменьшить одновременно, чтобы изменить стоимость операций ввода/вывода по отношению к стоимости процессорных операций, которая определяется следующими параметрами.</para>

       <para>Произвольный доступ к механическому дисковому хранилищу обычно гораздо дороже последовательного доступа, более чем в четыре раза. Однако по умолчанию выбран небольшой коэффициент (4.0), в предположении, что большой объём данных при произвольном доступе, например, при чтении индекса, окажется в кеше. Таким образом, можно считать, что значение по умолчанию моделирует ситуацию, когда произвольный доступ в 40 раз медленнее последовательного, но 90% операций произвольного чтения удовлетворяются из кеша.</para>

       <para>Если вы считаете, что для вашей рабочей нагрузки процент попаданий не достигает 90%, вы можете увеличить параметр random_page_cost, чтобы он больше соответствовал реальной стоимости произвольного чтения. И напротив, если ваши данные могут полностью поместиться в кеше, например, когда размер базы меньше общего объёма памяти сервера, может иметь смысл уменьшить random_page_cost. С хранилищем, у которого стоимость произвольного чтения не намного выше последовательного, как например, у твердотельных накопителей, так же лучше выбрать меньшее значение random_page_cost.</para>

       <tip>
        <para>Хотя система позволяет сделать <varname>random_page_cost</varname> меньше, чем <varname>seq_page_cost</varname>, это лишено физического смысла. Однако сделать их равными имеет смысл, если база данных полностью кешируется в ОЗУ, так как в этом случае с обращением к страницам в произвольном порядке не связаны никакие дополнительные издержки. Кроме того, для сильно загруженной базы данных оба этих параметра следует понизить по отношению к стоимости процессорных операций, так как стоимость выборки страницы, уже находящейся в ОЗУ, оказывается намного меньше, чем обычно.</para>
       </tip>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-tuple-cost" xreflabel="cpu_tuple_cost">
      <term><varname>cpu_tuple_cost</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>cpu_tuple_cost</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт приблизительную стоимость обработки каждой строки при выполнении запроса. Значение по умолчанию — 0.01.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-index-tuple-cost" xreflabel="cpu_index_tuple_cost">
      <term><varname>cpu_index_tuple_cost</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>cpu_index_tuple_cost</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт приблизительную стоимость обработки каждой записи индекса при сканировании индекса. Значение по умолчанию — 0.005.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-operator-cost" xreflabel="cpu_operator_cost">
      <term><varname>cpu_operator_cost</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>cpu_operator_cost</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт приблизительную стоимость обработки оператора или функции при выполнении запроса. Значение по умолчанию — 0.0025.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-parallel-setup-cost" xreflabel="parallel_setup_cost">
      <term><varname>parallel_setup_cost</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>parallel_setup_cost</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт приблизительную стоимость запуска параллельных рабочих процессов. Значение по умолчанию — 1000.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-parallel-tuple-cost" xreflabel="parallel_tuple_cost">
      <term><varname>parallel_tuple_cost</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>parallel_tuple_cost</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт приблизительную стоимость передачи одного кортежа от параллельного рабочего процесса другому процессу. Значение по умолчанию — 0.01.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-min-parallel-relation-size" xreflabel="min_parallel_relation_size">
      <term><varname>min_parallel_relation_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>min_parallel_relation_size</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт минимальный размер отношения, при котором возможно распараллеливание сканирования. Значение по умолчанию — 8 мегабайт (<literal>8MB</literal>).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-effective-cache-size" xreflabel="effective_cache_size">
      <term><varname>effective_cache_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>effective_cache_size</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет представление планировщика об эффективном размере дискового кеша, доступном для одного запроса. Это представление влияет на оценку стоимости использования индекса; чем выше это значение, тем больше вероятность, что будет применяться сканирование по индексу, чем ниже, тем более вероятно, что будет выбрано последовательное сканирование. При установке этого параметра следует учитывать и объём разделяемых буферов <productname>&productname;</productname>, и процент дискового кеша ядра, который будут занимать файлы данных <productname>&productname;</productname>. Кроме того, следует принять во внимание ожидаемое число параллельных запросов к разным таблицам, так как общий размер будет разделяться между ними. Этот параметр не влияет на размер разделяемой памяти, выделяемой <productname>&productname;</productname>, или размер резервируемого кеша ядра; он используется только для целей оценки стоимости. При этом система не учитывает, что данные могут оставаться в дисковом кеше от запроса к запросу. Значение этого параметра по умолчанию — 4 гигабайта (<literal>4GB</literal>).</para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>
     <sect2 id="runtime-config-query-geqo">
     <title>Генетический оптимизатор запросов</title>

     <para>Генетический оптимизатор запросов (GEnetic Query Optimizer, GEQO) осуществляет планирование запросов, применяя эвристический поиск. Это позволяет сократить время планирования для сложных запросов (в которых соединяются множество отношений), ценой того, что иногда полученные планы уступают по качеству планам, выбираемым при полном переборе. За дополнительными сведениями обратитесь к <xref remap="3" linkend="geqo"/>.</para>

     <variablelist>

     <varlistentry id="guc-geqo" xreflabel="geqo">
      <term><varname>geqo</varname> (<type>boolean</type>) <indexterm><primary>генетическая оптимизация запросов</primary></indexterm> <indexterm><primary>GEQO</primary> <see>генетическая оптимизация запросов</see></indexterm> <indexterm><primary>параметр конфигурации <varname>geqo</varname></primary></indexterm></term>
      <listitem>
       <para>Включает или отключает генетическую оптимизацию запросов. По умолчанию она включена. В производственной среде её лучше не отключать; более гибко управлять GEQO можно с помощью переменной <varname>geqo_threshold</varname>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-threshold" xreflabel="geqo_threshold">
      <term><varname>geqo_threshold</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>geqo_threshold</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт минимальное число элементов во <literal>FROM</literal>, при котором для планирования запроса будет привлечён генетический оптимизатор. (Заметьте, что конструкция <literal>FULL OUTER JOIN</literal> считается одним элементом списка <literal>FROM</literal>.) Значение по умолчанию — 12. Для более простых запросов часто лучше использовать обычный планировщик, производящий полный перебор, но для запросов со множеством таблиц полный перебор займёт слишком много времени, чаще гораздо больше, чем будет потеряно из-за выбора не самого эффективного плана. Таким образом, ограничение по размеру запроса даёт удобную возможность управлять GEQO.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-effort" xreflabel="geqo_effort">
      <term><varname>geqo_effort</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>geqo_effort</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет выбором между сокращением временем планирования и повышением качества плана запроса в GEQO. Это значение должна задаваться целым числом от 1 до 10. Значение по умолчанию равно пяти. Чем больше значение этого параметра, тем больше времени будет потрачено на планирование запроса, но и тем больше вероятность, что будет выбран эффективный план.</para>

       <para>Параметр <varname>geqo_effort</varname> сам по себе ничего не делает, он используется только для вычисления значений по умолчанию для других переменных, влияющих на поведение GEQO (они описаны ниже). При желании эти переменные можно просто установить вручную.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-pool-size" xreflabel="geqo_pool_size">
      <term><varname>geqo_pool_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>geqo_pool_size</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт размер пула для алгоритма GEQO, то есть число особей в генетической популяции. Это число должно быть не меньше двух, но полезные значения обычно лежат в интервале от 100 до 1000. Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается, исходя из значения <varname>geqo_effort</varname> и числа таблиц в запросе.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-generations" xreflabel="geqo_generations">
      <term><varname>geqo_generations</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>geqo_generations</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт число поколений для GEQO, то есть число итераций этого алгоритма. Оно должно быть не меньше единицы, но полезные значения находятся в том же диапазоне, что и размер пула. Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается, исходя из <varname>geqo_pool_size</varname>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-selection-bias" xreflabel="geqo_selection_bias">
      <term><varname>geqo_selection_bias</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>geqo_selection_bias</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт интенсивность селекции для GEQO, то есть селективное давление в популяции. Допустимые значения лежат в диапазоне от 1.50 до 2.00 (это значение по умолчанию).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-seed" xreflabel="geqo_seed">
      <term><varname>geqo_seed</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>geqo_seed</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт начальное значение для генератора случайных чисел, который применяется в GEQO для выбора случайных путей в пространстве поиска порядка соединений. Может иметь значение от нуля (по умолчанию) до одного. При изменении этого значения меняется набор анализируемых путей, в результате чего может быть найден как более, так и менее оптимальный путь.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-query-other">
     <title>Другие параметры планировщика</title>

     <variablelist>

     <varlistentry id="guc-default-statistics-target" xreflabel="default_statistics_target">
      <term><varname>default_statistics_target</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>default_statistics_target</varname></primary></indexterm></term>
      <listitem>
       <para>Устанавливает целевое ограничение статистики по умолчанию, распространяющееся на столбцы, для которых командой <command>ALTER TABLE SET STATISTICS</command> не заданы отдельные ограничения. Чем больше установленное значение, тем больше времени требуется для выполнения <command>ANALYZE</command>, но тем выше может быть качество оценок планировщика. Значение этого параметра по умолчанию &mdash; 100. За дополнительными сведениями об использовании статистики планировщиком запросов <productname>&productname;</productname> обратитесь к <xref remap="3" linkend="planner-stats"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-constraint-exclusion" xreflabel="constraint_exclusion">
      <term><varname>constraint_exclusion</varname> (<type>enum</type>) <indexterm><primary>исключение по ограничению</primary></indexterm> <indexterm><primary>параметр конфигурации <varname>constraint_exclusion</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет использованием ограничений таблиц для оптимизации запросов. Допустимые значения <varname>constraint_exclusion</varname>: <literal>on</literal> (задействовать ограничения всех таблиц), <literal>off</literal> (никогда не задействовать ограничения) и <literal>partition</literal> (задействовать ограничения только для дочерних таблиц и подзапросов <literal>UNION ALL</literal>). Значение по умолчанию — <literal>partition</literal>. Оно часто помогает увеличить производительность, когда применяются секционированные таблицы и наследование.</para>

       <para>Когда данный параметр разрешает это для таблицы, планировщик сравнивает условия запроса с ограничениями <literal>CHECK</literal> данной таблицы и не сканирует её, если они оказываются несовместимыми. Например: <programlisting>CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;</programlisting> Если включено исключение по ограничению, команда <command>SELECT</command> не будет сканировать таблицу <structname>child1000</structname>, в результате чего запрос выполнится быстрее.</para>

       <para>В настоящее время исключение по ограничению разрешено по умолчанию только в условиях, возникающих при реализации секционированных таблиц. Включение этой возможности для всех таблиц влечёт дополнительные издержки на планирование, довольно заметные для простых запросов, но никакого выигрыша это не приносит. Если вы не применяете секционированные таблицы, лучше всего полностью отключить эту возможность.</para>

       <para>За дополнительными сведениями об исключении по ограничению и секционировании таблиц обратитесь к <xref remap="3" linkend="ddl-partitioning-constraint-exclusion"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cursor-tuple-fraction" xreflabel="cursor_tuple_fraction">
      <term><varname>cursor_tuple_fraction</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>cursor_tuple_fraction</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт для планировщика оценку процента строк, которые будут получены через курсор. Значение по умолчанию — 0.1 (10%). При меньших значениях планировщик будет склонен использовать для курсоров планы с <quote>быстрым стартом</quote>, позволяющие получать первые несколько строк очень быстро, хотя для выборки всех строк может уйти больше времени. При больших значениях планировщик стремится оптимизировать общее время запроса. При максимальном значении, равном 1.0, работа с курсорами планируется так же, как и обычные запросы — минимизируется только общее время, а не время получения первых строк.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-from-collapse-limit" xreflabel="from_collapse_limit">
      <term><varname>from_collapse_limit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>from_collapse_limit</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальное число элементов в списке <literal>FROM</literal>, до которого планировщик будет объединять вложенные запросы с внешним запросом. При меньших значениях сокращается время планирования, но план запроса может стать менее эффективным. По умолчанию это значение равно восьми. За дополнительными сведениями обратитесь к <xref remap="3" linkend="explicit-joins"/>.</para>

       <para>Если это значение сделать равным <xref linkend="guc-geqo-threshold"/> или больше, при таком объединении запросов может включиться планировщик GEQO и в результате будет получен неоптимальный план. См. <xref remap="4" linkend="runtime-config-query-geqo"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-join-collapse-limit" xreflabel="join_collapse_limit">
      <term><varname>join_collapse_limit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>join_collapse_limit</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальное количество элементов в списке <literal>FROM</literal>, до достижения которого планировщик будет сносить в него явные конструкции <literal>JOIN</literal> (за исключением <literal>FULL JOIN</literal>). При меньших значениях сокращается время планирования, но план запроса может стать менее эффективным.</para>

       <para>По умолчанию эта переменная имеет то же значение, что и <varname>from_collapse_limit</varname>, и это приемлемо в большинстве случаев. При значении, равном 1, предложения <literal>JOIN</literal> переставляться не будут, так что явно заданный в запросе порядок соединений определит фактический порядок, в котором будут соединяться отношения. Так как планировщик не всегда выбирает оптимальный порядок соединений, опытные пользователи могут временно задать для этой переменной значение 1, а затем явно определить желаемый порядок. За дополнительными сведениями обратитесь к <xref remap="3" linkend="explicit-joins"/>.</para>

       <para>Если это значение сделать равным <xref linkend="guc-geqo-threshold"/> или больше, при таком объединении запросов может включиться планировщик GEQO и в результате будет получен неоптимальный план. См. <xref remap="4" linkend="runtime-config-query-geqo"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-force-parallel-mode" xreflabel="force_parallel_mode">
      <term><varname>force_parallel_mode</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>force_parallel_mode</varname></primary></indexterm></term>
      <listitem>
       <para>Позволяет распараллеливать запрос в целях тестирования, даже когда от этого не ожидается никакого выигрыша в скорости. Допустимые значения параметра <varname>force_parallel_mode</varname> — <literal>off</literal> (использовать параллельный режим только когда ожидается увеличение производительности), <literal>on</literal> (принудительно распараллеливать все запросы, для которых это безопасно) и <literal>regress</literal> (как <literal>on</literal>, но с дополнительными изменениями поведения, описанными ниже).</para>

       <para>Говоря точнее, со значением <literal>on</literal> узел <literal>Gather</literal> добавляется в вершину любого плана запроса, для которого допускается распараллеливание, так что запрос выполняется внутри параллельного исполнителя. Даже когда параллельный исполнитель недоступен или не может быть использован, такие операции, как запуск подтранзакции, которые не должны выполняться в контексте параллельного запроса, не будут выполняться в этом режиме, если только планировщик не решит, что это приведёт к ошибке запроса. Если при включении этого параметра возникают ошибки или выдаются неожиданные результаты, вероятно, некоторые функции, задействованные в этом запросе, нужно пометить как <literal>PARALLEL UNSAFE</literal> (или, возможно, <literal>PARALLEL RESTRICTED</literal>).</para>

       <para>Значение <literal>regress</literal> действует так же, как и значение <literal>on</literal>, с некоторыми дополнительными особенностями, предназначенными для облегчения автоматического регрессионного тестирования. Обычно сообщения от параллельных исполнителей включают строку контекста, отмечающую это, но значение <literal>regress</literal> подавляет эту строку, так что вывод не отличается от выполнения в не параллельном режиме. Кроме того, узлы <literal>Gather</literal>, добавляемые в планы с этим значением параметра, скрываются в выводе <literal>EXPLAIN</literal>, чтобы вывод соответствовал тому, что будет получен при отключении этого параметра (со значением <literal>off</literal>).</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-logging">
    <title>Регистрация ошибок и протоколирование работы сервера</title>

    <indexterm zone="runtime-config-logging"><primary>журнал сервера</primary></indexterm>

    <sect2 id="runtime-config-logging-where">
     <title>Куда протоколировать</title>

     <indexterm zone="runtime-config-logging-where"><primary>куда протоколировать</primary></indexterm>

     <variablelist>

     <varlistentry id="guc-log-destination" xreflabel="log_destination">
      <term><varname>log_destination</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>log_destination</varname></primary></indexterm></term>
      <listitem>
       <para><productname>&productname;</productname> поддерживает несколько методов протоколирования сообщений сервера: <systemitem>stderr</systemitem>, <systemitem>csvlog</systemitem> и <systemitem>syslog</systemitem>. На Windows также поддерживается <systemitem>eventlog</systemitem>. В качестве значения <varname>log_destination</varname> указывается один или несколько методов протоколирования, разделённых запятыми. По умолчанию используется <systemitem>stderr</systemitem>. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера.</para>
       <para>Если в <varname>log_destination</varname> включено значение <systemitem>csvlog</systemitem>, то протоколирование ведётся в формате <acronym>CSV</acronym> (разделённые запятыми значения). Это удобно для программной обработки журнала. Подробнее об этом в <xref remap="6" linkend="runtime-config-logging-csvlog"/>. Для вывода в формате CSV должен быть включён <xref linkend="guc-logging-collector"/>.</para>

       <note>
        <para>В большинстве систем Unix потребуется изменить конфигурацию системного демона <application>syslog</application> для использования варианта <systemitem>syslog</systemitem> в <varname>log_destination</varname>. Для указания типа протоколируемой программы (facility), <productname>&productname;</productname> может использовать значения с <literal>LOCAL0</literal> по <literal>LOCAL7</literal> (см. <xref remap="4" linkend="guc-syslog-facility"/>). Однако, на большинстве платформ, конфигурация <application>syslog</application> по умолчанию не учитывает сообщения подобного типа. Чтобы это работало, потребуется добавить в конфигурацию демона <application>syslog</application> что-то подобное: <programlisting>local0.*    /var/log/postgresql</programlisting></para>
        <para>Для использования <literal>eventlog</literal> в <varname>log_destination</varname> на Windows, необходимо зарегистрировать источник событий и его библиотеку в операционной системе. Тогда Windows Event Viewer сможет отображать сообщения журнала событий. Подробнее в <xref remap="6" linkend="event-log-registration"/>.</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-logging-collector" xreflabel="logging_collector">
      <term><varname>logging_collector</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>logging_collector</varname></primary></indexterm></term>
      <listitem>
       <para>Параметр включает коллектор сообщений (<firstterm>logging collector</firstterm>). Это фоновый процесс, который собирает отправленные в <systemitem>stderr</systemitem> сообщения и перенаправляет их в журнальные файлы. Такой подход зачастую более полезен чем запись в <application>syslog</application>, поскольку некоторые сообщения в <application>syslog</application> могут не попасть. (Типичный пример с сообщениями об ошибках динамического связывания, другой пример — ошибки в скриптах типа <varname>archive_command</varname>.) Для установки параметра требуется перезапуск сервера.</para>

       <note>
        <para>Можно обойтись без коллектора сообщений и просто писать в <systemitem>stderr</systemitem>. Сообщения будут записываться в место, куда направлен поток <systemitem>stderr</systemitem>. Такой способ подойдёт только для небольших объёмов протоколирования, потому что не предоставляет удобных средств для организации ротации журнальных файлов. Кроме того, на некоторых платформах отказ от использования коллектора сообщений может привести к потере или искажению сообщений, так как несколько процессов, одновременно пишущих в один журнальный файл, могут перезаписывать информацию друг друга.</para>
       </note>

       <note>
        <para>Коллектор спроектирован так, чтобы сообщения никогда не терялись. А это значит, что при очень высокой нагрузке, серверные процессы могут быть заблокированы при попытке отправить сообщения во время сбоя фонового процесса коллектора. В противоположность этому, <application>syslog</application> предпочитает удалять сообщения, при невозможности их записать. Поэтому часть сообщений может быть потеряна, но система не будет блокироваться.</para>
       </note>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-directory" xreflabel="log_directory">
      <term><varname>log_directory</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>log_directory</varname></primary></indexterm></term>
      <listitem>
       <para>При включённом <varname>logging_collector</varname>, определяет каталог, в котором создаются журнальные файлы. Можно задавать как абсолютный путь, так и относительный от каталога данных кластера. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера. Значение по умолчанию <literal>pg_log</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-filename" xreflabel="log_filename">
      <term><varname>log_filename</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>log_filename</varname></primary></indexterm></term>
      <listitem>
       <para>При включённом <varname>logging_collector</varname> задаёт имена журнальных файлов. Значение трактуется как строка формата в функции <function>strftime</function>, поэтому в ней можно использовать спецификаторы <literal>%</literal> для включения в имена файлов информации о дате и времени. (При наличии зависящих от часового пояса спецификаторов <literal>%</literal> будет использован пояс, заданный в <xref linkend="guc-log-timezone"/>.) Поддерживаемые спецификаторы <literal>%</literal> похожи на те, что перечислены в описании <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html">strftime </ulink> спецификации Open Group. Обратите внимание, что системная функция <function>strftime</function> напрямую не используется. Поэтому нестандартные, специфичные для платформы особенности не будут работать. Значение по умолчанию <literal>postgresql-%Y-%m-%d_%H%M%S.log</literal>.</para>
       <para>Если для задания имени файлов не используются спецификаторы <literal>%</literal>, то для избежания переполнения диска, следует использовать утилиты для ротации журнальных файлов. В версиях до 8.4, при отсутствии спецификаторов <literal>%</literal>, <productname>PostgreSQL</productname> автоматически добавлял время в формате Epoch к имени файла. Сейчас в этом больше нет необходимости.</para>
       <para>Если в <varname>log_destination</varname> включён вывод в формате CSV, то к имени журнального файла будет добавлено расширение <literal>.csv</literal>. (Если <varname>log_filename</varname> заканчивается на <literal>.log</literal>, то это расширение заменится на <literal>.csv</literal>.)</para>
       <para>Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-file-mode" xreflabel="log_file_mode">
      <term><varname>log_file_mode</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>log_file_mode</varname></primary></indexterm></term>
      <listitem>
       <para>В системах Unix задаёт права доступа к журнальным файлам, при включённом <varname>logging_collector</varname>. (В Windows этот параметр игнорируется.) Значение параметра должно быть числовым, в формате команд <function>chmod</function> и <function>umask</function>. (Для восьмеричного формата, требуется задать лидирующий <literal>0</literal> (ноль).)</para>
       <para>Права доступа по умолчанию <literal>0600</literal>, т. е. только владелец сервера может читать и писать в журнальные файлы. Также, может быть полезным значение <literal>0640</literal>, разрешающее чтение файлов членам группы. Однако, чтобы установить такое значение, нужно каталог для хранения журнальных файлов (<xref linkend="guc-log-directory"/>) вынести за пределы каталога данных кластера. В любом случае, нежелательно открывать для всех доступ на чтение журнальных файлов, так как они могут содержать конфиденциальные данные.</para>
       <para>Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-age" xreflabel="log_rotation_age">
      <term><varname>log_rotation_age</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>log_rotation_age</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет максимальное время жизни отдельного журнального файла, при включённом <varname>logging_collector</varname>. После того как прошло заданное количество минут, создаётся новый журнальный файл. Для запрета создания нового файла по прошествии определённого времени, нужно установить значение 0. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-size" xreflabel="log_rotation_size">
      <term><varname>log_rotation_size</varname> (<type>integer</type>) <indexterm><primary>параметр <varname>log_rotation_size</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет максимальный размер отдельного журнального файла, при включённом <varname>logging_collector</varname>. После того как заданное количество килобайт записано в текущий файл, создаётся новый журнальный файл. Для запрета создания нового файла при превышении определённого размера, нужно установить значение 0. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-truncate-on-rotation" xreflabel="log_truncate_on_rotation">
      <term><varname>log_truncate_on_rotation</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_truncate_on_rotation</varname></primary></indexterm></term>
      <listitem>
       <para>Если параметр <varname>logging_collector</varname> включён, <productname>&productname;</productname> будет перезаписывать существующие журнальные файлы, а не дописывать в них. Однако, перезапись при переключении на новый файл возможна только в результате ротации по времени, но не при старте сервера или ротации по размеру файла. При выключенном параметре всегда продолжается запись в существующий файл. Например, включение этого параметра в комбинации с <varname>log_filename</varname> равным <literal>postgresql-%H.log</literal>, приведёт к генерации 24-х часовых журнальных файлов, которые циклически перезаписываются. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера.</para>
       <para>Пример: для хранения журнальных файлов в течение 7 дней, по одному файлу на каждый день с именами вида <literal>server_log.Mon</literal>, <literal>server_log.Tue</literal> и т. д., а также с автоматической перезаписью файлов прошлой недели, нужно установить <varname>log_filename</varname> в <literal>server_log.%a</literal>, <varname>log_truncate_on_rotation</varname> в <literal>on</literal> и <varname>log_rotation_age</varname> в <literal>1440</literal>.</para>
       <para>Пример: для хранения журнальных файлов в течение 24 часов, по одному файлу на час, с дополнительной возможностью переключения файла при превышения 1ГБ, установите <varname>log_filename</varname> в <literal>server_log.%H%M</literal>, <varname>log_truncate_on_rotation</varname> в <literal>on</literal>, <varname>log_rotation_age</varname> в <literal>60</literal> и <varname>log_rotation_size</varname> в <literal>1000000</literal>. Добавление <literal>%M</literal> в <varname>log_filename</varname> позволит при переключении по размеру указать другое имя файла в пределах одного часа.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-facility" xreflabel="syslog_facility">
      <term><varname>syslog_facility</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>syslog_facility</varname></primary></indexterm></term>
      <listitem>
       <para>При включённом протоколировании в <application>syslog</application>, этот параметр определяет значение <quote>facility</quote>. Допустимые значения <literal>LOCAL0</literal>, <literal>LOCAL1</literal>, <literal>LOCAL2</literal>, <literal>LOCAL3</literal>, <literal>LOCAL4</literal>, <literal>LOCAL5</literal>, <literal>LOCAL6</literal>, <literal>LOCAL7</literal>. По умолчанию используется <literal>LOCAL0</literal>. Подробнее в документации на системный демон <application>syslog</application>. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-ident" xreflabel="syslog_ident">
      <term><varname>syslog_ident</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>syslog_ident</varname></primary></indexterm></term>
       <listitem>
        <para>При включённом протоколировании в <application>syslog</application>, этот параметр задаёт имя программы, которое будет использоваться в <application>syslog</application> для идентификации сообщений относящихся к <productname>&productname;</productname>. По умолчанию используется <literal>postgres</literal>. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-syslog-sequence-numbers" xreflabel="syslog_sequence_numbers">
       <term><varname>syslog_sequence_numbers</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>syslog_sequence_numbers</varname></primary></indexterm></term>

       <listitem>
        <para>Когда сообщения выводятся в <application>syslog</application> и этот параметр включён (по умолчанию), все сообщения будут предваряться последовательно увеличивающимися номерами (например, <literal>[2]</literal>). Это позволяет обойти подавление повторов <quote>--- последнее сообщение повторилось N раз ---</quote>, которое по умолчанию осуществляется во многих реализациях syslog. В более современных реализациях syslog подавление повторных сообщений можно настроить (например, в <productname>rsyslog</productname> есть директива <literal>$RepeatedMsgReduction</literal>), так что это может излишне. Если же вы действительно хотите, чтобы повторные сообщения подавлялись, вы можете отключить этот параметр.</para>

        <para>Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-split-messages" xreflabel="syslog_split_messages">
      <term><varname>syslog_split_messages</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>syslog_split_messages</varname></primary></indexterm></term>
      <listitem>
       <para>Когда активен вывод сообщений в <application>syslog</application>, этот параметр определяет, как будут доставляться сообщения. Если он включён (по умолчанию), сообщения разделяются по строкам, а длинные строки разбиваются на строки не длиннее 1024 байт, что составляет типичное ограничение размера для традиционных реализаций syslog. Когда он отключён, сообщения сервера &productname; передаются службе syslog как есть, и она должна сама корректно воспринять потенциально длинные сообщения.</para>

       <para>Если syslog в итоге выводит сообщения в текстовый файл, результат будет тем же и лучше оставить этот параметр включённым, так как многие реализации syslog не способны обрабатывать большие сообщения или их нужно специально настраивать для этого. Но если syslog направляет сообщения в некоторую другую среду, может потребоваться или будет удобнее сохранять логическую целостность сообщений.</para>

       <para>Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-event-source" xreflabel="event_source">
      <term><varname>event_source</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>event_source</varname></primary></indexterm></term>
      <listitem>
       <para>При включённом протоколировании в <application>event log</application>, этот параметр задаёт имя программы, которое будет использоваться в журнале событий для идентификации сообщений относящихся к <productname>&productname;</productname>. По умолчанию используется <literal>&productname;</literal>. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

      </variablelist>
    </sect2>
     <sect2 id="runtime-config-logging-when">
     <title>Когда протоколировать</title>

     <variablelist>

     <varlistentry id="guc-client-min-messages" xreflabel="client_min_messages">
      <term><varname>client_min_messages</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>client_min_messages</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет минимальным уровнем сообщений, посылаемых клиенту. Допустимые значения <literal>DEBUG5</literal>, <literal>DEBUG4</literal>, <literal>DEBUG3</literal>, <literal>DEBUG2</literal>, <literal>DEBUG1</literal>, <literal>LOG</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>, <literal>ERROR</literal>, <literal>FATAL</literal> и <literal>PANIC</literal>. Каждый из перечисленных уровней включает все идущие после него. Чем дальше в этом списке уровень сообщения, тем меньше сообщений будет посылаться клиенту. По умолчанию используется <literal>NOTICE</literal>. Обратите внимание, что <literal>LOG</literal> расположен по-разному здесь и в <varname>log_min_messages</varname>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-messages" xreflabel="log_min_messages">
      <term><varname>log_min_messages</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>log_min_messages</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет минимальным уровнем сообщений, записываемых в журнал сервера. Допустимые значения <literal>DEBUG5</literal>, <literal>DEBUG4</literal>, <literal>DEBUG3</literal>, <literal>DEBUG2</literal>, <literal>DEBUG1</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>, <literal>ERROR</literal>, <literal>LOG</literal>, <literal>FATAL</literal> и <literal>PANIC</literal>. Каждый из перечисленных уровней включает все идущие после него. Чем дальше в этом списке уровень сообщения, тем меньше сообщений будет записано в журнал сервера. По умолчанию используется <literal>WARNING</literal>. Обратите внимание, что <literal>LOG</literal> расположен по-разному здесь и в <varname>client_min_messages</varname>. Только суперпользователи могут изменить этот параметр.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-error-statement" xreflabel="log_min_error_statement">
      <term><varname>log_min_error_statement</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>log_min_error_statement</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет тем, какие SQL-операторы, завершившиеся ошибкой, записываются в журнал сервера. SQL-оператор будет записан в журнал, если он завершится ошибкой с указанным уровнем важности или выше. Допустимые значения: <literal>DEBUG5</literal>, <literal>DEBUG4</literal>, <literal>DEBUG3</literal>, <literal>DEBUG2</literal>, <literal>DEBUG1</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>, <literal>ERROR</literal>, <literal>LOG</literal>, <literal>FATAL</literal> и <literal>PANIC</literal>. По умолчанию используется <literal>ERROR</literal>. Это означает, что в журнал сервера будут записаны все операторы, завершившиеся сообщением с уровнем важности <literal>ERROR</literal>, <literal>LOG</literal>, <literal>FATAL</literal> и <literal>PANIC</literal>. Чтобы фактически отключить запись операторов с ошибками, установите для этого параметра значение <literal>PANIC</literal>. Изменить этот параметр могут только суперпользователи.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-duration-statement" xreflabel="log_min_duration_statement">
      <term><varname>log_min_duration_statement</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>log_min_duration_statement</varname></primary></indexterm></term>
       <listitem>
        <para>Записывает в журнал продолжительность выполнения всех команд, время работы которых равно или превышает указанное количество миллисекунд. Значение 0 (ноль) заставляет записывать продолжительность работы всех команд. Значение -1 (по умолчанию) запрещает регистрировать продолжительность выполнения операторов. Например, при значении <literal>250ms</literal>, все команды, которые выполняются за 250 миллисекунд и дольше будут записаны в журнал сервера. Включение параметра полезно для выявления плохо оптимизированных запросов в приложении. Только суперпользователи могут изменить этот параметр.</para>

        <para>Для клиентов, использующих расширенный протокол запросов, будет записываться продолжительность фаз: разбор, связывание и выполнение.</para>

       <note>
        <para>При использовании совместно с <xref linkend="guc-log-statement"/>, текст SQL-операторов будет записываться только один раз (от использования <varname>log_statement</varname>) и не будет задублирован в сообщении о длительности выполнения. Если не используется вывод в <application>syslog</application>, то рекомендуется в <xref linkend="guc-log-line-prefix"/> включить идентификатор процесса или сессии. Это позволит связать текст запроса с записью о продолжительности выполнения, которая появится позже.</para>
       </note>
       </listitem>
      </varlistentry>

     </variablelist>

    <para>В <xref remap="6" linkend="runtime-config-severity-levels"/> поясняются уровни важности сообщений в <productname>&productname;</productname>. Также в этой таблице показано, как эти уровни транслируются в системные при использовании <systemitem>syslog</systemitem> или <systemitem>eventlog</systemitem> в Windows.</para>

    <table id="runtime-config-severity-levels">
     <title>Уровни важности сообщений</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Уровень</entry>
        <entry>Использование</entry>
        <entry><systemitem>syslog</systemitem></entry>
        <entry><systemitem>eventlog</systemitem></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>DEBUG1..DEBUG5</literal></entry>
        <entry>Более детальная информация для разработчиков. Чем больше номер, тем детальнее.</entry>
        <entry><literal>DEBUG</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

       <row>
        <entry><literal>INFO</literal></entry>
        <entry>Неявно запрошенная пользователем информация, например вывод команды <command>VACUUM VERBOSE</command>.</entry>
        <entry><literal>INFO</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

       <row>
        <entry><literal>NOTICE</literal></entry>
        <entry>Информация, которая может быть полезной пользователям. Например, уведомления об усечении длинных идентификаторов.</entry>
        <entry><literal>NOTICE</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

       <row>
        <entry><literal>WARNING</literal></entry>
        <entry>Предупреждения о возможных проблемах. Например, <command>COMMIT</command> вне транзакционного блока.</entry>
        <entry><literal>NOTICE</literal></entry>
        <entry><literal>WARNING</literal></entry>
       </row>

       <row>
        <entry><literal>ERROR</literal></entry>
        <entry>Сообщает об ошибке, из-за которой прервана текущая команда.</entry>
        <entry><literal>WARNING</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>

       <row>
        <entry><literal>LOG</literal></entry>
        <entry>Информация, полезная для администраторов. Например, выполнение контрольных точек.</entry>
        <entry><literal>INFO</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

       <row>
        <entry><literal>FATAL</literal></entry>
        <entry>Сообщает об ошибке, из-за которой прервана текущая сессия.</entry>
        <entry><literal>ERR</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>

       <row>
        <entry><literal>PANIC</literal></entry>
        <entry>Сообщает об ошибке, из-за которой прерваны все сессии.</entry>
        <entry><literal>CRIT</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    </sect2>
     <sect2 id="runtime-config-logging-what">
     <title>Что протоколировать</title>

     <variablelist>

     <varlistentry id="guc-application-name" xreflabel="application_name">
      <term><varname>application_name</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>application_name</varname></primary></indexterm></term>
      <listitem>
       <para><varname>application_name</varname> это любая строка, не превышающая <symbol>NAMEDATALEN</symbol> символов (64 символа при стандартной сборке). Обычно устанавливается приложением при подключении к серверу. Значение отображается в представлении <structname>pg_stat_activity</structname> и добавляется в журнал сервера, при использовании формата CSV. Для прочих форматов, <varname>application_name</varname> можно добавить в журнал через параметр <xref linkend="guc-log-line-prefix"/>. Значение <varname>application_name</varname> может содержать только печатные ASCII символы. Остальные символы будут заменены знаками вопроса (<literal>?</literal>).</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>debug_print_parse</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>debug_print_parse</varname></primary></indexterm></term>
      <term><varname>debug_print_rewritten</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>debug_print_rewritten</varname></primary></indexterm></term>
      <term><varname>debug_print_plan</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>debug_print_plan</varname></primary></indexterm></term>
      <listitem>
       <para>Эти параметры включают вывод различной отладочной информации. А именно: вывод дерева запроса, дерево запроса после применения правил или плана выполнения запроса, соответственно. Все эти сообщения имеют уровень <literal>LOG</literal>. Поэтому, по умолчанию, они записываются в журнал сервера, но не отправляются клиенту. Отправку клиенту можно настроить через <xref linkend="guc-client-min-messages"/> и/или <xref linkend="guc-log-min-messages"/>. По умолчанию параметры выключены.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>debug_pretty_print</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>debug_pretty_print</varname></primary></indexterm></term>
      <listitem>
       <para>Включает выравнивание сообщений, выводимых <varname>debug_print_parse</varname>, <varname>debug_print_rewritten</varname> или <varname>debug_print_plan</varname>. В результате сообщения легче читать, но они значительно длиннее, чем в формате <quote>compact</quote>, который используется при выключенном значении. По умолчанию включён.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-checkpoints" xreflabel="log_checkpoints">
      <term><varname>log_checkpoints</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_checkpoints</varname></primary></indexterm></term>
      <listitem>
       <para>Включает протоколирование выполнения контрольных точек и точек перезапуска сервера. При этом записывается некоторая статистическая информация. Например, число записанных буферов и время, затраченное на их запись. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера. По умолчанию выключен.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-connections" xreflabel="log_connections">
      <term><varname>log_connections</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_connections</varname></primary></indexterm></term>
      <listitem>
       <para>Включает протоколирование всех попыток подключения к серверу, в том числе успешного завершения аутентификации клиентов. Изменить его можно только в начале сеанса и сделать это могут только суперпользователи. Значение по умолчанию — <literal>off</literal>.</para>

       <note>
        <para>Некоторые программы, например <application>psql</application>, предпринимают две попытки подключения (первая для определения, нужен ли пароль). Поэтому дублирование сообщения <quote>connection received</quote> не обязательно говорит о наличии проблемы.</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-disconnections" xreflabel="log_disconnections">
      <term><varname>log_disconnections</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_disconnections</varname></primary></indexterm></term>
      <listitem>
       <para>Включает протоколирование завершения сеанса. В журнал выводится примерно та же информация, что и с <varname>log_connections</varname>, плюс длительность сеанса. Изменить этот параметр можно только в начале сеанса и сделать это могут только суперпользователи. Значение по умолчанию — <literal>off</literal>.</para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-log-duration" xreflabel="log_duration">
      <term><varname>log_duration</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_duration</varname></primary></indexterm></term>
      <listitem>
       <para>Записывает продолжительность каждой завершённой команды. По умолчанию выключен. Только суперпользователи могут изменить этот параметр.</para>

       <para>Для клиентов, использующих расширенный протокол запросов, будет записываться продолжительность фаз: разбор, связывание и выполнение.</para>

       <note>
        <para>Включение этого параметра и установка <xref linkend="guc-log-min-duration-statement"/> в 0 (ноль) различаются. Разница в том, что при превышении значения <varname>log_min_duration_statement</varname>, в журнал записывается текст запроса, а при включении <varname>log_duration</varname> нет. Таким образом, при <varname>log_duration</varname> = <literal>on</literal> и <varname>log_min_duration_statement</varname> больше нуля, в журнал сервера будет записываться продолжительность выполнения всех команд, а текст запросов только для команд, превысивших заданное значение. Такое поведение может оказаться полезным при сборе статистики в условиях большой нагрузки.</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-error-verbosity" xreflabel="log_error_verbosity">
      <term><varname>log_error_verbosity</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>log_error_verbosity</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет количеством детальной информации, записываемой в журнал сервера для каждого сообщения. Допустимые значения: <literal>TERSE</literal>, <literal>DEFAULT</literal> и <literal>VERBOSE</literal>. Каждое последующее значение добавляет больше полей в выводимое сообщение. Для <literal>TERSE</literal> из сообщения об ошибке исключаются поля <literal>DETAIL</literal>, <literal>HINT</literal>, <literal>QUERY</literal> и <literal>CONTEXT</literal>. Для <literal>VERBOSE</literal> в сообщение включается код ошибки <symbol>SQLSTATE</symbol> (см. <xref remap="4" linkend="errcodes-appendix"/>), а также имя файла с исходным кодом, имя функции и номер строки сгенерировавшей ошибку. Только суперпользователи могут изменить этот параметр.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-hostname" xreflabel="log_hostname">
      <term><varname>log_hostname</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_hostname</varname></primary></indexterm></term>
      <listitem>
       <para>По умолчанию, сообщения журнала содержат лишь IP-адрес подключившегося клиента. При включении этого параметра, дополнительно будет фиксироваться и имя сервера. Обратите внимание, что в зависимости от применяемого способа разрешения имён, это может отрицательно сказаться на производительности. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-line-prefix" xreflabel="log_line_prefix">
      <term><varname>log_line_prefix</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>log_line_prefix</varname></primary></indexterm></term>
      <listitem>
       <para>Строка, в стиле функции <function>printf</function>, которая выводится в начале каждой строки журнала сообщений. С символов <literal>%</literal> начинаются управляющие последовательности, которые заменяются статусной информацией, описанной ниже. Неизвестные управляющие последовательности игнорируются. Все остальные символы напрямую копируются в журнальную строку. Некоторые управляющие последовательности используются только для пользовательских процессов и будут игнорироваться фоновыми процессами, например основным процессом сервера. Подставляемая информация может быть выровнена по ширине влево или вправо указанием числа после % и перед кодом последовательности. Отрицательное число дополняет значение пробелами справа, а положительное число дополняет пробелами слева. Выравнивание можно использовать для улучшения читаемости. Параметр можно задать только в конфигурационных файлах или в командной строке при запуске сервера. По умолчанию используется пустая строка. <informaltable>
          <tgroup cols="3">
           <thead>
            <row>
             <entry>Спецсимвол</entry>
             <entry>Назначение</entry>
             <entry>Только для пользовательского процесса</entry>
             </row>
            </thead>
           <tbody>
            <row>
             <entry><literal>%a</literal></entry>
             <entry>Имя приложения (<xref linkend="guc-application-name"/>)</entry>
             <entry>да</entry>
            </row>
            <row>
             <entry><literal>%u</literal></entry>
             <entry>Имя пользователя</entry>
             <entry>да</entry>
            </row>
            <row>
             <entry><literal>%d</literal></entry>
             <entry>Имя базы данных</entry>
             <entry>да</entry>
            </row>
            <row>
             <entry><literal>%r</literal></entry>
             <entry>Имя удалённого узла или IP-адрес, а также номер порта</entry>
             <entry>да</entry>
            </row>
            <row>
             <entry><literal>%h</literal></entry>
             <entry>Имя удалённого узла или IP-адрес</entry>
             <entry>да</entry>
            </row>
            <row>
             <entry><literal>%p</literal></entry>
             <entry>Идентификатор процесса</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%t</literal></entry>
             <entry>Штамп времени, без миллисекунд</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%m</literal></entry>
             <entry>Штамп времени, с миллисекундами</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%n</literal></entry>
             <entry>Штамп времени, с миллисекундами (в виде времени Unix)</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%i</literal></entry>
             <entry>Тег команды: тип текущей команды в сессии</entry>
             <entry>да</entry>
            </row>
            <row>
             <entry><literal>%e</literal></entry>
             <entry>Код ошибки SQLSTATE</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%c</literal></entry>
             <entry>Идентификатор сессии. Подробности ниже</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%l</literal></entry>
             <entry>Номер строки журнала для каждой сессии или процесса. Начинается с 1</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%s</literal></entry>
             <entry>Штамп времени начала процесса</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%v</literal></entry>
             <entry>Идентификатор виртуальной транзакции (backendID/localXID)</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%x</literal></entry>
             <entry>Идентификатор транзакции (0 если не присвоен)</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%q</literal></entry>
             <entry>Ничего не выводит. Непользовательские процессы останавливаются в этой точке. Игнорируется пользовательскими процессами</entry>
             <entry>нет</entry>
            </row>
            <row>
             <entry><literal>%%</literal></entry>
             <entry>Выводит <literal>%</literal></entry>
             <entry>нет</entry>
            </row>
           </tbody>
          </tgroup>
         </informaltable> <literal>%c</literal> выводит псевдоуникальный номер сессии, состоящий из двух 4-х битных шестнадцатеричных чисел (без лидирующих нулей), разделённых точкой. Эти числа представляют собой время старта процесса и идентификатор процесса, поэтому <literal>%c</literal> можно использовать для экономии места при записи этих значений. Например, для получения идентификатора сессии из <literal>pg_stat_activity</literal>, используйте запрос: <programlisting>SELECT to_hex(trunc(EXTRACT(EPOCH FROM backend_start))::integer) || '.' ||
       to_hex(pid)
FROM pg_stat_activity;</programlisting></para>

       <tip>
        <para>Последним символом в <varname>log_line_prefix</varname> лучше оставлять пробел, чтобы отделить от остальной строки. Можно использовать и символы пунктуации.</para>
       </tip>

       <tip>
        <para><application>Syslog</application> также формирует штамп времени и идентификатор процесса, поэтому вероятно нет смысла использовать соответствующие управляющие последовательности при использовании <application>syslog</application>.</para>
       </tip>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-lock-waits" xreflabel="log_lock_waits">
      <term><varname>log_lock_waits</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_lock_waits</varname></primary></indexterm></term>
      <listitem>
       <para>Определяет, нужно ли фиксировать в журнале события, когда сеанс ожидает получения блокировки дольше, чем указано в <xref linkend="guc-deadlock-timeout"/>. Это позволяет выяснить, не связана ли низкая производительность с ожиданием блокировок. По умолчанию отключено. Только суперпользователи могут изменить этот параметр.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-statement" xreflabel="log_statement">
      <term><varname>log_statement</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>log_statement</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет тем, какие SQL-команды записывать в журнал. Допустимые значения: <literal>none</literal> (отключено), <literal>ddl</literal>, <literal>mod</literal> и <literal>all</literal> (все команды). <literal>ddl</literal> записывает все команды определения данных, такие как <command>CREATE</command>, <command>ALTER</command>, <command>DROP</command>. <literal>mod</literal> записывает все команды <literal>ddl</literal>, а также команды изменяющие данные, такие как <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>, <command>TRUNCATE</command> и <command>COPY FROM</command>. <command>PREPARE</command>, <command>EXECUTE</command> и <command>EXPLAIN ANALYZE</command> также записываются, если вызваны для команды соответствующего типа. Если клиент использует расширенный протокол запросов, то запись происходит на фазе выполнения и содержит значения всех связанных переменных (если есть символы одиночных кавычек, то они удваиваются).</para>

       <para>По умолчанию <literal>none</literal>. Только суперпользователи могут изменить этот параметр.</para>

       <note>
        <para>Команды с синтаксическими ошибками не записываются, даже если <varname>log_statement</varname> = <literal>all</literal>, так как сообщение формируется только после выполнения предварительного разбора, определяющего тип команды. При расширенном протоколе запросов, похожим образом не будут записываться команды, неуспешно завершившиеся до фазы выполнения (например, при разборе или построении плана запроса). Для включения в журнал таких команд установите <varname>log_min_error_statement</varname> в <literal>ERROR</literal> (или ниже).</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-replication-commands" xreflabel="log_replication_commands">
      <term><varname>log_replication_commands</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_replication_commands</varname></primary></indexterm></term>
      <listitem>
       <para>Включает запись в журнал сервера всех команд репликации. Подробнее о командах репликации можно узнать в <xref remap="6" linkend="protocol-replication"/>. Значение по умолчанию — <literal>off</literal>. Изменить этот параметр могут только суперпользователи.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-temp-files" xreflabel="log_temp_files">
      <term><varname>log_temp_files</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>log_temp_files</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет включением в журнал информации об именах и размерах временных файлов. Временные файлы могут использоваться для сортировок, хеширования и временного хранения результатов запросов. На каждый временный файл, при его удалении, в журнал записывается отдельное сообщение. Значение 0 говорит о том, что нужно записывать информацию о всех временных файлах. Положительное значение задаёт размер временных файлов в килобайтах, при достижении или превышении которого, информация о временном файле будет записана. Значение по умолчанию -1, что отключает запись информации о временных файлах. Только суперпользователи могут изменить этот параметр.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-timezone" xreflabel="log_timezone">
      <term><varname>log_timezone</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>log_timezone</varname></primary></indexterm></term>
      <listitem>
       <para>Устанавливает часовой пояс для штампов времени при записи в журнал сервера. В отличие от <xref linkend="guc-timezone"/>, это значение одинаково для всех баз данных кластера, поэтому для всех сессий используются согласованные значения штампов времени. Встроенное значение по умолчанию <literal>GMT</literal>, но оно переопределяется в <filename>postgresql.conf</filename>: <application>initdb</application> записывает в него значение, соответствующее системной среде. Подробнее об этом в <xref remap="6" linkend="datatype-timezones"/>. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-logging-csvlog">
     <title>Использование вывода журнала в формате CSV</title>

       <para>Добавление <literal>csvlog</literal> в <varname>log_destination</varname> делает удобным загрузку журнальных файлов в таблицу базы данных. Строки журнала представляют собой значения разделённые запятыми (CSV формат) со следующими полями: штамп времени с миллисекундами; имя пользователя; имя базы данных; идентификатор процесса; клиентский узел:номер порта; идентификатор сессии; номер строки каждой сессии; тег команды; время начала сессии; виртуальный идентификатор транзакции; идентификатор транзакции; уровень важности ошибки; код ошибки SQLSTATE; сообщение об ошибке; подробности к сообщению об ошибке; подсказка к сообщению об ошибке; внутренний запрос, приведший к ошибке (если есть); номер символа внутреннего запроса, где произошла ошибка; контекст ошибки; запрос пользователя, приведший к ошибке (если есть и включён <varname>log_min_error_statement</varname>); номер символа в запросе пользователя, где произошла ошибка; расположение ошибки в исходном коде &productname; (если <varname>log_error_verbosity</varname> установлен в <literal>verbose</literal>) и имя приложения. Вот пример определения таблицы, для хранения журналов в формате CSV: <programlisting>CREATE TABLE postgres_log
(
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  PRIMARY KEY (session_id, session_line_num)
);</programlisting></para>

       <para>Для загрузки журнального файла в такую таблицу можно использовать команду <command>COPY FROM</command>: <programlisting>COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;</programlisting></para>

       <para>Для упрощения загрузки журналов в CSV формате используйте следующее: <orderedlist>
         <listitem>
           <para>Установите для <varname>log_filename</varname> и <varname>log_rotation_age</varname> значения, гарантирующие согласованную и предсказуемую схему именования журнальных файлов. Зная, какие имена будут у журнальных файлов, можно определить, когда конкретный файл заполнен и готов к загрузке.</para>
        </listitem>

        <listitem>
           <para>Установите <varname>log_rotation_size</varname> в 0, чтобы запретить ротацию файлов по достижении определённого размера, так как это делает непредсказуемой схему именования журнальных файлов.</para>
        </listitem>

        <listitem>
          <para>Установите <varname>log_truncate_on_rotation</varname> в <literal>on</literal>, чтобы новые сообщения не смешивались со старыми при переключении на существующий файл.</para>
        </listitem>

        <listitem>
          <para>Определение таблицы содержит первичный ключ. Это полезно для предотвращения случайной повторной загрузки данных. Команда <command>COPY</command> фиксирует изменения один раз, поэтому любая ошибка приведёт к отмене всей загрузки. Если сначала загрузить неполный журнальный файл, то его повторная загрузка (по заполнении) приведёт к нарушению первичного ключа и, следовательно, к ошибке загрузки. Поэтому необходимо дожидаться окончания записи в журнальный файл перед началом загрузки. Похожим образом предотвращается случайная загрузка частично сформированной строки сообщения, что также приведёт к сбою в команде <command>COPY</command>.</para>
        </listitem>
        </orderedlist></para>
    </sect2>

   <sect2>
    <title>Заголовок процесса</title>

    <para>Эти параметры влияют на то, как формируются заголовки серверных процессов. Заголовок процесса обычно можно наблюдать в программах типа <application>ps</application>, а в Windows — в <application>Process Explorer</application>. За подробностями обратитесь к <xref remap="3" linkend="monitoring-ps"/>.</para>

    <variablelist>
     <varlistentry id="guc-cluster-name" xreflabel="cluster_name">
      <term><varname>cluster_name</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>cluster_name</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт имя кластера, которое отображается в заголовке процесса для всех серверных процессов данного кластера. Это имя может быть любой строкой не длиннее <symbol>NAMEDATALEN</symbol> символов (64 символа в стандартной сборке). В строке <varname>cluster_name</varname> могут использоваться только печатаемые ASCII-символы. Любой другой символ будет заменён символом вопроса (<literal>?</literal>). Если этот параметр содержит пустую строку <literal>''</literal> (это значение по умолчанию), никакое имя не выводится. Этот параметр можно задать только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-update-process-title" xreflabel="update_process_title">
      <term><varname>update_process_title</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>update_process_title</varname></primary></indexterm></term>
      <listitem>
       <para>Включает изменение заголовка процесса при получении сервером каждой очередной команды SQL. На большинстве платформ он включён (имеет значение <literal>on</literal>), но в Windows по умолчанию выключен (<literal>off</literal>) ввиду больших издержек на изменение этого заголовка. Изменить этот параметр могут только суперпользователи.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
  </sect1>

   <sect1 id="runtime-config-statistics">
    <title>Статистика времени выполнения</title>

    <sect2 id="runtime-config-statistics-collector">
     <title>Сбор статистики по запросам и индексам</title>

     <para>Эти параметры управляет функциями сбора статистики на уровне сервера. Когда ведётся сбор статистики, собираемые данные можно просмотреть в семействе системных представлений <structname>pg_stat</structname> и <structname>pg_statio</structname>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="monitoring"/>.</para>

     <variablelist>

     <varlistentry id="guc-track-activities" xreflabel="track_activities">
      <term><varname>track_activities</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>track_activities</varname></primary></indexterm></term>
      <listitem>
       <para>Включает сбор сведений о текущих командах, выполняющихся во всех сеансах (в частности, отслеживается время запуска команды). По умолчанию этот параметр включён. Заметьте, что даже когда сбор ведётся, собранная информация доступна не для всех пользователей, а только для суперпользователей и пользователя-владельца сеанса, в котором выполняется текущая команда. Поэтому это не должно повлечь риски, связанные с безопасностью. Изменить этот параметр могут только суперпользователи.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-activity-query-size" xreflabel="track_activity_query_size">
      <term><varname>track_activity_query_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>track_activity_query_size</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт число байт, которое будет зарезервировано для отслеживания выполняемой в данной момент команды в каждом активном сеансе, для поля <structname>pg_stat_activity</structname>.<structfield>query</structfield>. Значение по умолчанию — 1024. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-counts" xreflabel="track_counts">
      <term><varname>track_counts</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>track_counts</varname></primary></indexterm></term>
      <listitem>
       <para>Включает сбор статистики активности в базе данных. Этот параметр по умолчанию включён, так как собранная информация требуется демону автоочистки. Изменить этот параметр могут только суперпользователи.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-io-timing" xreflabel="track_io_timing">
      <term><varname>track_io_timing</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>track_io_timing</varname></primary></indexterm></term>
      <listitem>
       <para>Включает замер времени операций ввода/вывода. Этот параметр по умолчанию отключён, так как для этого требуется постоянно запрашивать текущее время у операционной системы, что может значительно замедлить работу на некоторых платформах. Для оценивания издержек замера времени на вашей платформе можно воспользоваться утилитой <xref linkend="pgtesttiming"/>. Статистику ввода/вывода можно получить через представление <xref linkend="pg-stat-database-view"/>, в выводе <xref linkend="sql-explain"/> (когда используется параметр <literal>TIMING</literal>) и через представление <xref linkend="pgstatstatements"/>. Изменить этот параметр могут только суперпользователи.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-functions" xreflabel="track_functions">
      <term><varname>track_functions</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>track_functions</varname></primary></indexterm></term>
      <listitem>
       <para>Включает подсчёт вызовов функций и времени их выполнения. Значение <literal>pl</literal> включает отслеживание только функций на процедурном языке, а <literal>all</literal> — также функций на языках SQL и C. Значение по умолчанию — <literal>none</literal>, то есть сбор статистики по функциям отключён. Изменить этот параметр могут только суперпользователи.</para>

       <note>
        <para>Функции на языке SQL, достаточно простые для <quote>внедрения</quote> в вызывающий запрос, отслеживаться не будут вне зависимости от этого параметра.</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-stats-temp-directory" xreflabel="stats_temp_directory">
      <term><varname>stats_temp_directory</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>stats_temp_directory</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт каталог, в котором будут храниться временные данные статистики. Этот путь может быть абсолютным или задаваться относительно каталога данных. Значение по умолчанию — <filename>pg_stat_tmp</filename>. Если разместить целевой каталог в файловой системе в ОЗУ, это снизит нагрузку на физическое дисковое хранилище и может увеличить быстродействие. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-statistics-monitor">
     <title>Мониторинг статистики</title>
     <variablelist>

     <varlistentry>
      <term><varname>log_statement_stats</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_statement_stats</varname></primary></indexterm></term>
      <term><varname>log_parser_stats</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_parser_stats</varname></primary></indexterm></term>
      <term><varname>log_planner_stats</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_planner_stats</varname></primary></indexterm></term>
      <term><varname>log_executor_stats</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_executor_stats</varname></primary></indexterm></term>
      <listitem>
       <para>Эти параметры включают вывод статистики по производительности соответствующего модуля в протокол работы сервера. Это грубый инструмент профилирования, похожий на функцию <function>getrusage()</function> в операционной системе. Параметр <varname>log_statement_stats</varname> включает вывод общей статистики по операторам, тогда как другие управляют статистикой по модулям (разбор, планирование, выполнение). Включить <varname>log_statement_stats</varname> одновременно с параметрами, управляющими модулями, нельзя. По умолчанию все эти параметры отключены. Изменить эти параметры могут только суперпользователи.</para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>
   </sect1>

   <sect1 id="runtime-config-autovacuum">
    <title>Автоматическая очистка</title>

    <indexterm><primary>автоочистка</primary> <secondary>параметры конфигурации</secondary></indexterm>

     <para>Эти параметры управляют поведением механизма <firstterm>автоочистки</firstterm>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="autovacuum"/>. Заметьте, что многие из этих параметров могут быть переопределены на уровне таблиц; см. <xref remap="4" linkend="sql-createtable-storage-parameters" endterm="sql-createtable-storage-parameters-title"/>.</para>

    <variablelist>

     <varlistentry id="guc-autovacuum" xreflabel="autovacuum">
      <term><varname>autovacuum</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет состоянием демона, запускающего автоочистку. По умолчанию он включён, но чтобы автоочистка работала, нужно также включить <xref linkend="guc-track-counts"/>. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако автоочистку можно отключить для отдельных таблиц, изменив их параметры хранения.</para>
       <para>Заметьте, что даже если этот параметр отключён, система будет запускать процессы автоочистки, когда потребуется сжать <literal>pg_clog</literal> и <literal>pg_multixact</literal>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="vacuum-for-wraparound"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-autovacuum-min-duration" xreflabel="log_autovacuum_min_duration">
      <term><varname>log_autovacuum_min_duration</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>log_autovacuum_min_duration</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт время (в миллисекундах) выполнения действия автоочистки, при превышении которого информация об этом действии записывается в протокол. При нулевом значении в протоколе фиксируются все действия автоочистки. Значение -1 (по умолчанию) отключает протоколирование действий автоочистки. Например, если задать значение <literal>250ms</literal>, в протоколе будут фиксироваться все операции автоматической очистки и анализа, выполняемые дольше 250 мс. Кроме того, когда этот параметр имеет любое значение, отличное от <literal>-1</literal>, в протокол будет записываться сообщение в случае пропуска действия автоочистки из-за конфликтующей блокировки. Таким образом, включение этого параметра позволяет отслеживать активность автоочистки. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако его можно переопределить для отдельных таблиц, изменив их параметры хранения.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-max-workers" xreflabel="autovacuum_max_workers">
      <term><varname>autovacuum_max_workers</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_max_workers</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальное число процессов автоочистки (не считая процесс, запускающий автоочистку), которые могут выполняться одновременно. По умолчанию это число равно трём. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-naptime" xreflabel="autovacuum_naptime">
      <term><varname>autovacuum_naptime</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_naptime</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт минимальную задержку между двумя запусками автоочистки для отдельной базы данных. Демон автоочистки проверяет базу данных через заданный интервал времени и выдаёт команды <command>VACUUM</command> и <command>ANALYZE</command>, когда это требуется для таблиц этой базы. Задержка задаётся в секундах и по умолчанию равна одной минуте (<literal>1min</literal>). Этот параметр можно задать только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-threshold" xreflabel="autovacuum_vacuum_threshold">
      <term><varname>autovacuum_vacuum_threshold</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_vacuum_threshold</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт минимальное число изменённых или удалённых кортежей, при котором будет выполняться <command>VACUUM</command> для отдельно взятой таблицы. Значение по умолчанию — 50 кортежей. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако данное значение можно переопределить для избранных таблиц, изменив их параметры хранения.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-analyze-threshold" xreflabel="autovacuum_analyze_threshold">
      <term><varname>autovacuum_analyze_threshold</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_analyze_threshold</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт минимальное число добавленных, изменённых или удалённых кортежей, при котором будет выполняться <command>ANALYZE</command> для отдельно взятой таблицы. Значение по умолчанию — 50 кортежей. Этот параметр можно задать только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако данное значение можно переопределить для избранных таблиц, изменив их параметры хранения.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-scale-factor" xreflabel="autovacuum_vacuum_scale_factor">
      <term><varname>autovacuum_vacuum_scale_factor</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_vacuum_scale_factor</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт процент от размера таблицы, который будет добавляться к <varname>autovacuum_vacuum_threshold</varname> при выборе порога срабатывания команды <command>VACUUM</command>. Значение по умолчанию — 0.2 (20% от размера таблицы). Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако данное значение можно переопределить для избранных таблиц, изменив их параметры хранения.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-analyze-scale-factor" xreflabel="autovacuum_analyze_scale_factor">
      <term><varname>autovacuum_analyze_scale_factor</varname> (<type>floating point</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_analyze_scale_factor</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт процент от размера таблицы, который будет добавляться к <varname>autovacuum_analyze_threshold</varname> при выборе порога срабатывания команды <command>ANALYZE</command>. Значение по умолчанию — 0.1 (10% от размера таблицы). Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако данное значение можно переопределить для избранных таблиц, изменив их параметры хранения.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-freeze-max-age" xreflabel="autovacuum_freeze_max_age">
      <term><varname>autovacuum_freeze_max_age</varname> (<type>integer 64</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_freeze_max_age</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный возраст (в транзакциях) для поля <structname>pg_class</structname>.<structfield>relfrozenxid</structfield> некоторой таблицы, при достижении которого будет запущена операция <command>VACUUM</command> для сжатия <literal>pg_clog</literal>. Заметьте, что система запустит процессы автоочистки для этого, даже если для всех других целей автоочистка отключена.</para>

       <para>Задать этот параметр можно только при запуске сервера, но для отдельных таблиц его можно определить по-другому, изменив их параметры хранения. За дополнительными сведениями обратитесь к <xref remap="3" linkend="vacuum-for-wraparound"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-multixact-freeze-max-age" xreflabel="autovacuum_multixact_freeze_max_age">
      <term><varname>autovacuum_multixact_freeze_max_age</varname> (<type>integer 64</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_multixact_freeze_max_age</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный возраст (в мультитранзакциях) для поля <structname>pg_class</structname>.<structfield>relminmxid</structfield> некоторой таблицы, при достижении которого будет запущена операция <command>VACUUM</command> для сжатия <literal>pg_multixact</literal>. Заметьте, что система запустит процессы автоочистки для этого, даже если для всех других целей автоочистка отключена.</para>

       <para>Задать этот параметр можно только при запуске сервера, но для отдельных таблиц его можно определить по-другому, изменив их параметры хранения. За дополнительными сведениями обратитесь к <xref remap="3" linkend="vacuum-for-multixact-wraparound"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-cost-delay" xreflabel="autovacuum_vacuum_cost_delay">
      <term><varname>autovacuum_vacuum_cost_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_vacuum_cost_delay</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт задержку при превышении предела стоимости, которая будет применяться при автоматических операциях <command>VACUUM</command>. При значении -1 применяется обычная задержка <xref linkend="guc-vacuum-cost-delay"/>. Значение по умолчанию — 20 миллисекунд. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако его можно переопределить для отдельных таблиц, изменив их параметры хранения.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-cost-limit" xreflabel="autovacuum_vacuum_cost_limit">
      <term><varname>autovacuum_vacuum_cost_limit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>autovacuum_vacuum_cost_limit</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт предел стоимости, который будет учитываться при автоматических операциях <command>VACUUM</command>. При значении -1 (по умолчанию) применяется обычное значение <xref linkend="guc-vacuum-cost-limit"/>. Заметьте, что это значение распределяется пропорционально среди всех работающих процессов автоочистки, если их больше одного, так что сумма ограничений всех процессов никогда не превосходит данный предел. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера. Однако его можно переопределить для отдельных таблиц, изменив их параметры хранения.</para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="runtime-config-client">
    <title>Параметры клиентских сеансов по умолчанию</title>

    <sect2 id="runtime-config-client-statement">
     <title>Поведение команд</title>
     <variablelist>

     <varlistentry id="guc-search-path" xreflabel="search_path">
      <term><varname>search_path</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>search_path</varname></primary></indexterm> <indexterm><primary>путь</primary> <secondary>для схем</secondary></indexterm></term>
      <listitem>
       <para>Эта переменная определяет порядок, в котором будут просматриваться схемы при поиске объекта (таблицы, типа данных, функции и т. д.), к которому обращаются просто по имени, без указания схемы. Если объекты с одинаковым именем находятся в нескольких схемах, использоваться будет тот, что встретится первым при просмотре пути поиска. К объекту, который не относится к схемам, перечисленным в пути поиска, можно обратиться только по полному имени (с точкой), с указанием содержащей его схемы.</para>

       <para>Значением <varname>search_path</varname> должен быть список имён схем через запятую. Если для имени, указанного в этом списке, не находится существующая схема, либо пользователь не имеет права <literal>USAGE</literal> для схемы с этим именем, такое имя просто игнорируется.</para>

       <para>Если список содержит специальный элемент <literal>$user</literal>, вместо него подставляется схема с именем, возвращаемым функцией <function>SESSION_USER</function>, если такая схема существует и пользователь имеет право <literal>USAGE</literal> для неё. (В противном случае элемент <literal>$user</literal> игнорируется.)</para>

       <para>Схема системных каталогов, <literal>pg_catalog</literal>, просматривается всегда, независимо от того, указана она в пути или нет. Если она указана в пути, она просматривается в заданном порядке. Если же <literal>pg_catalog</literal> отсутствует в пути, эта схема будет просматриваться <emphasis>перед</emphasis> остальными элементами пути.</para>

       <para>Аналогично всегда просматривается схема временных таблиц текущего сеанса, <literal>pg_temp_<replaceable>nnn</replaceable></literal>, если она существует. Её можно включить в путь поиска, указав её псевдоним <literal>pg_temp</literal><indexterm><primary>pg_temp</primary></indexterm>. Если она отсутствует в пути, она будет просматриваться первой (даже перед <literal>pg_catalog</literal>). Временная схема просматривается только при поиске отношений (таблиц, представлений, последовательностей и т. д.) и типов данных, но никогда при поиске функций и операторов.</para>

       <para>Когда объекты создаются без указания определённой целевой схемы, они помещаются в первую пригодную схему, указанную в <varname>search_path</varname>. Если путь поиска схем пуст, выдаётся ошибка.</para>

       <para>По умолчанию этот параметр имеет значение <literal>"$user", public</literal>. При таком значении поддерживается совместное использование базы данных (когда пользователи не имеют личных схем, все используют схему <literal>public</literal>), использование личных схем, а также комбинация обоих вариантов. Другие подходы можно реализовать, изменяя значение пути по умолчанию, либо глобально, либо индивидуально для каждого пользователя.</para>

       <para>Текущее действующее значение пути поиска можно получить, воспользовавшись <acronym>SQL</acronym>-функцией <function>current_schemas</function> (см. <xref remap="4" linkend="functions-info"/>). Это значение может отличаться от значения <varname>search_path</varname>, так как <function>current_schemas</function> показывает, как были преобразованы элементы, фигурирующие в <varname>search_path</varname>.</para>

       <para>Чтобы больше узнать о работе со схемами, обратитесь к <xref remap="3" linkend="ddl-schemas"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-row-security" xreflabel="row_security">
      <term><varname>row_security</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>row_security</varname></primary></indexterm></term>
      <listitem>
       <para>Эта переменная определяет, должна ли выдаваться ошибка при применении политик защиты строк. Со значением <literal>on</literal> политики применяются в обычном режиме. Со значением <literal>off</literal> запросы, ограничиваемые минимум одной политикой, будут выдавать ошибку. Значение по умолчанию — <literal>on</literal>. Значение <literal>off</literal> рекомендуется, когда ограничение видимости строк чревато некорректными результатами; например, <application>pg_dump</application> устанавливает это значение. Эта переменная не влияет на роли, которые обходят все политики защиты строк, а именно, на суперпользователей и роли с атрибутом <literal>BYPASSRLS</literal>.</para>

       <para>Подробнее о политиках защиты строк можно узнать в описании <xref linkend="sql-createpolicy"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-tablespace" xreflabel="default_tablespace">
      <term><varname>default_tablespace</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>default_tablespace</varname></primary></indexterm> <indexterm><primary>табличное пространство</primary> <secondary>по умолчанию</secondary></indexterm></term>
      <listitem>
       <para>Эта переменная устанавливает табличное пространство по умолчанию, в котором будут создаваться объекты (таблицы и индексы), когда в команде <command>CREATE</command> табличное пространство не указывается явно.</para>

       <para>Её значением может быть либо имя табличного пространства, либо пустая строка, подразумевающая использование табличного пространства по умолчанию в текущей базе данных. Если табличное пространство с заданным именем не существует, <productname>&productname;</productname> будет автоматически использовать табличное пространство по умолчанию. Если используется не пространство по умолчанию, пользователь должен иметь право <literal>CREATE</literal> для него, иначе он не сможет создавать объекты.</para>

       <para>Эта переменная не используется для временных таблиц; для них задействуется <xref linkend="guc-temp-tablespaces"/>.</para>

       <para>Эта переменная также не используется при создании баз данных. По умолчанию, новая база данных наследует выбор табличного пространства от базы-шаблона, из которой она копируется.</para>

       <para>За дополнительными сведениями о табличных пространствах обратитесь к <xref remap="3" linkend="manage-ag-tablespaces"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-temp-tablespaces" xreflabel="temp_tablespaces">
      <term><varname>temp_tablespaces</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>temp_tablespaces</varname></primary></indexterm> <indexterm><primary>табличное пространство</primary> <secondary>временное</secondary></indexterm></term>
      <listitem>
       <para>Эта переменная задаёт табличные пространства, в которых будут создаваться временные объекты (временные таблицы и индексы временных таблиц), когда в команде <command>CREATE</command> табличное пространство не указывается явно. В этих табличных пространствах также создаются временные файлы для внутреннего использования, например, для сортировки больших наборов данных.</para>

       <para>Её значение содержит список имён табличных пространств. Когда этот список содержит больше одного имени, <productname>&productname;</productname> выбирает из этого списка случайный элемент при создании каждого временного объекта; однако при создании последующих объектов внутри транзакции табличные пространства перебираются последовательно. Если в этом списке оказывается пустая строка, <productname>&productname;</productname> будет автоматически использовать вместо этого элемента табличное пространство по умолчанию для текущей базы данных.</para>

       <para>Когда <varname>temp_tablespaces</varname> задаётся интерактивно, указание несуществующего табличного пространства считается ошибкой, как и указание табличного пространства, для которого пользователь не имеет права <literal>CREATE</literal>. Однако при использовании значения, заданного ранее, несуществующие табличные пространства и пространства, для которых у пользователя нет права <literal>CREATE</literal>, просто игнорируются. В частности, это касается значения, заданного в <filename>postgresql.conf</filename>.</para>

       <para>По умолчанию значение этой переменной — пустая строка. С таким значением все временные объекты создаются в табличном пространстве по умолчанию, установленном для текущей базы данных.</para>

       <para>См. также <xref remap="4" linkend="guc-default-tablespace"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-check-function-bodies" xreflabel="check_function_bodies">
      <term><varname>check_function_bodies</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>check_function_bodies</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр обычно включён. Выключение этого параметра (присвоение ему значения <literal>off</literal>) отключает проверку строки с телом функции, передаваемой команде <xref linkend="sql-createfunction"/>. Отключение проверки позволяет избежать побочных эффектов процесса проверки и исключить ложные срабатывания из-за таких проблем, как ссылки вперёд. Этому параметру нужно присваивать значение <literal>off</literal> перед загрузкой функций от лица других пользователей; <application>pg_dump</application> делает это автоматически.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-isolation" xreflabel="default_transaction_isolation">
      <term><varname>default_transaction_isolation</varname> (<type>enum</type>) <indexterm><primary>уровень изоляции транзакции</primary> <secondary>выбор по умолчанию</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>default_transaction_isolation</varname></primary></indexterm></term>
      <listitem>
       <para>Для каждой транзакции в SQL устанавливается уровень изоляции: <quote>read uncommitted</quote>, <quote>read committed</quote>, <quote>repeatable read</quote> или <quote>serializable</quote>. Этот параметр задаёт уровень изоляции, который будет устанавливаться по умолчанию для новых транзакций. Значение этого параметра по умолчанию — <quote>read committed</quote>.</para>

       <para>Дополнительную информацию вы можете найти в <xref remap="6" linkend="mvcc"/> и <xref remap="6" linkend="sql-set-transaction"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-read-only" xreflabel="default_transaction_read_only">
      <term><varname>default_transaction_read_only</varname> (<type>boolean</type>) <indexterm><primary>транзакция в режиме &laquo;только чтение&raquo;</primary> <secondary>выбор по умолчанию</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>default_transaction_read_only</varname></primary></indexterm></term>
      <listitem>
       <para>SQL-транзакции в режиме &laquo;только чтение&raquo; не могут модифицировать не временные таблицы. Этот параметр определяет, будут ли новые транзакции по умолчанию иметь характеристику &laquo;только чтение&raquo;. Значение этого параметра по умолчанию — <literal>off</literal> (допускается чтение и запись).</para>

       <para>За дополнительной информацией обратитесь к <xref remap="3" linkend="sql-set-transaction"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-deferrable" xreflabel="default_transaction_deferrable">
      <term><varname>default_transaction_deferrable</varname> (<type>boolean</type>) <indexterm><primary>откладываемая транзакция</primary> <secondary>выбор по умолчанию</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>default_transaction_deferrable</varname></primary></indexterm></term>
      <listitem>
       <para>Транзакция, работающая на уровне изоляции <literal>serializable</literal>, в режиме &laquo;только чтение&raquo; может быть задержана, прежде чем будет разрешено её выполнение. Однако, когда она начинает выполняться, для обеспечения сериализуемости не требуется никаких дополнительных усилий, так что коду сериализации ни при каких условиях не придётся прерывать её из-за параллельных изменений, поэтому это вполне подходит для длительных транзакций в режиме &laquo;только чтение&raquo;.</para>

        <para>Этот параметр определяет, будет ли каждая новая транзакция по умолчанию откладываемой. В настоящее время его действие не распространяется на транзакции, для которых устанавливается режим &laquo;чтение/запись&raquo; или уровень изоляции ниже <literal>serializable</literal>. Значение по умолчанию — <literal>off</literal> (выкл.).</para>

       <para>За дополнительной информацией обратитесь к <xref remap="3" linkend="sql-set-transaction"/>.</para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-session-replication-role" xreflabel="session_replication_role">
      <term><varname>session_replication_role</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>session_replication_role</varname></primary></indexterm></term>
      <listitem>
       <para>Управляет срабатыванием правил и триггеров, связанных с репликацией, в текущем сеансе. Изменение этой переменной требует наличия прав суперпользователя и приводит к сбросу всех ранее кешированных планов запросов. Она может принимать следующие значения <literal>origin</literal> (значение по умолчанию), <literal>replica</literal> и <literal>local</literal>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="sql-altertable"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-statement-timeout" xreflabel="statement_timeout">
      <term><varname>statement_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>statement_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальное время выполнения оператора (в миллисекундах), начиная с момента получения сервером команды от клиента, по истечении которого оператор прерывается. Если <varname>log_min_error_statement</varname> имеет значение <literal>ERROR</literal> или ниже, оператор, прерванный по тайм-ауту, будет также записан в журнал. При значении, равном нулю (по умолчанию), этот контроль длительности отключается.</para>

       <para>Устанавливать значение <varname>statement_timeout</varname> в <filename>postgresql.conf</filename> не рекомендуется, так как это повлияет на все сеансы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lock-timeout" xreflabel="lock_timeout">
      <term><varname>lock_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>lock_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальную длительность ожидания (в миллисекундах) любым оператором получения блокировки таблицы, индекса, строки или другого объекта базы данных. Если ожидание не закончилось за указанное время, оператор прерывается. Это ограничение действует на каждую попытку получения блокировки по отдельности и применяется как к явным запросам блокировки (например, <command>LOCK TABLE</command> или <command>SELECT FOR UPDATE</command> без <literal>NOWAIT</literal>), так и к неявным. Если <varname>log_min_error_statement</varname> имеет значение <literal>ERROR</literal> или ниже, оператор, прерванный по тайм-ауту, будет также записан в журнал. При значении, равном нулю (по умолчанию), этот контроль длительности отключается.</para>

       <para>В отличие от <varname>statement_timeout</varname>, этот тайм-аут может произойти только при ожидании блокировки. Заметьте, что при ненулевом <varname>statement_timeout</varname> бессмысленно задавать в <varname>lock_timeout</varname> такое же или большее значение, так как тайм-аут оператора всегда будет происходить раньше.</para>

       <para>Устанавливать значение <varname>lock_timeout</varname> в <filename>postgresql.conf</filename> не рекомендуется, так как это повлияет на все сеансы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-idle-session-timeout" xreflabel="idle_session_timeout">
      <term><varname>idle_session_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>idle_session_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Завершать любые сеансы, которые простаивают дольше заданного (в миллисекундах) времени.</para>
       <para>Значение по умолчанию (0) отключает это поведение.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-idle-in-transaction-session-timeout" xreflabel="idle_in_transaction_session_timeout">
      <term><varname>idle_in_transaction_session_timeout</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>idle_in_transaction_session_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Завершать любые сеансы, в которых открытая транзакция простаивает дольше заданного (в миллисекундах) времени. Когда этот параметр установлен, он переопределяет значение <xref linkend="guc-idle-session-timeout"/> для открытых транзакций. Это позволяет освободить все блокировки сеанса и вновь задействовать слот подключения; также это позволяет очистить кортежи, видимые только для этой транзакции. Подробнее это описано в <xref remap="6" linkend="routine-vacuuming"/>.</para>
       <para>Значение по умолчанию (0) отключает это поведение.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-freeze-table-age" xreflabel="vacuum_freeze_table_age">
      <term><varname>vacuum_freeze_table_age</varname> (<type>integer 64</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_freeze_table_age</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный возраст для поля <structname>pg_class</structname>.<structfield>relfrozenxid</structfield> таблицы, при достижении которого <command>VACUUM</command> будет производить агрессивное сканирование. Агрессивное сканирование отличается от обычного сканирования <command>VACUUM</command> тем, что затрагивает все страницы, которые могут содержать незамороженные XID или MXID, а не только те, что могут содержать мёртвые кортежи. Значение по умолчанию — 150 миллионов транзакций. Хотя пользователи могут задать любое значение от нуля до 2^63 - 1, в <command>VACUUM</command> введён внутренний предел для действующего значения, равный 95% от <xref linkend="guc-autovacuum-freeze-max-age"/>, чтобы периодически запускаемая вручную команда <command>VACUUM</command> имела шансы выполниться, прежде чем для таблицы будет запущена автоочистка для сжатия <literal>pg_clog</literal> и <literal>pg_multixact</literal>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="vacuum-for-wraparound"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-freeze-min-age" xreflabel="vacuum_freeze_min_age">
      <term><varname>vacuum_freeze_min_age</varname> (<type>integer 64</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_freeze_min_age</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт возраст для отсечки (в транзакциях), при достижении которого команда <command>VACUUM</command> должна замораживать версии строк при сканировании таблицы. Значение по умолчанию — 50 миллионов транзакций. Хотя пользователи могут задать любое значение от нуля до 2^63 - 1, в <command>VACUUM</command> введён внутренний предел для действующего значения, равный половине <xref linkend="guc-autovacuum-freeze-max-age"/>, чтобы принудительная автоочистка выполнялась не слишком часто. За дополнительными сведениями обратитесь к <xref remap="3" linkend="vacuum-for-wraparound"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-multixact-freeze-table-age" xreflabel="vacuum_multixact_freeze_table_age">
      <term><varname>vacuum_multixact_freeze_table_age</varname> (<type>integer 64</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_multixact_freeze_table_age</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный возраст для поля <structname>pg_class</structname>.<structfield>relminmxid</structfield> таблицы, при достижении которого <command>VACUUM</command> будет производить агрессивное сканирование. Агрессивное сканирование отличается от обычного сканирования <command>VACUUM</command> тем, что затрагивает все страницы, которые могут содержать незамороженные XID или MXID, а не только те, что могут содержать мёртвые кортежи. Значение по умолчанию — 150 миллионов мультитранзакций. Хотя пользователи могут задать любое значение от нуля до 2^63 - 1, в <command>VACUUM</command> введён внутренний предел для действующего значения, равный 95% от <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>, чтобы периодически запускаемая вручную команда <command>VACUUM</command> имела шансы выполниться, прежде чем для таблицы будет запущена автоочистка для сжатия <literal>pg_clog</literal> и <literal>pg_multixact</literal>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="vacuum-for-multixact-wraparound"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-multixact-freeze-min-age" xreflabel="vacuum_multixact_freeze_min_age">
      <term><varname>vacuum_multixact_freeze_min_age</varname> (<type>integer 64</type>) <indexterm><primary>параметр конфигурации <varname>vacuum_multixact_freeze_min_age</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт возраст для отсечки (в мультитранзакциях), при достижении которого команда <command>VACUUM</command> должна заменять идентификаторы мультитранзакций новыми идентификаторами транзакций или мультитранзакций при сканировании таблицы. Значение по умолчанию — 5 миллионов мультитранзакций. Хотя пользователи могут задать любое значение от нуля до 2^63 - 1, в <command>VACUUM</command> введён внутренний предел для действующего значения, равный половине <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>, чтобы принудительная автоочистка не выполнялась слишком часто. За дополнительными сведениями обратитесь к <xref remap="3" linkend="vacuum-for-multixact-wraparound"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bytea-output" xreflabel="bytea_output">
      <term><varname>bytea_output</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>bytea_output</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт выходной формат для значения типа <type>bytea</type>. Это может быть формат <literal>hex</literal> (по умолчанию) или <literal>escape</literal> (традиционный формат &productname;). За дополнительными сведениями обратитесь к <xref remap="3" linkend="datatype-binary"/>. Входные значения <type>bytea</type> воспринимаются в обоих форматах, независимо от данного параметра.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-xmlbinary" xreflabel="xmlbinary">
      <term><varname>xmlbinary</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>xmlbinary</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт способ кодирования двоичных данных в XML. Это кодирование применяется, например, когда значения <type>bytea</type> преобразуются в XML функциями <function>xmlelement</function> или <function>xmlforest</function>. Допустимые варианты, определённые в стандарте XML-схем: <literal>base64</literal> и <literal>hex</literal>. Значение по умолчанию — <literal>base64</literal>. Чтобы узнать больше о функциях для работы с XML, обратитесь к <xref remap="3" linkend="functions-xml"/>.</para>

       <para>Конечный выбор в основном дело вкуса, ограничения могут накладываться только клиентскими приложениями. Оба метода поддерживают все возможные значения, хотя результат кодирования в base64 немного компактнее шестнадцатеричного вида (hex).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-xmloption" xreflabel="xmloption">
      <term><varname>xmloption</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>xmloption</varname></primary></indexterm> <indexterm><primary><varname>SET XML OPTION</varname></primary></indexterm> <indexterm><primary>XML option</primary></indexterm></term>
      <listitem>
       <para>Задаёт подразумеваемый по умолчанию тип преобразования между XML и символьными строками (<literal>DOCUMENT</literal> или <literal>CONTENT</literal>). За описанием этого преобразования обратитесь к <xref remap="3" linkend="datatype-xml"/>. Значение по умолчанию — <literal>CONTENT</literal> (кроме него допускается значение <literal>DOCUMENT</literal>).</para>

       <para>Согласно стандарту SQL этот параметр должен задаваться командой <synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis> Этот синтаксис тоже поддерживается в &productname;.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-gin-pending-list-limit" xreflabel="gin_pending_list_limit">
      <term><varname>gin_pending_list_limit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>gin_pending_list_limit</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт максимальный размер очереди записей GIN, которая используется, когда включён режим <literal>fastupdate</literal>. Если размер очереди превышает заданный предел, записи из неё массово переносятся в основную структуру данных GIN и очередь очищается. Размер по умолчанию — четыре мегабайта (<literal>4MB</literal>). Этот предел можно переопределить для отдельных индексов GIN, изменив их параметры хранения. За дополнительными сведениями обратитесь к <xref remap="3" linkend="gin-fast-update"/> и <xref remap="3" linkend="gin-tips"/>.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-client-format">
     <title>Языковая среда и форматы</title>

     <variablelist>

     <varlistentry id="guc-datestyle" xreflabel="DateStyle">
      <term><varname>DateStyle</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>DateStyle</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт формат вывода значений даты и времени, а также правила интерпретации неоднозначных значений даты. По историческим причинам эта переменная содержит два независимых компонента: указание выходного формата (<literal>ISO</literal>, <literal>Postgres</literal>, <literal>SQL</literal> и <literal>German</literal>) и указание порядка год(Y)/месяц(M)/день(D) для вводимых и выводимых значений (<literal>DMY</literal>, <literal>MDY</literal> или <literal>YMD</literal>). Эти два компонента могут задаваться по отдельности или вместе. Ключевые слова <literal>Euro</literal> и <literal>European</literal> являются синонимами <literal>DMY</literal>, а ключевые слова <literal>US</literal>, <literal>NonEuro</literal> и <literal>NonEuropean</literal> — синонимы <literal>MDY</literal>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="datatype-datetime"/>. Встроенное значение по умолчанию — <literal>ISO, MDY</literal>, но <application>initdb</application> при инициализации записывает в файл конфигурации значение, соответствующее выбранной локали <varname>lc_time</varname>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-intervalstyle" xreflabel="IntervalStyle">
      <term><varname>IntervalStyle</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>IntervalStyle</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт формат вывода для значений-интервалов. В формате <literal>sql_standard</literal> интервал выводится в виде, установленном стандартом <acronym>SQL</acronym>. В формате <literal>postgres</literal> (выбранном по умолчанию) интервал выводится в виде, применявшемся в <productname>PostgreSQL</productname> до версии 8.4, когда параметр <xref linkend="guc-datestyle"/> имел значение <literal>ISO</literal>. В формате <literal>postgres_verbose</literal> интервал выводится в виде, применявшемся в <productname>PostgreSQL</productname> до версии 8.4, когда параметр <varname>DateStyle</varname> имел значение не <literal>ISO</literal>. В формате <literal>iso_8601</literal> выводимая строка будет соответствовать <quote>формату с кодами</quote>, определённому в разделе 4.4.3.2 стандарта ISO 8601.</para>
       <para>На интерпретацию неоднозначных вводимых данных также влияет параметр <varname>IntervalStyle</varname>. За дополнительными сведениями обратитесь к <xref remap="3" linkend="datatype-interval-input"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-timezone" xreflabel="TimeZone">
      <term><varname>TimeZone</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>TimeZone</varname></primary></indexterm> <indexterm><primary>часовой пояс</primary></indexterm></term>
      <listitem>
       <para>Задаёт часовой пояс для вывода и ввода значений времени. Встроенное значение по умолчанию — <literal>GMT</literal>, но обычно оно переопределяется в <filename>postgresql.conf</filename>; <application>initdb</application> устанавливает в нём значение, соответствующее системному окружению. За дополнительными сведениями обратитесь к <xref remap="3" linkend="datatype-timezones"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-timezone-abbreviations" xreflabel="timezone_abbreviations">
      <term><varname>timezone_abbreviations</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>timezone_abbreviations</varname></primary></indexterm> <indexterm><primary>имена часовых поясов</primary></indexterm></term>
      <listitem>
       <para>Задаёт набор сокращений часовых поясов, которые будут приниматься сервером во вводимых значениях даты и времени. Значение по умолчанию — <literal>'Default'</literal>, которое представляет набор основных сокращений, принятых в мире; допускаются также значения <literal>'Australia'</literal> и <literal>'India'</literal>, кроме них для конкретной инсталляции можно определить и другие наборы. За дополнительными сведениями обратитесь к <xref remap="3" linkend="datetime-config-files"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-extra-float-digits" xreflabel="extra_float_digits">
      <term><varname>extra_float_digits</varname> (<type>integer</type>) <indexterm><primary>значимые цифры</primary></indexterm> <indexterm><primary>число с плавающей точкой</primary> <secondary>отображение</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>extra_float_digits</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр корректирует число цифр, выводимых при отображении чисел с плавающей точкой, включая типы <type>float4</type>, <type>float8</type> и геометрические типы. Значение параметра добавляется к стандартному числу цифр (<literal>FLT_DIG</literal> или <literal>DBL_DIG</literal>, в зависимости от типа). Значение может быть положительным, до 3, и тогда в выводе добавляются частично значимые цифры (это особенно полезно для выгрузки чисел с плавающей точкой, которые должны быть восстановлены точно), или отрицательным, тогда в выводе будут подавляться нежелательные цифры. См. также <xref remap="4" linkend="datatype-float"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-client-encoding" xreflabel="client_encoding">
      <term><varname>client_encoding</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>client_encoding</varname></primary></indexterm> <indexterm><primary>набор символов</primary></indexterm></term>
      <listitem>
       <para>Задаёт кодировку (набор символов) на стороне клиента. По умолчанию выбирается кодировка базы данных. Наборы символов, которые поддерживает сервер <productname>&productname;</productname>, перечислены в <xref remap="6" linkend="multibyte-charset-supported"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-messages" xreflabel="lc_messages">
      <term><varname>lc_messages</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>lc_messages</varname></primary></indexterm></term>
      <listitem>
       <para>Устанавливает язык выводимых сообщений. Набор допустимых значений зависит от системы; за дополнительными сведениями обратитесь к <xref remap="3" linkend="locale"/>. Если эта переменная определена как пустая строка (по умолчанию), то действующее значение получается из среды выполнения сервера, в зависимости от системы.</para>

       <para>В некоторых системах такая категория локали отсутствует, так что даже если задать значение этой переменной, действовать оно не будет. Также может оказаться, что переведённые сообщения для запрошенного языка отсутствуют. В этих случаях вы по-прежнему будете получать сообщения на английском языке.</para>

       <para>Изменить этот параметр могут только суперпользователи. Он влияет и на сообщения, которые сервер передаёт клиентам, и на те, что записываются в журнал, поэтому неподходящее значение может сделать серверные журналы нечитаемыми.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-monetary" xreflabel="lc_monetary">
      <term><varname>lc_monetary</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>lc_monetary</varname></primary></indexterm></term>
      <listitem>
       <para>Устанавливает локаль для форматирования денежных сумм, например с использованием функций семейства <function>to_char</function>. Набор допустимых значений зависит от системы; за дополнительными сведениями обратитесь к <xref remap="3" linkend="locale"/>. Если эта переменная определена как пустая строка (по умолчанию), то действующее значение получается из среды выполнения сервера, в зависимости от системы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-numeric" xreflabel="lc_numeric">
      <term><varname>lc_numeric</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>lc_numeric</varname></primary></indexterm></term>
      <listitem>
       <para>Устанавливает локаль для форматирования чисел, например с использованием функций семейства <function>to_char</function>. Набор допустимых значений зависит от системы; за дополнительными сведениями обратитесь к <xref remap="3" linkend="locale"/>. Если эта переменная определена как пустая строка (по умолчанию), то действующее значение получается из среды выполнения сервера, в зависимости от системы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-time" xreflabel="lc_time">
      <term><varname>lc_time</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>lc_time</varname></primary></indexterm></term>
      <listitem>
       <para>Устанавливает локаль для форматирования даты и времени, например с использованием функций семейства <function>to_char</function>. Набор допустимых значений зависит от системы; за дополнительными сведениями обратитесь к <xref remap="3" linkend="locale"/>. Если эта переменная определена как пустая строка (по умолчанию), то действующее значение получается из среды выполнения сервера, в зависимости от системы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-text-search-config" xreflabel="default_text_search_config">
      <term><varname>default_text_search_config</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>default_text_search_config</varname></primary></indexterm></term>
      <listitem>
       <para>Выбирает конфигурацию текстового поиска для тех функций текстового поиска, которым не передаётся аргумент, явно указывающий конфигурацию. За дополнительной информацией обратитесь к <xref remap="3" linkend="textsearch"/>. Встроенное значение по умолчанию — <literal>pg_catalog.simple</literal>, но <application>initdb</application> при инициализации записывает в файл конфигурации сервера значение, соответствующее выбранной локали <varname>lc_ctype</varname>, если удастся найти такую конфигурацию текстового поиска.</para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>

    <sect2 id="runtime-config-client-preload">
     <title>Предзагрузка разделяемых библиотек</title>

     <para>Для настройки предварительной загрузки разделяемых библиотек в память сервера, в целях подключения дополнительной функциональности или увеличения быстродействия, предназначены несколько параметров. Значения этих параметров задаются однотипно, например, со значением <literal>'$libdir/mylib'</literal> в память будет загружена <literal>mylib.so</literal> (или в некоторых ОС, <literal>mylib.sl</literal>) из стандартного каталога библиотек данной инсталляции сервера. Различаются эти параметры тем, когда они вступают в силу и какие права требуются для их изменения.</para>

     <para>Таким же образом можно загрузить библиотеки на процедурных языках <productname>&productname;</productname>, обычно в виде <literal>'$libdir/plXXX'</literal>, где <literal>XXX</literal> — имя языка: <literal>pgsql</literal>, <literal>perl</literal>, <literal>tcl</literal> или <literal>python</literal>.</para>

     <para>Если в любом из этих параметров требуется загрузить несколько библиотек, их имена нужно перечислять через запятую. Все имена библиотек переводятся в нижний регистр, если только они не заключены в двойные кавычки.</para>

     <para>Этим способом можно загрузить только разделяемые библиотеки, предназначенные специально для использования с &productname;. &productname; при загрузке библиотеки проверяет наличие <quote>отличительного блока</quote> для гарантии совместимости. Поэтому загрузить библиотеки не для &productname; таким образом нельзя. Для этого вы можете воспользоваться средствами операционной системы, например, переменной окружения <envar>LD_PRELOAD</envar>.</para>

     <para>В общем случае, чтобы узнать, какой способ рекомендуется для загрузки модуля, следует обратиться к документации этого модуля.</para>

     <variablelist>
     <varlistentry id="guc-local-preload-libraries" xreflabel="local_preload_libraries">
      <term><varname>local_preload_libraries</varname> (<type>string</type>) <indexterm><primary><varname>local_preload_libraries</varname> параметр конфигурации</primary></indexterm> <indexterm><primary><filename>$libdir/plugins</filename></primary></indexterm></term>
      <listitem>
       <para>В этом параметре задаются одна или несколько разделяемых библиотек, которые будут загружаться при установлении соединения. Заданное значение параметра действует только в начале соединения, так что последующие изменения ни на что не влияют. Если указанная в нём библиотека не найдена, установить подключение не удастся.</para>

       <para>Этот параметр разрешено устанавливать всем пользователям. Поэтому библиотеки, которые так можно загрузить, ограничиваются теми, что находятся в подкаталоге <filename>plugins</filename> стандартного каталога библиотек установленного сервера. (Ответственность за то, чтобы в этом подкаталоге находились только <quote>безопасные</quote> библиотеки, лежит на администраторе.) В <varname>local_preload_libraries</varname> этот каталог можно задать явно (например, так: <literal>$libdir/plugins/mylib</literal>), либо просто указать имя библиотеки &mdash; <literal>mylib</literal> (оно будет воспринято как <literal>$libdir/plugins/mylib</literal>).</para>

       <para>Данный механизм предназначен для того, чтобы непривилегированные пользователи могли загружать отладочные или профилирующие библиотеки в избранных сеансах, обходясь без явной команды <command>LOAD</command>. Для такого применения этот параметр обычно устанавливается в переменной окружения <envar>PGOPTIONS</envar> на клиенте или с помощью команды <command>ALTER ROLE SET</command>.</para>

       <para>Обычно этот параметр не следует использовать, если только модуль не предназначен специально для такой загрузки обычными пользователями. Предпочтительная альтернатива ему — <xref linkend="guc-session-preload-libraries"/>.</para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-session-preload-libraries" xreflabel="session_preload_libraries">
      <term><varname>session_preload_libraries</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>session_preload_libraries</varname></primary></indexterm></term>
      <listitem>
       <para>В этом параметре задаются одна или несколько разделяемых библиотек, которые будут загружаться при установлении соединения. Изменить его могут только суперпользователи. Заданное значение параметра действует только в начале соединения, так что последующие изменения ни на что не влияют. Если указанная в нём библиотека не найдена, установить подключение не удастся.</para>

       <para>Данный параметр предназначен для загрузки отладочных или профилирующих библиотек в избранных сеансах, без явного выполнения команды <command>LOAD</command>. Например, можно загрузить модуль <xref linkend="auto-explain"/> во всех сеансах пользователя с заданным именем, установив этот параметр командой <command>ALTER ROLE SET</command>. Кроме того, этот параметр можно изменить без перезапуска сервера (хотя изменения вступают в силу только при запуске нового сеанса), так что таким образом проще подгружать новые модули, даже если это нужно сделать для всех сеансов.</para>

       <para>В отличие от <xref linkend="guc-shared-preload-libraries"/>, этот вариант загрузки библиотеки не даёт большого выигрыша в скорости по сравнению с вариантом загрузки при первом использовании. Однако он оказывается выигрышным, когда используется пул соединений.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-shared-preload-libraries" xreflabel="shared_preload_libraries">
      <term><varname>shared_preload_libraries</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>shared_preload_libraries</varname></primary></indexterm></term>
      <listitem>
       <para>В этом параметре задаются одна или несколько разделяемых библиотек, которые будут загружаться во время запуска сервера. Этот параметр можно задать только при запуске сервера. Если указанная в нём библиотека не найдёна, сервер не запустится.</para>

       <para>Некоторые библиотеки при загрузке должны выполнять операции, которые могут иметь место только при запуске главного процесса, например, выделять разделяемую память, резервировать легковесные блокировки или запускать фоновые рабочие процессы. Такие библиотеки должны загружаться при запуске сервера посредством этого параметра. За подробностями обратитесь к документации библиотек.</para>

       <para>Также можно предварительно загрузить и другие библиотеки. Предварительная загрузка позволяет избавиться от задержки, возникающей при первом использовании библиотеки. Однако при этом может несколько увеличиться время запуска каждого нового процесса, даже если он не будет использовать эту библиотеку. Поэтому применять этот параметр рекомендуется только для библиотек, которые будут использоваться большинством сеансов. Кроме того, при изменении этого параметра необходимо перезапускать сервер, так что этот вариант не подходит, например, для краткосрочных задач отладки. В таких случаях используйте вместо него <xref linkend="guc-session-preload-libraries"/>.</para>

      <note>
       <para>В системе Windows загрузка библиотек при запуске сервера не сокращает время запуска каждого нового серверного процесса; каждый процесс будет заново загружать все библиотеки. Однако параметр <varname>shared_preload_libraries </varname> всё же может быть полезен в Windows для загрузки библиотек, которые должны выполнять некоторые операции при запуске главного процесса.</para>
      </note>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>

     <sect2 id="runtime-config-client-other">
     <title>Другие параметры по умолчанию</title>

     <variablelist>

     <varlistentry id="guc-dynamic-library-path" xreflabel="dynamic_library_path">
      <term><varname>dynamic_library_path</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>dynamic_library_path</varname></primary></indexterm> <indexterm><primary>динамическая загрузка</primary></indexterm></term>
      <listitem>
       <para>Когда требуется открыть динамически загружаемый модуль и его имя, заданное в команде <command>CREATE FUNCTION</command> или <command>LOAD</command> не содержит имён каталогов (т. е. в этом имени нет косой черты), система будет искать запрошенный файл в данном пути.</para>

       <para>Значением параметра <varname>dynamic_library_path</varname> должен быть список абсолютных путей, разделённых двоеточием (или точкой с запятой в Windows). Если элемент в этом списке начинается со специальной строки <literal>$libdir</literal>, вместо неё подставляется заданный при компиляции путь каталога библиотек <productname>&productname;</productname>; в этот каталог устанавливаются модули, поставляемые в составе стандартного дистрибутива <productname>&productname;</productname>. (Чтобы узнать имя этого каталога, можно выполнить <literal>pg_config --pkglibdir</literal>.) Например: <programlisting>dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir'</programlisting> Или в среде Windows: <programlisting>dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'</programlisting></para>

       <para>Значение по умолчанию этого параметра — <literal>'$libdir'</literal>. Если его значение — пустая строка, автоматический поиск по заданному пути отключается.</para>

       <para>Суперпользователи могут изменить этот параметр в процессе работы сервера, но такое изменение будет действовать только до завершения клиентского соединения, так что этот вариант следует оставить для целей разработки. Для других целей этот параметр рекомендуется устанавливать в файле конфигурации <filename>postgresql.conf</filename>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-gin-fuzzy-search-limit" xreflabel="gin_fuzzy_search_limit">
      <term><varname>gin_fuzzy_search_limit</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>gin_fuzzy_search_limit</varname></primary></indexterm></term>
      <listitem>
       <para>Задаёт мягкий верхний лимит для размера набора, возвращаемого при сканировании индексов GIN. За дополнительными сведениями обратитесь к <xref remap="3" linkend="gin-tips"/>.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-locks">
    <title>Управление блокировками</title>

     <variablelist>

     <varlistentry id="guc-deadlock-timeout" xreflabel="deadlock_timeout">
      <term><varname>deadlock_timeout</varname> (<type>integer</type>) <indexterm><primary>взаимоблокировка</primary> <secondary>тайм-аут</secondary></indexterm> <indexterm><primary>тайм-аут</primary> <secondary>взаимоблокировка</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>deadlock_timeout</varname></primary></indexterm></term>
      <listitem>
       <para>Время ожидания блокировки (в миллисекундах), по истечении которого будет выполняться проверка состояния взаимоблокировки. Эта проверка довольно дорогостоящая, поэтому сервер не выполняет её при всяком ожидании блокировки. Мы оптимистично полагаем, что взаимоблокировки редки в производственных приложениях и поэтому просто ждём некоторое время, прежде чем пытаться выявить взаимоблокировку. При увеличении значения этого параметра сокращается время, уходящее на ненужные проверки взаимоблокировки, но замедляется реакция на реальные взаимоблокировки. Значение по умолчанию — одна секунда (<literal>1s</literal>), что близко к минимальному значению, которое стоит применять на практике. На сервере с большой нагрузкой имеет смысл увеличить его. В идеале это значение должно превышать типичное время транзакции, чтобы повысить шансы на то, что блокировка всё-таки будет освобождена, прежде чем ожидающая транзакция решит проверить состояние взаимоблокировки. Изменить этот параметр могут только суперпользователи.</para>

       <para>Когда включён параметр <xref linkend="guc-log-lock-waits"/>, данный параметр также определяет, спустя какое время в журнал сервера будут записываться сообщения об ожидании блокировки. Если вы пытаетесь исследовать задержки, вызванные блокировками, имеет смысл уменьшить его по сравнению с обычным значением <varname>deadlock_timeout</varname>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-locks-per-transaction" xreflabel="max_locks_per_transaction">
      <term><varname>max_locks_per_transaction</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_locks_per_transaction</varname></primary></indexterm></term>
      <listitem>
       <para>Общая таблица блокировок отслеживает блокировки для <varname>max_locks_per_transaction</varname> * (<xref linkend="guc-max-connections"/> + <xref linkend="guc-max-prepared-transactions"/>) объектов (например, таблиц); таким образом, в любой момент времени может быть заблокировано не больше этого числа различных объектов. Этот параметр управляет средним числом блокировок объектов, выделяемым для каждой транзакции; отдельные транзакции могут заблокировать и больше объектов, если все они умещаются в таблице блокировок. Заметьте, что это <emphasis>не</emphasis> число строк, которое может быть заблокировано; их количество не ограничено. Значение по умолчанию, 64, как показала практика, вполне приемлемо, но может возникнуть потребность его увеличить, если запросы обращаются ко множеству различных таблиц в одной транзакции, как например, запрос к родительской таблице со многими потомками. Этот параметр можно задать только при запуске сервера.</para>

       <para>Для сервера, работающего в режиме резерва, значение этого параметра должно быть больше или равно значению на главном. В противном случае на резервном сервере не будут разрешены запросы.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-pred-locks-per-transaction" xreflabel="max_pred_locks_per_transaction">
      <term><varname>max_pred_locks_per_transaction</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_pred_locks_per_transaction</varname></primary></indexterm></term>
      <listitem>
       <para>Общая таблица предикатных блокировок отслеживает блокировки для <varname>max_pred_locks_per_transaction</varname> * (<xref linkend="guc-max-connections"/> + <xref linkend="guc-max-prepared-transactions"/>) объектов (например, таблиц); таким образом, в одним момент времени может быть заблокировано не больше этого число различных объектов. Этот параметр управляет средним числом блокировок объектов, выделяемым для каждой транзакции; отдельные транзакции могут заблокировать и больше объектов, если все они умещаются в таблице блокировок. Заметьте, что это <emphasis>не</emphasis> число строк, которое может быть заблокировано; их количество не ограничено. Значение по умолчанию, 64, как показала практика, вполне приемлемо, но может возникнуть потребность его увеличить, если запросы обращаются ко множеству различных таблиц в одной сериализуемой транзакции, как например, запрос к родительской таблице со многими потомками. Этот параметр можно задать только при запуске сервера.</para>

      </listitem>
     </varlistentry>

     </variablelist>
   </sect1>

   <sect1 id="runtime-config-compatible">
    <title>Совместимость с разными версиями и платформами</title>

    <sect2 id="runtime-config-compatible-version">
     <title>Предыдущие версии &productname;</title>

     <variablelist>

     <varlistentry id="guc-array-nulls" xreflabel="array_nulls">
      <term><varname>array_nulls</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>array_nulls</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр определяет, будет ли при разборе вводимого массива распознаваться строка <literal>NULL</literal> без кавычек как элемент массива, равный NULL. Значение по умолчанию, <literal>on</literal>, позволяет задавать NULL в качестве элементов вводимого массива. Однако до версии 8.2 <productname>PostgreSQL</productname> не поддерживал ввод элементов NULL в массивах, а воспринимал <literal>NULL</literal> как обычный элемент массива со строковым значением <quote>NULL</quote>. Для обратной совместимости с приложениями, зависящими от старого поведения, эту переменную можно отключить (присвоив ей <literal>off</literal>).</para>

       <para>Заметьте, что массивы, содержащие NULL, можно создать, даже когда эта переменная имеет значение <literal>off</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-backslash-quote" xreflabel="backslash_quote">
      <term><varname>backslash_quote</varname> (<type>enum</type>) <indexterm><primary>строки</primary> <secondary>апостроф с обратной косой</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>backslash_quote</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр определяет, можно ли будет представить знак апострофа в строковой константе в виде <literal>\'</literal>. В стандарте SQL определён другой, предпочитаемый вариант передачи апострофа, удвоением (<literal>''</literal>), но <productname>&productname;</productname> исторически также принимал вариант <literal>\'</literal>. Однако применение варианта <literal>\'</literal> сопряжено с угрозами безопасности, так как в некоторых клиентских кодировках существуют многобайтные символы, последний байт которых численно равен ASCII-коду <literal>\</literal>. Если код на стороне клиента выполнит экранирование некорректно, это может открыть возможности для SQL-инъекции. Предотвратить этот риск можно, запретив серверу принимать запросы, в которых апостроф экранируется обратной косой. Допустимые значения параметра <varname>backslash_quote</varname>: <literal>on</literal> (принимать <literal>\'</literal> всегда), <literal>off</literal> (не принимать никогда) и <literal>safe_encoding</literal> (принимать, только если клиентская кодировка не допускает присутствия ASCII-кода <literal>\</literal> в многобайтных символах). Значение по умолчанию — <literal>safe_encoding</literal>.</para>

       <para>Заметьте, что в строковой константе, записанной согласно стандарту, знаки <literal>\</literal> обозначают просто <literal>\</literal>. Этот параметр влияет только на восприятие строк, не соответствующих стандарту, в том числе с синтаксисом спецпоследовательностей (<literal>E'...'</literal>).</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-with-oids" xreflabel="default_with_oids">
      <term><varname>default_with_oids</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>default_with_oids</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр определяет, будут ли команды <command>CREATE TABLE</command> и <command>CREATE TABLE AS</command> без явных указаний <literal>WITH OIDS</literal> и <literal>WITHOUT OIDS</literal> добавлять столбец OID в создаваемые таблицы. Он также устанавливает, будут ли столбцы OID добавляться в таблицы, создаваемые командой <command>SELECT INTO</command>. По умолчанию значение этого параметра — <literal>off</literal> (столбцы OID не добавляются); в <productname>PostgreSQL</productname> версии 8.0 и ранее он был включён (<literal>on</literal>).</para>

       <para>Практика использования OID в пользовательских таблицах считается устаревшей, так что в большинстве инсталляций не следует включать этот параметр. Приложения, которым требуется столбец OID в определённой таблице, могут явно указать <literal>WITH OIDS</literal> при создании таблицы. Этот параметр следует включать только для совместимости со старыми приложениями, которые не делают этого.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-escape-string-warning" xreflabel="escape_string_warning">
      <term><varname>escape_string_warning</varname> (<type>boolean</type>) <indexterm><primary>строки</primary> <secondary>предупреждение о спецсимволах</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>escape_string_warning</varname></primary></indexterm></term>
      <listitem>
       <para>Когда этот параметр включён, сервер выдаёт предупреждение, если обратная косая черта (<literal>\</literal>) встречается в обычной строковой константе (с синтаксисом <literal>'...'</literal>) и параметр <varname>standard_conforming_strings</varname> отключён. Значение по умолчанию — <literal>on</literal> (вкл.).</para>
       <para>Приложения, которые предпочитают использовать обратную косую в виде спецсимвола, должны перейти к применению синтаксиса спецстрок (<literal>E'...'</literal>), так как по умолчанию теперь в обычных строках обратная косая воспринимается как обычный символ, в соответствии со стандартом SQL. Включение данного параметра помогает найти код, нуждающийся в модификации.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lo-compat-privileges" xreflabel="lo_compat_privileges">
      <term><varname>lo_compat_privileges</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>lo_compat_privileges</varname></primary></indexterm></term>
      <listitem>
       <para>В <productname>PostgreSQL</productname> до версии 9.0 для больших объектов не назначались права доступа, и поэтому они были всегда доступны на чтение и запись для всех пользователей. Если установить для этого параметра значение <literal>on</literal>, существующие теперь проверки прав отключаются для совместимости с предыдущими версиями. Значение по умолчанию — <literal>off</literal>. Изменить этот параметр могут только суперпользователи.</para>
       <para>Установка данного параметра не приводит к отключению всех проверок безопасности, связанных с большими объектами &mdash; затрагиваются только те проверки, которые изменились в <productname>PostgreSQL</productname> 9.0. Например, функции <literal>lo_import()</literal> и <literal>lo_export()</literal> будут требовать прав суперпользователя вне зависимости от данного значения.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-operator-precedence-warning" xreflabel="operator_precedence_warning">
      <term><varname>operator_precedence_warning</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>operator_precedence_warning</varname></primary></indexterm></term>
      <listitem>
       <para>Когда этот параметр включён, анализатор запроса будет выдавать предупреждение для всех конструкций, которые поменяли поведение после <productname>PostgreSQL</productname> 9.4 в результате изменения приоритетов операторов. Это полезно для аудита, так как позволяет понять, не сломалось ли что-то вследствие этого изменения. Но в производственной среде включать его не следует, так как предупреждения могут выдаваться и тогда, когда код абсолютно правильный и соответствует стандарту SQL. Значение по умолчанию — <literal>off</literal>.</para>

       <para>За подробностями обратитесь к <xref remap="3" linkend="sql-precedence"/>.</para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-quote-all-identifiers" xreflabel="quote-all-identifiers">
      <term><varname>quote_all_identifiers</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>quote_all_identifiers</varname></primary></indexterm></term>
      <listitem>
       <para>Принудительно заключать в кавычки все идентификаторы, даже если это не ключевые слова (сегодня), при получении SQL из базы данных. Это касается вывода <command>EXPLAIN</command>, а также результатов функций типа <function>pg_get_viewdef</function>. См. также описание аргумента <option>--quote-all-identifiers</option> команд <xref linkend="app-pgdump"/> и <xref linkend="app-pg-dumpall"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-sql-inheritance" xreflabel="sql_inheritance">
      <term><varname>sql_inheritance</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>sql_inheritance</varname></primary></indexterm> <indexterm><primary>наследование</primary></indexterm></term>
      <listitem>
       <para>Этот параметр определяет, будет ли использование таблиц без уточнений подразумевать включение дочерних таблиц в иерархии наследования. Значение по умолчанию — <literal>on</literal>, что означает, что дочерние таблицы включаются (то есть по умолчанию подразумевается суффикс <literal>*</literal>). При значении <literal>off</literal> дочерние таблицы не включаются (то есть подразумевается префикс <literal>ONLY</literal>). Стандарт SQL требует, чтобы дочерние таблицы включались, так что вариант <literal>off</literal> не соответствует стандарту, но предлагается для совместимости с <productname>PostgreSQL</productname> до версии 7.1. За дополнительными сведениями обратитесь к <xref remap="3" linkend="ddl-inherit"/>.</para>

       <para>Поведение с выключенным <varname>sql_inheritance</varname> считается устаревшим, так как оно не только противоречит стандарту SQL, но и провоцирует ошибки. При обсуждении наследования в этом руководстве обычно предполагается, что данный параметр имеет значение <literal>on</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-standard-conforming-strings" xreflabel="standard_conforming_strings">
      <term><varname>standard_conforming_strings</varname> (<type>boolean</type>) <indexterm><primary>строки</primary> <secondary>соответствие стандарту</secondary></indexterm> <indexterm><primary>параметр конфигурации <varname>standard_conforming_strings</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр определяет, будет ли обратная косая черта в обычных строковых константах (<literal>'...'</literal>) восприниматься буквально, как того требует стандарт SQL. Начиная с версии <productname>PostgreSQL</productname> 9.1, он имеет значение <literal>on</literal> (в предыдущих версиях значение по умолчанию было <literal>off</literal>). Приложения могут выяснить, как обрабатываются строковые константы, проверив этот параметр. Наличие этого параметра может также быть признаком того, что поддерживается синтаксис спецпоследовательностей (<literal>E'...'</literal>). Этот синтаксис (<xref linkend="sql-syntax-strings-escape"/>) следует использовать, если приложению нужно, чтобы обратная косая воспринималась как спецсимвол.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-synchronize-seqscans" xreflabel="synchronize_seqscans">
      <term><varname>synchronize_seqscans</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>synchronize_seqscans</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр включает синхронизацию обращений при последовательном сканировании больших таблиц, чтобы эти операции читали один блок примерно в одно и то же время, и, таким образом, нагрузка разделялась между ними. Когда он включён, сканирование может начаться в середине таблицы, чтобы синхронизироваться со сканированием, которое уже выполняется. По достижении конца таблицы сканирование <quote>заворачивается</quote> к началу и завершает обработку пропущенных строк. Это может привести к непредсказуемому изменению порядка строк, возвращаемых запросами, в которых отсутствует предложение <literal>ORDER BY</literal>. Когда этот параметр выключен (имеет значение <literal>off</literal>), реализуется поведение, принятое до версии 8.3, когда последовательное сканирование всегда начиналось с начала таблицы. Значение по умолчанию — <literal>on</literal>.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-compatible-clients">
     <title>Совместимость с разными платформами и клиентами</title>
     <variablelist>

     <varlistentry id="guc-transform-null-equals" xreflabel="transform_null_equals">
      <term><varname>transform_null_equals</varname> (<type>boolean</type>) <indexterm><primary>IS NULL</primary></indexterm> <indexterm><primary>параметр конфигурации <varname>transform_null_equals</varname></primary></indexterm></term>
      <listitem>
       <para>Когда этот параметр включён, проверки вида <literal><replaceable>выражение</replaceable> = NULL</literal> (или <literal>NULL = <replaceable>выражение</replaceable></literal>) воспринимаются как <literal><replaceable>выражение</replaceable> IS NULL</literal>, то есть они истинны, если <replaceable>выражение</replaceable> даёт значение NULL, и ложны в противном случае. Согласно спецификации SQL, сравнение <literal><replaceable>выражение</replaceable> = NULL</literal> должно всегда возвращать NULL (неизвестное значение). Поэтому по умолчанию этот параметр выключен (равен <literal>off</literal>).</para>

       <para>Однако формы фильтров в <productname>Microsoft Access</productname> генерируют запросы, в которых проверка на значение NULL записывается как <literal><replaceable>выражение</replaceable> = NULL</literal>, так что если вы используете этот интерфейс для обращения к базе данных, имеет смысл включить данный параметр. Так как проверки вида <literal><replaceable>выражение</replaceable> = NULL</literal> всегда возвращают значение NULL (следуя правилам стандарта SQL), они не очень полезны и не должны встречаться в обычных приложениях, так что на практике от включения этого параметра не будет большого вреда. Однако начинающие пользователи часто путаются в семантике выражений со значениями NULL, поэтому по умолчанию этот параметр выключен.</para>

       <para>Заметьте, что этот параметр влияет только на точную форму сравнения <literal>= NULL</literal>, но не на другие операторы сравнения или выражения, результат которых может быть равнозначен сравнению с применением оператора равенства (например, конструкцию <literal>IN</literal>). Поэтому данный параметр не может быть универсальной защитой от плохих приёмов программирования.</para>

       <para>За сопутствующей информацией обратитесь к <xref remap="3" linkend="functions-comparison"/>.</para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-cfs">
    <title>Сжатие данных</title>

    <variablelist>

     <varlistentry id="guc-cfs-gc" xreflabel="cfs-gc">
      <term><varname>cfs_gc</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>cfs_gc</varname></primary></indexterm></term>
      <listitem>
       <para>Включает/отключает процесс сборки мусора в сжимаемых страницах. По умолчанию: <literal>on</literal> (вкл.)</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cfs-encryption" xreflabel="cfs-encryption">
      <term><varname>cfs_encryption</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>cfs_encryption</varname></primary></indexterm></term>
      <listitem>
       <para>Включает/отключает шифрование сжимаемых страниц. По умолчанию: <literal>off</literal> (откл.)</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cfs-gc-workers" xreflabel="cfs-gc-workers">
      <term><varname>cfs_gc_workers</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>cfs_gc_workers</varname></primary></indexterm></term>
      <listitem>
       <para>Число фоновых сборщиков мусора CFS. По умолчанию: 1</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cfs-level" xreflabel="cfs-level">
      <term><varname>cfs_level</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>cfs_level</varname></primary></indexterm></term>
      <listitem>
       <para>Уровень сжатия CFS: 0 &mdash; сжатие отсутствует, 1 &mdash; сжатие с максимальной скоростью. Другие возможные значения определяются алгоритмом сжатия. Например, для <literal>zlib</literal> максимум 9, а для <literal>zstd</literal> — 19. По умолчанию: 1</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cfs-gc-threshold" xreflabel="cfs-gc-threshold">
      <term><varname>cfs_gc_threshold</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>cfs_gc_threshold</varname></primary></indexterm></term>
      <listitem>
       <para>Минимальный процент «мусорных» блоков в файле, при котором начинается сборка мусора. По умолчанию: 50%</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cfs-gc-period" xreflabel="cfs-gc-period">
      <term><varname>cfs_gc_period</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>cfs_gc_period</varname></primary></indexterm></term>
      <listitem>
       <para>Интервал между итерациями процесса сборки мусора CFS (задаётся в миллисекундах). По умолчанию: 5 секунд</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cfs-gc-delay" xreflabel="cfs-gc-delay">
      <term><varname>cfs_gc_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>cfs_gc_delay</varname></primary></indexterm></term>
      <listitem>
       <para>Интервал времени, на который сборка мусора приостанавливается после дефрагментации каждого файла (в миллисекундах). По умолчанию: 0</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>

   <sect1 id="runtime-config-error-handling">
    <title>Обработка ошибок</title>

    <variablelist>

     <varlistentry id="guc-exit-on-error" xreflabel="exit_on_error">
      <term><varname>exit_on_error</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>exit_on_error</varname></primary></indexterm></term>
      <listitem>
       <para>Если этот параметр включён, любая ошибка приведёт к прерыванию текущего сеанса. По умолчанию он отключён, так что сеанс будет прерываться только при критических ошибках.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-restart-after-crash" xreflabel="restart_after_crash">
      <term><varname>restart_after_crash</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>restart_after_crash</varname></primary></indexterm></term>
      <listitem>
       <para>Когда этот параметр включён (это состояние по умолчанию), <productname>&productname;</productname> будет автоматически перезагружаться после сбоя серверного процесса. Такой вариант позволяет обеспечить максимальную степень доступности базы данных. Однако в некоторых обстоятельствах, например, когда <productname>&productname;</productname> управляется кластерным ПО, такую перезагрузку лучше отключить, чтобы кластерное ПО могло вмешаться и выполнить, возможно, более подходящие действия.</para>
      </listitem>
     </varlistentry>

    </variablelist>

   </sect1>

   <sect1 id="runtime-config-preset">
    <title>Предопределённые параметры</title>

    <para>Следующие <quote>параметры</quote> доступны только для чтения, их значения задаются при компиляции или при установке <productname>&productname;</productname>. По этой причине они исключены из примера файла <filename>postgresql.conf</filename>. Эти параметры сообщают различные аспекты поведения <productname>&productname;</productname>, которые могут быть интересны для определённых приложений, например, средств администрирования.</para>

    <variablelist>

     <varlistentry id="guc-block-size" xreflabel="block_size">
      <term><varname>block_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>block_size</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает размер блока на диске. Он определяется значением <literal>BLCKSZ</literal> при сборке сервера. Значение по умолчанию — 8192 байта. Значение <varname>block_size</varname> влияет на некоторые другие переменные конфигурации (например, <xref linkend="guc-shared-buffers"/>). Об этом говорится в <xref remap="6" linkend="runtime-config-resource"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-data-checksums" xreflabel="data_checksums">
      <term><varname>data_checksums</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>data_checksums</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает, включён ли в этом кластере контроль целостности данных. За дополнительными сведениями обратитесь к <xref remap="3" linkend="app-initdb-data-checksums"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-debug-assertions" xreflabel="debug_assertions">
      <term><varname>debug_assertions</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>debug_assertions</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает, был ли <productname>&productname;</productname> собран с проверочными утверждениями. Это имеет место, когда при сборке <productname>&productname;</productname> определён макрос <symbol>USE_ASSERT_CHECKING</symbol> (для этого нужно передать <command>configure</command> флаг <option>--enable-cassert</option>). По умолчанию <productname>&productname;</productname> собирается без проверочных утверждений.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-integer-datetimes" xreflabel="integer_datetimes">
      <term><varname>integer_datetimes</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>integer_datetimes</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает, был ли <productname>&productname;</productname> собран с поддержкой даты и времени в 64-битных целых. Эта поддержка отключается аргументом <literal>--disable-integer-datetimes</literal> при конфигурировании в процессе сборки <productname>&productname;</productname>. Значение по умолчанию — <literal>on</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-collate" xreflabel="lc_collate">
      <term><varname>lc_collate</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>lc_collate</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает локаль, по правилам которой выполняется сортировка текстовых данных. За дополнительными сведениями обратитесь к <xref remap="3" linkend="locale"/>. Это значение определяется при создании базы данных.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-ctype" xreflabel="lc_ctype">
      <term><varname>lc_ctype</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>lc_ctype</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает локаль, определяющую классификацию символов. За дополнительными сведениями обратитесь к <xref remap="3" linkend="locale"/>. Это значение определяется при создании базы данных. Обычно оно не отличается от <varname>lc_collate</varname>, но для некоторых приложений оно может быть определено по-другому.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-function-args" xreflabel="max_function_args">
      <term><varname>max_function_args</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_function_args</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает верхний предел для числа аргументов функции. Он определяется константой <literal>FUNC_MAX_ARGS</literal> при сборке сервера. По умолчанию установлен предел в 100 аргументов.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-identifier-length" xreflabel="max_identifier_length">
      <term><varname>max_identifier_length</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_identifier_length</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает максимальную длину идентификатора. Она определяется числом на 1 меньше, чем <literal>NAMEDATALEN</literal>, при сборке сервера. По умолчанию константа <literal>NAMEDATALEN</literal> равна 64; следовательно <varname>max_identifier_length</varname> по умолчанию равна 63 байтам, но число символов в многобайтной кодировке будет меньше.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-index-keys" xreflabel="max_index_keys">
      <term><varname>max_index_keys</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>max_index_keys</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает верхний предел для числа ключей индекса. Он определяется константой <literal>INDEX_MAX_KEYS</literal> при сборке сервера. По умолчанию установлен предел в 32 ключа.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-segment-size" xreflabel="segment_size">
      <term><varname>segment_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>segment_size</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает, сколько блоков (страниц) можно сохранить в одном файловом сегменте. Это число определяется константой <literal>RELSEG_SIZE</literal> при сборке сервера. Максимальный размер сегмента в файлах равен произведению <varname>segment_size</varname> и <varname>block_size</varname>; по умолчанию это 1 гигабайт.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-encoding" xreflabel="server_encoding">
      <term><varname>server_encoding</varname> (<type>string</type>) <indexterm><primary>параметр кодировки <varname>server_encoding</varname></primary></indexterm> <indexterm><primary>набор символов</primary></indexterm></term>
      <listitem>
       <para>Сообщает кодировку базы данных (набор символов). Она определяется при создании базы данных. Обычно клиентов должно интересовать только значение <xref linkend="guc-client-encoding"/>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-version" xreflabel="server_version">
      <term><varname>server_version</varname> (<type>string</type>) <indexterm><primary>параметр конфигурации <varname>server_version</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает номер версии сервера. Она определяется константой <literal>PG_VERSION</literal> при сборке сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-version-num" xreflabel="server_version_num">
      <term><varname>server_version_num</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>server_version_num</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает номер версии сервера в виде целого числа. Она определяется константой <literal>PG_VERSION_NUM</literal> при сборке сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-block-size" xreflabel="wal_block_size">
      <term><varname>wal_block_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_block_size</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает размер блока WAL на диске. Он определяется константой <literal>XLOG_BLCKSZ</literal> при сборке сервера. Значение по умолчанию — 8192 байта.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-segment-size" xreflabel="wal_segment_size">
      <term><varname>wal_segment_size</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>wal_segment_size</varname></primary></indexterm></term>
      <listitem>
       <para>Сообщает число блоков (страниц) в файле сегмента WAL. Общий размер файла сегмента WAL равняется произведению <varname>wal_segment_size</varname> и <varname>wal_block_size</varname>; по умолчанию это 16 мегабайт. За дополнительными сведениями обратитесь к <xref remap="3" linkend="wal-configuration"/>.</para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="runtime-config-custom">
    <title>Внесистемные параметры</title>

    <para>Поддержка внесистемных параметров была реализована, чтобы дополнительные модули (например, процедурные языки) могли добавлять собственные параметры, неизвестные серверу <productname>&productname;</productname>. Это позволяет единообразно настраивать модули расширения.</para>

    <para>Имена параметров расширений записываются следующим образом: имя расширения, точка и затем собственно имя параметра, подобно полным именам объектов в SQL. Например: <literal>plpgsql.variable_conflict</literal>.</para>

    <para>Так как внесистемные параметры могут быть установлены в процессах, не загружающих соответствующий модуль расширения, <productname>&productname;</productname> принимает значения для любых имён с двумя компонентами. Такие параметры воспринимаются как заготовки и не действуют до тех пор, пока не будет загружен определяющий их модуль. Когда модуль расширения загружается, он добавляет свои определения параметров и присваивает все заготовленные значения этим параметрам, либо выдаёт предупреждение, если начинающееся с имени данного расширения имя заготовленного параметра оказывается нераспознанным.</para>
   </sect1>

   <sect1 id="runtime-config-developer">
    <title>Параметры для разработчиков</title>

    <para>Следующие параметры предназначены для работы над исходным кодом <productname>&productname;</productname>, а в некоторых случаях они могут помочь восстановить сильно повреждённые базы данных. Для использования их в производственной среде не должно быть причин, поэтому они исключены из примера файла <filename>postgresql.conf</filename>. Заметьте, что для работы с многими из этих параметров требуются специальные флаги компиляции.</para>

    <variablelist>
     <varlistentry id="guc-allow-system-table-mods" xreflabel="allow_system_table_mods">
      <term><varname>allow_system_table_mods</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>allow_system_table_mods</varname></primary></indexterm></term>
      <listitem>
       <para>Разрешает модификацию структуры системных таблиц. Этот параметр используется командой <command>initdb</command>. Задать этот параметр можно только при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ignore-system-indexes" xreflabel="ignore_system_indexes">
      <term><varname>ignore_system_indexes</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>ignore_system_indexes</varname></primary></indexterm></term>
      <listitem>
       <para>Отключает использование индексов при чтении системных таблиц (при этом индексы всё же будут изменяться при записи в эти таблицы). Это полезно для восстановления работоспособности при повреждённых системных индексах. Этот параметр нельзя изменить после запуска сеанса.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-post-auth-delay" xreflabel="post_auth_delay">
      <term><varname>post_auth_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>post_auth_delay</varname></primary></indexterm></term>
      <listitem>
       <para>При ненулевом значении этот параметр задаёт задержку (в секундах) при запуске нового серверного процесса после выполнения процедуры аутентификации. Он предназначен для того, чтобы разработчики имели возможность подключить отладчик к серверному процессу. Этот параметр нельзя изменить после начала сеанса.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-pre-auth-delay" xreflabel="pre_auth_delay">
      <term><varname>pre_auth_delay</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>pre_auth_delay</varname></primary></indexterm></term>
      <listitem>
       <para>При ненулевом значении этот параметр задаёт задержку (в секундах), добавляемую сразу после порождения нового серверного процесса, до выполнения процедуры аутентификации. Он предназначен для того, чтобы разработчики имели возможность подключить отладчик к серверному процессу при решении проблем с аутентификацией. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-notify" xreflabel="trace_notify">
      <term><varname>trace_notify</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>trace_notify</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод очень подробной отладочной информации при выполнении команд <command>LISTEN</command> и <command>NOTIFY</command>. Чтобы эти сообщения передавались клиенту или в журнал сервера, параметр <xref linkend="guc-client-min-messages"/> или <xref linkend="guc-log-min-messages"/>, соответственно, должен иметь значение <literal>DEBUG1</literal> или ниже.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-recovery-messages" xreflabel="trace_recovery_messages">
      <term><varname>trace_recovery_messages</varname> (<type>enum</type>) <indexterm><primary>параметр конфигурации <varname>trace_recovery_messages</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод в журнал отладочных сообщений, связанных с восстановлением, которые иначе не выводятся. Этот параметр позволяет пользователю переопределить обычное значение <xref linkend="guc-log-min-messages"/>, но только для специфических сообщений. Он предназначен для отладки режима горячего резерва. Допустимые значения: <literal>DEBUG5</literal>, <literal>DEBUG4</literal>, <literal>DEBUG3</literal>, <literal>DEBUG2</literal>, <literal>DEBUG1</literal> и <literal>LOG</literal>. Значение по умолчанию, <literal>LOG</literal>, никак не влияет на запись этих сообщений в журнал. С другими значениями отладочные сообщения, связанные с восстановлением, имеющие заданный приоритет или выше, выводятся, как если бы они имели приоритет <literal>LOG</literal>; при стандартных значениях <varname>log_min_messages</varname> это означает, что они будут фиксироваться в журнале сервера. Задать этот параметр можно только в <filename>postgresql.conf</filename> или в командной строке при запуске сервера.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-sort" xreflabel="trace_sort">
      <term><varname>trace_sort</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>trace_sort</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод информации об использовании ресурсов во время операций сортировки. Этот параметр доступен, только если при сборке <productname>&productname;</productname> был определён макрос <symbol>TRACE_SORT</symbol>. (По умолчанию макрос <symbol>TRACE_SORT</symbol> определён.)</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_locks</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>trace_locks</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод подробной информации о блокировках. Она содержит вид операции блокировки, тип блокировки и уникальный идентификатор объекта, который блокируется или разблокируется. Кроме того, в её составе выводятся битовые маски для типов блокировок, уже полученных для данного объекта, и для типов блокировок, ожидающих его освобождения. В дополнение к этому выводится количество полученных и ожидающих блокировок для каждого типа блокировок, а также их общее количество. Ниже показан пример вывода в журнал: <screen>
LOG:  LockAcquire: new: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  GrantLock: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(2) req(1,0,0,0,0,0,0)=1 grant(1,0,0,0,0,0,0)=1
      wait(0) type(AccessShareLock)
LOG:  UnGrantLock: updated: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  CleanUpLock: deleting: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(INVALID)
</screen> Подробнее о структуре выводимой информации можно узнать в <filename>src/include/storage/lock.h</filename>.</para>
       <para>Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>LOCK_DEBUG</symbol>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_lwlocks</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>trace_lwlocks</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод информации об использовании легковесных блокировок. Такие блокировки предназначены в основном для взаимоисключающего доступа к общим структурам данных в памяти.</para>
       <para>Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>LOCK_DEBUG</symbol>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_userlocks</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>trace_userlocks</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод информации об использовании пользовательских блокировок. Она выводится в том же формате, что и с <symbol>trace_locks</symbol>, но по рекомендательным блокировкам.</para>
       <para>Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>LOCK_DEBUG</symbol>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_lock_oidmin</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>trace_lock_oidmin</varname></primary></indexterm></term>
      <listitem>
       <para>Если этот параметр установлен, при трассировке блокировок не будут отслеживаться таблицы с OID меньше заданного (это используется для исключения из трассировки системных таблиц).</para>
       <para>Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>LOCK_DEBUG</symbol>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_lock_table</varname> (<type>integer</type>) <indexterm><primary>параметр конфигурации <varname>trace_lock_table</varname></primary></indexterm></term>
      <listitem>
       <para>Безусловно трассировать блокировки для таблицы с заданным OID.</para>
       <para>Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>LOCK_DEBUG</symbol>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>debug_deadlocks</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>debug_deadlocks</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод информации обо всех текущих блокировках при тайм-ауте взаимоблокировки.</para>
       <para>Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>LOCK_DEBUG</symbol>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_btree_build_stats</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>log_btree_build_stats</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод статистики использования системных ресурсов (памяти и процессора) при различных операциях с B-деревом.</para>
       <para>Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>BTREE_BUILD_STATS</symbol>.</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-debug" xreflabel="wal_debug">
      <term><varname>wal_debug</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>wal_debug</varname></primary></indexterm></term>
      <listitem>
       <para>Включает вывод отладочной информации, связанной с WAL. Этот параметр доступен, только если при компиляции <productname>&productname;</productname> был определён макрос <symbol>WAL_DEBUG</symbol>.</para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-ignore-checksum-failure" xreflabel="ignore_checksum_failure">
      <term><varname>ignore_checksum_failure</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>ignore_checksum_failure</varname></primary></indexterm></term>
      <listitem>
       <para>Этот параметр действует, только если включён <xref linkend="app-initdb-data-checksums"/>.</para>
       <para>При обнаружении ошибок контрольных сумм при чтении <productname>&productname;</productname> обычно сообщает об ошибке и прерывает текущую транзакцию. Если параметр <varname>ignore_checksum_failure</varname> включён, система игнорирует проблему (но всё же предупреждает о ней) и продолжает обработку. Это поведение может <emphasis>привести к краху, распространению или сокрытию повреждения данных и другим серьёзными проблемам</emphasis>. Однако, включив его, вы можете обойти ошибку и получить неповреждённые данные, которые могут находиться в таблице, если цел заголовок блока. Если же повреждён заголовок, будет выдана ошибка, даже когда этот параметр включён. По умолчанию этот параметр отключён (имеет значение <literal>off</literal>) и изменить его состояние может только суперпользователь.</para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-zero-damaged-pages" xreflabel="zero_damaged_pages">
      <term><varname>zero_damaged_pages</varname> (<type>boolean</type>) <indexterm><primary>параметр конфигурации <varname>zero_damaged_pages</varname></primary></indexterm></term>
      <listitem>
       <para>При выявлении повреждённого заголовка страницы <productname>&productname;</productname> обычно сообщает об ошибке и прерывает текущую транзакцию. Если параметр <varname>zero_damaged_pages</varname> включён, вместо этого система выдаёт предупреждение, обнуляет повреждённую страницу в памяти и продолжает обработку. Это поведение <emphasis>разрушает данные</emphasis>, а именно все строки в повреждённой странице. Однако, включив его, вы можете обойти ошибку и получить строки из неповреждённых страниц, которые могут находиться в таблице. Это бывает полезно для восстановления данных, испорченных в результате аппаратной или программной ошибки. Обычно включать его следует только тогда, когда не осталось никакой другой надежды на восстановление данных в повреждённых страницах таблицы. Обнулённые страницы не сохраняются на диск, поэтому прежде чем выключать этот параметр, рекомендуется пересоздать проблемные таблицы или индексы. По умолчанию этот параметр отключён (имеет значение <literal>off</literal>) и изменить его состояние может только суперпользователь.</para>
      </listitem>
     </varlistentry>
   </variablelist>
  </sect1>
  <sect1 id="runtime-config-short">
   <title>Краткие аргументы</title>

   <para>Для удобства с некоторыми параметрами сопоставлены однобуквенные аргументы командной строки. Все они описаны в <xref remap="6" linkend="runtime-config-short-table"/>. Некоторые из этих сопоставлений существуют по историческим причинам, так что наличие однобуквенного синонима не обязательно является признаком того, что этот аргумент часто используется.</para>

    <table id="runtime-config-short-table">
     <title>Ключ краткого аргумента</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Краткий аргумент</entry>
        <entry>Эквивалент</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><option>-B <replaceable>x</replaceable></option></entry>
        <entry><literal>shared_buffers = <replaceable>x</replaceable></literal></entry>
       </row>
       <row>
        <entry><option>-d <replaceable>x</replaceable></option></entry>
        <entry><literal>log_min_messages = DEBUG<replaceable>x</replaceable></literal></entry>
       </row>
       <row>
        <entry><option>-e</option></entry>
        <entry><literal>datestyle = euro</literal></entry>
       </row>
       <row>
        <entry><option>-fb</option>, <option>-fh</option>, <option>-fi</option>, <option>-fm</option>, <option>-fn</option>, <option>-fo</option>, <option>-fs</option>, <option>-ft</option></entry>
         <entry><literal>enable_bitmapscan = off</literal>, <literal>enable_hashjoin = off</literal>, <literal>enable_indexscan = off</literal>, <literal>enable_mergejoin = off</literal>, <literal>enable_nestloop = off</literal>, <literal>enable_indexonlyscan = off</literal>, <literal>enable_seqscan = off</literal>, <literal>enable_tidscan = off</literal></entry>
       </row>
       <row>
        <entry><option>-F</option></entry>
        <entry><literal>fsync = off</literal></entry>
       </row>
       <row>
        <entry><option>-h <replaceable>x</replaceable></option></entry>
        <entry><literal>listen_addresses = <replaceable>x</replaceable></literal></entry>
       </row>
       <row>
        <entry><option>-i</option></entry>
        <entry><literal>listen_addresses = '*'</literal></entry>
       </row>
       <row>
        <entry><option>-k <replaceable>x</replaceable></option></entry>
        <entry><literal>unix_socket_directories = <replaceable>x</replaceable></literal></entry>
       </row>
       <row>
        <entry><option>-l</option></entry>
        <entry><literal>ssl = on</literal></entry>
       </row>
       <row>
        <entry><option>-N <replaceable>x</replaceable></option></entry>
        <entry><literal>max_connections = <replaceable>x</replaceable></literal></entry>
       </row>
       <row>
        <entry><option>-O</option></entry>
        <entry><literal>allow_system_table_mods = on</literal></entry>
       </row>
       <row>
        <entry><option>-p <replaceable>x</replaceable></option></entry>
        <entry><literal>port = <replaceable>x</replaceable></literal></entry>
       </row>
       <row>
        <entry><option>-P</option></entry>
        <entry><literal>ignore_system_indexes = on</literal></entry>
       </row>
       <row>
        <entry><option>-s</option></entry>
        <entry><literal>log_statement_stats = on</literal></entry>
       </row>
       <row>
        <entry><option>-S <replaceable>x</replaceable></option></entry>
        <entry><literal>work_mem = <replaceable>x</replaceable></literal></entry>
       </row>
       <row>
        <entry><option>-tpa</option>, <option>-tpl</option>, <option>-te</option></entry>
        <entry><literal>log_parser_stats = on</literal>, <literal>log_planner_stats = on</literal>, <literal>log_executor_stats = on</literal></entry>
       </row>
       <row>
        <entry><option>-W <replaceable>x</replaceable></option></entry>
        <entry><literal>post_auth_delay = <replaceable>x</replaceable></literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>
</chapter>
