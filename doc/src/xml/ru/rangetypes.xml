<!-- doc/src/xml/rangetypes.xml -->

<sect1 id="rangetypes">
 <title>Диапазонные типы</title>

 <indexterm><primary>диапазонный тип</primary></indexterm>

 <para>Диапазонные типы представляют диапазоны значений некоторого типа данных (он также называется <firstterm>подтипом</firstterm> диапазона). Например, диапазон типа <type>timestamp</type> может представлять временной интервал, когда зарезервирован зал заседаний. В данном случае типом данных будет <type>tsrange</type> (сокращение от <quote>timestamp range</quote>), а подтипом &mdash; <type>timestamp</type>. Подтип должен быть полностью упорядочиваемым, чтобы можно было однозначно определить, где находится значение по отношению к диапазону: внутри, до или после него.</para>

 <para>Диапазонные типы полезны тем, что позволяют представить множество возможных значений в одной структуре данных и чётко выразить такие понятия, как пересечение диапазонов. Наиболее очевидный вариант их использования &mdash; применять диапазоны даты и времени для составления расписания, но также полезными могут оказаться диапазоны цен, интервалы измерений и т. д.</para>

 <sect2 id="rangetypes-builtin">
  <title>Встроенные диапазонные типы</title>

 <para>&productname; имеет следующие встроенные диапазонные типы: <itemizedlist>
    <listitem>
      <para><type>int4range</type> &mdash; диапазон подтипа <type>integer</type></para>
    </listitem>
    <listitem>
      <para><type>int8range</type> &mdash; диапазон подтипа <type>bigint</type></para>
    </listitem>
    <listitem>
      <para><type>numrange</type> &mdash; диапазон подтипа <type>numeric</type></para>
    </listitem>
    <listitem>
      <para><type>tsrange</type> &mdash; диапазон подтипа <type>timestamp without time zone</type></para>
    </listitem>
    <listitem>
      <para><type>tstzrange</type> &mdash; диапазон подтипа <type>timestamp with time zone</type></para>
    </listitem>
    <listitem>
      <para><type>daterange</type> &mdash; диапазон подтипа <type>date</type></para>
    </listitem>
  </itemizedlist> Помимо этого, вы можете определять собственные типы; подробнее это описано в <xref remap="6" linkend="sql-createtype"/>.</para>
 </sect2>

 <sect2 id="rangetypes-examples">
  <title>Примеры</title>

  <para><programlisting>CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');

-- Вхождение
SELECT int4range(10, 20) @&gt; 3;

-- Перекрытие
SELECT numrange(11.1, 22.2) &amp;&amp; numrange(20.0, 30.0);

-- Получение верхней границы
SELECT upper(int8range(15, 25));

-- Вычисление пересечения
SELECT int4range(10, 20) * int4range(15, 25);

-- Является ли диапазон пустым?
SELECT isempty(numrange(1, 5));</programlisting> Полный список операторов и функций, предназначенных для диапазонных типов, приведён в <xref remap="6" linkend="range-operators-table"/> и <xref remap="6" linkend="range-functions-table"/>.</para>
 </sect2>

 <sect2 id="rangetypes-inclusivity">
  <title>Включение и исключение границ</title>

  <para>Любой непустой диапазон имеет две границы, верхнюю и нижнюю, и включает все точки между этими значениями. В него также может входить точка, лежащая на границе, если диапазон включает эту границу. И наоборот, если диапазон не включает границу, считается, что точка, лежащая на этой границе, в него не входит.</para>

  <para>В текстовой записи диапазона включение нижней границы обозначается символом <quote><literal>[</literal></quote>, а исключением &mdash; символом <quote><literal>(</literal></quote>. Для верхней границы включение обозначается аналогично, символом <quote><literal>]</literal></quote>, а исключение &mdash; символом <quote><literal>)</literal></quote>. (Подробнее это описано в <xref remap="6" linkend="rangetypes-io"/>.)</para>

  <para>Для проверки, включается ли нижняя или верхняя граница в диапазон, предназначены функции <literal>lower_inc</literal> и <literal>upper_inc</literal>, соответственно.</para>
 </sect2>

 <sect2 id="rangetypes-infinite">
  <title>Неограниченные (бесконечные) диапазоны</title>

  <para>Нижнюю границу диапазона можно опустить и определить тем самым диапазон, включающий все точки, лежащие ниже верхней границы. Подобным образом, если не определить верхнюю границу, в диапазон войдут все точки, лежащие выше нижней границы. Если же опущена и нижняя, и правая границы, такой диапазон будет включать все возможные значения своего подтипа.</para>

  <para>Это равнозначно тому, что нижней границей будет считаться <quote>минус бесконечность</quote>, а верхней &mdash; <quote>плюс бесконечность</quote>. Но заметьте, что эти бесконечные значения не являются значениями подтипа диапазона и поэтому также не могут входить в диапазон. (Как следствие, нет такого понятия, как включаемая нижняя бесконечная граница &mdash; если попытаться записать такой диапазон, она будет автоматически преобразована в исключаемую.)</para>

  <para>Кроме этого, в некоторых типах есть понятие <quote>бесконечность</quote>, но в данном контексте оно считается просто одним из значений. Например, во временных диапазонах <literal>[today,]</literal> означает то же самое, что и <literal>[today,)</literal>. Но диапазон <literal>[today,infinity]</literal> отличается от <literal>[today,infinity)</literal> &mdash; в последнем специальное значение <literal>infinity</literal> типа <type>timestamp</type> не входит в диапазон.</para>

  <para>Проверить, определена ли верхняя или нижняя граница, можно с помощью функций <literal>lower_inf</literal> и <literal>upper_inf</literal>, соответственно.</para>
 </sect2>

 <sect2 id="rangetypes-io">
  <title>Ввод/вывод диапазонов</title>

  <para>Вводимое значение диапазона должно записываться в одной из следующих форм: <synopsis>
(<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</replaceable>)
(<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</replaceable>]
[<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</replaceable>)
[<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</replaceable>]
empty
</synopsis> Тип скобок (квадратные или круглые) определяет, включаются ли в диапазон соответствующие границы, как описано выше. Заметьте, что последняя форма содержит только слово <literal>empty</literal> и определяет пустой диапазон (диапазон, не содержащий точек).</para>

  <para>Здесь <replaceable>нижняя-граница</replaceable> может быть строкой с допустимым значением подтипа или быть пустой (тогда диапазон будет без нижней границы). Аналогично, <replaceable>верхняя-граница</replaceable> может задаваться одним из значений подтипа или быть неопределённой (пустой).</para>

  <para>Любое значение диапазона можно заключить в кавычки (<literal>"</literal>). А если значение содержит круглые или квадратные скобки, запятые, кавычки или обратную косую черту, использовать кавычки необходимо, чтобы эти символы не рассматривались как часть синтаксиса диапазона. Чтобы включить в значение диапазона, заключённое в кавычки, такие символы, как кавычки или обратная косая черта, перед ними нужно добавить обратную косую черту. (Кроме того, продублированные кавычки в значении диапазона, заключённого в кавычки, воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой стороны, можно обойтись без кавычек, защитив все символы в данных, которые могут быть восприняты как часть синтаксиса диапазона, с помощью спецпоследовательностей. Чтобы задать в качестве границы пустую строку, нужно ввести <literal>""</literal>, так как пустая строка без кавычек будет означать отсутствие границы.</para>

  <para>Пробельные символы до и после определения диапазона игнорируются, но когда они присутствуют внутри скобок, они воспринимаются как часть значения верхней или нижней границы. (Хотя они могут также игнорироваться в зависимости от подтипа диапазона.)</para>

  <note>
   <para>Эти правила очень похожи на правила записи значений для полей составных типов. Дополнительные замечания приведены в <xref remap="6" linkend="rowtypes-io-syntax"/>.</para>
  </note>

  <para>Примеры: <programlisting>-- в диапазон включается 3, не включается 7 и включаются все точки между ними
SELECT '[3,7)'::int4range;

-- в диапазон не включаются 3 и 7, но включаются все точки между ними
SELECT '(3,7)'::int4range;

-- в диапазон включается только одно значение 4
SELECT '[4,4]'::int4range;

-- диапазон не включает никаких точек (нормализация заменит его определение
--  на 'empty')
SELECT '[4,4)'::int4range;</programlisting></para>
 </sect2>

 <sect2 id="rangetypes-construct">
  <title>Конструирование диапазонов</title>

  <para>Для каждого диапазонного типа определена функция конструктора, имеющая то же имя, что и данный тип. Использовать этот конструктор обычно удобнее, чем записывать текстовую константу диапазона, так как это избавляет от потребности в дополнительных кавычках. Функция конструктора может принимать два или три параметра. Вариант с двумя параметрами создаёт диапазон в стандартной форме (нижняя граница включается, верхняя исключается), тогда как для варианта с тремя параметрами включение границ определяется третьим параметром. Третий параметр должен содержать одну из строк: <quote><literal>()</literal></quote>, <quote><literal>(]</literal></quote>, <quote><literal>[)</literal></quote> или <quote><literal>[]</literal></quote>. Например: <programlisting>-- Полная форма: нижняя граница, верхняя граница и текстовая строка, определяющая
-- включение/исключение границ.
SELECT numrange(1.0, 14.0, '(]');

-- Если третий аргумент опущен, подразумевается '[)'.
SELECT numrange(1.0, 14.0);

-- Хотя здесь указывается '(]', при выводе значение будет приведено к
-- каноническому виду, так как int8range &mdash; тип дискретного диапазона (см. ниже).
SELECT int8range(1, 14, '(]');

-- Когда вместо любой границы указывается NULL, соответствующей границы
--  у диапазона не будет.
SELECT numrange(NULL, 2.2);</programlisting></para>
 </sect2>

 <sect2 id="rangetypes-discrete">
  <title>Типы дискретных диапазонов</title>

  <para>Дискретным диапазоном считается диапазон, для подтипа которого однозначно определён <quote>шаг</quote>, как например для типов <type>integer</type> и <type>date</type>. Значения этих двух типов можно назвать соседними, когда между ними нет никаких других значений. В непрерывных диапазонах, напротив, всегда (или почти всегда) можно найти ещё одно значение между двумя данными. Например, непрерывным диапазоном будет диапазон с подтипами <type>numeric</type> и <type>timestamp</type>. (Хотя <type>timestamp</type> имеет ограниченную точность, то есть теоретически он является дискретным, но всё же лучше считать его непрерывным, так как шаг его обычно не определён.)</para>

  <para>Можно также считать дискретным подтип диапазона, в котором чётко определены понятия <quote>следующего</quote> и <quote>предыдущего</quote> элемента для каждого значения. Такие определения позволяют преобразовывать границы диапазона из включаемых в исключаемые, выбирая следующий или предыдущий элемент вместо заданного значения. Например, диапазоны целочисленного типа <literal>[4,8]</literal> и <literal>(3,9)</literal> описывают одно и то же множество значений; но для диапазона подтипа numeric это не так.</para>

  <para>Для типа дискретного диапазона определяется функция <firstterm>канонизации</firstterm>, учитывающая размер шага для данного подтипа. Задача этой функции &mdash; преобразовать равнозначные диапазоны к единственному представлению, в частности нормализовать включаемые и исключаемые границы. Если функция канонизации не определена, диапазоны с различным определением будут всегда считаться разными, даже когда они на самом деле представляют одно множество значений.</para>

  <para>Для встроенных типов <type>int4range</type>, <type>int8range</type> и <type>daterange</type> каноническое представление включает нижнюю границу и не включает верхнюю; то есть диапазон приводится к виду <literal>[)</literal>. Однако для нестандартных типов можно использовать и другие соглашения.</para>
 </sect2>

 <sect2 id="rangetypes-defining">
  <title>Определение новых диапазонных типов</title>

  <para>Пользователи могут определять собственные диапазонные типы. Это может быть полезно, когда нужно использовать диапазоны с подтипами, для которых нет встроенных диапазонных типов. Например, можно определить новый тип диапазона для подтипа <type>float8</type>: <programlisting>CREATE TYPE floatrange AS RANGE (
    subtype = float8,
    subtype_diff = float8mi
);

SELECT '[1.234, 5.678]'::floatrange;</programlisting> Так как для <type>float8</type> осмысленное значение <quote>шага</quote> не определено, функция канонизации в данном примере не задаётся.</para>

  <para>Определяя собственный диапазонный тип, вы также можете выбрать другие правила сортировки или класс оператора B-дерева для его подтипа, что позволит изменить порядок значений, от которого зависит, какие значения попадают в заданный диапазон.</para>

  <para>Если подтип можно рассматривать как дискретный, а не непрерывный, в команде <command>CREATE TYPE</command> следует также задать функцию <literal>канонизации</literal>. Этой функции будет передаваться значение диапазона, а она должна вернуть равнозначное значение, но, возможно, с другими границами и форматированием. Для двух диапазонов, представляющих одно множество значений, например, целочисленные диапазоны <literal>[1, 7]</literal> и <literal>[1, 8)</literal>, функция канонизации должна выдавать один результат. Какое именно представление будет считаться каноническим, не имеет значения &mdash; главное, чтобы два равнозначных диапазона, отформатированных по-разному, всегда преобразовывались в одно значение с одинаковым форматированием. Помимо исправления формата включаемых/исключаемых границ, функция канонизации может округлять значения границ, если размер шага превышает точность хранения подтипа. Например, в типе диапазона для подтипа <type>timestamp</type> можно определить размер шага, равный часу, тогда функция канонизации должна будет округлить границы, заданные, например с точностью до минут, либо вместо этого выдать ошибку.</para>

  <para>Помимо этого, для любого диапазонного типа, ориентированного на использование с индексами GiST или SP-GiST, должна быть определена разница значений подтипов, функция <literal>subtype_diff</literal>. (Индекс сможет работать и без <literal>subtype_diff</literal>, но в большинстве случаев это будет не так эффективно.) Эта функция принимает на вход два значения подтипа и возвращает их разницу (т. е. <replaceable>X</replaceable> минус <replaceable>Y</replaceable>) в значении типа <type>float8</type>. В показанном выше примере может использоваться функция <function>float8mi</function>, определяющая нижележащую реализацию обычного оператора <quote>минус</quote> для типа <type>float8</type>, но для другого подтипа могут потребоваться дополнительные преобразования. Иногда для представления разницы в числовом виде требуется ещё и творческий подход. Функция <literal>subtype_diff</literal>, насколько это возможно, должна быть согласована с порядком сортировки, вытекающим из выбранных правил сортировки и класса оператора; то есть, её результат должен быть положительным, если согласно порядку сортировки первый её аргумент больше второго.</para>

  <para>Ещё один, не столь тривиальный пример функции <literal>subtype_diff</literal>:</para>

<programlisting>CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS
'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;

CREATE TYPE timerange AS RANGE (
    subtype = time,
    subtype_diff = time_subtype_diff
);

SELECT '[11:10, 23:00]'::timerange;</programlisting>

  <para>Дополнительные сведения о создании диапазонных типов можно найти в описании <xref linkend="sql-createtype"/>.</para>
 </sect2>

 <sect2 id="rangetypes-indexing">
  <title>Индексация</title>

  <indexterm><primary>диапазонный тип</primary> <secondary>индексы</secondary></indexterm>

  <para>Для столбцов, имеющих диапазонный тип, можно создать индексы GiST и SP-GiST. Например, так создаётся индекс GiST: <programlisting>CREATE INDEX reservation_idx ON reservation USING GIST (during);</programlisting> Индекс GiST или SP-GiST помогает ускорить запросы со следующими операторами: <literal>=</literal>, <literal>&amp;&amp;</literal>, <literal>&lt;@</literal>, <literal>@&gt;</literal>, <literal>&lt;&lt;</literal>, <literal>&gt;&gt;</literal>, <literal>-|-</literal>, <literal>&amp;&lt;</literal> и <literal>&amp;&gt;</literal> (дополнительно о них можно узнать в <xref remap="6" linkend="range-operators-table"/>.</para>

  <para>Кроме того, для таких столбцов можно создать индексы на основе хеша и B-деревьев. Для индексов таких типов полезен по сути только один оператор диапазона &mdash; равно. Порядок сортировки B-дерева определяется для значений диапазона соответствующими операторами <literal>&lt;</literal> и <literal>&gt;</literal>, но этот порядок может быть произвольным и он не очень важен в реальном мире. Поддержка B-деревьев и хешей диапазонными типами нужна в основном для сортировки и хеширования при выполнении запросов, но не для создания самих индексов.</para>
 </sect2>

 <sect2 id="rangetypes-constraint">
  <title>Ограничения для диапазонов</title>

  <indexterm><primary>диапазонный тип</primary> <secondary>исключение</secondary></indexterm>

  <para>Тогда как для скалярных значений естественным ограничением является <literal>UNIQUE</literal>, оно обычно не подходит для диапазонных типов. Вместо этого чаще оказываются полезнее ограничения-исключения (см. <link linkend="sql-createtable-exclude">CREATE TABLE ... CONSTRAINT ... EXCLUDE</link>). Такие ограничения позволяют, например определить условие <quote>непересечения</quote> диапазонов. Например: <programlisting>CREATE TABLE reservation (
    during tsrange,
    EXCLUDE USING GIST (during WITH &amp;&amp;)
);</programlisting> Это ограничение не позволит одновременно сохранить в таблице несколько диапазонов, которые накладываются друг на друга: <programlisting>INSERT INTO reservation VALUES
    ('[2010-01-01 11:30, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO reservation VALUES
    ('[2010-01-01 14:45, 2010-01-01 15:45)');
ОШИБКА:  конфликтующее значение ключа нарушает ограничение-исключение "reservation_during_excl"
ПОДРОБНОСТИ: Ключ (during)=(["2010-01-01 14:45:00","2010-01-01 15:45:00"))
конфликтует с существующим ключом (during)=(["2010-01-01 11:30:00","2010-01-01 15:00:00"))</programlisting></para>

  <para>Для максимальной гибкости в ограничении-исключении можно сочетать простые скалярные типы данных с диапазонами, используя расширение <link linkend="btree-gist"><literal>btree_gist</literal></link>. Например, если <literal>btree_gist</literal> установлено, следующее ограничение не будет допускать пересекающиеся диапазоны, только если совпадают также и номера комнат: <programlisting>CREATE EXTENSION btree_gist;
CREATE TABLE room_reservation (
    room text,
    during tsrange,
    EXCLUDE USING GIST (room WITH =, during WITH &amp;&amp;)
);

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');
ОШИБКА:  конфликтующее значение ключа нарушает ограничение-исключение
  "room_reservation_room_during_excl"
ПОДРОБНОСТИ:  Ключ (room, during)=(123A, [ 2010-01-01 14:30:00,
  2010-01-01 15:30:00 )) конфликтует
с существующим ключом (room, during)=(123A, ["2010-01-01 14:00:00","2010-01-01 15:00:00")).

INSERT INTO room_reservation VALUES
    ('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');
INSERT 0 1</programlisting></para>
 </sect2>
</sect1>
