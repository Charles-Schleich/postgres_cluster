<!-- doc/src/xml/intarray.xml -->

<sect1 id="intarray" xreflabel="intarray">
 <title>intarray</title>

 <indexterm zone="intarray"><primary>intarray</primary></indexterm>

 <para>Модуль <filename>intarray</filename> предоставляет ряд полезных функций и операторов для работы с массивами целых чисел без NULL. Также он поддерживает поиск по индексу для некоторых из этих операторов.</para>

 <para>Все эти операции выдают ошибку, если в передаваемом массиве оказываются значения NULL.</para>

 <para>Многие из этих операций имеют смысл только с одномерными массивами. Хоти им можно передать входной массив и большей размерности, значения будут считываться из него как из линейного массива в порядке хранения.</para>

 <sect2>
  <title>Функции и операторы <filename>intarray</filename></title>

  <para>Реализованные в модуле <filename>intarray</filename> функции перечислены в <xref remap="6" linkend="intarray-func-table"/>, а операторы — в <xref remap="6" linkend="intarray-op-table"/>.</para>

  <table id="intarray-func-table">
   <title>Функции <filename>intarray</filename></title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>Функция</entry>
      <entry>Тип результата</entry>
      <entry>Описание</entry>
      <entry>Пример</entry>
      <entry>Результат</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><function>icount(int[])</function><indexterm><primary>icount</primary></indexterm></entry>
      <entry><type>int</type></entry>
      <entry>число элементов в массиве</entry>
      <entry><literal>icount('{1,2,3}'::int[])</literal></entry>
      <entry><literal>3</literal></entry>
     </row>

     <row>
      <entry><function>sort(int[], text dir)</function><indexterm><primary>sort</primary></indexterm></entry>
      <entry><type>int[]</type></entry>
      <entry>сортирует массив &mdash; в <parameter>dir</parameter> должно задаваться <literal>asc</literal> (по возрастанию) или <literal>desc</literal> (по убыванию)</entry>
      <entry><literal>sort('{1,2,3}'::int[], 'desc')</literal></entry>
      <entry><literal>{3,2,1}</literal></entry>
     </row>

     <row>
      <entry><function>sort(int[])</function></entry>
      <entry><type>int[]</type></entry>
      <entry>сортирует в порядке возрастания</entry>
      <entry><literal>sort(array[11,77,44])</literal></entry>
      <entry><literal>{11,44,77}</literal></entry>
     </row>

     <row>
      <entry><function>sort_asc(int[])</function><indexterm><primary>sort_asc</primary></indexterm></entry>
      <entry><type>int[]</type></entry>
      <entry>сортирует в порядке возрастания</entry>
      <entry><literal/></entry>
      <entry><literal/></entry>
     </row>

     <row>
      <entry><function>sort_desc(int[])</function><indexterm><primary>sort_desc</primary></indexterm></entry>
      <entry><type>int[]</type></entry>
      <entry>сортирует в порядке убывания</entry>
      <entry><literal/></entry>
      <entry><literal/></entry>
     </row>

     <row>
      <entry><function>uniq(int[])</function><indexterm><primary>uniq</primary></indexterm></entry>
      <entry><type>int[]</type></entry>
      <entry>удаляет дубликаты</entry>
      <entry><literal>uniq(sort('{1,2,3,2,1}'::int[]))</literal></entry>
      <entry><literal>{1,2,3}</literal></entry>
     </row>

     <row>
      <entry><function>idx(int[], int item)</function><indexterm><primary>idx</primary></indexterm></entry>
      <entry><type>int</type></entry>
      <entry>индекс первого элемента, равного <parameter>item</parameter> (0, если такого нет)</entry>
      <entry><literal>idx(array[11,22,33,22,11], 22)</literal></entry>
      <entry><literal>2</literal></entry>
     </row>

     <row>
      <entry><function>subarray(int[], int start, int len)</function><indexterm><primary>subarray</primary></indexterm></entry>
      <entry><type>int[]</type></entry>
      <entry>часть массива, начинающаяся с позиции <parameter>start</parameter> и состоящая из <parameter>len</parameter> элементов</entry>
      <entry><literal>subarray('{1,2,3,2,1}'::int[], 2, 3)</literal></entry>
      <entry><literal>{2,3,2}</literal></entry>
     </row>

     <row>
      <entry><function>subarray(int[], int start)</function></entry>
      <entry><type>int[]</type></entry>
      <entry>часть массива, начинающаяся с позиции <parameter>start</parameter></entry>
      <entry><literal>subarray('{1,2,3,2,1}'::int[], 2)</literal></entry>
      <entry><literal>{2,3,2,1}</literal></entry>
     </row>

     <row>
      <entry><function>intset(int)</function><indexterm><primary>intset</primary></indexterm></entry>
      <entry><type>int[]</type></entry>
      <entry>создаёт массив с одним элементом</entry>
      <entry><literal>intset(42)</literal></entry>
      <entry><literal>{42}</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="intarray-op-table">
   <title>Операторы <filename>intarray</filename></title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Оператор</entry>
      <entry>Возвращает</entry>
      <entry>Описание</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>int[] &amp;&amp; int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>пересекается с &mdash; <literal>true</literal>, если массивы имеют минимум один общий элемент</entry>
     </row>
     <row>
      <entry><literal>int[] @&gt; int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>включает &mdash; <literal>true</literal>, если левый массив содержит правый массив</entry>
     </row>
     <row>
      <entry><literal>int[] &lt;@ int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry>включается в &mdash; <literal>true</literal>, если левый массив содержится в правом массиве</entry>
     </row>
     <row>
      <entry><literal># int[]</literal></entry>
      <entry><type>int</type></entry>
      <entry>число элементов в массиве</entry>
     </row>
     <row>
      <entry><literal>int[] # int</literal></entry>
      <entry><type>int</type></entry>
      <entry>индекс элемента (делает то же, что и функция <function>idx</function>)</entry>
     </row>
     <row>
      <entry><literal>int[] + int</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>вставляет элемент в массив (добавляет его в конец массива)</entry>
     </row>
     <row>
      <entry><literal>int[] + int[]</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>соединяет массивы (правый массив добавляется в конец левого)</entry>
     </row>
     <row>
      <entry><literal>int[] - int</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>удаляет из массива записи, равные правому аргументу</entry>
     </row>
     <row>
      <entry><literal>int[] - int[]</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>удаляет из левого массива элементы правого массива</entry>
     </row>
     <row>
      <entry><literal>int[] | int</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>объединение аргументов</entry>
     </row>
     <row>
      <entry><literal>int[] | int[]</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>объединение массивов</entry>
     </row>
     <row>
      <entry><literal>int[] &amp; int[]</literal></entry>
      <entry><type>int[]</type></entry>
      <entry>пересечение массивов</entry>
     </row>
     <row>
      <entry><literal>int[] @@ query_int</literal></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal>, если массив удовлетворяет запросу (см. ниже)</entry>
     </row>
     <row>
      <entry><literal>query_int ~~ int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal>, если запросу удовлетворяет массив (коммутирующий оператор к <literal>@@</literal>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>(До версии PostgreSQL 8.2 операторы включения <literal>@&gt;</literal> и <literal>&lt;@</literal> обозначались соответственно как <literal>@</literal> и <literal>~</literal>. Эти имена по-прежнему действуют, но считаются устаревшими и в конце концов будут упразднены. Заметьте, что старые имена произошли из соглашения, которому раньше следовали ключевые геометрические типы данных!)</para>

  <para>Операторы <literal>&amp;&amp;</literal>, <literal>@&gt;</literal> и <literal>&lt;@</literal> равнозначны встроенным операторам <productname>&productname;</productname> с теми же именами, за исключением того, что они работают только с целочисленными массивами, не содержащими NULL, тогда как встроенные операторы работают с массивами любых типов. Благодаря этому ограничению, в большинстве случаев они работают быстрее, чем встроенные операторы.</para>

  <para>Операторы <literal>@@</literal> и <literal>~~</literal> проверяют, удовлетворяет ли массив <firstterm>запросу</firstterm>, представляемому в виде значения специализированного типа данных <type>query_int</type>. <firstterm>Запрос</firstterm> содержит целочисленные значения, сравниваемые с элементами массива, возможно с использованием операторов <literal>&amp;</literal> (AND), <literal>|</literal> (OR) и <literal>!</literal> (NOT). При необходимости могут использоваться скобки. Например, запросу <literal>1&amp;(2|3)</literal> удовлетворяют запросы, которые содержат 1 и также содержат 2 или 3.</para>
 </sect2>

 <sect2>
  <title>Поддержка индексов</title>

  <para>Модуль <filename>intarray</filename> поддерживает индексы для операторов <literal>&amp;&amp;</literal>, <literal>@&gt;</literal>, <literal>&lt;@</literal> и <literal>@@</literal>, а также обычную проверку равенства массивов.</para>

  <para>Модуль предоставляет два класса операторов GiST: <literal>gist__int_ops</literal> (используется по умолчанию), подходящий для маленьких и средних по размеру наборов данных, и <literal>gist__intbig_ops</literal>, применяющий сигнатуру большего размера и подходящий для индексации больших наборов данных (то есть столбцов, содержащих много различных значений массива). В этой реализации используется структура данных RD-дерева со встроенным сжатием с потерями.</para>

  <para>Есть также нестандартный класс операторов GIN, <literal>gin__int_ops</literal>, поддерживающий те же операторы.</para>

  <para>Выбор между индексами GiST и GIN зависит от относительных характеристик производительности GiST и GIN, которые здесь не рассматриваются.</para>
 </sect2>

 <sect2>
  <title>Пример</title>

<programlisting>-- сообщение может относиться к одной или нескольким <quote>секциям</quote>
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], ...);

-- создать специализированный индекс
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);

-- вывести сообщения из секций 1 или 2 — оператор пересечения
SELECT message.mid FROM message WHERE message.sections &amp;&amp; '{1,2}';

-- вывести сообщения из секций 1 и 2 — оператор включения
SELECT message.mid FROM message WHERE message.sections @&gt; '{1,2}';

-- тот же результат, но с оператором запроса
SELECT message.mid FROM message WHERE message.sections @@ '1&amp;2'::query_int;</programlisting>
 </sect2>

 <sect2>
  <title>Тестирование производительности</title>

  <para>В каталоге исходного кода <filename>contrib/intarray/bench</filename> содержится набор тестов, которые можно провести на установленном сервере <productname>&productname;</productname>. (Для этого нужно установить пакет <filename>DBD::Pg</filename>.) Чтобы запустить эти тесты, выполните:</para>

<programlisting>cd .../contrib/intarray/bench
createdb TEST
psql -c "CREATE EXTENSION intarray" TEST
./create_test.pl | psql TEST
./bench.pl</programlisting>

  <para>Скрипт <filename>bench.pl</filename> принимает несколько аргументов, о которых можно узнать, запустив его без аргументов.</para>
 </sect2>

 <sect2>
  <title>Авторы</title>

  <para>Разработку осуществили Фёдор Сигаев (<email>teodor@sigaev.ru</email>) и Олег Бартунов (<email>oleg@sai.msu.su</email>). Дополнительные сведения можно найти на странице <ulink url="http://www.sai.msu.su/~megera/postgres/gist/"/>. Андрей Октябрьский проделал отличную работу, добавив новые функции и операторы.</para>
 </sect2>

</sect1>
