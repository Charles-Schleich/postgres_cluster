<!-- doc/src/xml/xaggr.xml -->

 <sect1 id="xaggr">
  <title>Пользовательские агрегатные функции</title>

  <indexterm zone="xaggr"><primary>агрегатная функция</primary> <secondary>пользовательская</secondary></indexterm>

  <para>Агрегатные функции в <productname>&productname;</productname> определяются в терминах <firstterm>значений состояния</firstterm> и <firstterm>функций перехода состояния</firstterm>. То есть агрегатная функция работает со значением состояния, которое меняется при обработке каждой последующей строки. Чтобы определить агрегатную функцию, нужно выбрать тип данных для значения состояния, начальное значение состояния и функцию перехода состояния. Функция перехода состояния принимает предыдущее значение состояния и входное агрегируемое значение для текущей строки и возвращает новое значение состояния. Также можно указать <firstterm>функцию завершения</firstterm>, на случай, если ожидаемый результат агрегатной функции отличается от данных, которые сохраняются в изменяющемся значении состояния. Функция завершения принимает конечное значение состояния и возвращает то, что она хочет вернуть в виде результата агрегирования. В принципе, функции перехода и завершения представляют собой просто обычные функции, которые также могут применяться вне контекста агрегирования. (На практике для большей производительности часто создаются специализированные функции перехода, которые работают, только когда вызываются при агрегировании.)</para>

  <para>Таким образом, помимо типов данных аргументов и результата, с которыми имеет дело пользователь агрегатной функции, есть также тип данных внутреннего состояния, который может отличаться от этих типов.</para>

  <para>Если мы определяем агрегат, не использующий функцию завершения, наш агрегат будет вычислять бегущее значение функции по столбцам каждой строки. Примером такой агрегатной функции является <function>sum</function>. Вычисление <function>sum</function> начинается с нуля, а затем к накапливаемой сумме всегда прибавляется значение из текущей строки. Например, если мы хотим сделать агрегатную функцию <function>sum</function> для комплексных чисел, нам потребуется только функция сложения для такого типа данных. Такая агрегатная функция может быть определена так: <programlisting>CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)'
);</programlisting> Использовать её можно будет так: <programlisting>SELECT sum(a) FROM test_complex;

   sum
-----------
 (34,53.9)</programlisting> (Заметьте, что мы задействуем перегрузку функций: в системе есть несколько агрегатных функций с именем <function>sum</function>, но <productname>&productname;</productname> может определить, какая именно из них применима к столбцу типа <type>complex</type>.)</para>

  <para>Определённая выше функция <function>sum</function> вернёт ноль (начальное значение состояния), если в наборе данных не окажется значений, отличных от NULL. У нас может возникнуть желание вернуть NULL в этом случае &mdash; стандарт SQL требует, чтобы <function>sum</function> работала так. Мы можем добиться этого, просто опустив фразу <literal>initcond</literal>, так что начальным значением состояния будет NULL. Обычно это будет означать, что в <literal>sfunc</literal> придётся проверять входное значение состояния на NULL. Но для <function>sum</function> и некоторых других простых агрегатных функций, как <function>max</function> и <function>min</function>, достаточно вставить в переменную состояния первое входное значение не NULL, а затем начать применять функцию перехода со следующего значения не NULL. <productname>&productname;</productname> сделает это автоматически, если начальное значение состояние равно NULL и функция перехода помечена как <quote>strict</quote> (то есть не должна вызываться для аргументов NULL).</para>

  <para>Ещё одна особенность поведения по умолчанию <quote>строгой</quote> функции перехода — предыдущее значение состояния остаётся без изменений, когда встречается значение NULL. Другими словами, значения NULL игнорируются. Если вам нужно другое поведение для входных значений NULL, не объявляйте свою функцию перехода строгой (strict); вместо этого, проверьте в ней поступающие значения на NULL и обработайте их, как требуется.</para>

  <para>Функция <function>avg</function> (вычисляющая среднее арифметическое) представляет собой более сложный пример агрегатной функции. Ей необходимы два компонента текущего состояния: сумма входных значений и их количество. Окончательный результат получается как частное этих величин. При реализации этой функции для значения состояния обычно используется массив. Например, встроенная реализация <function>avg(float8)</function> выглядит так: <programlisting>CREATE AGGREGATE avg (float8)
(
    sfunc = float8_accum,
    stype = float8[],
    finalfunc = float8_avg,
    initcond = '{0,0,0}'
);</programlisting></para>

  <note>
   <para>Функция <function>float8_accum</function> принимает массив из трёх, а не двух элементов, так как в дополнение к количеству и сумме значений она подсчитывает ещё сумму их квадратов. Это сделано для того, чтобы её можно было применять для <function>avg</function> и для некоторых других агрегатных функций.</para>
  </note>

  <para>Вызовы агрегатных функций SQL допускают указания <literal>DISTINCT</literal> и <literal>ORDER BY</literal>, которые определяют, какие строки и в каком порядке будут поступать в функцию перехода агрегата. Это реализовано на заднем плане и непосредственно не затрагивает функции, поддерживающие работу агрегата.</para>

  <para>За дополнительными подробностями обратитесь к описанию <xref linkend="sql-createaggregate"/>.</para>

 <sect2 id="xaggr-moving-aggregates">
  <title>Режим движущегося агрегата</title>

  <indexterm><primary>режим движущегося агрегата</primary></indexterm>

  <indexterm><primary>агрегатная функция</primary> <secondary>движущийся агрегат</secondary></indexterm>

  <para>Агрегатные функции могут дополнительно поддерживать <firstterm>режим движущегося агрегата</firstterm>, который позволяет значительно быстрее выполнять агрегатные функции в окнах со сдвигающимся началом рамки. (За информацией об использовании агрегатных функций в качестве оконных обратитесь к <xref remap="3" linkend="tutorial-window"/> и <xref remap="3" linkend="syntax-window-functions"/>.) Основная идея состоит в том, что помимо добавления обычной функции перехода <quote>вперёд</quote>, для агрегатной функции задаётся <firstterm>функция обратного перехода</firstterm>, которая позволяет убирать строки из накапливаемого значения состояния, когда они покидают рамку окна. Например, для <function>sum</function> в качестве функции прямого перехода выполняется сложение, а в качестве функции обратного перехода выполняется вычитание. Без функции обратного перехода механизм оконных функций вынужден вычислять агрегат заново при каждом перемещении начала рамки, в результате чего время обработки оказывается пропорциональным количеству входных строк, помноженному на средний размер рамки. С функцией обратного перехода это время пропорционально только количеству входных строк.</para>

  <para>Функции обратного перехода передаётся текущее значение состояния и агрегируемое входное значение(я) для строки, ранее учтённой в текущем состоянии. Она должна восстановить то значение состояния, которое было бы получено, если бы эта строка не агрегировалась, но агрегировались все последующие. Иногда для этого нужно, чтобы функция обратного перехода сохраняла больше информации о состоянии, чем это требуется для простого режима агрегирования. Таким образом, для режима движущегося агрегата используется реализация, отличная от простого режима: для него определяется отдельный тип данных, отдельная функция прямого перехода и отдельная функция завершения, при необходимости. Они могут совпадать с типом данных и аналогичными функциями обычного режима, если в дополнительном состоянии необходимости нет.</para>

  <para>В качестве примера мы можем доработать показанную выше агрегатную функцию <function>sum</function>, чтобы она поддерживала режим движущегося агрегата так: <programlisting>CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)',
    msfunc = complex_add,
    minvfunc = complex_sub,
    mstype = complex,
    minitcond = '(0,0)'
);</programlisting> Параметры, имена которых начинаются с <literal>m</literal>, определяют реализацию для движущегося агрегата. За исключением функции обратного перехода, <literal>minvfunc</literal>, они соответствуют параметрам обычного агрегата без <literal>m</literal>.</para>

  <para>Функции прямого перехода в режиме движущегося агрегата не разрешено возвращать NULL в качестве нового значения состояния. Если функция обратного перехода возвращает NULL, это воспринимается как признак того, что она не может восстановить предыдущее состояние для полученных данных, и значит, агрегатное вычисление нужно производить заново с текущей позиции начала рамки. Это соглашение позволяет применять режим движущегося агрегата и в ситуациях, когда прокручивать назад значение состояния непрактично. Функция обратного перехода может <quote>спасовать</quote> в таких случаях, но включаться в работу, насколько это возможно в большинстве случаев. Например, агрегатная функция, работающая с числами с плавающей точкой, может спасовать, когда от неё потребуется убрать значение <literal>NaN</literal> (не число, not a number) из текущего значения состояния.</para>

  <para>Разрабатывая функции, реализующие режим движущегося агрегата, важно, чтобы функция обратного перехода могла восстановить в точности требуемое значение состояния. В противном случае, в результатах могут проявляться различия, в зависимости от того, использовался ли режим движущегося агрегата. Например, на первый взгляд может показаться, что легко добавить функцию обратного перехода для сложения, но заявленное требование не будет выполняться для <function>sum</function> с типом <type>float4</type> или <type>float8</type>. Наивное объявление <function>sum(<type>float8</type>)</function> может быть таким: <programlisting>CREATE AGGREGATE unsafe_sum (float8)
(
    stype = float8,
    sfunc = float8pl,
    mstype = float8,
    msfunc = float8pl,
    minvfunc = float8mi
);</programlisting> Однако такой агрегат может выдавать результаты, радикально отличающиеся от тех, что он выдавал бы без функции обратного перехода. Например, рассмотрите запрос <programlisting>SELECT
  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
             (2, 1.0::float8)) AS v (n,x);</programlisting> Он возвращает <literal>0</literal> в качестве второго результата, а не ожидаемое значение <literal>1</literal>. Это связано с ограниченной точностью значений с плавающей точкой: при добавлении <literal>1</literal> к <literal>1e20</literal> снова получается <literal>1e20</literal>, а при вычитании <literal>1e20</literal> из результата получается <literal>0</literal>, а не <literal>1</literal>. Заметьте, что это принципиальное ограничение арифметики чисел с плавающей точкой, а не недостаток <productname>&productname;</productname>.</para>

 </sect2>

 <sect2 id="xaggr-polymorphic-aggregates">
  <title>Агрегатные функции с полиморфными и переменными аргументами</title>

  <indexterm><primary>агрегатная функция</primary> <secondary>полиморфная</secondary></indexterm>

  <indexterm><primary>агрегатная функция</primary> <secondary>с переменными аргументами</secondary></indexterm>

  <para>Агрегатная функция может использовать полиморфные функции перехода состояния или функции завершения, так что эти функции могут применяться для реализации нескольких агрегатов. За объяснением полиморфных функций обратитесь к <xref remap="3" linkend="extend-types-polymorphic"/>. Более того, сама агрегатная функция может описываться с полиморфными типами входных данных и состояния, так что одно определение агрегатной функции может служить для использования с разными типами данных. Пример полиморфного агрегата: <programlisting>CREATE AGGREGATE array_accum (anyelement)
(
    sfunc = array_append,
    stype = anyarray,
    initcond = '{}'
);</programlisting> Здесь фактическим типом состояния для любого конкретного агрегатного вызова будет массив, элементы которого будут иметь тип входных данных. Действие данного агрегата заключается в накоплении всех входных значений в массиве этого типа. (К вашему сведению: встроенная агрегатная функция <function>array_agg</function> обеспечивает подобную функциональность, но работает быстрее, чем могла бы функция с приведённым определением.)</para>

  <para>Так будут выглядеть результаты с аргументами двух различных типов: <programlisting>SELECT attrelid::regclass, array_accum(attname)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |              array_accum              
---------------+---------------------------------------
 pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)

SELECT attrelid::regclass, array_accum(atttypid::regtype)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |        array_accum        
---------------+---------------------------
 pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)</programlisting></para>

  <para>Обычно агрегатная функция с полиморфным типом результата имеет и полиморфный тип состояния, как в предыдущем примере. Это необходимо, так как иначе нельзя будет объявить функцию завершения: она должна будет иметь полиморфный тип результата, но не будет иметь полиморфного аргумента, что команда <command>CREATE FUNCTION</command> не примет на основании того, что тип результата нельзя будет определить при вызове. Но иметь полиморфный тип состояния не всегда удобно. Чаще всего эта проблема возникает, когда функции реализации агрегата пишутся на C и тип состояния должен объявляться как <type>internal</type>, так как для него нет соответствующего типа на уровне SQL. Чтобы решить эту проблему, можно объявить функцию завершения как принимающую дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата. В этих фиктивных аргументах всегда передаются значения NULL, так как при вызове функции завершения какое-либо определённое значение отсутствует. Единственное их предназначение — позволить связать тип результата полиморфной функции завершения с типом входных данных агрегата. Например, определение встроенного агрегата <function>array_agg</function> выглядит так: <programlisting>CREATE FUNCTION array_agg_transfn(internal, anynonarray)
  RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anynonarray)
  RETURNS anyarray ...;

CREATE AGGREGATE array_agg (anynonarray)
(
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra
);</programlisting> Здесь параметр <literal>finalfunc_extra</literal> указывает, что функция завершения помимо значения состояния получит дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата. Дополнительный аргумент <type>anynonarray</type> позволяет сделать объявление <function>array_agg_finalfn</function> допустимым.</para>

  <para>Агрегатную функцию можно сделать принимающей переменное число аргументов, объявив её последний аргумент как массив <literal>VARIADIC</literal>, в том же ключе, как и обычную функцию; см. <xref remap="4" linkend="xfunc-sql-variadic-functions"/>. При этом у функций перехода агрегата их последний аргумент должен иметь тот же тип массива. Такие функции обычно также объявляются как <literal>VARIADIC</literal>, но строго это не требуется.</para>

  <note>
   <para>Агрегатные функции с переменными аргументами легко допускают ошибочное использование в сочетании с указанием <literal>ORDER BY</literal> (см. <xref remap="4" linkend="syntax-aggregates"/>), так как анализатор запроса не может определить, было ли передано нужное количество фактических параметров в такой комбинации. Помните, что всё, находящееся справа от <literal>ORDER BY</literal>, является ключом сортировки, а не аргументом агрегатной функции. Например, в <programlisting>SELECT myaggregate(a ORDER BY a, b, c) FROM ...</programlisting> анализатор запроса увидит один агрегатный аргумент функции и три ключа сортировки. Однако пользователь мог подразумевать и следующее: <programlisting>SELECT myaggregate(a, b, c ORDER BY a) FROM ...</programlisting> Если функция <literal>myaggregate</literal> принимает переменные аргументы, оба эти вызова будут вполне допустимы.</para>

   <para>По этой же причине, стоит подумать дважды, прежде чем создавать агрегатные функции с одинаковыми именами, но разным числом обычных аргументов.</para>
  </note>

 </sect2>

 <sect2 id="xaggr-ordered-set-aggregates">
  <title>Сортирующие агрегатные функции</title>

  <indexterm><primary>агрегатная функция</primary> <secondary>сортирующая</secondary></indexterm>

  <para>Описанные выше агрегатные функции были <quote>обычными</quote> агрегатами. Но <productname>&productname;</productname> также поддерживает <firstterm>сортирующие агрегатные функции</firstterm>, которые имеют два отличия от обычных. Во-первых, в дополнение к обычным агрегируемым аргументам, вычисляемых для каждой входной строки, сортирующий агрегат может иметь <quote>непосредственные</quote> аргументы, которые должны вычисляться в операции агрегирования только один раз. Во-вторых, для обычных агрегируемых аргументов порядок их сортировки задаётся явно, а сортирующий агрегат обычно выполняет вычисления, зависящие от конкретного порядка строк, например, вычисляет ранг или процентиль, так что порядок сортировки критичен для каждого вызова. Например, встроенное определение функции <function>percentile_disc</function> равнозначно следующему: <programlisting>CREATE FUNCTION ordered_set_transition(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
  RETURNS anyelement ...;

CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra
);</programlisting> Этот агрегат принимает непосредственный аргумент <type>float8</type> (дробь процентиля) и агрегируемые данные, которые могут быть любого упорядочиваемого типа. Используя его, можно рассчитать средний семейный доход следующим образом: <programlisting>SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-----------------
           50489</programlisting> В данном случае, <literal>0.5</literal> — это непосредственный аргумент; если бы дробь процентиля менялась от строки к строке, это не имело бы смысла.</para>

  <para>В отличие от случая с обычными агрегатами, сортировка входных строк для сортирующего агрегата <emphasis>не</emphasis> выполняется на заднем плане, а является задачей функций, реализующих агрегат. Обычный подход к такой реализации заключается в сохранении ссылки на объект <quote>tuplesort</quote> в значении состояния агрегата, загрузке поступающих строк в этот объект, и собственно завершении сортировки и обработки данных в функции завершения. Такая конструкция позволяет функции завершения выполнять специальные операции, в частности, вставлять дополнительные <quote>гипотетические</quote> строки в сортируемые данные. Тогда как обычные агрегаты часто реализуются функциями, написанными на <application>PL/pgSQL</application> или другом процедурном языке, сортирующие агрегатные функции обычно должны быть написаны на C, так как их значение состояния нельзя выразить каким-либо типом данных SQL. (Обратите внимание, что в приведённом выше примере значение состояния объявлено как имеющее тип <type>internal</type> &mdash; это типичный вариант.)</para>

  <para>Функция перехода состояния для сортирующего агрегата получает значение текущего состояния плюс агрегируемые входные данные для каждой строки и возвращает изменённое значение состояния. Это определение распространяется и на обычные агрегаты, но заметьте, что непосредственные аргументы (если они есть) при этом не передаются. Функция завершения же получает последнее значение состояния и значения непосредственных аргументов (если они есть), а также (если присутствует указание <literal>finalfunc_extra</literal>) значения NULL, соответствующие агрегируемым данным. С обычными агрегатами указание <literal>finalfunc_extra</literal> действительно полезно, только если агрегат полиморфный; тогда дополнительные фиктивные аргументы необходимы, чтобы связать тип результата функции завершения с типом(ами) входных данных агрегата.</para>

  <para>В настоящее время сортирующие агрегаты не могут использоваться в качестве оконных функций, поэтому от них поддержка режима движущегося агрегата не требуется.</para>

 </sect2>

  <sect2 id="xaggr-partial-aggregates">
  <title>Частичное агрегирование</title>

  <indexterm><primary>агрегатная функция</primary> <secondary>частичное агрегирование</secondary></indexterm>

  <para>Дополнительно агрегатная функция может поддерживать <firstterm>частичное агрегирование</firstterm>. Идея такого агрегирования в том, чтобы вызывать функции перехода состояния для различных подмножеств входных данных независимо, а затем комбинировать значения состояния, вычисленные по этим подмножествам, и получать тот же результат, что был бы получен при сканировании сразу всех входных данных. Этот режим может применяться для параллельного агрегирования, когда разные рабочие процессы сканируют различные части таблицы. При этом каждый рабочий процесс выдаёт частичное значение состояния, а в конце эти значения комбинируются вместе и получается окончательное значение состояния. (В будущем этот режим может также применяться, например для комбинированного агрегирования локальных и удалённых таблиц, но пока это не реализовано.)</para>

  <para>Для поддержки частичного агрегирования в определении агрегатной функции должна задаваться <firstterm>комбинирующая функция</firstterm>, принимающая два значения типа состояния агрегата (представляющие результаты агрегирования по двум подмножествам входных строк) и выдающая новое значение типа состояния, представляющее то состояние, которое было бы получено при агрегировании совокупности этих подмножеств строк. При этом относительный порядок входных строк в этих двух множествах не оговаривается. Это значит, что для агрегатных функций, зависящих от порядка входных строк, обычно невозможно определить осмысленную комбинирующую функцию.</para>

  <para>В качестве простого примера, частичное агрегирование могут поддерживать функции <literal>MAX</literal> и <literal>MIN</literal>, если задать в качестве комбинирующей соответственно функцию сравнения значений большее-из-двух или меньшее-из-двух, ту же, что они используют и как функцию перехода. Для <literal>SUM</literal> комбинирующей функцией будет просто функция сложения. (И это опять же функция перехода, если только значение состояния не выходит за рамки типа входных данных.)</para>

  <para>Комбинирующая функция задействуется практически так же, как функция перехода, но принимает в качестве второго аргумента значение типа состояния, а не нижележащего входного типа. В частности, на неё распространяются те же правила строгости функции и передачи значений NULL. Также учтите, что если в определении агрегатной функции задаётся отличное от NULL значение <literal>initcond</literal>, оно будет задавать начальное состояние не только для каждого прохода частичного агрегирования, но также и начальное состояние для комбинирующей функции, которая будет вызываться для комбинирования каждого частичного результата в этом состоянии.</para>

  <para>Если типом состояния агрегатной функции выбран <type>internal</type>, комбинирующая функция отвечает за то, чтобы её результат был помещён в контекст памяти, подходящий для значений агрегатного состояния. В частности это значит, что, получив в первом аргументе <literal>NULL</literal>, нельзя просто возвратить второй аргумент, так как это значение окажется в неверном контексте и не просуществует достаточное время.</para>

  <para>Когда типом состояния агрегатной функции выбран <type>internal</type>, обычно в определении агрегатной функции также уместно задать <firstterm>функцию сериализации</firstterm> и <firstterm>функцию десериализации</firstterm>, которые позволяют копировать значение состояния из одного процесса в другой. Без этих функций параллельное агрегирование невозможно, а также вероятно не будут работать такие будущие приложения, как локальное/удалённое агрегирование.</para>

  <para>Функция сериализации должна принимать один аргумент типа <type>internal</type> и возвращать результат типа <type>bytea</type>, представляющий значение состояния, упакованное в плоский набор байтов. Функция десериализации, напротив, обращает это преобразование. Она должна принимать два аргумента типов <type>bytea</type> и <type>internal</type> и возвращать результат типа <type>internal</type>. (Второй её аргумент не используется и всегда равен нулю, но он требуется из соображений типобезопасности.) Результат функции десериализации следует просто разместить в текущем контексте памяти, так как в отличие от результата комбинирующей функции он недолговечен.</para>

  <para>Также стоит заметить, что для выполнения агрегатной функции в параллельном режиме она должна иметь характеристику <literal>PARALLEL SAFE</literal> (безопасная для распараллеливания). Характеристики допустимости распараллеливания её опорных функций значения не имеют.</para>

 </sect2>

 <sect2 id="xaggr-support-functions">
  <title>Вспомогательные функции для агрегатов</title>

  <indexterm><primary>агрегатная функция</primary> <secondary>вспомогательные функции</secondary></indexterm>

  <para>Функция, написанная на C, может определить, была ли она вызвана как вспомогательная функция агрегирования, вызвав <function>AggCheckCallContext</function>, например, так: <programlisting>if (AggCheckCallContext(fcinfo, NULL))</programlisting> Смысл такой проверки в том, что для функции перехода (когда эта функция возвращает true) первым входным аргументом является временное значение состояния, которое можно безопасно модифицировать на месте, не создавая новую копию. Пример вы можете увидеть в функции <function>int8inc()</function>. (Это <emphasis>единственный</emphasis> случай, когда функция может безопасно изменять входные данные, передаваемые по ссылке. В частности, функции завершения для обычных агрегатов не должны изменять входные данные ни в коем случае, так как в некоторых ситуациях они могут вызываться повторно с тем же конечным значением состояния.)</para>

  <para>Второй аргумент <function>AggCheckCallContext</function> можно использовать, чтобы получить контекст памяти, в котором содержатся значения агрегатного состояния. Это полезно для функций перехода, которые желают использовать <quote>развёрнутые</quote> объёкты (см. <xref remap="4" linkend="xtypes-toast"/>) в качестве значений состояния. При первом вызове такая функция перехода должна возвратить развёрнутый объект в контексте памяти, относящемся к контексту состояния агрегата, а затем продолжать возвращать тот же объект при последующих вызовах. Например, эту логику можно увидеть в функции <function>array_append()</function>. (Функция <function>array_append()</function> не используется в качестве перехода никаким встроенным агрегатом, но она написана так, чтобы работать эффективно в таком качестве в дополнительном агрегате.)</para>

  <para>Ещё одна вспомогательная подпрограмма, предназначенная для агрегатных функций, написанных на C, называется <function>AggGetAggref</function>. Эта функция возвращает узел разбора <literal>Aggref</literal>, описывающий вызов агрегата. Это в основном полезно для сортирующих агрегатов, которые могут исследовать структуру узла <literal>Aggref</literal> и выяснить, какой порядок сортировки они должны реализовать. Примеры использования можно найти в <filename>orderedsetaggs.c</filename> в исходном коде <productname>&productname;</productname>.</para>

 </sect2>

 </sect1>
