<!-- doc/src/xml/atx.xml -->

<chapter id="atx">
 <title>Автономные транзакции</title>

<sect1 id="atx-overview">
  <title>Обзор</title>

<para>&productname; поддерживает вложенные транзакции: они редко явно используются программистами; чаще всего они применяются для обработки ошибок и хранимых процедур. Вложенную подтранзакцию можно откатить, никак не влияя на родительскую транзакцию, но её фиксирование откладывается до момента фиксирования родительской транзакции.</para>
<para>Однако в некоторых случаях приложениям требуется выполнять в рамках одной транзакции несколько независимых транзакций &mdash; <quote>автономные транзакции</quote>. Автономные транзакции нужны в первую очередь для реализации аудита, когда факт попытки действия, подлежащего аудиту, должен быть зафиксирован независимо от того, будет ли это действие завершено успешно или нет.</para>

</sect1>

<sect1><title>Поведение</title>
<para>Автономные транзакции могут выполняться только внутри другой транзакции. Если уже начата транзакция (назовём её T0), пользователь может решить начать подтранзакцию. При этом T0 приостанавливается, помещается в стек автономных транзакций, и начинается новая транзакция (назовём её T1).</para>
<para>Затем в какой-то момент пользователь может зафиксировать автономную транзакцию; после того как T1 будет зафиксирована, T0 извлекается из стека автономных транзакций и продолжает выполняться. Пользователь может также выполнить <command>COMMIT</command> в родительской транзакции T0 — в этом случае сначала фиксируется T1, затем T0 извлекается из стека и фиксируется.</para>
<para>Все эти транзакции происходят одновременно; в любой момент времени может быть активна только одна транзакция, тогда как в стеке находятся несколько (или ноль) приостановленных транзакций. При этом могут иметь место любые комбинации <command>COMMIT</command>/<command>ROLLBACK</command> с T0 и T1; например, можно выполнить COMMIT T1 и ROLLBACK T0. Одни автономные транзакции могут вкладываться в другие, насколько это позволяют глобальные ограничения ресурсов (например, размер стека автономных транзакций), которые могут быть установлены на сервере.</para>

</sect1>

<sect1><title>Примеры</title>

<para>Этот пример показывает, как выполняется автономная транзакция. Непрерывная линия обозначает активную транзакцию, а пунктирная — транзакцию, которая была приостановлена и помещена в стек автономных транзакций. Течение времени направлено вниз.</para>

<programlisting>BEGIN; -- начинается обычная транзакция T0
|
INSERT INTO t VALUES (1);
:\
: BEGIN AUTONOMOUS TRANSACTION; -- начинается автономная транзакция
: |                             -- T1, транзакция T0 помещается в стек
: |
: INSERT INTO t VALUES (2);
: |
: COMMIT AUTONOMOUS TRANSACTION / ROLLBACK AUTONOMOUS TRANSACTION; 
: |                             -- завершается автономная транзакция
: |                             -- T1, транзакция T0 извлекается из стека
:/
COMMIT / ROLLBACK;              -- завершается транзакция T0</programlisting>

<para>В зависимости от выбора из <command>COMMIT</command> и <command>ROLLBACK</command> в двух местах, мы можем получить четыре разных результата из: <programlisting>SELECT sum(x) from t;</programlisting></para>

<para>В одной родительской транзакции может быть несколько автономных транзакций, если приложение будет просто повторять цикл помещения/извлечения их из стека.</para>

<programlisting>BEGIN;                          -- начинается обычная транзакция T0
|
INSERT INTO t VALUES (1);
:\
: BEGIN AUTONOMOUS TRANSACTION; -- начинается автономная транзакция
: |                             -- T1, транзакция T0 помещается в стек
: |
: INSERT INTO t VALUES (2);
: |
: COMMIT AUTONOMOUS TRANSACTION / ROLLBACK AUTONOMOUS TRANSACTION; 
: |                             -- завершается автономная транзакция
: |                             -- T1, транзакция T0 извлекается из стека
:/
|
:\
: BEGIN AUTONOMOUS TRANSACTION; -- начинается автономная транзакция
: |                             -- T2, транзакция T0 помещается в стек
: |
: INSERT INTO t VALUES (4);
: |
: COMMIT AUTONOMOUS TRANSACTION / ROLLBACK AUTONOMOUS TRANSACTION; 
: |                             -- завершается автономная транзакция
: |                             -- T2, транзакция T0 извлекается из стека
:/
COMMIT / ROLLBACK;              -- завершается транзакция T0</programlisting>

</sect1>

<sect1><title>Видимость</title>

<para>Правила видимости действуют так же, как и с независимыми транзакциями, выполняемыми через <literal>dblink</literal> T1 не видит эффекта действия T0, как ещё не зафиксированной транзакции. T0 может видеть эффект действия T1, в зависимости своего собственного режима изоляции. Если выбран режим изоляции Read Committed, родительская транзакция будет видеть изменения, производимые автономными транзакциями, но в режиме Repeatable Read они не будут видны.</para>

<para>При этом становятся возможны взаимоблокировки в одном сеансе, так как автономная транзакция может оказаться в спутанном состоянии с одной из приостановленных транзакций в сеансе. Автономная транзакций T1 считается зависимой от родительской транзакции T0, и если она пытается получить какой-либо ресурс, удерживаемый T0, происходит взаимоблокировка.</para>

</sect1>

<sect1><title>Расширение языка SQL для автономных транзакций</title>

<para>Транзакционные операторы <literal>BEGIN</literal>/<literal>END</literal> в &productname; расширены необязательным ключевым словом <literal>AUTONOMOUS</literal>:</para>

<programlisting>    BEGIN [AUTONOMOUS] [TRANSACTION] [<replaceable>уровень-изоляции</replaceable>]
    END [AUTONOMOUS] [TRANSACTION]</programlisting>

<para>Указывать ключевое слово <literal>AUTONOMOUS</literal> в предложении <literal>END TRANSACTION</literal> не обязательно. С автономными транзакциями возможно организовать несколько уровней вложенности, но транзакция верхнего уровня автономной быть не может.</para>

</sect1>

<sect1><title>Расширение языка PL/pgSQL для автономных транзакций</title>

<para>Конструкция блока в PL/pgSQL расширена необязательным ключевым словом <literal>autonomous</literal>. Это позволяет выполнять всё тело функции как автономную транзакцию:</para>

<programlisting>create function foo(x integer) returns integer as $$
begin autonomous
  return x;
end;
$$ language plpgsql;</programlisting>

<para>или создать отдельный блок begin-end:</para>

<programlisting>create or replace function myaudit() returns boolean as $$
begin autonomous
        begin autonomous
        insert into audit_schedule values ('new audit',now());
        end;
        ... -- собственно произвести аудит
        return true;
end;
$$ language plpgsql;</programlisting>

<para>Когда в блоке <command>BEGIN AUTONOMOUS</command> возникает исключение, автономная транзакция прерывается и начинается обычная процедура обработки исключения — стек поднимается до тех пор, пока это исключение не будет перехвачено каким-либо обработчиком. То есть исключения обрабатываются точно так же, как и с обычными подтранзакциями &productname;.</para>
<para>Когда ошибка перехватывается конструкцией <literal>EXCEPTION</literal>, локальные переменные функции PL/pgSQL остаются в том же состоянии, в каком они были в момент ошибки, но все изменения в состоянии базы данных, произведённые данным блоком кода, откатываются назад.</para>

</sect1>

<sect1><title>Расширения языка PL/Python для автономных транзакций</title>

<para>В дополнение к методу <varname>subtransaction</varname>, модуль PL/Python предоставляет новый метод <varname>autonomous</varname>, который можно использовать с предложением <varname>WITH</varname> для того, чтобы начать автономную транзакцию:</para>

<programlisting>create or replace function pythonomous() returns void as $$
        plpy.execute("insert into atx_test values ('asd', 123)")

        try:
                with plpy.autonomous():
                        plpy.execute("insert into atx_test values ('bsd', 456)")
        except plpy.SPIError, e:
                print("error: %s" % e.args)

        plpy.execute("insert into atx_test values ('csd', 'csd')")
$$ language plpythonu;</programlisting>

<para>Обработка исключений в автономных транзакциях на языке PL/Python осуществляется так же, как и в подтранзакциях.</para>

</sect1>
</chapter>
