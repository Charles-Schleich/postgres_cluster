<!-- doc/src/xml/xtypes.xml -->

 <sect1 id="xtypes">
  <title>Пользовательские типы</title>

  <indexterm zone="xtypes"><primary>тип данных</primary> <secondary>определённый пользователем</secondary></indexterm>

  <para>Как описывалось в <xref remap="6" linkend="extend-type-system"/>, <productname>&productname;</productname> может расширяться и поддерживать новые типы данных. В этом разделе описывается, как определить новые базовые типы, то есть типы данных, описанные ниже уровня языка <acronym>SQL</acronym>. Для создания нового базового типа необходимо реализовать функции, работающие с этим типом, на языке низкого уровня, обычно C.</para>

  <para>Примеры, рассматриваемые в этой главе, можно найти в <filename>complex.sql</filename> и в <filename>complex.c</filename> в каталоге <filename>src/tutorial</filename> пакета с исходным кодом. Инструкции по запуску этих примеров можно найти в файле <filename>README</filename> в том же каталоге.</para>

 <para><indexterm><primary>функция ввода</primary></indexterm> <indexterm><primary>функция вывода</primary></indexterm> Пользовательский тип должен всегда иметь функции ввода и вывода. Эти функции определяют, как тип будет выглядеть в строковом виде (при вводе и выводе для пользователя) и как этот тип размещается в памяти. Функция ввода принимает в качестве аргумента строку символов, заканчивающуюся нулём, и возвращает внутреннее представление типа (в памяти). Функция вывода принимает в качестве аргумента внутреннее представление типа и возвращает строку символов, заканчивающуюся нулём. Если мы хотим не просто сохранить тип, но делать с ним нечто большее, мы должны предоставить дополнительные функции, реализующие все операции, которые мы хотели бы иметь для этого типа.</para>

 <para>Предположим, что нам нужен тип <type>complex</type>, представляющий комплексные числа. Естественным образом комплексное число можно представить в памяти в виде следующей структуры C: <programlisting>typedef struct Complex {
    double      x;
    double      y;
} Complex;</programlisting> Нам нужно будет передавать этот тип по ссылке, так как он слишком велик, чтобы уместиться в одном значении <type>Datum</type>.</para>

 <para>В качестве внешнего строкового представления типа мы выберем строку вида <literal>(x,y)</literal>.</para>

 <para>Функции ввода и вывода обычно несложно написать, особенно функцию вывода. Но определяя внешнее строковое представление типа, помните, что в конце концов вам придётся реализовать законченный и надёжный метод разбора этого представления в функции ввода. Например, так: <programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_in);

Datum
complex_in(PG_FUNCTION_ARGS)
{
    char       *str = PG_GETARG_CSTRING(0);
    double      x,
                y;
    Complex    *result;

    if (sscanf(str, " ( %lf , %lf )", &x, &y) != 2)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                 errmsg("invalid input syntax for complex: \"%s\"",
                        str)));

    result = (Complex *) palloc(sizeof(Complex));
    result->x = x;
    result->y = y;
    PG_RETURN_POINTER(result);
}
]]>
</programlisting> Функция вывода может быть простой: <programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_out);

Datum
complex_out(PG_FUNCTION_ARGS)
{
    Complex    *complex = (Complex *) PG_GETARG_POINTER(0);
    char       *result;

    result = psprintf("(%g,%g)", complex->x, complex->y);
    PG_RETURN_CSTRING(result);
}
]]>
</programlisting></para>

 <para>Вам нужно позаботиться о том, чтобы функции ввода и вывода были обратными друг к другу. В противном случае вы столкнётесь с проблемами, когда вам потребуется выгрузить данные в файл, а затем прочитать их. Это особенно распространённая проблема, когда дело касается чисел с плавающей точкой.</para>

 <para>Дополнительно пользовательский тип может предоставлять функции для ввода и вывода в двоичном виде. Двоичный ввод/вывод обычно работает быстрее, но хуже портируется, чем текстовый. Как и с текстовым представлением, выбор, каким будет двоичное представление, остаётся за вами. Многие встроенные типы данных стараются обеспечить двоичное представление, независимое от машинной архитектуры. Для типа <type>complex</type> мы воспользуемся функциями двоичного ввода/вывода типа <type>float8</type>: <programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_recv);

Datum
complex_recv(PG_FUNCTION_ARGS)
{
    StringInfo  buf = (StringInfo) PG_GETARG_POINTER(0);
    Complex    *result;

    result = (Complex *) palloc(sizeof(Complex));
    result->x = pq_getmsgfloat8(buf);
    result->y = pq_getmsgfloat8(buf);
    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(complex_send);

Datum
complex_send(PG_FUNCTION_ARGS)
{
    Complex    *complex = (Complex *) PG_GETARG_POINTER(0);
    StringInfoData buf;

    pq_begintypsend(&buf);
    pq_sendfloat8(&buf, complex->x);
    pq_sendfloat8(&buf, complex->y);
    PG_RETURN_BYTEA_P(pq_endtypsend(&buf));
}
]]>
</programlisting></para>

 <para>Написав функции ввода/вывода и скомпилировав их в разделяемую библиотеку, мы можем определить тип <type>complex</type> в SQL. Сначала мы объявим его как тип-пустышку: <programlisting>CREATE TYPE complex;</programlisting> Это позволит нам ссылаться на этот тип, определяя для него функции ввода/вывода. Теперь мы определим функции ввода/вывода: <programlisting>CREATE FUNCTION complex_in(cstring)
    RETURNS complex
    AS '<replaceable>имя_файла</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_out(complex)
    RETURNS cstring
    AS '<replaceable>имя_файла</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_recv(internal)
   RETURNS complex
   AS '<replaceable>имя_файла</replaceable>'
   LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_send(complex)
   RETURNS bytea
   AS '<replaceable>имя_файла</replaceable>'
   LANGUAGE C IMMUTABLE STRICT;</programlisting></para>

 <para>Наконец, мы можем предоставить полное определение типа данных: <programlisting>CREATE TYPE complex (
   internallength = 16,
   input = complex_in,
   output = complex_out,
   receive = complex_recv,
   send = complex_send,
   alignment = double
);</programlisting></para>

 <para><indexterm><primary>массив элементов</primary> <secondary>пользовательского типа</secondary></indexterm> Когда определяется новый базовый тип, <productname>&productname;</productname> автоматически обеспечивает поддержку массивов с элементами такого типа. Тип массива обычно получает имя по имени базового типа с добавленным спереди символом подчёркивания (<literal>_</literal>).</para>

 <para>Когда тип данных определён, мы можем объявить дополнительные функции для выполнения полезных операций с этим типом. Затем поверх этих функций могут быть определены операторы, а если потребуется, и классы операторов, для поддержки индексации этого типа. Эти дополнительные уровни обсуждаются в следующих разделах.</para>

 <para>Если внутреннее представление типа данных имеет переменную длину, оно должно соответствовать стандартной схеме данных переменной длины: первые четыре байта должно занимать поле <type>char[4]</type>, к которому никогда не следует обращаться напрямую (по обыкновению названное <structfield>vl_len_</structfield>). Чтобы сохранить в этом поле размер элемента (включая длину самого поля), вы должны использовать макрос <function>SET_VARSIZE()</function>, а чтобы получить его — макрос <function>VARSIZE()</function>. (Эти макросы нужны, потому что поле длины может кодироваться по-разному на разных платформах.)</para>

 <para>За дополнительными подробностями обратитесь к команде <xref linkend="sql-createtype"/>.</para>

 <sect2 id="xtypes-toast">
  <title>Особенности TOAST</title>
   <indexterm><primary>TOAST</primary> <secondary>и пользовательские типы</secondary></indexterm>

 <para>Если значения вашего типа данных могут быть разного размера (во внутренней форме), обычно для такого типа желательно реализовать поддержку <acronym>TOAST</acronym> (см. <xref remap="4" linkend="storage-toast"/>). Это следует делать, даже если значения слишком малы для сжатия или внешнего хранения, так как <acronym>TOAST</acronym> позволяет сэкономить пространство и с данными маленького размера, сокращая издержки в заголовке.</para>

 <para>Для поддержки хранения <acronym>TOAST</acronym> функции на C, работающие с таким типом данных, должны позаботиться о распаковке поступивших им данных, используя макрос <function>PG_DETOAST_DATUM</function>. (Эту внутреннюю особенность обычно скрывает дополнительный, определяемый для типа макрос <function>GETARG_DATATYPE_P</function>.) Затем, выполняя команду <command>CREATE TYPE</command>, укажите в качестве внутренней длины <literal>variable</literal> и выберите подходящий вариант хранения (не <literal>plain</literal>).</para>

 <para>Если выравнивание данных не имеет значения (либо только для некоторой функции, либо потому что для типа данных в любом случае применяется выравнивание по байтам), некоторых издержек, связанных с макросом <function>PG_DETOAST_DATUM</function>, можно избежать. Вместо него можно использовать <function>PG_DETOAST_DATUM_PACKED</function> (его обычно скрывает определяемый для типа макрос <function>GETARG_DATATYPE_PP</function>) и воспользоваться макросами <function>VARSIZE_ANY_EXHDR</function> и <function>VARDATA_ANY</function> для обращения к потенциально сжатым данным. Стоит ещё раз отметить, что данные, возвращаемые этими макросами, не выравниваются, даже если выравнивание задано в определении типа. Если выравнивание важно, вы должны задействовать обычный интерфейс <function>PG_DETOAST_DATUM</function>.</para>

 <note>
  <para>В старом коде поле <structfield>vl_len_</structfield> часто объявлялось как <type>int32</type>, а не <type>char[4]</type>. Это ничем не чревато до той поры, пока в определении структуры имеются другие поля с выравниванием как минимум <type>int32</type>. Но с потенциально невыровненными данными такое определение структуры опасно; компилятор может воспринять его как право полагать, что данные выровнены, что может привести к аварийным сбоям в архитектурах, строгих к выравниванию.</para>
 </note>

 <para>Поддержка <acronym>TOAST</acronym> даёт также возможность иметь <firstterm>развёрнутое</firstterm> представление данных в памяти, работать с которым будет удобнее, чем с форматом хранения на диске. Обычный или <quote>плоский</quote> формат хранения varlena в конце концов представляет собой просто набор байт; он не может содержать указатели, так как эти байты могут быть скопированы в другие адреса. Для сложных типов данных работать с плоским форматом данных может быть довольно дорого, так что <productname>&productname;</productname> даёт возможность <quote>развернуть</quote> плоский формат в представление, более подходящее для вычислений, и затем передавать эту структуру в памяти функциям, работающим с этим типом.</para>

 <para>Для использования развёрнутого хранения тип данных должен определять развёрнутый формат по правилам, описанным в <filename>src/include/utils/expandeddatum.h</filename>, и предоставлять функции для <quote>разворачивания</quote> плоского значения в этот формат, а также для <quote>заворачивания</quote> этого формата опять в обычное представление varlena. Затем надо добиться, чтобы все функции на C могли принимать любое представление, возможно выполняя преобразование одного в другое непосредственно при получении. Для этого не требуется исправлять сразу все существующие функции для этого типа данных, так как имеющийся стандартный макрос <function>PG_DETOAST_DATUM</function> способен преобразовывать развёрнутые входные данные в обычный плоский формат. Таким образом, все существующие функции, работающие с плоским форматом varlena продолжат работать, хотя и не очень эффективно, с развёрнутыми входными данными; их необязательно переделывать, пока не потребуется оптимизировать производительность.</para>

 <para>Функции на C, умеющие работать с развёрнутым представлением, обычно делятся на две категории: те, что могут работать с развёрнутым форматом, и те, что могут принимать и развёрнутые, и плоские данные varlena. Первые проще написать, но они могут быть менее эффективными в целом, так как преобразование плоского значения в развёрнутую форму для использования только одной функцией может стоить больше, чем сэкономится при обработке данных в развёрнутом формате. Когда нужно работать только с развёрнутым форматом, преобразование плоских значений в развёрнутую форму можно скрыть в макросе, извлекающем аргументы, чтобы функция была не сложнее, чем работающая с традиционными входными данными varlena. Чтобы принимать оба варианта входных значений, напишите функцию извлечения аргументов, которая будет распаковывать значения с сокращённым заголовком, а также внешние и сжатые, но не развёрнутые данные. Такую функцию можно определить как возвращающую указатель на объединение плоского формата varlena и развёрнутого формата. Какой формат получен фактически, вызывающий код может определить, вызвав макрос <function>VARATT_IS_EXPANDED_HEADER()</function>.</para>

 <para>Инфраструктура <acronym>TOAST</acronym> позволяет не только отличить обычные значения varlena от развёрнутых значений, но и различить указатели <quote>для чтения/записи</quote> и <quote>только для чтения</quote> на развёрнутые значения. Функции на C, которым нужно читать развёрнутое значение, или которые будут менять его безопасным и невидимым извне образом, могут не обращать внимания на тип полученного указателя. Если же функции на C выдают изменённую версию входного значения, они могут изменять развёрнутые входные данные на месте, только когда получают указатель для чтения/записи, но не когда получен указатель только для чтения. В последнем случае они должны сначала скопировать значение и получить новое значение, допускающее изменение. Функция на C, создающая новое развёрнутое значение, должна всегда возвращать указатель на него для чтения/записи. Кроме того, функция, изменяющая развёрнутое значение непосредственно по указателю для чтения/записи должна позаботиться о том, чтобы это значение осталось в приемлемом состоянии, если она отработает не полностью.</para>

 <para>Примеры работы с развёрнутыми значениями можно найти в стандартной инфраструктуре массивов, в частности в <filename>src/backend/utils/adt/array_expanded.c</filename>.</para>

 </sect2>

</sect1>
