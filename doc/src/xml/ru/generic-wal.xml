<!-- doc/src/xml/generic-wal.xml -->

<chapter id="generic-wal">
 <title>Унифицированные записи WAL</title>

  <para>Хотя у всех внутренних модулей, взаимодействующих с WAL, имеются собственные типы записей WAL, существует также унифицированный тип записей WAL, описывающий изменения в страницах унифицированным образом. Это полезно для расширений, реализующих собственные методы доступа, так как они не могут зарегистрировать свои подпрограммы воспроизведения изменений WAL.</para>

  <para>API для конструирования унифицированных записей WAL определён в <filename>access/generic_xlog.h</filename> и реализован в <filename>access/transam/generic_xlog.c</filename>.</para>

  <para>Чтобы сформировать запись изменения данных для WAL, применяя механизм унифицированных записей WAL, выполните следующие действия: <orderedlist>
    <listitem>
     <para><function>state = GenericXLogStart(relation)</function> &mdash; начните формирование унифицированной записи WAL для заданного отношения.</para>
    </listitem>

    <listitem>
     <para><function>page = GenericXLogRegisterBuffer(state, buffer, flags)</function> &mdash; зарегистрируйте буфер, который будет изменён текущей унифицированной записью WAL. Эта функция возвращает указатель на временную копию страницы буфера, в которой должны производиться изменения. (Модифицировать непосредственно содержимое буфера нельзя.) В третьем аргументе передаётся битовая маска флагов, применимых к этой операции. В настоящее время флаг только один — <literal>GENERIC_XLOG_FULL_IMAGE</literal>, который показывает, что в запись WAL нужно включить образ всей страницы, а не только изменения. Обычно этот флаг должен устанавливаться, когда страница новая или полностью перезаписана. Вызов <function>GenericXLogRegisterBuffer</function> можно повторять, если фиксируемое в WAL действие изменяет несколько страниц.</para>
    </listitem>

    <listitem>
     <para>Применить изменения к образам страниц, полученным на предыдущем шаге.</para>
    </listitem>

    <listitem>
     <para><function>GenericXLogFinish(state)</function> &mdash; завершите изменения в буферах и выдайте унифицированную запись WAL.</para>
    </listitem>
   </orderedlist></para>

  <para>Формирование записи WAL можно прервать на любом шаге, вызвав <function>GenericXLogAbort(state)</function>. При этом будут отменены все изменения, внесённые в копии образов страниц.</para>

  <para>Используя механизм унифицированных записей WAL, необходимо учитывать следующее: <itemizedlist>
    <listitem>
     <para>Модифицировать буферы напрямую нельзя! Все изменения должны производиться в копиях, полученных от функции <function>GenericXLogRegisterBuffer()</function>. Другими словами, код, формирующий унифицированные записи WAL, никогда не должен сам вызывать <function>BufferGetPage()</function>. Однако, вызывающий код отвечает за закрепление/открепление и блокировку/разблокировку буферов в подходящие моменты времени. Исключительная блокировка каждого целевого буфера должна удерживаться от вызова <function>GenericXLogRegisterBuffer()</function> до <function>GenericXLogFinish()</function>.</para>
    </listitem>

    <listitem>
     <para>Регистрацию буферов (шаг 2) и модификацию образов страниц (шаг 3) можно свободно смешивать, оба этих шага можно повторять в любой последовательности. Но помните, что буферы должны регистрироваться в том же порядке, в каком для них должны получаться блокировки при воспроизведении.</para>
    </listitem>

    <listitem>
     <para>Максимальное число буферов, которые можно зарегистрировать для унифицированной записи WAL, составляет <literal>MAX_GENERIC_XLOG_PAGES</literal>. При исчерпании этого лимита будет выдана ошибка.</para>
    </listitem>

    <listitem>
     <para>Унифицированный тип WAL подразумевает, что страницы, подлежащие изменению, имеют стандартную структуру, в частности между <structfield>pd_lower</structfield> и <structfield>pd_upper</structfield> нет полезных данных.</para>
    </listitem>

    <listitem>
     <para>Так как изменяются копии страниц буфера, <function>GenericXLogStart()</function> не начинает критическую секцию. Таким образом вы можете безопасно выделять память, выдать ошибку и т. п. между <function>GenericXLogStart()</function> и <function>GenericXLogFinish()</function>. Единственная фактическая критическая секция присутствует внутри <function>GenericXLogFinish()</function>. При выходе по ошибке так же не нужно заботиться о вызове <function>GenericXLogAbort()</function>.</para>
    </listitem>

    <listitem>
     <para><function>GenericXLogFinish()</function> помечает буферы как грязные и устанавливает для них LSN. Вам делать явно это не нужно.</para>
    </listitem>

    <listitem>
     <para>Для нежурналируемых отношений всё работает так же, за исключением того, что фактически запись в WAL не выдаётся. Таким образом, явно проверять, является ли отношение нежурналируемым, не требуется.</para>
    </listitem>

    <listitem>
     <para>Функция воспроизведения унифицированных изменений WAL получит исключительные блокировки буферов в том же порядке, в каком они были зарегистрированы. После воспроизведения всех изменений блокировки в том же порядке и освобождаются.</para>
    </listitem>

    <listitem>
     <para>Если для регистрируемого буфера не задаётся <literal>GENERIC_XLOG_FULL_IMAGE</literal>, унифицированная запись WAL содержит различие между старым и новым образом страницы, которое вычисляется при побайтовом сравнении. Результат оказывается не очень компактным при перемещении данных в странице, но это может быть доработано в будущем.</para>
    </listitem>
   </itemizedlist></para>
</chapter>
