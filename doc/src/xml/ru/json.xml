<!-- doc/src/xml/json.xml -->

<sect1 id="datatype-json">
 <title>Типы <acronym>JSON</acronym></title>

 <indexterm zone="datatype-json"><primary>JSON</primary></indexterm>

 <indexterm zone="datatype-json"><primary>JSONB</primary></indexterm>

 <para>Типы JSON предназначены для хранения данных JSON (JavaScript Object Notation, Запись объекта JavaScript) согласно стандарту <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</ulink>. Такие данные можно хранить и в типе <type>text</type>, но типы JSON лучше тем, что проверяют, соответствует ли вводимое значение формату JSON. Для работы с ними есть также несколько специальных функций и операторов; см. <xref remap="4" linkend="functions-json"/>.</para>

 <para>Существуют два типа данных JSON: <type>json</type> и <type>jsonb</type>. Они принимают на вход <emphasis>почти</emphasis> одинаковые наборы значений, но основное их отличие в эффективности. Тип <type>json</type> сохраняет точную копию введённого текста, которую функции обработки должны разбирать заново при каждом выполнении, тогда как данные <type>jsonb</type> сохраняются в разобранном двоичном формате, что несколько замедляет ввод из-за преобразования, но значительно ускоряет обработку, не требуя многократного разбора текста. Кроме того, <type>jsonb</type> поддерживает индексацию, что тоже может быть очень полезно.</para>

 <para>Так как тип <type>json</type> сохраняет точную копию введённого текста, он сохраняет семантически незначащие пробелы между элементами, а также порядок ключей в JSON-объектах. И если JSON-объект внутри содержит повторяющиеся ключи, этот тип сохранит все пары ключ/значение. (Функции обработки будут считать действительной последнюю пару.) Тип <type>jsonb</type>, напротив, не сохраняет пробелы, порядок ключей и значения с дублирующимися ключами. Если во входных данных оказываются дублирующиеся ключи, сохраняется только последнее значение.</para>

 <para>Для большинства приложений предпочтительнее хранить данные JSON в типе <type>jsonb</type> (если нет особых противопоказаний, например важны прежние предположения о порядке ключей объектов).</para>

 <para><productname>&productname;</productname> позволяет использовать только одну кодировку символов в базе данных, поэтому данные JSON не будут полностью соответствовать спецификации, если кодировка базы данных не UTF-8. При этом нельзя будет вставить символы, непредставимые в кодировке сервера, и наоборот, допустимыми будут символы, представимые в кодировке сервера, но не в UTF-8.</para>

 <para>RFC 7159 разрешает включать в строки JSON спецпоследовательности Unicode в виде <literal>\u<replaceable>XXXX</replaceable></literal>. В функцию ввода для типа <type>json</type> эти спецпоследовательности допускаются вне зависимости от кодировки базы данных, и проверяется только правильность их синтаксиса (за <literal>\u</literal> должны следовать четыре шестнадцатеричных цифры). Однако, функция ввода для типа <type>jsonb</type> более строгая: она не допускает спецпоследовательности Unicode для не-ASCII символов (символов после <literal>U+007F</literal>), если кодировка базы данных не UTF8. Тип <type>jsonb</type> также не принимает <literal>\u0000</literal> (так как это значение не может быть представлено в типе <type>text</type> <productname>&productname;</productname>), и требует, чтобы суррогатные пары Unicode использовались для представления символов вне основной многоязыковой плоскости (BMP) правильно. Корректные спецпоследовательности Unicode преобразуются для хранения в соответствующий символ ASCII или UTF8 (это подразумевает сворачивание суррогатных пар в один символ).</para>

 <note>
  <para>Многие из функций обработки JSON, описанные в <xref remap="6" linkend="functions-json"/>, преобразуют спецпоследовательности Unicode в обычные символы, поэтому могут выдавать подобные ошибки, даже если им на вход поступает тип <type>json</type>, а не <type>jsonb</type>. То, что функция ввода в тип <type>json</type> не производит этих проверок, можно считать историческим артефактом, хотя это и позволяет просто сохранять (но не обрабатывать) в JSON спецкоды Unicode в базе данных с кодировкой не UTF8. Вообще же, по возможности следует избегать смешения спецкодов Unicode в JSON с кодировкой базой данных не UTF8.</para>
 </note>

 <para>При преобразовании вводимого текста JSON в тип <type>jsonb</type>, примитивные типы, описанные в <acronym>RFC</acronym> 7159, по сути отображаются в собственные типы <productname>&productname;</productname> как показано в <xref remap="6" linkend="json-type-mapping-table"/>. Таким образом, к содержимому типа <type>jsonb</type> предъявляются некоторые дополнительные требования, продиктованные ограничениями представления нижележащего типа данных, которые не распространяются ни на тип <type>json</type>, ни на формат JSON вообще. В частности, тип <type>jsonb</type> не принимает числа, выходящие за диапазон типа данных <productname>&productname;</productname> <type>numeric</type>, тогда как с <type>json</type> такого ограничения нет. Такие ограничения, накладываемые реализацией, допускаются согласно <acronym>RFC</acronym> 7159. Однако, на практике такие проблемы более вероятны в других реализациях, так как обычно примитивный тип JSON <type>number</type> представляется в виде числа с плавающей точкой двойной точности IEEE 754 (что <acronym>RFC</acronym> 7159 явно признаёт и допускает). При использовании JSON в качестве формата обмена данными с такими системами следует учитывать риски потери точности чисел, хранившихся в <productname>&productname;</productname>.</para>

 <para>И напротив, как показано в таблице, есть некоторые ограничения в формате ввода примитивных типов JSON, не актуальные для соответствующих типов <productname>&productname;</productname>.</para>

  <table id="json-type-mapping-table">
     <title>Примитивные типы JSON и соответствующие им типы <productname>&productname;</productname></title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Примитивный тип JSON</entry>
        <entry>Тип <productname>&productname;</productname></entry>
        <entry>Замечания</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>string</type></entry>
        <entry><type>text</type></entry>
        <entry><literal>\u0000</literal> не допускается, как не ASCII символ, если кодировка базы данных не UTF8</entry>
       </row>
       <row>
        <entry><type>number</type></entry>
        <entry><type>numeric</type></entry>
        <entry>Значения <literal>NaN</literal> и <literal>infinity</literal> не допускаются</entry>
       </row>
       <row>
        <entry><type>boolean</type></entry>
        <entry><type>boolean</type></entry>
        <entry>Допускаются только варианты <literal>true</literal> и <literal>false</literal> (в нижнем регистре)</entry>
       </row>
       <row>
        <entry><type>null</type></entry>
        <entry>(нет)</entry>
        <entry><literal>NULL</literal> в SQL имеет другой смысл</entry>
       </row>
      </tbody>
     </tgroup>
   </table>

 <sect2 id="json-keys-elements">
  <title>Синтаксис вводимых и выводимых значений JSON</title>
  <para>Синтаксис ввода/вывода типов данных JSON соответствует стандарту <acronym>RFC</acronym> 7159.</para>
  <para>Примеры допустимых выражений с типом <type>json</type> (или <type>jsonb</type>): <programlisting>-- Простое скалярное/примитивное значение
-- Простыми значениями могут быть числа, строки в кавычках, true, false или null
SELECT '5'::json;

-- Массив из нуля и более элементов (элементы могут быть разных типов)
SELECT '[1, 2, "foo", null]'::json;

-- Объект, содержащий пары ключей и значений
-- Заметьте, что ключи объектов &mdash; это всегда строки в кавычках
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-- Массивы и объекты могут вкладываться произвольным образом
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;</programlisting></para>

  <para>Как было сказано ранее, когда значение JSON вводится и затем выводится без дополнительной обработки, тип <type>json</type> выводит тот же текст, что поступил на вход, а <type>jsonb</type> не сохраняет семантически незначащие детали, такие как пробелы. Например, посмотрите на эти различия: <programlisting>SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json                       
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb                       
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)</programlisting> Первая семантически незначимая деталь, заслуживающая внимания: с <type>jsonb</type> числа выводятся по правилам нижележащего типа <type>numeric</type>. На практике это означает, что числа, заданные в записи с <literal>E</literal>, будут выведены без неё, например: <programlisting>SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb          
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)</programlisting> Однако, как видно из этого примера, <type>jsonb</type> сохраняет конечные нули дробного числа, хотя они и не имеют семантической значимости, в частности для проверки на равенство.</para>
 </sect2>

 <sect2 id="json-doc-design">
  <title>Эффективная организация документов JSON</title>
  <para>Представлять данные в JSON можно гораздо более гибко, чем в традиционной реляционной модели данных, что очень привлекательно там, где нет жёстких условий. И оба этих подхода вполне могут сосуществовать и дополнять друг друга в одном приложении. Однако, даже для приложений, которым нужна максимальная гибкость, рекомендуется, чтобы документы JSON имели некоторую фиксированную структуру. Эта структура обычно не навязывается жёстко (хотя можно декларативно диктовать некоторые бизнес-правила), но когда она предсказуема, становится гораздо проще писать запросы, которые извлекают полезные данные из набора <quote>документов</quote> (информации) в таблице.</para>
  <para>Данные JSON, как и данные любых других типов, хранящиеся в таблицах, находятся под контролем механизма параллельного доступа. Хотя хранить большие документы вполне возможно, не забывайте, что при любом изменении устанавливается блокировка всей строки (на уровне строки). Поэтому для оптимизации блокировок транзакций, изменяющих данные, стоит ограничить размер документов JSON разумными пределами. В идеале каждый документ JSON должен собой представлять атомарный информационный блок, который, согласно бизнес-логике, нельзя разделить на меньшие, индивидуально изменяемые блоки.</para>
 </sect2>

 <sect2 id="json-containment">
  <title>Проверки на вхождение и существование <type>jsonb</type></title>
  <indexterm><primary>jsonb</primary> <secondary>вхождение</secondary></indexterm>
  <indexterm><primary>jsonb</primary> <secondary>существование</secondary></indexterm>
  <para>Проверка <firstterm>вхождения</firstterm> &mdash; важная особенность типа <type>jsonb</type>, не имеющая аналога для типа <type>json</type>. Эта проверка определяет, входит ли один документ <type>jsonb</type> в другой. В следующих примерах возвращается истинное значение (кроме упомянутых исключений):</para>
<programlisting>-- Простые скалярные/примитивные значения включают только одно идентичное значение:
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

-- Массив с правой стороны входит в массив слева:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

-- Порядок элементов в массиве не важен, поэтому это условие тоже выполняется:
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

-- А повторяющиеся элементы массива не имеют значения:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

-- Объект с одной парой справа входит в объект слева:
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

-- Массив справа <emphasis>не</emphasis> считается входящим в
-- массив слева, хотя в последний и вложен подобный массив:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -- выдаёт false

-- Но если добавить уровень вложенности, проверка на вхождение выполняется:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

-- Аналогично, это вхождением не считается:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"bar": "baz"}'::jsonb;  -- выдаёт false

-- Ключ с пустым объектом на верхнем уровне входит в объект с таким ключом:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;</programlisting>

  <para>Общий принцип этой проверки в том, что входящий объект должен соответствовать объекту, содержащему его, по структуре и данным, возможно, после исключения из содержащего объекта лишних элементов массива или пар ключ/значение. Но помните, что порядок элементов массива для проверки на вхождение не имеет значения, а повторяющиеся элементы массива считаются только один раз.</para>

  <para>В качестве особого исключения для требования идентичности структур, массив может содержать примитивное значение:</para>
<programlisting>-- В этот массив входит примитивное строковое значение:
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

-- Это исключение действует только в одну сторону -- здесь вхождения нет:
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -- выдаёт false</programlisting>

  <para>Для типа <type>jsonb</type> введён также оператор <firstterm>существования</firstterm>, который является вариацией на тему вхождения: он проверяет, является ли строка (заданная в виде значения <type>text</type>) ключом объекта или элементом массива на верхнем уровне значения <type>jsonb</type>. В следующих примерах возвращается истинное значение (кроме упомянутых исключений):</para>
<programlisting>-- Строка существует в качестве элемента массива:
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-- Строка существует в качестве ключа объекта:
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-- Значения объектов не рассматриваются:
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- выдаёт false

-- Как и вхождение, существование определяется на верхнем уровне:
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- выдаёт false

-- Строка считается существующей, если она соответствует примитивной строке JSON:
SELECT '"foo"'::jsonb ? 'foo';</programlisting>

  <para>Объекты JSON для проверок на существование и вхождение со множеством ключей или элементов подходят больше, чем массивы, так как, в отличие от массивов, они внутри оптимизируются для поиска, и поиск элемента не будет линейным.</para>

  <tip>
   <para>Так как вхождение в JSON проверяется с учётом вложенности, правильно написанный запрос может заменить явную выборку внутренних объектов. Например, предположим, что у нас есть столбец <structfield>doc</structfield>, содержащий объекты на верхнем уровне, и большинство этих объектов содержит поля <literal>tags</literal> с массивами вложенных объектов. Данный запрос найдёт записи, в которых вложенные объекты содержат ключи <literal>"term":"paris"</literal> и <literal>"term":"food"</literal>, и при этом пропустит такие ключи, находящиеся вне массива <literal>tags</literal>: <programlisting>SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';</programlisting> Этого же результата можно добиться, например, так: <programlisting>SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';</programlisting> Но данный подход менее гибкий и часто также менее эффективный.</para>

   <para>С другой стороны, оператор существования JSON не учитывает вложенность: он будет искать заданный ключ или элемент массива только на верхнем уровне значения JSON.</para>
  </tip>

  <para>Различные операторы вхождения и существования, а также все другие операторы и функции для работы с JSON документированы в <xref remap="6" linkend="functions-json"/>.</para>
 </sect2>

 <sect2 id="json-indexing">
  <title>Индексация <type>jsonb</type></title>
  <indexterm><primary>jsonb</primary> <secondary>индексы по</secondary></indexterm>

  <para>Для эффективного поиска ключей или пар ключ/значение в большом количестве документов <type>jsonb</type> можно успешно применять индексы GIN. Для этого предоставляются два <quote>класса операторов</quote> GIN, предлагающие выбор между производительностью и гибкостью.</para>
  <para>Класс операторов GIN по умолчанию для <type>jsonb</type> поддерживает запросы с операторами существования ключа на верхнем уровне (<literal>?</literal>, <literal>?&amp;</literal> и <literal>?|</literal>) и оператором существования пути/значения (<literal>@&gt;</literal>). (Подробнее семантика, реализуемая этими операторами, описана в <xref remap="6" linkend="functions-jsonb-op-table"/>.) Пример создания индекса с этим классом операторов: <programlisting>CREATE INDEX idxgin ON api USING GIN (jdoc);</programlisting> Дополнительный класс операторов GIN <literal>jsonb_path_ops</literal> поддерживает индексацию только для оператора <literal>@&gt;</literal>. Пример создания индекса с этим классом операторов: <programlisting>CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);</programlisting></para>

  <para>Рассмотрим пример таблицы, в которой хранятся документы JSON, получаемые от сторонней веб-службы, с документированным определением схемы. Типичный документ:<programlisting>{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}</programlisting> Мы сохраняем эти документы в таблице <structname>api</structname>, в столбце <structfield>jdoc</structfield> типа <type>jsonb</type>. Если по этому столбцу создаётся GIN-индекс, он может применяться в подобных запросах: <programlisting>-- Найти документы, в которых ключ "company" имеет значение "Magnafone"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';</programlisting> Однако, в следующих запросах он не будет использоваться, потому что, несмотря на то, что оператор <literal>?</literal> &mdash; индексируемый, он применяется не к индексированному столбцу <structfield>jdoc</structfield> непосредственно: <programlisting>-- Найти документы, в которых ключ "tags" содержит ключ или элемент массива "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';</programlisting> И всё же, правильно применяя индексы выражений, в этом запросе можно задействовать индекс. Если запрос определённых элементов в ключе <literal>"tags"</literal> выполняется часто, вероятно стоит определить такой индекс: <programlisting>CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));</programlisting> Теперь предложение <literal>WHERE</literal> <literal>jdoc -&gt; 'tags' ? 'qui'</literal> будет выполняться как применение индексируемого оператора <literal>?</literal> к индексируемому выражению <literal>jdoc -&gt; 'tags'</literal>. (Подробнее об индексах выражений можно узнать в <xref remap="6" linkend="indexes-expressional"/>.)</para>
  <para>Ещё один подход к использованию проверок на существование: <programlisting>-- Найти документы, в которых ключ "tags" содержит элемент массива "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';</programlisting> Этот запрос может задействовать простой GIN-индекс по столбцу <structfield>jdoc</structfield>. Но заметьте, что такой индекс будет хранить копии всех ключей и значений в поле <structfield>jdoc</structfield>, тогда как индекс выражения из предыдущего примера хранит только данные внутри объекта с ключом <literal>tags</literal>. Хотя подход с простым индексом гораздо более гибкий (так как он поддерживает запросы по любому ключу), индексы конкретных выражений скорее всего будут меньше и быстрее, чем простые индексы.</para>

  <para>Класс операторов <literal>jsonb_path_ops</literal> поддерживает только запросы с оператором <literal>@&gt;</literal>, но зато он значительно производительнее класса по умолчанию <literal>jsonb_ops</literal>. Индекс <literal>jsonb_path_ops</literal> обычно гораздо меньше индекса <literal>jsonb_ops</literal> для тех же данных и более точен при поиске, особенно, если запросы обращаются к ключам, часто встречающимся в данных. Таким образом, с ним операции поиска выполняются гораздо лучше, чем с классом операторов по умолчанию.</para>

  <para>Техническое различие между GIN-индексами <literal>jsonb_ops</literal> и <literal>jsonb_path_ops</literal> состоит в том, что для первых создаются независимые элементы индекса для каждого ключа/значения в данных, тогда как для вторых создаются элементы только для значений. <footnote>
     <para>Поэтому понятие <quote>значение</quote> включает и элементы массивов, хотя в терминологии JSON иногда элементы массивов считаются отличными от значений внутри объектов.</para>
    </footnote> По сути, каждый элемент индекса <literal>jsonb_path_ops</literal> представляет собой хеш значения и ключа(ей), приводящего к нему; например, при индексации <literal>{"foo": {"bar": "baz"}}</literal> будет создан один элемент индекса с хешем, рассчитанным по всем трём значениям: <literal>foo</literal>, <literal>bar</literal> и <literal>baz</literal>. Таким образом, проверка на вхождение этой структуры будет использовать крайне точный поиск по индексу, но определить, является ли <literal>foo</literal> ключом, с помощью такого индекса нельзя. С другой стороны, индекс <literal>jsonb_ops</literal> создаст три отдельных элемента индекса, представляющих <literal>foo</literal>, <literal>bar</literal> и <literal>baz</literal> по отдельности; для выполнения проверки на вхождение будут проверены строки таблицы, содержащие все эти три значения. Хотя GIN-индексы позволяют вычислить AND довольно эффективно, такой поиск всё же будет менее точным и более медленным, чем равнозначный поиск с <literal>jsonb_path_ops</literal>, особенно если любое одно из этих трёх значений содержится в большом количестве строк.</para>

  <para>Недостаток класса <literal>jsonb_path_ops</literal> заключается в том, что он не учитывает в индексе структуры JSON, не содержащие никаких значений <literal>{"a": {}}</literal>. Для поиска по документам, содержащих такие структуры, потребуется выполнить полное сканирование индекса, что довольно долго, поэтому <literal>jsonb_path_ops</literal> не очень подходит для приложений, часто выполняющих такие запросы.</para>

  <para>Тип <type>jsonb</type> также поддерживает индексы <literal>btree</literal> и <literal>hash</literal>. Они полезны, только если требуется проверять равенство JSON-документов в целом. Порядок сортировки <literal>btree</literal> для типа <type>jsonb</type> редко имеет большое значение, но для полноты он приводится ниже: <synopsis>
<replaceable>Объект</replaceable> &gt; <replaceable>Массив</replaceable> &gt; <replaceable>Логическое значение</replaceable> &gt; <replaceable>Число</replaceable> &gt; <replaceable>Строка</replaceable> &gt; <replaceable>Null</replaceable>

<replaceable>Объект с n парами</replaceable> &gt; <replaceable>Объект с n - 1 парами</replaceable>

<replaceable>Массив с n элементами</replaceable> &gt; <replaceable>Массив с n - 1 элементами</replaceable>
</synopsis> Объекты с равным количеством пар сравниваются в таком порядке: <synopsis>
<replaceable>ключ-1</replaceable>, <replaceable>значение-1</replaceable>, <replaceable>ключ-2</replaceable> ...
</synopsis> Заметьте, что ключи объектов сравниваются согласно порядку при хранении; в частности, из-за того, что короткие ключи хранятся перед длинными, результаты могут оказаться несколько не интуитивными: <programlisting>{ "aa": 1, "c": 1} &gt; {"b": 1, "d": 1}</programlisting> Массивы с равным числом элементом упорядочиваются аналогично: <synopsis>
<replaceable>элемент-1</replaceable>, <replaceable>элемент-2</replaceable> ...
</synopsis> Примитивные значения JSON сравниваются по тем же правилам сравнения, что и нижележащие типы данных <productname>&productname;</productname>. Строки сравниваются с учётом порядка сортировки по умолчанию в текущей базе данных.</para>
 </sect2>
</sect1>
